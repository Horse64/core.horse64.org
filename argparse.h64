
# Copyright (c) 2020-2022,  ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import path from core.horse64.org
import process from core.horse64.org
import system from core.horse64.org



const TAKES_STR_DEFAULT = -999


type ArgumentInfo {
    var name = ""
    var takes_str = no
    var aliases = []
    var optional = no
    var positional = no
}


func ArgumentInfo.init(name, aliases=[], takes_str=TAKES_STR_DEFAULT) {
    self.name = name + ""
    for alias in aliases {
        self.aliases.add(alias + "")
    }
    self.positional = (not self.name.starts("-"))
    if takes_str == TAKES_STR_DEFAULT {
        if self.positional {
            self.takes_str = yes
        } else {
            self.takes_str = no
        }
    } elseif takes_str == "optional" {
        if not self.positional {
            raise new ValueError("only positional arguments "
                "may take a string parameter optionally")
        }
        self.optional = yes
    } else {
        if type(takes_str) != "boolean" {
            raise new ValueError("unsupported value for "
                "takes_str")
        }
        if not takes_str and self.positional {
            raise new ValueError(
                "positonal arguments must take a "
                "string parameter, at least optionally"
            )
        }
        self.takes_str = takes_str
        self.optional = no
    }
}


func ArgumentInfo.names_intersect(names) {
    if names.contains(self.name) {
        return yes
    }
    for alias in self.aliases {
        if names.contains(alias) {
            return yes
        }
    }
    return no
}


type ArgumentDefs {
    var args protect = []
    var min_positional_args protect = 0
    var max_positional_args protect = 0
    var program_name = "unknown"
}


func ArgumentDefs.init(program_name=none) {
    # Sanitize and guess the program name for this arguments set:
    if program_name != none {
        # Make sure this can be used as a string:
        program_name = program_name + ""
    }
    if program_name == none {
        program_name = path.basename(system.self_exec_path())
        if program_name == "none" {
            program_name = "unknown"
        }
    }
    self.program_name = program_name
}


func ArgumentDefs.get_nth_posarg(index) {
    for arg in self.args {
        if arg.positional {
            if index > 1 {
                index -= 1
            } else {
                return arg
            }
        }
    }
    return none
}


func ArgumentDefs.get_namedarg(name) {
    if not name.starts("-") {
        return none
    }
    for arg in self.args {
        if arg.name == name or arg.aliases.contains(name) {
            return arg
        }
    }
    return none
}


func ArgumentDefs.add_arg(name, aliases=[],
        takes_str=TAKES_STR_DEFAULT) {
    for arg in self.args {
        if arg.names_intersect([name]) or
                arg.names_intersect(aliases) {
            raise new ValueError(
                "name conflict with existing options"
            )
        }
    }
    self.args.add(new ArgumentInfo(
        name, aliases=aliases, takes_str=takes_str
    ))
    if self.args[self.args.len].positional {
        self.max_positional_args += 1
        if not self.args[self.args.len].optional {
            self.min_positional_args += 1
        }
    }
}


type ParseResult {
    var output = ""
    var output_exit_code = 0
    var success = no
    var args
}


func get_usage_text(options) {
    var output = ""
    output += "Usage: " +
        options.program_name + " [..Options..]"
    for arg in options.args {
        if not arg.positional {
            continue
        }
        output += " [" + arg.name + (
            if arg.optional ("<optional>") else ("")
        ) + "]"
    }
    output += "\n"
    print("Available Options:")
    var unsorted_names = []
    for arg in options.args {
        if not arg.name.starts("-") {
            continue
        }
        unsorted_names.add(arg.name)
    }
    if not unsorted_names.contains("--help") {
        unsorted_names.add("--help")
    }
    var sorted_names = unsorted_names  # FIXME...


    return output
}


func parse(argument_defs, args=none) {
    if not has_attr(argument_defs, "max_positional_args") {
        raise new TypeError(
            "argument_defs must have the "
            "argparse.ArgumentDefs attributes"
        )
    }
    if args == none {
        args = process.args
    }
    var result = new ParseResult()
    var result_args = {->}
    var posargs_seen = 0

    # Extract all arguments:
    var i = 0
    while i < args.len {
        var argstr = args[i]
        if not argstr.starts("-") {
            # Positional argument. See if we reached maximum:
            if posargs_seen + 1 > argument_defs.max_positional_args {
                result.output += argument_defs.program_name + ": error: "
                    "excessive positional argument: " + argstr + "\n"
                result.output += (
                    "Use " + argument_defs.program_name +
                    " --help to show usage.\n"
                )
                result.output_exit_code = -1
                return result
            }

            # Check what exactly this maps to:
            var target_arg = (
                argument_defs.get_nth_posarg(posargs_seen + 1)
            )
            assert(target_arg != none)
            result_args[target_arg.name] = argstr
        } else {
            # Special handling for --help:
            if argstr == "--help" {
                result.output = get_usage_text(argument_defs)
                result.output_exit_code = 0
                return result
            }
            # See if we can find out the arg def this matches:
            var target_arg = argument_defs.get_namedarg(argstr)
            if target_arg == none {
                result.output += argument_defs.program_name + ": error: "
                    "unknown option: " + argstr + "\n"
                result.output += (
                    "Use " + argument_defs.program_name +
                    " --help to show usage.\n"
                )
                result.output_exit_code = -1
                return result
            }
            # If this named arg takes a parameter, check that it's
            # following:
            if target_arg.takes_str {
                if i + 1 > args.len or
                        args[i + 1].starts("-") {
                    result.output += argument_defs.program_name + ": error: "
                        "option is missing argument: " + argstr + "\n"
                    result.output += (
                        "Use " + argument_defs.program_name +
                        " --help to show usage.\n"
                    )
                    result.output_exit_code = -1
                    return result
                }
                result_args[target_arg.name] = args[i + 1]
                i += 2
                continue
            }
            result_args[target_arg.name] = yes
        }
        i += 1
    }
    # Fill in empty spots in result dictionary:
    for arg in argument_defs.args {
        if not result.args.contains(arg) {
            if result.args.takes_str {
                result_args[arg] = none
            } else {
                result_args[arg] = no
            }
        }
    }
    result.args = result_args
    result.success = yes
    return result
}
