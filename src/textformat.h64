
# @module textformat
# Copyright (c) 2020-2022,  ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import math from core.horse64.org


func wrap(s, length,
        all_lines_prefix="",
        later_lines_prefix="",
        ) {
    #print("textformat.wrap on: " + [s, length].as_str())
    if typename(length) != "num" or length <= 0 {
        raise ValueError("wrapped-to length must be positive number")
    }
    length = math.round(length)
    var line_break = "\n"
    if s.contains("\r\n") {
        line_break = "\r\n"
    }
    s = s.replace("\r\n", "\n").replace("\r", "\n")
    var final_lines = []
    var is_first_line = yes
    while yes {
        var line_length = length - all_lines_prefix.len
        var prefix = all_lines_prefix + ""
        if not is_first_line {
            line_length -= later_lines_prefix.len
            prefix = later_lines_prefix + prefix
        }
        if s.len < line_length or s.len <= 1 {
            var remaining_lines_noprefix = s.split("\n")
            var remaining_lines = []
            for remaining_line in remaining_lines_noprefix {
                remaining_lines.add(prefix + remaining_line)
                prefix = later_lines_prefix + all_lines_prefix + ""
            }
            final_lines += remaining_lines
            var result = final_lines.join(line_break)
            #print("textformat.wrap result: " + result.as_str())
            return result
        }
        var wrap_index = math.max(1, line_length)
        var line_break_idx = s.find("\n")
        if line_break_idx != none and
                line_break_idx < wrap_index {
            wrap_index = line_break_idx
        }
        var k = wrap_index
        while k > s.len / 2 and k > 1 {
            if s[k] == " " or s[k] == "\n" or s[k] == "\t" {
                wrap_index = k
                break
            }
            k -= 1
        }
        final_lines.add(prefix + s.sub(0, wrap_index))
        if s[wrap_index] == "\n" or s[wrap_index] == "\t" or
                s[wrap_index] == "\r" or s[wrap_index] == " " {
            assert(wrap_index >= 0)
            s = s.sub(wrap_index + 1)
        } else {
            assert(wrap_index >= 1)
            s = s.sub(wrap_index)
        }
        is_first_line = no
    }
    var result = final_lines.join(line_break)
    #print("textformat.wrap result: " + result.as_str())
    return result
}

