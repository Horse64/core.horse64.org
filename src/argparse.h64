# @module argparse
# Copyright (c) 2020-2022,  ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import math from core.horse64.org
import path from core.horse64.org
import process from core.horse64.org
import system from core.horse64.org
import textformat from core.horse64.org


type _ArgumentInfo {
    var name = ""
    var catchall = no
    var takes_arg = no
    var aliases = []
    var optional = no
    var positional = no
    var action_func = none
    var description = none
}


func _ArgumentInfo.init(
        name, aliases=[],
        is_switch=no, takes_arg="default",
        description=none, action_func=none
        ) {
    self.description = (
        if description != none (description + "") else (none)
    )
    self.name = name + ""
    for alias in aliases {
        self.aliases.add(alias + "")
    }
    self.positional = not self.name.starts("-")
    if is_switch != (not self.positional) {
        throw ValueError("is_switch must be yes if "
            "argument begins with dash, otherwise no")
    }
    if not is_switch and action_func != none {
        throw ValueError("action_func only allowed "
            "for switches")
    }
    self.action_func = action_func
    if takes_arg == "default" {
        if self.positional {
            self.takes_arg = yes
        } else {
            self.takes_arg = no
        }
    } elseif takes_arg == "optional" or takes_arg == "catchall" {
        self.takes_arg = yes
        if not self.positional {
            throw new ValueError("only positional arguments "
                "may take an argument value optionally or "
                "as catchall")
        }
        if takes_arg == "optional" {
            self.optional = yes
        } else {
            self.catchall = yes
        }
    } else {
        if typename(takes_arg) != "bool" {
            throw new ValueError("unsupported value for "
                "takes_arg of type: " + typename(takes_arg))
        }
        if not takes_arg and self.positional {
            throw new ValueError(
                "positonal arguments must take an "
                "argument value at least optionally"
            )
        }
        self.takes_arg = takes_arg
        self.optional = no
    }
}


func _ArgumentInfo.contains_argname(names) {
    if names.contains(self.name) {
        return yes
    }
    for alias in self.aliases {
        if names.contains(alias) {
            return yes
        }
    }
    return no
}


type ArgumentDefs {
    var args protect = []
    var min_positional_args protect = 0
    var max_positional_args protect = 0
    var catchall_exists protect = no
    var program_name = "unknown"
}


func ArgumentDefs.init(program_name=none) {
    # Sanitize and guess the program name for this arguments set:
    if program_name != none and typename(program_name) != "str" {
        throw TypeError("program_name must be none or string")
    }
    if program_name == none {
        program_name = path.basename(system.self_exec_path())
        if program_name == "none" {
            program_name = "unknown"
        }
    }
    self.program_name = program_name
}


func ArgumentDefs.get_nth_posarg(index) {
    for arg in self.args {
        if arg.positional {
            if index > 1 {
                index -= 1
            } else {
                return arg
            }
        }
    }
    return none
}


func ArgumentDefs.get_namedarg(name) {
    if not name.starts("-") {
        return none
    }
    for arg in self.args {
        if arg.name == name or arg.aliases.contains(name) {
            return arg
        }
    }
    return none
}


## @func ArgumentDefs.add_arg
##
## Add a positional argument that must be passed in by the user.
## This might e.g. be a target file, or similar.
##
## After @{parsing|ArgumentDefs.parse}, the map of all parsed values
## will contain an entry with the name set to the passed argument as
## @{str}.
##
## Example:
## ```horse64
## var defs = argparse.ArgumentDefs()
## defs.add_arg("target_file")
## var parsed_values = argparse.parse(defs, ["some_file.txt"])
## print(parsed_values["target_file"])  # will print out "some_file.txt"!
## ```
##
## @param name str the name for the positional argument
## @param is_optional bool specifies that the positional argument can
##   be silently omitted if set to true. Then the final map of all parsed
##   values will have the corresponding entry set to @{none} if
##   it isn't specified by the user.
## @param description str (optional) a description for the user
##   what this argument is for
func ArgumentDefs.add_arg(name, is_optional=no, description=none) {
    if name.starts("-") {
        throw new ValueError(
            "positional arguments can't have a name "
            "starting with a dash")
    }
    for arg in self.args {
        if arg.contains_argname([name]) {
            throw new ValueError(
                "name conflict with existing options"
            )
        }
        if arg.positional and arg.catchall {
            throw new ValueError(
                "cannot add positional argument after a catchall"
            )
        }
    }
    self.args.add(new _ArgumentInfo(
        name, is_switch=no, description=description,
        takes_arg=(if is_optional ("optional") else (yes))
    ))
    if self.args[self.args.len - 1].positional {
        self.max_positional_args += 1
        if not self.args[self.args.len - 1].optional {
            self.min_positional_args += 1
        }
    }
}


## @func ArgumentDefs.add_catchall
##
## **(Advanced functionality)**
## Add a catchall argument that will consume all arguments following
## the last positional argument. This is only useful for special
## cases, like if you want to pass them on to some nested program.
## Requires that one or more regular @{positional arguments were
## previously added|ArgumentDefs.add_arg}.
##
## After @{parsing|ArgumentDefs.parse}, the map of all parsed values
## will contain an entry with the name set to the consumed arguments as
## a @{list}.
##
## @param name str the name for the catchall argument
## @param description str (optional) a description for the user
##   what this argument is for
func ArgumentDefs.add_catchall(name, description=none) {
    if name.starts("-") {
        throw new ValueError(
            "positional arguments can't have a name "
            "starting with a dash")
    }
    var positional_count = 0
    for arg in self.args {
        if arg.contains_argname([name]) {
            throw new ValueError(
                "name conflict with existing options"
            )
        }
        if arg.positional and not arg.catchall {
            positional_count += 1
        }
        if arg.positional and arg.catchall {
            throw new ValueError(
                "cannot add multiple catchall arguments"
            )
        }
    }
    if positional_count == 0 {
        throw new ValueError(
            "cannot add catchall without any positional arguments"
        )
    }
    self.args.add(new _ArgumentInfo(
        name, is_switch=no,
        takes_arg="catchall", description=description
    ))
    self.catchall_exists = yes
}


## @func ArgumentDefs.add_switch
##
## Add an option switch that begins with a dash that the user may or
## may not use. This usually enables optional behavior of your program.
##
## After @{parsing|ArgumentDefs.parse}, the map of all parsed values
## will contain an entry with the switch name set to @{yes} if the
## switch was specified, or otherwise @{no}.
##
## Example:
## ```horse64
## var defs = argparse.ArgumentDefs()
## defs.add_switch("--switch-1")
## defs.add_switch("--switch-2")
## var parsed_values = argparse.parse(defs, ["--switch-2"])
## print(parsed_values["switch-1"])  # will print out "no"!
## print(parsed_values["switch-2"])  # will print out "yes"!
## ```
##
## @param name str the name of a switch which must start with a dash
## @param aliases list alternate names for this switch which also
##     must all start with a dash
## @param takes_arg bool specify that this switch takes an argument
##   specified right after, e.g. `--target-file path-to-file`. If set
##   to yes, the map of all parsed values will instead contain either
##   @{none} if the switch wasn't specified, or the user-given @{str}
##   of that argument.
## @param description str (optional) a description for the user
##   what this argument is for
## @param action_func func (optional) a function that should be
##   run as soon as this switch is found during a
##   @{parse|ArgumentDefs.parse} run.
func ArgumentDefs.add_switch(
        name, aliases=[], takes_arg=no, description=none,
        action_func=none
        ) {
    if not name.starts("-") {
        throw new ValueError("switch names must start with dash")
    }
    for alias in aliases {
        if not alias.startswith("-") {
            throw new ValueError("switch aliases must start with dash")
        }
    }
    if takes_arg != yes and takes_arg != no {
        throw new ValueError("takes_arg must be yes or no")
    }
    for arg in self.args {
        if arg.contains_argname([name]) or
                arg.contains_argname(aliases) {
            throw new ValueError(
                "name conflict with existing options"
            )
        }
    }
    self.args.add(new _ArgumentInfo(
        name, aliases=aliases, is_switch=yes,
        takes_arg=takes_arg, description=description,
        action_func=action_func
    ))
}


type ParseResult {
    var output = ""
    var exit_code = none
    var args
}


func get_usage_text(options) {
    var output = ""

    # Output main usage line with positional args:
    output += "Usage: " +
        options.program_name + " [..options..]"
    for arg in options.args {
        if not arg.positional {
            continue
        }
        output += " " + arg.name.replace(" ", "_") + (
            if arg.optional ("[optional]") else ("")
        ) + (if arg.catchall ("..") else ("")) + ""
    }
    output += "\n\n"

    # Output info on all positional args:
    var got_positional = no
    for arg in options.args {
        if arg.positional {
            got_positional = yes
            break
        }
    }
    if got_positional {
        output += "Arguments:\n"
        var longest_arg_len = 0
        for arg in options.args {
            if arg.positional {
                longest_arg_len = math.max(
                    longest_arg_len, arg.name.len)
            }
        }
        var indent_target_len = min(
            30, longest_arg_len + 3
        )
        for arg in options.args {
            if arg.positional {
                var spaces = " ".repeat(math.max(
                    2, indent_target_len - arg.name.len
                ))
                var spaces_after_wrap = " ".repeat(indent_target_len)
                var wrapped = textformat.wrap(
                    "   " + arg.name.replace(" ", "_") +
                    (if arg.description != none (spaces + arg.description)
                    else ("")), 79,
                    later_lines_prefix="   " + spaces_after_wrap)
                output += wrapped + "\n"
            }
        }
        output += "\n"
    }

    # Output all available option switches as a nice table:
    output += "Available Options:\n"
    var switch_desc_map = {->}
    var unsorted_names = []
    for arg in options.args {
        if not arg.name.starts("-") {
            continue
        }
        unsorted_names.add(arg.name)
        if arg.description != none and
                arg.description.len > 0 {
            switch_desc_map[arg.name] = arg.description
        }
    }
    if not unsorted_names.contains("--help") {
        unsorted_names.add("--help")
        switch_desc_map["--help"] =
            "Show this help text."
    }
    var sorted_names = unsorted_names.sort()
    var longest_switch_len = 0
    for switch_name in sorted_names {
        longest_switch_len = math.max(
            longest_switch_len, switch_name.len)
    }
    var indent_target_len = min(
        30, longest_switch_len + 3
    )
    for switch_name in sorted_names {
        var spaces = " ".repeat(math.max(
            2, indent_target_len - switch_name.len
        ))
        var spaces_after_wrap = " ".repeat(indent_target_len)
        var switch_description = none
        if switch_desc_map.contains(switch_name) {
            switch_description = switch_desc_map[switch_name]
        }
        var wrapped = textformat.wrap(
            "   " + switch_name +
            (if switch_description != none
                (spaces + switch_description)
                else ("")),
            79,
            later_lines_prefix="   " + spaces_after_wrap)
        output += wrapped + "\n"
    }

    return output
}


func parse(argument_defs, args=none) {
    if not has_attr(argument_defs, "max_positional_args") {
        throw new TypeError(
            "argument_defs must have the "
            "argparse.ArgumentDefs attributes"
        )
    }
    if args == none {
        args = process.args
    }
    var result = new ParseResult()
    var result_args = {->}
    var posargs_seen = 0

    # Extract all arguments:
    var i = 0
    while i < args.len {
        var argstr = args[i]
        if not args[i].starts("-") {
            # Positional argument. See if we reached maximum:
            if posargs_seen + 1 > argument_defs.max_positional_args and
                    not argument_defs.catchall_exists {
                result.output += argument_defs.program_name + ": error: "
                    "excessive positional argument: " + argstr + "\n"
                result.output += (
                    "Use " + argument_defs.program_name +
                    " --help to show usage.\n"
                )
                result.output_exit_code = -1
                return result
            }

            # Check what exactly this maps to:
            var target_arg = (
                argument_defs.get_nth_posarg(posargs_seen + 1)
            )
            assert(target_arg != none)
            result_args[target_arg.name] = argstr
        } else {
            # Special handling for --help:
            if argstr == "--help" {
                result.output = get_usage_text(argument_defs)
                result.output_exit_code = 0
                return result
            }
            # See if we can find out the arg def this matches:
            var target_arg = argument_defs.get_namedarg(argstr)
            if target_arg == none {
                result.output += argument_defs.program_name +
                    ": error: "
                    "unknown option: " + argstr + "\n"
                result.output += (
                    "Use " + argument_defs.program_name +
                    " --help to show usage.\n"
                )
                result.exit_code = -1
                return result
            }
            # If this named arg takes an argument, check that it's
            # specified after:
            if target_arg.takes_arg == yes {
                if i + 1 > args.len or
                        args[i + 1].starts("-") {
                    result.output += argument_defs.program_name +
                        ": error: "
                        "option is missing argument: " + argstr + "\n"
                    result.output += (
                        "Use " + argument_defs.program_name +
                        " --help to show usage.\n"
                    )
                    result.exit_code = -1
                    return result
                }
                result_args[target_arg.name] = args[i + 1]
                i += 2
                continue
            }
            result_args[target_arg.name] = yes
        }
        i += 1
    }
    # Fill in empty spots in result dictionary:
    for arg in argument_defs.args {
        if not arg.positional and
                not result_args.contains(arg.name) {
            if arg.takes_arg {
                result_args[arg.name] = none
            } else {
                result_args[arg.name] = no
            }
        }
    }
    # Collect all switches that will have an action_func run:
    var action_switch_names = []
    for arg in argument_defs.args {
        if not arg.positional and
                arg.action_func != none and
                result_args.contains(arg.name) and
                result_args[arg.name] != none and
                result_args[arg.name] != no {
            # A switch with an action. Collect it for later sorting:
            action_switch_names.add(arg.name)
        }
    }
    # Get each action_func to be run in alphabetical switch order:
    action_switch_names = action_switch_names.sort()
    var action_funcs_in_order = []
    for action_switch_name in action_switch_names {
        for arg in argument_defs.args {
            if arg.name == action_switch_name {
                action_funcs_in_order.add(arg.action_func)
                break
            }
        }
    }
    # Run each action_func in order:
    for action_func in action_funcs_in_order {
        var result_value = action_func()
        if typename(result_value) == "str" and
                result.exit_code == none {
            result.output = result_value
            result.exit_code = 0
        }
    }
    # Return result:
    result.args = result_args
    return result
}
