
# @module argparse
# Copyright (c) 2020-2022,  ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import path from core.horse64.org
import process from core.horse64.org
import system from core.horse64.org


type ArgumentInfo {
    var name = ""
    var catchall = no
    var takes_arg = no
    var aliases = []
    var optional = no
    var positional = no
}


func ArgumentInfo.init(
        name, aliases=[],
        is_switch=no, takes_arg="default"
        ) {
    self.name = name + ""
    for alias in aliases {
        self.aliases.add(alias + "")
    }
    self.positional = not self.name.starts("-")
    if is_switch != (not self.positional) {
        throw ValueError("is_switch must be yes if "
            "argument begins with dash, otherwise no")
    }
    if takes_arg == "default" {
        if self.positional {
            self.takes_arg = yes
        } else {
            self.takes_arg = no
        }
    } elseif takes_arg == "optional" or takes_arg == "catchall" {
        if not self.positional {
            throw new ValueError("only positional arguments "
                "may take an argument value optionally or "
                "as catchall")
        }
        if takes_arg == "optional" {
            self.optional = yes
        } else {
            self.catchall = yes
        }
    } else {
        if typename(takes_arg) != "bool" {
            throw new ValueError("unsupported value for "
                "takes_arg of type: " + typename(takes_arg))
        }
        if not takes_arg and self.positional {
            throw new ValueError(
                "positonal arguments must take an "
                "argument value at least optionally"
            )
        }
        self.takes_arg = takes_arg
        self.optional = no
    }
}


func ArgumentInfo.names_intersect(names) {
    if names.contains(self.name) {
        return yes
    }
    for alias in self.aliases {
        if names.contains(alias) {
            return yes
        }
    }
    return no
}


type ArgumentDefs {
    var args protect = []
    var min_positional_args protect = 0
    var max_positional_args protect = 0
    var program_name = "unknown"
}


func ArgumentDefs.init(program_name=none) {
    # Sanitize and guess the program name for this arguments set:
    if program_name != none and typename(program_name) != "str" {
        throw TypeError("program_name must be none or string")
    }
    if program_name == none {
        program_name = path.basename(system.self_exec_path())
        if program_name == "none" {
            program_name = "unknown"
        }
    }
    self.program_name = program_name
}


func ArgumentDefs.get_nth_posarg(index) {
    for arg in self.args {
        if arg.positional {
            if index > 1 {
                index -= 1
            } else {
                return arg
            }
        }
    }
    return none
}


func ArgumentDefs.get_namedarg(name) {
    if not name.starts("-") {
        return none
    }
    for arg in self.args {
        if arg.name == name or arg.aliases.contains(name) {
            return arg
        }
    }
    return none
}


## @func ArgumentDefs.add_arg
##
## Add a positional argument that must be passed in by the user.
## This might e.g. be a target file, or similar.
##
## After @{parsing|ArgumentDefs.parse}, the map of all parsed values
## will contain an entry with the name set to the passed argument as
## @{str}.
##
## Example:
## ```horse64
## var defs = argparse.ArgumentDefs()
## defs.add_arg("target_file")
## var parsed_values = argparse.parse(defs, ["some_file.txt"])
## print(parsed_values["target_file"])  # will print out "some_file.txt"!
## ```
##
## @param is_optional specifies that the positional argument can
##   be silently omitted, in which case the final map of all parsed
##   values will have the corresponding entry set to @{none} instead.
func ArgumentDefs.add_arg(name, aliases=[], is_optional=no) {
    if name.starts("-") {
        throw new ValueError(
            "positional arguments can't have a name "
            "starting with a dash")
    }
    for arg in self.args {
        if arg.names_intersect([name]) or
                arg.names_intersect(aliases) {
            throw new ValueError(
                "name conflict with existing options"
            )
        }
        if arg.positional and arg.catchall {
            throw new ValueError(
                "cannot add positional argument after a catchall"
            )
        }
    }
    self.args.add(new ArgumentInfo(
        name, aliases=aliases, is_switch=no,
        takes_arg=(if is_optional ("optional") else (no))
    ))
    if self.args[self.args.len].positional {
        self.max_positional_args += 1
        if not self.args[self.args.len].optional {
            self.min_positional_args += 1
        }
    }
}

## @func ArgumentDefs.add_catchall
##
## **(Advanced functionality)**
## Add a catchall argument that will consume all arguments following
## the last positional argument. This is only useful for special
## cases, like if you want to pass them on to some nested program.
## Requires that one or more regular @{positional arguments were
## previously added|ArgumentDefs.add_arg}.
##
## After @{parsing|ArgumentDefs.parse}, the map of all parsed values
## will contain an entry with the name set to the consumed arguments as
## a @{list}.
func ArgumentDefs.add_catchall(name, aliases=[]) {
    if name.starts("-") {
        throw new ValueError(
            "positional arguments can't have a name "
            "starting with a dash")
    }
    var positional_count = 0
    for arg in self.args {
        if arg.names_intersect([name]) or
                arg.names_intersect(aliases) {
            throw new ValueError(
                "name conflict with existing options"
            )
        }
        if arg.positional and not arg.catchall {
            positional_count += 1
        }
        if arg.positional and arg.catchall {
            throw new ValueError(
                "cannot add multiple catchall arguments"
            )
        }
    }
    if positional_count == 0 {
        throw new ValueError(
            "cannot add catchall without any positional arguments"
        )
    }
    self.args.add(new ArgumentInfo(
        name, aliases=aliases, is_switch=no,
        takes_arg="catchall"
    ))
}


## @func ArgumentDefs.add_switch
##
## Add an option switch that begins with a dash that the user may or
## may not use. This usually enables optional behavior of your program.
##
## After @{parsing|ArgumentDefs.parse}, the map of all parsed values
## will contain an entry with the switch name set to @{yes} if the
## switch was specified, or otherwise @{no}.
##
## Example:
## ```horse64
## var defs = argparse.ArgumentDefs()
## defs.add_switch("--switch-1")
## defs.add_switch("--switch-2")
## var parsed_values = argparse.parse(defs, ["--switch-2"])
## print(parsed_values["switch-1"])  # will print out "no"!
## print(parsed_values["switch-2"])  # will print out "yes"!
## ```
##
## @param takes_arg specify that this switch takes its own argument
##   specified right after, e.g. `--target-file path-to-file`. If set
##   to yes, the map of all parsed values will instead contain either
##   @{none} if the switch wasn't specified, or the user-given @{str}
##   of that argument.
func ArgumentDefs.add_switch(
        name, aliases=[], takes_arg=no
        ) {
    if not name.starts("-") {
        throw new ValueError("switch names must start with dash")
    }
    if takes_arg != yes and takes_arg != no {
        throw new ValueError("takes_arg must be yes or no")
    }
    for arg in self.args {
        if arg.names_intersect([name]) or
                arg.names_intersect(aliases) {
            throw new ValueError(
                "name conflict with existing options"
            )
        }
    }
    self.args.add(new ArgumentInfo(
        name, aliases=aliases, is_switch=yes,
        takes_arg=takes_arg
    ))
    if self.args[self.args.len].positional {
        self.max_positional_args += 1
        if not self.args[self.args.len].optional {
            self.min_positional_args += 1
        }
    }
}


type ParseResult {
    var output = ""
    var exit_code = none
    var args
}


func get_usage_text(options) {
    var output = ""

    # Output main usage line with positional args:
    output += "Usage: " +
        options.program_name + " [..options..]"
    for arg in options.args {
        if not arg.positional {
            continue
        }
        output += " " + arg.name.replace(" ", "_") + (
            if arg.optional ("[optional]") else ("")
        ) + ""
    }
    output += "\n\n"

    # Output all available option switches as a nice table:
    output += "Available Options:\n"
    var unsorted_names = []
    for arg in options.args {
        if not arg.name.starts("-") {
            continue
        }
        unsorted_names.add(arg.name)
    }
    if not unsorted_names.contains("--help") {
        unsorted_names.add("--help")
    }
    var sorted_names = unsorted_names.sort()
    for name in sorted_names {
        output += "   " + name + "\n"
    }

    return output
}


func parse(argument_defs, args=none) {
    if not has_attr(argument_defs, "max_positional_args") {
        throw new TypeError(
            "argument_defs must have the "
            "argparse.ArgumentDefs attributes"
        )
    }
    if args == none {
        args = process.args
    }
    var result = new ParseResult()
    var result_args = {->}
    var posargs_seen = 0

    # Extract all arguments:
    var i = 0
    while i < args.len {
        var argstr = args[i]
        if not argstr.starts("-") {
            # Positional argument. See if we reached maximum:
            if posargs_seen + 1 > argument_defs.max_positional_args {
                result.output += argument_defs.program_name + ": error: "
                    "excessive positional argument: " + argstr + "\n"
                result.output += (
                    "Use " + argument_defs.program_name +
                    " --help to show usage.\n"
                )
                result.output_exit_code = -1
                return result
            }

            # Check what exactly this maps to:
            var target_arg = (
                argument_defs.get_nth_posarg(posargs_seen + 1)
            )
            assert(target_arg != none)
            result_args[target_arg.name] = argstr
        } else {
            # Special handling for --help:
            if argstr == "--help" {
                result.output = get_usage_text(argument_defs)
                result.output_exit_code = 0
                return result
            }
            # See if we can find out the arg def this matches:
            var target_arg = argument_defs.get_namedarg(argstr)
            if target_arg == none {
                result.output += argument_defs.program_name +
                    ": error: "
                    "unknown option: " + argstr + "\n"
                result.output += (
                    "Use " + argument_defs.program_name +
                    " --help to show usage.\n"
                )
                result.exit_code = -1
                return result
            }
            # If this named arg takes an argument, check that it's
            # specified after:
            if target_arg.takes_arg == yes {
                if i + 1 > args.len or
                        args[i + 1].starts("-") {
                    result.output += argument_defs.program_name +
                        ": error: "
                        "option is missing argument: " + argstr + "\n"
                    result.output += (
                        "Use " + argument_defs.program_name +
                        " --help to show usage.\n"
                    )
                    result.exit_code = -1
                    return result
                }
                result_args[target_arg.name] = args[i + 1]
                i += 2
                continue
            }
            result_args[target_arg.name] = yes
        }
        i += 1
    }
    # Fill in empty spots in result dictionary:
    for arg in argument_defs.args {
        if not result.args.contains(arg) {
            if result.args.takes_arg {
                result_args[arg] = none
            } else {
                result_args[arg] = no
            }
        }
    }
    result.args = result_args
    return result
}
