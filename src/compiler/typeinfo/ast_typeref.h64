 ## @module compiler.typeref
# Copyright (c) 2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import compiler.ast as ast
import compiler.ast.expr as ast_expr
import compiler.msg as msg
import compiler.token as token
import compiler.storage.ref as st_ref

const builtin_horse64_types = {}
const builtin_horse64_type_modifiers = {}
const builtin_moose64_types = {
    "byte", "i8", "i16", "u16",
    "i32", "i64", "size", "u32", "u64",
    "f32", "f64", "bool",
    "any", "auto", "moose64_failed_result_t"
}
const builtin_moose64_type_modifiers = {
    "ref", "array", "c_array", "readonly"
}

type TypeRefModProp {
}

type TypeRefModProp_Range base TypeRefModProp {
    var range_value_num
    var range_value_label
}

func TypeRefModProp_Range.as_str {
    var t = "["
    if self.range_value_num != none {
        t += self.range_value_num.as_str()
    } else {
        t += self.range_value_label.as_str()
    }
    t += "]"
    return t
}

type TypeRefMod {
    var name
    var props = []
}

func TypeRefMod.init(name) {
    self.name = name + ""
}

func TypeRefMod.as_str {
    var t = self.name + ""
    for prop in self.props {
        t += prop.as_str()
    }
    return t
}

type TypeRefFuncExpr base TypeRefExpr {
    var arg_typeref_exprs = []
    var return_typeref_expr
    var func_storage_ref
}

func TypeRefFuncExpr.init {
    base.init()
    self.is_func_ref = yes
    self.name = none
    self.type_path = none
}

func TypeRefFuncExpr.as_code(indent=0) {
    if self.damaged {
        return "(damaged type ref func expr.)"
    }
    var prefix_mod_names = {"readonly"}
    var t = ""
    for mod in self.modifiers {
        if prefix_mod_names.has(mod.name) {
            if t != "" {
                t += " "
            }
            t += mod.as_str()
        }
    }
    if t != "" {
        t += " "
    }
    t += "(("
    var is_first_param = yes
    for param_type in self.arg_typeref_exprs {
        if is_first_param {
            is_first_param = no
        } else {
            t += ", "
        }
        t += "_<-" + param_type.as_code(indent=indent)
    }
    t += ")->"
    if self.return_typeref_expr != none {
        t += self.return_typeref_expr.as_code(indent=indent)
    }
    t += ")"
    for mod in self.modifiers {
        if not prefix_mod_names.has(mod.name) {
            t += " " + mod.as_str()
        }
    }
    if self.has_init_expr {
        assert(self.subexprs.len == 1)
        t += self.subexprs[1].as_code(indent=(indent + 4))
    }
    return t
}

func TypeRefFuncExpr.copy {
    var self_copy = base.copy()
    var old_args = self_copy.arg_typeref_exprs
    self_copy.arg_typeref_exprs = []
    for old_arg in old_args {
        self_copy.arg_typeref_exprs.add(old_arg.copy())
    }
    self_copy.return_typeref_expr =
        self_copy.return_typeref_expr.copy()
    self_copy.func_storage_ref =
        self_copy.func_storage_ref.copy()
    return self_copy
}

func TypeRefFuncExpr.try_resolve_param_types(
        project_file, recursive=no, force_recompute=no,
        is_moose64=no
        ) {
    var had_failure = no

    var builtin_names =
        if is_moose64 (builtin_moose64_types)
            else (builtin_horse64_types)
    func resolve_item(item) {
        if not item.is_func_ref {
            var result = item.try_resolve_to_user_type(
                project_file, force_recompute=force_recompute,
                is_moose64=is_moose64
            ) later:

            await result
            if not result and not builtin_names.has(item.name) {
                had_failure = yes
            }
            return later
        }
        var result = item.try_resolve_to_user_type(
            project_file, recursive=recursive,
            skip_params=(not recursive),
            force_recompute=force_recompute,
            is_moose64=is_moose64
        ) later:

        await result
        # Func typerefs may not point to any specific actual
        # defined function, so we ignore if this fails.
    }

    base.try_resolve_to_user_type(
        project_file, force_recompute=force_recompute,
        is_moose64=is_moose64
    )
    later:

    var queue = self.arg_typeref_exprs.copy()
    if self.return_typeref_expr != none {
        queue.add(self.return_typeref_expr)
    }
    if queue.len == 0 {
        return later not had_failure
    }
    var item = queue.pop()
    var _unused = resolve_item(item)
    later:

    await _unused

    if queue.len == 0 {
        return later not had_failure
    }
    item = queue.pop()
    _unused = resolve_item(item) later repeat
}

func TypeRefFuncExpr.try_resolve_to_user_type(
        project_file, recursive=no, skip_params=no,
        force_recompute=no,
        is_moose64=no
        ) {
    func run_concurrent {
        if skip_params {
            return later yes
        }
        var result = self.try_resolve_param_types(
            project_file, recursive=recursive,
            force_recompute=force_recompute,
            is_moose64=is_moose64
        ) later:

        await result
        if not result or self.func_storage_ref == none {
            return later no
        }
        return later yes
    }
    var result = run_concurrent()

    later:
    await result
    if not result {
        return later none
    }
    return later self.func_storage_ref.copy()
}

func create_typeref_from_func_node(project_file, node) {
    var is_moose64 = project_file.project.is_moose64
    assert(node.kind == ast.N_STMT_FUNC)
    if node.symbol_info != none and
            node.symbol_info.typeref_expr != none {
        return node.symbol_info.typeref_expr
    }
    var type_expr = new TypeRefFuncExpr()
    if node.type_path != none and node.type_path.len > 0 {
        var anscope =
            project_file.make_attr_names_scope_from_funcattr(
                node, def_project_file=project_file,
                msgs=none, is_moose64=is_moose64
            )
        if anscope == none {
            throw new RuntimeError("Failed to get attr names scope.")
        }
        assert(not anscope.is_enum)
        if project_file.project == none {
            throw new RuntimeError("Unexpectedly, there's no "
                "project_file.project set which is required for "
                "this computation.")
        }
        var import_typepath = project_file.global_scope.
            get_import_path_for_global(
                project_file, anscope.storage_id)
        if import_typepath.len > 0 {
            type_expr.type_path = import_typepath
        }
        var self_type_expr = new TypeRefExpr()
        var gscope = none
        if not project_file.project.
                storage_id_to_global_scope_map.has(anscope.storage_id) {
            gscope = project_file.global_scope
        } else {
            gscope = project_file.project.
                storage_id_to_global_scope_map[
                    anscope.storage_id
                ]
        }
        assert(gscope.storage_id_to_entry.has(
            anscope.storage_id
        ))
        self_type_expr.name = gscope.storage_id_to_entry[
            anscope.storage_id
        ].label
        if import_typepath.len > 0 {
            self_type_expr.type_path = import_typepath.copy()
        }
        type_expr.arg_typeref_exprs.add(self_type_expr)
    }
    if node.has_arg_types {
        var arg_count = node.extended_final_arg_count()
        var i = 1
        while i <= arg_count {
            type_expr.arg_typeref_exprs.add(
                node.extended_final_arg_type_exprs()[i]
            )
            i += 1
        }
    }
    if node.has_failable and is_moose64 {
        var failable_type_expr = new TypeRefExpr()
        failable_type_expr.name = "moose64_failed_result_t"
        failable_type_expr.modifiers.add(
            new TypeRefMod("ref")
        )
        type_expr.arg_typeref_exprs.add(failable_type_expr)
    }
    if node.extended_final_has_return_type() {
        type_expr.return_typeref_expr =
            node.extended_final_return_type_expr()
    }
    return type_expr
}

type TypeRefExpr base ast.TreeNode {
    var type_path
    var name
    var modifiers = []
    var has_init_expr
    var is_func_ref = no
    var storage_ref = none
}

func TypeRefExpr.init {
    base.init()
    self.kind = ast.N_EXPR_TYPEREF
}

func TypeRefExpr.as_code(indent=0) {
    if self.damaged {
        return "(damaged type ref expr.)"
    }
    var prefix_mod_names = {"readonly"}
    var t = ""
    for mod in self.modifiers {
        if prefix_mod_names.has(mod.name) {
            if t != "" {
                t += " "
            }
            t += mod.as_str()
        }
    }
    if t != "" {
        t += " "
    }
    if self.type_path != none and self.type_path.len > 0 {
        t = self.type_path.join(".") + "." + t
    }
    t += self.name
    for mod in self.modifiers {
        if not prefix_mod_names.has(mod.name) {
            t += " " + mod.as_str()
        }
    }
    if self.has_init_expr {
        assert(self.subexprs.len == 1)
        t += self.subexprs[1].as_code(indent=(indent + 4))
    }
    return t
}

func TypeRefExpr.copy {
    var self_copy = base.copy()
    var old_modifiers = self_copy.modifiers
    self_copy.modifiers = []
    for item in old_modifiers {
        self_copy.modifiers.add(item.copy())
    }
    return self_copy
}

func TypeRefExpr.adjust_storage_to_file(pfile) {
    if self.storage_ref == none {
        return
    }
    if self.storage_ref.kind == st_ref.ST_GLOBAL {
        var ipath = pfile.global_scope.get_import_path_for_global(
            pfile, self.storage_ref.id
        )
        assert(typename(ipath) == "list")
        self.type_path = ipath
    }
}

func get_c_builtin_for_m64_base_type(name) {
    if not builtin_moose64_types.has(name) {
        return none
    }
    if name == "i32" {
        return "int32_t"
    } elseif name == "i64" {
        return "int64_t"
    } elseif name == "bool" {
        return "signed char"
    } elseif name == "byte" {
        return "unsigned char"
    } elseif name == "i16" {
        return "int16_t"
    } elseif name == "u16" {
        return "uint16_t"
    } elseif name == "u32" {
        return "uint32_t"
    } elseif name == "u64" or name == "size" {
        return "uint64_t"
    } elseif name == "any" {
        return "void"
    } else {
        print("horsec: error: Internal error, "
            "encountered unhandled C builtin type: " +
            name.as_str())
        throw new NotImplementedError(
            "Unhandled builtin type."
        )
    }
}

func TypeRefExpr.try_resolve_to_user_type(
        project_file, force_recompute=no, is_moose64=no
        ) {
    var builtin_names =
        if is_moose64 (builtin_moose64_types)
            else (builtin_horse64_types)
    if self.is_func_ref or builtin_names.has(self.name) {
        return none
    }
    if self.storage_ref != none and not force_recompute {
        return self.storage_ref.copy()
    }
    self.adjust_storage_to_file(project_file)
    var type_path = self.type_path
    if type_path != none and type_path.len == 0 {
        type_path = none
    }

    if self.name == none {
        print("horsec: error: Fatal internal error, "
            "trying to resolve type ref with no name: " +
            self.as_str())
    }
    assert(self.name != none)
    var result = project_file.try_lookup_symbol_path(
        none, name=self.name, type_path=type_path,
        is_write_access=no, is_moose64=is_moose64
    )
    self.storage_ref = result.copy()
    return later result
}

func TypeRefExpr.get_c_builtin_for_m64_base_type {
    if self.type_path != none and
            self.type_path.len > 0 {
        return none
    }
    return get_c_builtin_for_m64_base_type(self.name)
}

func TypeRefExpr.may_have_len_attr {
    if not builtin_moose64_types.has(self.name) {
        return yes
    }
    for mod in self.modifiers {
        if {"array"}.has(mod.name) {
            return yes
        }
    }
    return no
}

func TypeRefExpr.as_str {
    var t = "TypeRefExpr<" + self.as_code() + ">"
    return t
}

func _parse_typeref_notlater(
        tokens, pos, msgs, extend_typeref_expr=none,
        project_file=none,
        max_len=none, max_depth=64,
        is_moose64=no, debug=no
        ) {
    var startpos = pos
    if max_len == none {
        max_len = tokens.len
    }
    if pos > max_len {
        return none
    }

    func check_if_func_type(tokens, pos) {
        var startpos = pos
        if pos > max_len or
                tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != "(" {
            return none
        }
        var could_be_func = no
        pos += 1
        var bdepth = 1
        while pos < max_len and
                bdepth >= 1 {
            if tokens[pos].kind == token.T_ENCLOSE and
                    {'(', '[', '{'}.has(tokens[pos].str) {
                bdepth += 1
                pos += 1
                continue
            } elseif tokens[pos].kind == token.T_ENCLOSE and
                    {')', ']', '}'}.has(tokens[pos].str) {
                bdepth -= 1
                pos += 1
                if bdepth == 0 and could_be_func {
                    return (pos - startpos)
                }
                continue
            }
            if bdepth == 1 and
                    tokens[pos].kind == token.T_RIGHTPTR {
                could_be_func = yes
            }
            pos += 1
        }
        return none
    }
    func parse_func_type(tokens, pos) {
        func had_error(at_pos, description) {
            if not description.ends(" ") {
                description += " "
            }
            msgs.add(new msg.FileMsg(
                description + " func type "
                "in line " +
                token.get_line(tokens, startpos).as_str() +
                ", column " +
                token.get_col(tokens, startpos).as_str() + ".",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            var skiplen = token.get_naive_stmt_or_expr_len(
                tokens, startpos, max_len=max_len,
                for_expr=yes, is_moose64=is_moose64
            )
            var expr = new ast_expr.InvalidExpr(skiplen)
            return expr
        }
        var startpos = pos
        if pos > max_len or
                tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != "(" {
            return had_error(pos,
                "Invalid " + token.describe_token_at(
                    tokens, pos) + " "
                ", expected '(' to begin ")
        }
        pos += 1
        if pos > max_len or
                tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != "(" {
            return had_error(pos,
                "Invalid " + token.describe_token_at(
                    tokens, pos) + " "
                ", expected '(' to start args for ")
        }
        pos += 1

        # Parse argument list:
        var arg_types = []
        while pos <= max_len and
                (tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != ")") {
            if tokens[pos].kind != token.T_IDENT {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected identifier (T_IDENT) to "
                    "start next argument, or ')' to end "
                    "arguments for ")
            }
            if tokens[pos].kind == token.T_COMMA {
                pos += 1
                continue
            }
            assert(tokens[pos].kind == token.T_IDENT)
            pos += 1
            if tokens[pos].kind != token.T_LEFTPTR {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected '<-' (T_LEFTPTR) to "
                    "continue argument for ")
            }
            pos += 1
            var inner_expr = _parse_typeref_notlater(
                tokens, pos, msgs, project_file=project_file,
                max_len=max_len, is_moose64=is_moose64,
                debug=debug
            )
            if inner_expr == none {
                var skiplen = token.get_naive_stmt_or_expr_len(
                    tokens, startpos, max_len=max_len,
                    for_expr=yes, is_moose64=is_moose64
                )
                var expr = new ast_expr.InvalidExpr(skiplen)
                return expr
            }
            arg_types.add(inner_expr)
            pos += inner_expr.len
            if pos > max_len or
                    (tokens[pos].kind != token.T_COMMA and
                     (tokens[pos].kind != token.T_ENCLOSE or
                      tokens[pos].str != ')')) {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected ')' or ',' to end previous "
                    "argument")
            }
            if tokens[pos].kind == token.T_COMMA {
                pos += 1
            }
            continue
        }
        if pos > max_len or
                tokens[pos].kind != token.T_RIGHTPTR {
            if tokens[pos].kind != token.T_LEFTPTR {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected '->' (T_LEFTPTR) to "
                    "specif return type for ")
            }
        }
        var return_type = _parse_typeref_notlater(
            tokens, pos, msgs, project_file=project_file,
            max_len=max_len, is_moose64=is_moose64,
            debug=debug
        )
        if return_type == none {
            var skiplen = token.get_naive_stmt_or_expr_len(
                tokens, startpos, max_len=max_len,
                for_expr=yes, is_moose64=is_moose64
            )
            var expr = new ast_expr.InvalidExpr(skiplen)
            return expr
        }
        pos += return_type.token_len
        if pos > max_len or tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != ')' {
            return had_error(pos,
                "Invalid " + token.describe_token_at(
                    tokens, pos) + " "
                ", expected ')' (T_ENCLOSE) to "
                "end ")
        }
        pos += 1
        var func_ref = new TypeRefFuncExpr()
        func_ref.arg_typeref_exprs = arg_types
        func_ref.return_typeref_expr = return_type
        func_ref.token_len = pos - startpos
        return func_ref
    }

    var typeref_expr = extend_typeref_expr
    var start_token_len = 0
    if typeref_expr != none {
        start_token_len = typeref_expr.token_len
    }
    var typeref_token_len = start_token_len
    var typeref_damaged = no
    var mods = []
    while yes {
        if pos <= max_len and
                tokens[pos].kind == token.T_ENCLOSE and
                tokens[pos].str == "(" {
            var bracket_open_pos = pos
            if max_depth <= 0 {
                msgs.add(new msg.FileMsg(
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", exceeds maximum nesting depth "
                    "for type expression starting "
                    "in line " +
                    token.get_line(tokens, startpos).as_str() +
                    ", column " +
                    token.get_col(tokens, startpos).as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                pos += 1
                var expr_len = start_token_len + (pos - startpos)
                return new ast_expr.InvalidExpr(expr_len)
            }
            var is_func_type = check_if_func_type(tokens, pos)
            if typeref_expr == none and is_func_type {
                typeref_expr = parse_func_type(tokens, pos)
                assert(typeref_expr.token_len > 0)
                pos += typeref_expr.token_len
                continue
            }
            pos += 1  # Go past '('.
            var inner_expr = _parse_typeref_notlater(
                tokens, pos, msgs,
                extend_typeref_expr=typeref_expr,
                project_file=project_file,
                max_len=max_len, max_depth=(max_depth - 1),
                is_moose64=is_moose64, debug=debug
            )
            if inner_expr == none {
                # Revert back to before bracket.
                pos = bracket_open_pos
                break
            }
            pos += inner_expr.token_len
            if pos > max_len or
                    tokens[pos].kind != token.T_ENCLOSE or
                    tokens[pos].str != ")" {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected '(' "
                    "for ')' found "
                    "in line " +
                    token.get_line(tokens,
                                bracket_open_pos).as_str() +
                    ", column " +
                    token.get_col(tokens,
                                bracket_open_pos).as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                var expr_len = start_token_len + (pos - startpos)
                return new ast_expr.InvalidExpr(expr_len)
            }
            typeref_expr = inner_expr
            pos += 1  # Go past ')'
            typeref_token_len = start_token_len + (pos - startpos)
        }

        if typeref_expr == none and pos <= max_len and
                (tokens[pos].kind == token.T_IDENT or
                tokens[pos].kind == token.T_KEYWORD) and
                ((is_moose64 and
                  builtin_moose64_types.has(tokens[pos].str)) or
                 (not is_moose64 and
                  builtin_horse64_types.has(tokens[pos].str))) {
            typeref_expr = new TypeRefExpr()
            typeref_expr.name = tokens[pos].str
            typeref_expr.line = token.get_line(tokens, pos)
            typeref_expr.col = token.get_col(tokens, pos)
            pos += 1
            typeref_token_len =
                start_token_len + (pos - startpos)
        }
        if typeref_expr == none and pos <= max_len and
                tokens[pos].kind == token.T_IDENT and
                ((is_moose64 and
                  not builtin_moose64_type_modifiers.has(
                      tokens[pos].str)) or
                 (not is_moose64 and
                  not builtin_horse64_type_modifiers.has(
                      tokens[pos].str))) {
            typeref_expr = new TypeRefExpr()
            typeref_expr.name = tokens[pos].str
            typeref_expr.line = token.get_line(tokens, pos)
            typeref_expr.col = token.get_col(tokens, pos)
            pos += 1
            typeref_token_len =
                start_token_len + (pos - startpos)
            while pos + 1 <= max_len and
                    tokens[pos].kind == token.T_DOT and
                    tokens[pos + 1].kind == token.T_IDENT {
                if typeref_expr.type_path == none {
                    typeref_expr.type_path = []
                }
                typeref_expr.type_path.add(typeref_expr.name)
                typeref_expr.name = tokens[pos + 1].str
                typeref_token_len += 2
                pos += 2
            }
        }
        var had_mods = no
        while pos <= max_len and
                (tokens[pos].kind == token.T_IDENT or
                tokens[pos].kind == token.T_KEYWORD) and
                ((is_moose64 and
                  builtin_moose64_type_modifiers.has(
                      tokens[pos].str
                  )) or
                 (not is_moose64 and
                  builtin_horse64_type_modifiers.has(
                      tokens[pos].str
                  ))) {
            had_mods = yes
            var modifier_name = tokens[pos].str
            var modifier = new TypeRefMod(modifier_name)
            mods.add(modifier)
            pos += 1
            typeref_token_len = start_token_len + (pos - startpos)
            if modifier_name == "array" and is_moose64 {
                while pos + 2 <= max_len and
                        tokens[pos].kind == token.T_ENCLOSE and
                        tokens[pos].str == '[' and
                        tokens[pos + 2].kind == token.T_ENCLOSE and
                        tokens[pos + 2].str == ']' {
                    if tokens[pos + 1].kind == token.T_IDENT {
                        var prop = new TypeRefModProp_Range()
                        prop.range_value_label =
                            tokens[pos + 1].str
                    } elseif {token.T_NUM, token.T_BIGNUM}.has(
                            tokens[pos + 1].kind == token.T_NUM
                            ) {
                        var prop = new TypeRefModProp_Range()
                        prop.range_value_num =
                            tokens[pos + 1].str.to_num()
                    } else {
                        msgs.add(new msg.FileMsg(
                            "Unexpected '[' followed by " +
                                token.describe_token_at(
                                    tokens, pos) + " "
                            ", expected valid range expression "
                            "for array modifier.",
                            source_file=project_file,
                            line=token.get_line(tokens, pos),
                            col=token.get_col(tokens, pos),
                        ))
                        typeref_damaged = yes
                        return typeref_expr
                    }
                    pos += 3
                    typeref_token_len =
                        start_token_len + (pos - startpos)
                }
            }
        }
        if not had_mods {
            break
        }
    }
    if typeref_token_len <= start_token_len {
        return none
    }
    if typeref_expr != none {
        assert(typeref_token_len > 0)
        typeref_expr.damaged = typeref_damaged
        typeref_expr.modifiers = mods
        typeref_expr.token_len = typeref_token_len
    }
    return typeref_expr
}

func parse_typeref(
        tokens, pos, msgs, extend_typeref_expr=none,
        project_file=none, max_len=none, is_moose64=no,
        debug=no
        ) {
    if max_len == none {
        max_len = tokens.len
    }
    var expr = _parse_typeref_notlater(
        tokens, pos, msgs,
        extend_typeref_expr=extend_typeref_expr,
        project_file=project_file,
        max_len=max_len, is_moose64=is_moose64,
        debug=debug
    )
    return later expr
}

