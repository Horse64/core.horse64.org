 ## @module compiler.typeref
# Copyright (c) 2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import compiler.ast as ast
import compiler.ast.analyze as ast_analyze
import compiler.ast.expr as ast_expr
import compiler.msg as msg
import compiler.token as token
import compiler.storage.ref as st_ref
import compiler.storage.scope as st_scope
import compiler.token
import compiler.typeinfo as typeinfo

const builtin_horse64_types = {}
const builtin_horse64_type_modifiers = {}
const builtin_moose64_types = {
    "byte", "i8", "i16", "u16", "addr", "addr_diff",
    "i32", "i64", "size", "u32", "u64",
    "f32", "f64", "bool", "empty",
    "any", "auto", "moose64_failed_result_t"
}
const builtin_moose64_type_modifiers = {
    "ref", "array", "c_array", "readonly"
}
const builtin_moose64_unsigned_num_types = {
    "byte", "u8", "u16", "u32", "u64", "size",
    "addr"
}
const builtin_moose64_signed_num_types = {
    "i8", "i16", "i32", "i64", "f32",
    "f64", "addr_diff"
}
const builtin_moose64_num_types =
    builtin_moose64_unsigned_num_types +
    builtin_moose64_signed_num_types

func is_pos_inside_func_return_type(
        tokens, pos, max_len=none, is_moose64=no) {
    if max_len == none {
        max_len = tokens.len
    }
    func pos_is_type_kw(pos) {
        if pos < 1 or pos > max_len {
            return no
        }
        if {token.T_KEYWORD, token.T_IDENT}.has(
                tokens[pos].kind) and
                ((is_moose64 and
                 (builtin_moose64_types.has(tokens[pos].str) or
                  builtin_moose64_type_modifiers.has(tokens[pos].str))) or
                 (not is_moose64 and
                  (builtin_horse64_types.has(tokens[pos].str) or
                   builtin_horse64_type_modifiers.has(tokens[pos].str)))
                ) {
            return yes
        }
        return no
    }
    var i = pos
    if not pos_is_type_kw(i) {
        return no
    }
    while i >= 1 and tokens[i].kind != token.T_RIGHTPTR and
            pos_is_type_kw(i) {
        i -= 1
    }
    if i < 1 or tokens[i].kind != token.T_RIGHTPTR {
        return no
    }
    return yes
}

type TypeRefModProp {
    var prop_name = "unknown"
}

type TypeRefModProp_Range base TypeRefModProp {
    var prop_name = "range"
    var range_value_num
    var range_value_label
}

func TypeRefModProp_Range.as_str {
    var t = "["
    if self.range_value_num != none {
        t += self.range_value_num.as_str()
    } else {
        t += self.range_value_label.as_str()
    }
    t += "]"
    return t
}

func TypeRefModProp_Range.is_equivalent_prop_to(other_mod) {
    if other_mod.prop_name != self.prop_name {
        return no
    }
    if self.range_value_num != none {
        if self.range_value_num !=
                other_mod.range_value_num {
            return no
        }
    } else {
        return no
    }
    return yes
}

func TypeRefModProp_Range.as_array_key {
    var t = "m64_mod_prop_range_"
    if self.range_value_num != none {
        t += self.range_value_num.as_str()
    } else {
        t += self.range_value_label.as_str()
    }
    return t
}

type TypeRefMod {
    var name
    var props = []
}

func TypeRefMod.init(name) {
    self.name = name + ""
}

func TypeRefMod.as_str {
    var t = self.name + ""
    for prop in self.props {
        t += prop.as_str()
    }
    return t
}

func TypeRefMod.as_array_key {
    var t = self.name + ""
    for prop in self.props {
        t += prop.as_array_key()
    }
    return t
}

func TypeRefMod.as_c_code(
        indent=0, global_name_assign_callback=none,
        project=none, project_file=none, is_moose64=no
        ) {
    if self.name == "readonly" {
        return "const"
    }
    if {"ref", "c_array", "implicit ref"}.has(self.name) {
        return "*"
    }
    for prop in self.props {
        t += prop.as_c_code(indent=0,
            global_name_assign_callback=
                global_name_assign_callback,
            project=project, project_file=project_file,
            is_moose64=is_moose64)
    }
    return self.name
}

func TypeRefMod.is_equivalent_mod_to(other_mod) {
    if self.name != other_mod.name and
            (not {"ref", "c_array"}.has(self.name) or
            not {"ref", "c_array"}.has(other_mod.name)) {
        return no
    }
    if self.props.len != other_mod.props.len {
        return no
    }

    var claimed_indexes = {}
    for prop in self.props {
        var found_equivalent = no
        var idx = 0
        for other_prop in other_tinfo.props {
            idx += 1
            if claimed_indexes.has(idx) {
                continue
            }
            if other_prop.is_equivalent_prop_to(prop) {
                claimed_indexes.add(idx)
                found_equivalent = yes
                break
            }
        }
        if not found_equivalent {
            return no
        }
    }
    return yes
}

type TypeRefFuncExpr base TypeRefExpr {
    var arg_typeref_exprs = []
    var return_typeref_expr
    var func_storage_ref
    var is_failable = no
    var is_func_attr
}

func TypeRefFuncExpr.init {
    base.init()
    self.is_func_ref = yes
    self.name = none
    self.type_path = none
}

func TypeRefFuncExpr.is_equivalent(other_func_expr) {
    if not other_func_expr.is_func_ref {
        return no
    }
    if other_func_expr.arg_typeref_exprs.len !=
            self.arg_typeref_exprs.len {
        return no
    }
    if self.return_typeref_expr == none or
            self.return_typeref_expr.name == "empty" {
        if other_func_expr.return_typeref_expr != none and
                other_func_expr.return_typeref_expr.name !=
                "empty" {
            return no
        }
    } else {
        if not self.return_typeref_expr.is_equivalent(
                other_func_expr.return_typeref_expr) {
            return no
        }
    }
    if self.modifiers.len != other_func_expr.modifiers.len {
        return no
    }
    var modidx = 1
    while modidx <= self.modifiers.len {
        if not self.modifiers[modidx].is_equivalent_mod(
                other_func_expr.modifiers[modidx]) {
            return no
        }
        modidx += 1
    }
    var argidx = 1
    while argidx <= self.arg_typeref_exprs.len {
        if not self.arg_typeref_exprs[argidx].is_equivalent(
                other_func_expr.arg_typeref_exprs[argidx]) {
            return no
        }
        argidx += 1
    }
    return yes
}

func TypeRefFuncExpr.as_str(indent=0) {
    if self.damaged {
        return "(damaged type ref func expr.)"
    }
    var prefix_mod_names = {"readonly"}
    var t = ""
    for mod in self.modifiers {
        if prefix_mod_names.has(mod.name) {
            if t != "" {
                t += " "
            }
            t += mod.as_str()
        }
    }
    if t != "" {
        t += " "
    }
    t += "(("
    var is_first_param = yes
    for param_type in self.arg_typeref_exprs {
        if is_first_param {
            is_first_param = no
        } else {
            t += ", "
        }
        t += "_<-" + param_type.as_str()
    }
    t += ")->"
    if self.return_typeref_expr != none {
        t += self.return_typeref_expr.as_str()
    }
    t += ")"
    for mod in self.modifiers {
        if not prefix_mod_names.has(mod.name) {
            t += " " + mod.as_str()
        }
    }
    if self.has_init_expr {
        assert(self.subexprs.len == 1)
        t += self.subexprs[1].as_str(indent=indent)
    }
    return t
}

func TypeRefFuncExpr.as_c_code(
        indent=0, global_name_assign_callback=none,
        global_register_m64_array_callback=none,
        c_name_to_insert_if_func_ptr=none,
        project=none, project_file=none,
        is_moose64=no
        ) {
    if self.damaged {
        return "(damaged type ref func expr.)"
    }
    var prefix_mod_names = {"readonly"}
    var t = ""

    for mod in self.modifiers {
        if prefix_mod_names.has(mod.name) {
            if t != "" {
                t += " "
            }
            t += mod.as_c_code(indent=(indent + 4),
                global_name_assign_callback=
                    global_name_assign_callback,
                project=project, project_file=project_file,
                is_moose64=is_moose64)
        }
    }
    if self.return_typeref_expr != none and
            (self.return_typeref_expr.is_user_type() or
            self.return_typeref_expr.name != "empty") {
        t += self.return_typeref_expr.as_c_code(
            indent=(indent + 4),
            global_name_assign_callback=
                global_name_assign_callback,
            global_register_m64_array_callback=
                global_register_m64_array_callback,
            project=project, project_file=project_file,
            is_moose64=is_moose64)
    } else {
        t += "void"
    }
    t += " (*"
    if c_name_to_insert_if_func_ptr != none {
        t += c_name_to_insert_if_func_ptr
    } elseif self.name != none {
        # FIXME: Handle global name adjustment here.
        t += self.name
    }
    t += ")"

    if t != "" {
        t += " "
    }
    t += "("
    var is_first_param = yes
    for param_type in self.arg_typeref_exprs {
        if is_first_param {
            is_first_param = no
        } else {
            t += ", "
        }
        t += param_type.as_c_code(indent=(indent + 4),
            global_name_assign_callback=
                global_name_assign_callback,
            global_register_m64_array_callback=
                global_register_m64_array_callback,
            project=project, project_file=project_file,
            is_moose64=is_moose64)
    }
    t += ")"
    for mod in self.modifiers {
        if not prefix_mod_names.has(mod.name) {
            t += " " + mod.as_c_code(indent=(indent + 4),
                global_name_assign_callback=
                    global_name_assign_callback,
                project=project, project_file=project_file,
                is_moose64=is_moose64)
        }
    }
    return t
}

func TypeRefFuncExpr.copy {
    var self_copy = base.copy()
    var old_args = self_copy.arg_typeref_exprs
    self_copy.arg_typeref_exprs = []
    for old_arg in old_args {
        self_copy.arg_typeref_exprs.add(old_arg.copy())
    }
    self_copy.return_typeref_expr =
        self_copy.return_typeref_expr.copy()
    self_copy.func_storage_ref =
        self_copy.func_storage_ref.copy()
    return self_copy
}

func TypeRefFuncExpr.try_resolve_param_types(
        project_file, recursive=no, force_recompute=no,
        is_moose64=no
        ) {
    var had_failure = no

    var builtin_names =
        if is_moose64 (builtin_moose64_types)
            else (builtin_horse64_types)
    func resolve_item(item) {
        if not item.is_func_ref {
            var result = item.try_resolve_to_user_type(
                project_file, force_recompute=force_recompute,
                is_moose64=is_moose64
            ) later:

            await result
            if not result and not builtin_names.has(item.name) {
                had_failure = yes
            }
            return later
        }
        var result = item.try_resolve_to_user_type(
            project_file, recursive=recursive,
            skip_params=(not recursive),
            force_recompute=force_recompute,
            is_moose64=is_moose64
        ) later:

        await result
        # Func typerefs may not point to any specific actual
        # defined function, so we ignore if this fails.
    }

    base.try_resolve_to_user_type(
        project_file, force_recompute=force_recompute,
        is_moose64=is_moose64
    )
    later:

    var queue = self.arg_typeref_exprs.copy()
    if self.return_typeref_expr != none {
        queue.add(self.return_typeref_expr)
    }
    if queue.len == 0 {
        return later not had_failure
    }
    var item = queue.pop()
    var _unused = resolve_item(item)
    later:

    await _unused

    if queue.len == 0 {
        return later not had_failure
    }
    item = queue.pop()
    _unused = resolve_item(item) later repeat
}

func TypeRefFuncExpr.try_resolve_to_user_type(
        project_file, recursive=no, skip_params=no,
        force_recompute=no,
        is_moose64=no
        ) {
    func run_concurrent {
        if skip_params {
            return later yes
        }
        var result = self.try_resolve_param_types(
            project_file, recursive=recursive,
            force_recompute=force_recompute,
            is_moose64=is_moose64
        ) later:

        await result
        if not result or self.func_storage_ref == none {
            return later no
        }
        return later yes
    }
    var result = run_concurrent()

    later:
    await result
    if not result {
        return later none
    }
    if self.func_storage_ref == none {
        return later none
    }
    return later self.func_storage_ref.copy()
}

func create_typeref_from_func_node(
        project_file, node, debug=no
        ) {
    var is_moose64 = project_file.project.is_moose64
    assert(node.kind == ast.N_STMT_FUNC)
    assert(node.extended_final_arg_count() == 0 or
        not is_moose64 or node.extended_final_has_arg_types())
    assert(node.extended_final_arg_count() == 0 or
        not is_moose64 or node.was_ever_extended() or
        node.has_arg_types)
    if node.symbol_info != none and
            node.symbol_info.typeref_expr != none {
        return node.symbol_info.typeref_expr
    }
    var type_expr = new TypeRefFuncExpr()
    type_expr.is_func_attr = no
    if node.type_path != none and node.type_path.len > 0 {
        var anscope =
            project_file.make_attr_names_scope_from_funcattr(
                node, def_project_file=project_file,
                msgs=none, is_moose64=is_moose64
            )
        if anscope == none {
            throw new RuntimeError("Failed to get attr names scope.")
        }
        assert(not anscope.is_enum)
        if project_file.project == none {
            throw new RuntimeError("Unexpectedly, there's no "
                "project_file.project set which is required for "
                "this computation.")
        }
        var import_typepath = project_file.global_scope.
            get_import_path_for_global(
                project_file, anscope.storage_id)
        if import_typepath.len > 0 {
            type_expr.type_path = import_typepath
        }
        var self_type_expr = new TypeRefExpr()
        var gscope = none
        if not project_file.project.
                storage_id_to_global_scope_map.has(
                    anscope.storage_id
                ) {
            gscope = project_file.global_scope
        } else {
            gscope = project_file.project.
                storage_id_to_global_scope_map[
                    anscope.storage_id
                ]
        }
        assert(gscope.storage_id_to_entry.has(
            anscope.storage_id
        ))
        self_type_expr.name = gscope.storage_id_to_entry[
            anscope.storage_id
        ].label
        self_type_expr.storage_ref = new st_ref.StorageRef(
            st_ref.ST_GLOBAL, anscope.storage_id
        )
        if import_typepath.len > 0 {
            self_type_expr.type_path = import_typepath.copy()
        }
        self_type_expr.modifiers.add(new TypeRefMod("implicit ref"))
        if node.extended_final_is_readonly() {
            self_type_expr.modifiers.add_at(
                1, new TypeRefMod("readonly"))
        }
        type_expr.arg_typeref_exprs.add(self_type_expr)
        type_expr.is_func_attr = yes
    }
    if node.extended_final_has_arg_types() {
        var arg_count = node.extended_final_arg_count()
        var i = 1
        while i <= arg_count {
            type_expr.arg_typeref_exprs.add(
                node.extended_final_arg_type_exprs()[i]
            )
            i += 1
        }
    } elseif not is_moose64 and
            (node.extended_final_arg_count() > 0 or
             not node.extended_final_has_return_type()) {
        # For now, we don't support returning any signature
        # for Horse64, unless it's very clear everything
        # was specified.
        return none
    }
    if node.has_failable and is_moose64 {
        var failable_type_expr = new TypeRefExpr()
        failable_type_expr.name = "moose64_failed_result_t"
        failable_type_expr.modifiers.add(
            new TypeRefMod("ref")
        )
        type_expr.arg_typeref_exprs.add(failable_type_expr)
        type_expr.is_failable = yes
    }
    if node.extended_final_has_return_type() {
        type_expr.return_typeref_expr =
            node.extended_final_return_type_expr()
    } else {
        if not is_moose64 {
            # FIXME: For Horse64, we could scan if any return inside
            # the function has an expression argument, and then
            # still allow the type signature to be completed.
            # For now, however, we don't allow this.
            return none
        }
    }
    if debug {
        print(if is_moose64 ("moosec: ") else ("horsec: ") +
            "debug: "
            "create_typeref_from_func_node(): " +
            "Got result: "
            "node.label='" + node.label + "' "
            "node.type_path=" + node.type_path.as_str() + " "
            "type_expr.is_func_attr=" +
                type_expr.is_func_attr.as_str() + " "
            "node.extended_final_has_arg_types()=" +
                node.extended_final_has_arg_types().as_str() + " "
            "node.extended_final_arg_count()=" +
                node.extended_final_arg_count().as_str() + " "
            "node=" + node.as_str().sub(1, 200) + "... " +
            "type_expr=" + type_expr.as_str())
    }
    return type_expr
}

type TypeRefExpr base ast.TreeNode {
    var type_path
    var name
    var modifiers = []
    var has_init_expr
    var is_func_ref = no
    var storage_ref = none

    var is_special_madeup_builtin = no  # Like .len, etc.
    var special_madeup_builtin_base_expr = none
}

func TypeRefExpr.init {
    base.init()
    self.kind = ast.N_EXPR_TYPEREF
}

func TypeRefFuncExpr.is_equivalent(other_expr) {
    if other_expr.is_func_ref {
        return no
    }
    if other_expr.name != self.name {
        return no
    }
    if self.is_special_madeup_builtin !=
            other_expr.is_special_madeup_builtin {
        return no
    }
    if self.special_madeup_builtin_base_expr !=
            other_expr.special_madeup_builtin_base_expr {
        return no
    }
    if self.storage_ref != none {
        if other_expr.storage_ref == none {
            return no
        }
        if not other_expr.storage_ref.alike(self.storage_ref) {
            return no
        }
    } elseif other_expr.storage_ref != none {
        return no
    }
    if self.type_path == none or self.type_path.len == 0 {
        if other_expr.type_path != none and
                other_expr.type_path.len != 0 {
            return no
        }
    } else {
        if self.type_path.len != other_expr.type_path.len {
            return no
        }
        var type_path_idx = 1
        while type_path_idx <= type_path.len {
            if self.type_path[type_path_idx] !=
                    other_expr.type_path[type_path_idx] {
                return no
            }
            type_path_idx += 1
        }
    }
    if self.modifiers.len != other_func_expr.modifiers.len {
        return no
    }
    var modidx = 1
    while modidx <= self.modifiers.len {
        if not self.modifiers[modidx].is_equivalent_mod_to(
                other_func_expr.modifiers[modidx]) {
            return no
        }
        modidx += 1
    }
    return yes
}

func TypeRefExpr.as_code(indent=0) {
    if self.damaged {
        return "(damaged type ref expr.)"
    }
    var prefix_mod_names = {"readonly"}
    var t = ""
    for mod in self.modifiers {
        if prefix_mod_names.has(mod.name) {
            if t != "" {
                t += " "
            }
            t += mod.as_str()
        }
    }
    if t != "" {
        t += " "
    }
    if self.type_path != none and self.type_path.len > 0 {
        t = self.type_path.join(".") + "." + t
    }
    if self.name == none {
        t += "(unnamed type)"
    } else {
        t += self.name
    }
    for mod in self.modifiers {
        if not prefix_mod_names.has(mod.name) {
            t += " " + mod.as_str()
        }
    }
    if self.has_init_expr {
        assert(self.subexprs.len == 1)
        t += self.subexprs[1].as_code(indent=(indent + 4))
    }
    return t
}

func TypeRefExpr.as_c_code(
        indent=0, global_name_assign_callback=none,
        global_register_m64_array_callback=none,
        c_name_to_insert_if_func_ptr=none,
        project=none, project_file=none,
        is_moose64=no
        ) {
    if self.damaged {
        return "(damaged type ref expr.)"
    }

    if project_file != none and project == none {
        project = project_file.project
    }
    if self.is_array() {
        var ainfo = self.get_array_info(
            global_register_m64_array_callback=
                global_register_m64_array_callback,
            project=project,
            project_file=project_file,
            is_moose64=is_moose64)
        assert(ainfo != none)
        var inner_tinfo = ainfo[2]
        var t = ""
        for mod in ainfo[3] {
            if prefix_mod_names.has(mod.name) {
                if t != "" {
                    t += " "
                }
                t += mod.as_c_code(indent=indent,
                    global_name_assign_callback=
                        global_name_assign_callback,
                    project=project, project_file=project_file,
                    is_moose64=is_moose64)
            }
        }
        if t != "" {
            t += " "
        }
        t += "struct __m64arraystruct__" + ainfo[1] + "*"
        for mod in ainfo[3] {
            if not prefix_mod_names.has(mod.name) {
                if t != "" {
                    t += " "
                }
                t += mod.as_c_code(indent=indent,
                    global_name_assign_callback=
                        global_name_assign_callback,
                    project=project, project_file=project_file,
                    is_moose64=is_moose64)
            }
        }
        return t
    }

    var prefix_mod_names = {"readonly"}
    var t = ""
    for mod in self.modifiers {
        if prefix_mod_names.has(mod.name) {
            if t != "" {
                t += " "
            }
            t += mod.as_c_code(indent=indent,
                global_name_assign_callback=
                    global_name_assign_callback,
                project=project, project_file=project_file,
                is_moose64=is_moose64)
        }
    }
    if t != "" {
        t += " "
    }
    if self.is_user_type() or
            not _m64_to_c_name_map.has(self.name) {
        var sinfo = none
        if global_name_assign_callback != none and
                self.storage_ref != none {
            sinfo = st_ref.ref_to_symbol_info(
                self.storage_ref,
                project=project,
                is_moose64=is_moose64
            )
            if sinfo.def_file == none {
                sinfo = none
            }
        }
        if sinfo != none {
            t += global_name_assign_callback(sinfo.name,
                project_file=sinfo.def_file)
        } else {
            t += self.name
        }
    } else {
        t += _m64_to_c_name_map[self.name]
    }
    for mod in self.modifiers {
        if not prefix_mod_names.has(mod.name) {
            t += " " + mod.as_c_code(indent=indent,
                global_name_assign_callback=
                    global_name_assign_callback,
                project=project, project_file=project_file,
                is_moose64=is_moose64)
        }
    }
    if self.has_init_expr {
        assert(self.subexprs.len == 1)
        t += self.subexprs[1].as_c_code(indent=(indent + 4),
            global_name_assign_callback=
                global_name_assign_callback,
            project=project, project_file=project_file,
            is_moose64=is_moose64)
    }
    return t
}

func TypeRefExpr.copy {
    var self_copy = base.copy()
    var old_modifiers = self_copy.modifiers
    self_copy.modifiers = []
    for item in old_modifiers {
        self_copy.modifiers.add(item.copy())
    }
    return self_copy
}

func TypeRefExpr.adjust_storage_to_file(pfile) {
    if self.storage_ref == none {
        return
    }
    if self.storage_ref.kind == st_ref.ST_GLOBAL {
        var ipath = pfile.global_scope.get_import_path_for_global(
            pfile, self.storage_ref.id
        )
        assert(typename(ipath) == "list")
        self.type_path = ipath
    }
}

func TypeRefExpr.is_readonly {
    var t = typeinfo.TypeInfo(typeinfo.TI_USERTYPE)
    t.modifiers = self.modifiers.copy()
    return t.is_readonly()
}

func TypeRefExpr.is_array {
    var t = typeinfo.TypeInfo(typeinfo.TI_USERTYPE)
    t.modifiers = self.modifiers.copy()
    return t.is_array()
}

func TypeRefExpr.get_array_info(
        global_register_m64_array_callback=none,
        project=none, project_file=none,
        is_moose64=no) {
    var t = typeinfo.create_typeinfo_from_typeexpr(
        self, is_moose64=is_moose64)
    return typeinfo.get_array_type_info(
        t, global_register_m64_array_callback=
            global_register_m64_array_callback,
        project=project, project_file=project_file,
        is_moose64=is_moose64)
}

func TypeRefExpr.ref_count(
        include_c_arrays=yes,
        include_arrays=no,
        include_implicit_refs=no,
        include_explicit_refs=yes,
        ) {
    var t = typeinfo.TypeInfo(typeinfo.TI_USERTYPE)
    t.modifiers = self.modifiers.copy()
    return t.ref_count(
        include_c_arrays=include_c_arrays,
        include_arrays=include_arrays,
        include_implicit_refs=include_implicit_refs,
        include_explicit_refs=include_explicit_refs,
    )
}

func get_known_c_type_size(c_type) {
    if {"int32_t", "uint32_t", "_m64_float32_t"}.has(c_type) {
        return 4
    } elseif {"int64_t", "uint64_t",
            "_m64_float64_t"
            }.has(c_type) {
        return 8
    } elseif {"signed char", "unsigned char"}.has(c_type) {
        return 4
    }
    return none
}

const _m64_to_c_name_map = {
    "f32"-> "_m64_float32_t",
    "f64"-> "_m64_float64_t",
    "i32"-> "int32_t",
    "i64"-> "int64_t",
    "bool"-> "signed char",
    "byte"-> "unsigned char",
    "i16"-> "int16_t",
    "u16"-> "uint16_t",
    "u32"-> "uint32_t",
    "u64"-> "uint64_t",
    "size"-> "uint64_t",
    "addr_diff"-> "intptr_t",
    "addr"-> "uintptr_t",
    "moose64_failed_result_t"-> "uint32_t",
    "any"->"void",
    "empty"-> "void",
}

func get_c_builtin_for_m64_base_type(name) {
    if not builtin_moose64_types.has(name) {
        return none
    }
    if _m64_to_c_name_map.has(name) {
        return _m64_to_c_name_map[name]
    } else {
        print("horsec: error: Internal error, "
            "encountered unhandled C builtin type: " +
            name.as_str())
        throw new NotImplementedError(
            "Unhandled builtin type."
        )
    }
}

func TypeRefExpr.try_resolve_to_user_type_nonrecursive(
        project_file, force_recompute=no, is_moose64=no
        ) {
    var builtin_names =
        if is_moose64 (builtin_moose64_types)
            else (builtin_horse64_types)
    if self.is_func_ref or builtin_names.has(self.name) {
        if self.is_func_ref and self.storage_ref == none and
                self.func_storage_ref != none {
            self.storage_ref = self.func_storage_ref.copy()
        }
        return none
    }
    if self.storage_ref != none and not force_recompute {
        return self.storage_ref.copy()
    }
    self.adjust_storage_to_file(project_file)
    var type_path = self.type_path
    if type_path != none and type_path.len == 0 {
        type_path = none
    }

    if self.name == none {
        print("horsec: error: Fatal internal error, "
            "trying to resolve type ref with no name: " +
            self.as_str())
    }
    assert(self.name != none)
    var result = project_file.try_lookup_symbol_path(
        none, name=self.name, type_path=type_path,
        is_write_access=no, is_moose64=is_moose64
    )
    self.storage_ref = result.copy()
    return result
}

func TypeRefExpr.try_resolve_to_user_type(
        project_file, force_recompute=no, is_moose64=no
        ) {
    return later self.try_resolve_to_user_type_nonrecursive(
        project_file, force_recompute=force_recompute,
        is_moose64=is_moose64,
    )
}

func TypeRefExpr.get_c_builtin_for_m64_base_type {
    if self.type_path != none and
            self.type_path.len > 0 {
        return none
    }
    return get_c_builtin_for_m64_base_type(self.name)
}

func TypeRefExpr.is_user_type {
    if self.is_special_madeup_builtin {
        return no
    }
    return not builtin_moose64_types.has(self.name)
}

func TypeRefExpr.may_have_data_attr {
    if not builtin_moose64_types.has(self.name) {
        return yes
    }
    for mod in self.modifiers {
        if {"array"}.has(mod.name) {
            return yes
        }
    }
    return no
}

func TypeRefExpr.may_have_len_attr {
    if not builtin_moose64_types.has(self.name) {
        return yes
    }
    for mod in self.modifiers {
        if {"array"}.has(mod.name) {
            return yes
        }
    }
    return no
}

func TypeRefExpr.as_str {
    var t = "TypeRefExpr<" + self.as_code() + ">"
    return t
}

type TypeRefAndExprResult {
    var storage_ref
    var type_expr
    var resolved_func_is_override = no
    var has_self_expr = no
}

## Based on a node that is some identifier ref AST node,
## and a maybe already known reference for its origin,
## this returns the AST typeref expression and the
## storage reference for the type of the referenced value.
## For a referenced function as part of a call, it can
## also figure out if it should be redirected to an override.
func resolve_st_ref_to_type_ref_and_expr(
        project_file, value_ref,
        node=none, node_parents=none,
        apply_func_override_for_args_node=none,
        ignore_if_ref_none=no,
        msgs=none, is_moose64=no,
        debug=no,
        ) {
    var dbg_header = if is_moose64
        ("moosec: debug: ") else ("horsec: debug: ")

    if debug {
        print(dbg_header +
            "resolve_st_ref_to_type_ref_and_expr() "
            "called on: node=" + node.as_str() + " "
            "apply_func_override_for_args_node=" +
                apply_func_override_for_args_node.as_str() + " "
            "value_ref=" + value_ref.as_str() + " "
            "node_parents.len=" + if node_parents != none
                (node_parents.len.as_str())
                else ("<parents unset>") + " "
            "is_moose64=" + is_moose64.as_str())
    }
    if apply_func_override_for_args_node != none and
            (apply_func_override_for_args_node.kind !=
                ast.N_EXPR_CALLARGS or
             node == none or
             node_parents == none or node_parents.len == 0 or
             node_parents[node_parents.len].kind !=
                ast.N_EXPR_BINOP or
             node_parents[node_parents.len].optoken.str != "(" or
             node_parents[node_parents.len].subexprs[1] != node or
             node_parents[node_parents.len].subexprs[2] !=
                apply_func_override_for_args_node) {
        throw new RuntimeError(
            "Internal error: "
            "Invalid apply_func_override_for_args_node "
            "parameter not matching node_parents chain, or "
            "node is unset. One of those three parameters "
            "is bugged. Please report this error to the "
            "compiler makers.")
    }

    var override_resolution_result = none
    func try_resolve_override_if_needed {
        if apply_func_override_for_args_node == none {
            return later none
        }
        # In this case, delegate to get_called_or_assigned_func_types()
        # which can resolve func overrides.
        var result = ast_analyze.
            get_called_or_assigned_func_types(
                project_file, node,
                node_parents,
                allow_matching_func_override=(
                    node.kind ==
                        ast.N_EXPR_IDREF or
                    (node.kind == ast.N_EXPR_BINOP and
                    node.optoken.str == "." and
                    node.subexprs[2].kind == ast.N_EXPR_IDREF)
                ),
                msgs=msgs,
                is_moose64=is_moose64,
                debug=debug,
            ) later:

        await result
        if debug {
            var have_known_error_msg = no
            if msgs != none {
                for m in msgs {
                    if m.kind == msg.M_ERROR {
                        have_known_error_msg = yes
                        break
                    }
                }
            }
            print(dbg_header +
                "resolve_st_ref_to_type_ref_and_expr(): "
                "Got get_called_or_assigned_func_types result, "
                "result=" + result.as_str() +
                " (is msgs set: " +
                    (msgs != none).as_str() + ", "
                "node.damaged: " + node.damaged.as_str() + ", "
                "have_known_error_msg=" +
                    have_known_error_msg.as_str() + ")")
        }
        if result == none or
                result.func_var_name == none or
                result.func_ref == none or
                result.func_var_type_expr == none {
            # Couldn't be resolved to exact known function
            # and therefore also guaranteed not identified as
            # any override.
            return later none
        }
        # This function may be an override, so update
        # our info from what we obtained above:
        var result_ref = result.func_ref
        var result_type_expr = result.func_var_type_expr
        override_resolution_result = new TypeRefAndExprResult()
        override_resolution_result.storage_ref = result_ref
        override_resolution_result.type_expr = result_type_expr
        if result.func_was_overridden {
            override_resolution_result.
                resolved_func_is_override = yes
        }
        if result.self_var_type_expr != none {
            override_resolution_result.has_self_expr = yes
        }
    }
    try_resolve_override_if_needed() later:

    if override_resolution_result != none {
        return later override_resolution_result
    }
    if value_ref == none and node != none and
            node.kind == ast.N_EXPR_IDREF and
            node.ref != none {
        value_ref = node.ref
    }
    if value_ref == none {
        if not ignore_if_ref_none {
            throw new ValueError("Need value_ref parameter set, "
                "since the AST node doesn't have any ref info.")
        }
        if debug {
            print(dbg_header +
                "resolve_st_ref_to_type_ref_and_expr() "
                "result: Nothing, since value_ref is none.")
        }

        var result = new TypeRefAndExprResult()
        return later result
    }
    var lookup_label = none
    if node != none and has_attr(node, "label") {
        lookup_label = node.label
    }
    var result_ref = none
    var result_expr = none
    var var_node = none
    if value_ref.kind == st_ref.ST_LOCAL and
            lookup_label != none and
            node_parents != none and
            node_parents.len > 0 {
        var_node =
            st_scope.find_def_node_from_idref_node(
                node, node_parents
            )
        if var_node == none {
            if debug {
                print(dbg_header +
                    "resolve_st_ref_to_type_ref_and_expr() "
                    "result: Nothing, since local var "
                    "def node wasn't found.")
            }
            var result = new TypeRefAndExprResult()
            return later result
        }
        assert(typename(var_node) != "bool")
        if var_node.has_type_expr {
            result_expr =
                var_node.subexprs[var_node.subexprs.len]
        }
        var idx = var_node.var_labels.find(lookup_label)
        assert(idx != none)
        if result_expr == none and
                not var_node.is_empty and
                (var_node.is_const or
                 (var_node.vars_autoconst_list != none and
                  var_node.vars_autoconst_list[idx])) {
            var assigned_values = var_node.subexprs.copy()
            if var_node.has_type_expr {
                assigned_values = assigned_values.sub(
                    1, assigned_values.len - 1
                )
            }
            var value = assigned_values[idx]
            if value.kind == ast.N_EXPR_IDREF and
                    value.ref != none {
                result_ref = value.ref.copy()
            }
        }
    } elseif value_ref.kind == st_ref.ST_ARG and
            node.scope != none and node.scope.func_scope != none {
        var arg_type_exprs =
            node.scope.func_scope.extended_final_arg_type_exprs()
        if value_ref.id >= 1 and
                value_ref.id <= arg_type_exprs.len {
            result_expr = arg_type_exprs[
                value_ref.id]
        }
    } elseif value_ref.kind == st_ref.ST_SELF and
            node_parents != none {
        var i = node_parents.len
        while i >= 1 and (
                node_parents[i].kind != ast.N_STMT_FUNC or
                node_parents[i].type_path == none or
                node_parents[i].type_path.len == 0) {
            i -= 1
        }
        if i < 1 {
            if debug {
                print(dbg_header +
                    "resolve_st_ref_to_type_ref_and_expr() "
                    "result: Nothing, since self parent func "
                    "lookup failed.")
            }
            var result = new TypeRefAndExprResult()
            return later result
        }
        var anscope = project_file.
            make_attr_names_scope_from_funcattr(
                node_parents[i], msgs=msgs, is_moose64=is_moose64,
                def_project_file=project_file
            )
        assert(anscope.storage_id != none)
        result_ref = new st_ref.StorageRef(
            st_ref.ST_GLOBAL, anscope.storage_id
        )
    } elseif value_ref.kind == st_ref.ST_GLOBAL or
            value_ref.kind == st_ref.ST_GLOBALATTR {
        result_ref = value_ref.copy()
    }
    if result_expr == none and
            result_ref != none and
            result_ref.kind == st_ref.ST_GLOBAL {
        assert(result_expr == none)
        var gscope = project_file.project.
            storage_id_to_global_scope_map[result_ref.id]
        assert(gscope != none)
        var gnode = gscope.storage_id_to_entry[result_ref.id]
        assert(typename(gnode) != "list")
        var_node = gnode
        if debug {
            print(dbg_header +
                "resolve_st_ref_to_type_ref_and_expr(): "
                "Obtained global node: gnode=" + gnode.as_str())
        }
        if gnode.kind == ast.N_STMT_FUNC {
            result_expr = create_typeref_from_func_node(
                project_file, gnode
            ).copy()
            assert(result_expr != gnode)
        } elseif gnode.kind == ast.N_STMT_VAR and
                gnode.has_type_expr and gnode.subexprs.len > 0 {
            result_expr = gnode.subexprs[gnode.subexprs.len].copy()
        } elseif is_moose64 and gnode.kind == ast.N_STMT_STRUCT {
            result_expr = new TypeRefExpr()
            result_expr.name = gnode.label
            result_expr.storage_ref = result_ref.copy()
        }
    } elseif result_expr == none and
            result_ref != none and
            result_ref.kind == st_ref.ST_GLOBALATTR and
            lookup_label != none {
        var anscope =
            project_file.project.storage_id_to_anscope_map[
                result_ref.id[1]
            ]
        if debug {
            print(dbg_header +
            "resolve_st_ref_to_type_ref_and_expr() "
            "type scope obtained: anscope=" + anscope.as_str())
        }
        if anscope.is_struct or anscope.is_type {
            if not anscope.name_to_symbol_map.has(
                lookup_label) {
                if debug {
                    print(dbg_header +
                    "resolve_st_ref_to_type_ref_and_expr() "
                    "result: Nothing, since global attribute "
                    "member lookup failed.")
                }
                return later [none, none]
            }
            var sinfo = anscope.
            name_to_symbol_map[lookup_label]
            if debug {
                print(dbg_header +
                "resolve_st_ref_to_type_ref_and_expr() "
                "got member symbol info: "
                "sinfo=" + sinfo.as_str() + " "
                "lookup_label='" + lookup_label.as_str() + "'")
            }
            if sinfo.typeref_expr != none {
                result_expr = sinfo.typeref_expr
            } elseif is_moose64 {
                print(if is_moose64 ("moosec")
                else ("horsec") + ": error: "
                    "Found global attribute with no "
                    "type expr, this is an "
                    "internal error. Please report "
                    "this to the compiler makers: " +
                    "left_of_us=" +
                    left_of_us.as_str() + " "
                    "sinfo=" + sinfo.as_str())
                throw new RuntimeError("Internal error.")
            }
        }
    }

    func resolve_self_ref_if_needed {
        if result_ref == none or
                result_ref.kind != st_ref.ST_SELF {
            return later
        }
        result = resolve_st_ref_to_type_ref_and_expr(
            project_file, result_ref, node=var_node,
            is_moose64=is_moose64, debug=debug,
        )
        if result.storage_ref != none {
            result_ref = result.storage_ref
            result_expr = result.type_expr
        }
    }
    resolve_self_ref_if_needed()
    later:

    func obtain_result_ref_if_needed {
        if result_ref != none or
                result_expr == none {
            return later
        }
        var result = result_expr.try_resolve_to_user_type(
            project_file, force_recompute=no,
            is_moose64=is_moose64
        ) later:

        await result
        result_ref = result
    }
    obtain_result_ref_if_needed()
    later:

    if result_ref != none and
            {st_ref.ST_LOCAL, st_ref.ST_SELF,
            st_ref.ST_CCAPTURE,
            st_ref.ST_ARG}.has(result_ref.kind) {
        # This isn't a useful end result here.
        result_ref = none
    }
    if result_ref == none and
            value_ref != none and
            {st_ref.ST_MCREF, st_ref.ST_CEXT}.has(
            value_ref.kind) {
        result_ref = value_ref.copy()
    }
    if debug {
        print(dbg_header +
            "resolve_st_ref_to_type_ref_and_expr() "
            "result: " + [result_ref, result_expr].as_str())
    }
    var result = new TypeRefAndExprResult()
    result.storage_ref = result_ref
    result.type_expr = result_expr
    return result
}

func _parse_typeref_notlater(
        tokens, pos, msgs, extend_typeref_expr=none,
        project_file=none,
        max_len=none, max_depth=64, is_nested_in_type=no,
        is_moose64=no, debug=no
        ) {
    var program_name = if is_moose64 ("moosec") else ("horsec")
    var startpos = pos
    if max_len == none {
        max_len = tokens.len
    }
    if debug {
        print(program_name + ": debug: _parse_typeref_notlater(): " +
            "Called on " + tokens.len.as_str() + " token(s) with "
            "tokens.sub(1, 5)=" + tokens.sub(1, 5).as_str() + " "
            "pos=" + pos.as_str() + " max_len=" +
            max_len.as_str() + " "
            "max_depth=" + max_depth.as_str() + " "
            "is_moose64=" + is_moose64.as_str())
    }
    if pos > max_len {
        if debug {
            print(program_name + ": debug: "
                "_parse_typeref_notlater(): " +
                "No tokens to parse, bailing early.")
        }
        return none
    }

    func check_if_func_type(tokens, pos, max_len=none,
            is_nested_in_type=no, debug=no) {
        var startpos = pos
        if pos > max_len or
                tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != "(" {
            if debug {
                print(program_name + ": debug: "
                    "_parse_typeref_notlater(): " +
                    "In check_if_func_type(): "
                    "Early bail since no '(' at "
                    "the start.")
            }
            return none
        }
        var could_be_func = no
        pos += 1
        var bdepth = 1
        if debug {
            print(program_name + ": debug: "
                "_parse_typeref_notlater(): " +
                "In check_if_func_type(): "
                "pos=" + pos.as_str() + " "
                "max_len=" + max_len.as_str() + " "
                "is_nested_in_type=" +
                    is_nested_in_type.as_str())
        }
        while pos <= max_len and
                bdepth >= 1 {
            if tokens[pos].kind == token.T_ENCLOSE and
                    {'(', '[', '{'}.has(tokens[pos].str) {
                bdepth += 1
                pos += 1
                continue
            } elseif tokens[pos].kind == token.T_ENCLOSE and
                    {')', ']', '}'}.has(tokens[pos].str) {
                bdepth -= 1
                pos += 1
                if bdepth == 0 and (could_be_func or
                        (not is_nested_in_type and
                        pos <= max_len and
                        tokens[pos].kind == token.T_RIGHTPTR)) {
                    if pos > max_len or
                            tokens[pos].kind != token.T_RIGHTPTR {
                        var nested = yes
                        return [(pos - startpos), nested]
                    }
                    while pos <= max_len and
                            (tokens[pos].kind !=
                                token.T_ENCLOSE or
                             not {")", "}", "]"}.has(
                                 tokens[pos].str
                            )) {
                        pos += 1
                    }
                    var nested = no
                    return [(pos - startpos), nested]
                }
                continue
            }
            if bdepth == 1 and
                    tokens[pos].kind == token.T_RIGHTPTR {
                if debug {
                    print(program_name + ": debug: "
                        "_parse_typeref_notlater(): " +
                        "check_if_func_type(): We detected a "
                        "likely func. Scanning ahead to find "
                        "out if this fits our suspicion.")
                }
                could_be_func = yes
            }
            pos += 1
        }
        return none
    }
    func parse_func_type(tokens, pos, max_len=none,
            nested_in_parens=no, debug=no) {
        if debug {
            print(program_name + ": debug: "
                "_parse_typeref_notlater(): " +
                "parse_func_type(): Now starting at "
                "pos=" + pos.as_str() + " with "
                "max_len=" + max_len.as_str() + "...")
        }
        if max_len == none {
            max_len = tokens.len - pos
        }
        func had_error(at_pos, description) {
            if not description.ends(" ") {
                description += " "
            }
            msgs.add(new msg.FileMsg(
                description + "func type "
                "in line " +
                token.get_line(tokens, startpos).as_str() +
                ", column " +
                token.get_col(tokens, startpos).as_str() + ".",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            var skiplen = token.get_naive_stmt_or_expr_len(
                tokens, startpos, max_len=max_len,
                for_expr=yes, is_moose64=is_moose64
            )
            var expr = new ast_expr.InvalidExpr(skiplen)
            return expr
        }
        var startpos = pos
        if pos > max_len or (nested_in_parens and (
                tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != "(")) {
            if nested_in_parens {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected '(' to begin ")
            }
            return had_error(pos,
                "Invalid " + token.describe_token_at(
                    tokens, pos) + " "
                ", expected start of ")
        }
        if nested_in_parens {
            assert(tokens[pos].kind == token.T_ENCLOSE)
            pos += 1
        }
        if pos > max_len or
                tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != "(" {
            return had_error(pos,
                "Invalid " + token.describe_token_at(
                    tokens, pos) + " "
                ", expected '(' to start args for ")
        }
        pos += 1

        # Parse argument list:
        var arg_types = []
        while pos <= max_len and
                (tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != ")") {
            if tokens[pos].kind != token.T_IDENT and
                    tokens[pos].kind != token.T_LEFTPTR {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected identifier (T_IDENT) to "
                    "start next argument, or '<-' (T_LEFTPTR) "
                    "for an anonymous argument, or ')' to end "
                    "arguments for ")
            }
            if tokens[pos].kind != token.T_LEFTPTR {
                assert(tokens[pos].kind == token.T_IDENT)
                pos += 1
            }
            if pos > max_len or
                    tokens[pos].kind != token.T_LEFTPTR {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected '<-' (T_LEFTPTR) to "
                    "continue argument for ")
            }
            pos += 1
            if pos > max_len or (
                    tokens[pos].kind == token.T_ENCLOSE and
                    {")", "]", "}"}.has(tokens[pos].str)) {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected type following '<-' (T_LEFTPTR) "
                    "to describe argument type for ")
            }
            var inner_expr = _parse_typeref_notlater(
                tokens, pos, msgs, project_file=project_file,
                max_len=max_len, is_nested_in_type=yes,
                max_depth=(max_depth - 1),
                is_moose64=is_moose64,
                debug=debug
            )
            if inner_expr == none {
                var had_error = no
                for m in msgs {
                    if m.kind == msg.M_ERROR {
                        had_error = yes
                    }
                }
                if not had_error {
                    throw new RuntimeError("Internal error, "
                        "nested AST typeref parsing returned "
                        "no result but without any error.")
                }
                var skiplen = token.get_naive_stmt_or_expr_len(
                    tokens, startpos, max_len=max_len,
                    for_expr=yes, is_moose64=is_moose64
                )
                var expr = new ast_expr.InvalidExpr(skiplen)
                return expr
            }
            arg_types.add(inner_expr)
            pos += inner_expr.token_len
            if debug {
                print(program_name + ": debug: "
                    "_parse_typeref_notlater(): " +
                    "parse_func_type(): Parsed arg with type "
                    "inner_expr=" + inner_expr.as_str() + " "
                    "and we're now at pos=" + pos.as_str() + " "
                    "at this token: " + (
                        if pos <= max_len (tokens[pos].as_str())
                            else ("<end of tokens>")))
            }
            if pos > max_len or
                    (tokens[pos].kind != token.T_COMMA and
                     (tokens[pos].kind != token.T_ENCLOSE or
                      tokens[pos].str != ')')) {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected ')' or ',' to end previous "
                    "argument")
            }
            if tokens[pos].kind == token.T_COMMA {
                pos += 1
            } else {
                assert(tokens[pos].kind == token.T_ENCLOSE)
            }
            continue
        }
        if pos <= max_len {
            assert(tokens[pos].kind == token.T_ENCLOSE and
                tokens[pos].str == ')')
            pos += 1
        }
        if debug {
            print(program_name + ": debug: "
                "_parse_typeref_notlater(): " +
                "parse_func_type(): Completed parsing args, "
                "we're now at pos=" + pos.as_str() + " "
                "at this token: " + (
                    if pos <= max_len (tokens[pos].as_str())
                        else ("<end of tokens>")))
        }
        if pos > max_len or
                tokens[pos].kind != token.T_RIGHTPTR {
            return had_error(pos,
                "Invalid " + token.describe_token_at(
                    tokens, pos) + " "
                ", expected '->' (T_RIGHTPTR) to "
                "specify return type for ")
        }
        pos += 1
        var return_type = none
        if pos > max_len or
                ({token.T_KEYWORD,
                token.T_IDENT}.has(tokens[pos].kind) and
                tokens[pos].str == "empty") {
            # We got no return value.
            if pos < max_len {
                pos += 1
            }
        } else {
            return_type = _parse_typeref_notlater(
                tokens, pos, msgs, project_file=project_file,
                max_len=max_len, is_nested_in_type=yes,
                max_depth=(max_depth - 1),
                is_moose64=is_moose64,
                debug=debug
            )
            if return_type == none {
                var had_error = no
                for m in msgs {
                    if m.kind == msg.M_ERROR {
                        had_error = yes
                    }
                }
                if not had_error {
                    throw new RuntimeError("Internal error, "
                        "nested AST typeref parsing returned "
                        "no result but without any error.")
                }
                var skiplen = token.get_naive_stmt_or_expr_len(
                    tokens, startpos, max_len=max_len,
                    for_expr=yes, is_moose64=is_moose64
                )
                var expr = new ast_expr.InvalidExpr(skiplen)
                return expr
            }
            pos += return_type.token_len
        }
        if nested_in_parens {
            if pos > max_len or
                    tokens[pos].kind != token.T_ENCLOSE or
                    tokens[pos].str != ')' {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected ')' (T_ENCLOSE) to "
                    "end ")
            }
            pos += 1
        }
        var func_ref = new TypeRefFuncExpr()
        func_ref.arg_typeref_exprs = arg_types
        func_ref.return_typeref_expr = return_type
        func_ref.token_len = pos - startpos
        if debug {
            print(program_name + ": debug: "
                "_parse_typeref_notlater(): " +
                "parse_func_type(): Finished assembling "
                "func typeref expr. Result is: "
                "func_ref=" + func_ref.as_str() + " "
                "func_ref.token_len=" +
                    func_ref.token_len.as_str() + " "
                "pos=" + pos.as_str())
        }
        return func_ref
    }

    var typeref_expr = extend_typeref_expr
    var start_token_len = 0
    if typeref_expr != none {
        start_token_len = typeref_expr.token_len
    }
    var typeref_token_len = start_token_len
    var typeref_damaged = no
    var mods = []
    while yes {
        if pos <= max_len and
                tokens[pos].kind == token.T_ENCLOSE and
                tokens[pos].str == "(" {
            if debug {
                print(program_name + ": debug: "
                    "_parse_typeref_notlater(): " +
                    "Encountered a '(' that could "
                    "either be an inner nesting or a func.")
            }
            var bracket_open_pos = pos
            if max_depth <= 0 {
                msgs.add(new msg.FileMsg(
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", exceeds maximum nesting depth "
                    "for type expression starting "
                    "in line " +
                    token.get_line(tokens, startpos).as_str() +
                    ", column " +
                    token.get_col(tokens, startpos).as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                pos += 1
                var expr_len = start_token_len + (pos - startpos)
                return new ast_expr.InvalidExpr(expr_len)
            }
            var func_type_token_len = 0
            var func_type_nested = no
            var func_type_check_result = check_if_func_type(
                tokens, pos, max_len=max_len,
                is_nested_in_type=is_nested_in_type,
                debug=debug,
            )
            if func_type_check_result != none {
                func_type_token_len =
                    func_type_check_result[1]
                func_type_nested =
                    func_type_check_result[2]
            }
            if debug {
                print(program_name + ": debug: "
                    "_parse_typeref_notlater(): " +
                    "(func_type_check_result != none)=" +
                        (func_type_check_result !=
                        none).as_str() + " " +
                    "func_type_token_len=" +
                        func_type_token_len.as_str() + " "
                    "tokens[pos + func_type_token_len]=" +
                        tokens[pos + func_type_token_len -
                            1].as_str() + " "
                    "func_type_nested=" +
                        func_type_nested.as_str())
            }
            if typeref_expr == none and
                    func_type_token_len != none {
                typeref_expr = parse_func_type(
                    tokens, pos, max_len=func_type_token_len,
                    nested_in_parens=func_type_nested,
                    debug=debug,
                )
                if debug {
                    print(program_name + ": debug: "
                        "_parse_typeref_notlater(): " +
                        "Got inner func, typeref_expr=" +
                            typeref_expr.as_str())
                }
                assert(typeref_expr.token_len > 0)
                if typeref_expr.kind == ast.N_EXPR_INVALID {
                    var have_error = no
                    for m in msgs {
                        if m.kind == msg.M_ERROR {
                            have_error = yes
                            break
                        }
                    }
                    assert(have_error)
                }
                pos += typeref_expr.token_len
                typeref_token_len =
                    start_token_len + (pos - startpos)
                continue
            }
            pos += 1  # Go past '('.
            var inner_expr = _parse_typeref_notlater(
                tokens, pos, msgs,
                extend_typeref_expr=typeref_expr,
                project_file=project_file,
                is_nested_in_type=yes,
                max_len=max_len, max_depth=(max_depth - 1),
                is_moose64=is_moose64, debug=debug
            )
            if inner_expr == none {
                # Revert back to before bracket.
                pos = bracket_open_pos
                break
            }
            pos += inner_expr.token_len
            if pos > max_len or
                    tokens[pos].kind != token.T_ENCLOSE or
                    tokens[pos].str != ")" {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected '(' "
                    "for ')' found "
                    "in line " +
                    token.get_line(tokens,
                                bracket_open_pos).as_str() +
                    ", column " +
                    token.get_col(tokens,
                                bracket_open_pos).as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                var expr_len = start_token_len + (pos - startpos)
                return new ast_expr.InvalidExpr(expr_len)
            }
            typeref_expr = inner_expr
            pos += 1  # Go past ')'
            typeref_token_len = start_token_len + (pos - startpos)
        }

        func is_implicit_ref(tokens, pos, max_len) {
            return (is_moose64 and
                pos + 1 <= max_len and
                (tokens[pos].kind == token.T_IDENT or
                 tokens[pos].kind == token.T_KEYWORD) and
                (tokens[pos + 1].kind == token.T_IDENT or
                 tokens[pos + 1].kind == token.T_KEYWORD) and
                tokens[pos].str == "implicit" and
                tokens[pos + 1].str == "ref")
        }
        if typeref_expr == none and pos <= max_len and
                (tokens[pos].kind == token.T_IDENT or
                tokens[pos].kind == token.T_KEYWORD) and
                not is_implicit_ref(tokens, pos, max_len) and
                ((is_moose64 and
                  builtin_moose64_types.has(tokens[pos].str)) or
                 (not is_moose64 and
                  builtin_horse64_types.has(tokens[pos].str))) {
            typeref_expr = new TypeRefExpr()
            typeref_expr.name = tokens[pos].str
            typeref_expr.line = token.get_line(tokens, pos)
            typeref_expr.col = token.get_col(tokens, pos)
            pos += 1
            typeref_token_len =
                start_token_len + (pos - startpos)
        }
        if typeref_expr == none and pos <= max_len and
                tokens[pos].kind == token.T_IDENT and
                not is_implicit_ref(tokens, pos, max_len) and
                ((is_moose64 and
                  not builtin_moose64_type_modifiers.has(
                      tokens[pos].str)) or
                 (not is_moose64 and
                  not builtin_horse64_type_modifiers.has(
                      tokens[pos].str))) {
            typeref_expr = new TypeRefExpr()
            typeref_expr.name = tokens[pos].str
            typeref_expr.line = token.get_line(tokens, pos)
            typeref_expr.col = token.get_col(tokens, pos)
            pos += 1
            typeref_token_len =
                start_token_len + (pos - startpos)
            while pos + 1 <= max_len and
                    tokens[pos].kind == token.T_DOT and
                    tokens[pos + 1].kind == token.T_IDENT {
                if typeref_expr.type_path == none {
                    typeref_expr.type_path = []
                }
                typeref_expr.type_path.add(typeref_expr.name)
                typeref_expr.name = tokens[pos + 1].str
                typeref_token_len += 2
                pos += 2
            }
        }
        var had_mods = no
        while pos <= max_len and
                (tokens[pos].kind == token.T_IDENT or
                tokens[pos].kind == token.T_KEYWORD) and
                (is_implicit_ref(tokens, pos, max_len) or
                 (is_moose64 and
                  builtin_moose64_type_modifiers.has(
                      tokens[pos].str
                  )) or
                 (not is_moose64 and
                  builtin_horse64_type_modifiers.has(
                      tokens[pos].str
                  ))) {
            had_mods = yes
            var modifier_name = tokens[pos].str
            if modifier_name == "implicit" and
                    is_implicit_ref(tokens, pos, max_len) {
                modifier_name = "implicit ref"
                pos += 2
            } else {
                pos += 1
            }
            var modifier = new TypeRefMod(modifier_name)
            mods.add(modifier)
            typeref_token_len = start_token_len + (pos - startpos)
            if {"array", "c_array"}.has(modifier_name) and
                    is_moose64 {
                while pos + 2 <= max_len and
                        tokens[pos].kind == token.T_ENCLOSE and
                        tokens[pos].str == '[' and
                        tokens[pos + 2].kind == token.T_ENCLOSE and
                        tokens[pos + 2].str == ']' {
                    if tokens[pos + 1].kind == token.T_IDENT {
                        var prop = new TypeRefModProp_Range()
                        prop.range_value_label =
                            tokens[pos + 1].str
                    } elseif {token.T_NUM, token.T_BIGNUM}.has(
                            tokens[pos + 1].kind == token.T_NUM
                            ) {
                        var prop = new TypeRefModProp_Range()
                        prop.range_value_num =
                            tokens[pos + 1].str.to_num()
                    } else {
                        msgs.add(new msg.FileMsg(
                            "Unexpected '[' followed by " +
                                token.describe_token_at(
                                    tokens, pos) + " "
                            ", expected valid range expression "
                            "for array modifier.",
                            source_file=project_file,
                            line=token.get_line(tokens, pos),
                            col=token.get_col(tokens, pos),
                        ))
                        typeref_damaged = yes
                        return typeref_expr
                    }
                    pos += 3
                    typeref_token_len =
                        start_token_len + (pos - startpos)
                }
            }
        }
        if not had_mods {
            break
        }
    }
    if typeref_token_len <= start_token_len {
        return none
    }
    if typeref_expr != none {
        assert(typeref_token_len > 0)
        typeref_expr.damaged = typeref_damaged
        typeref_expr.modifiers = mods
        typeref_expr.token_len = typeref_token_len
    }
    return typeref_expr
}

func parse_typeref(
        tokens, pos, msgs, extend_typeref_expr=none,
        project_file=none, max_len=none, is_moose64=no,
        debug=no
        ) {
    if max_len == none {
        max_len = tokens.len
    }
    var expr = _parse_typeref_notlater(
        tokens, pos, msgs,
        extend_typeref_expr=extend_typeref_expr,
        project_file=project_file,
        max_len=max_len, is_moose64=is_moose64,
        debug=debug
    )
    return later expr
}

