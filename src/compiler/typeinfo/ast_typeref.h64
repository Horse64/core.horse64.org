## @module compiler.ast_typeref
# Copyright (c) 2024-2025, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import math from core.horse64.org
import text from core.horse64.org
import textfmt from core.horse64.org

import compiler.ast as ast
import compiler.ast.analyze as ast_analyze
import compiler.ast.expr as ast_expr
import compiler.msg as msg
import compiler.token as token
import compiler.storage.ref as st_ref
import compiler.storage.scope as st_scope
import compiler.token
import compiler.typeinfo as typeinfo

const moose64_forced_autoprop_names = {"len"}
const horse64_forced_autoprop_names = {"len"}
const builtin_horse64_types = {}
const builtin_horse64_type_modifiers = {}
const builtin_moose64_types = {
    "byte", "i8", "i16", "u16", "addr", "addr_diff",
    "i32", "i64", "size", "u32", "u64",
    "f32", "f64", "bool", "empty",
    "any", "auto", "moose64_failed_result_t",
    "c_vararg",
}
const builtin_moose64_type_modifiers = {
    "ref", "array", "c_array", "readonly"
}
const builtin_moose64_unsigned_num_types = {
    "byte", "u8", "u16", "u32", "u64", "size",
    "addr"
}
const builtin_moose64_signed_num_types = {
    "i8", "i16", "i32", "i64", "f32",
    "f64", "addr_diff"
}
const builtin_moose64_integer_num_types = {
    "i8", "i16", "i32", "i64", "addr_diff",
    "addr", "size", "byte", "u8", "u16",
    "u32", "u64",
}

const builtin_moose64_num_types =
    builtin_moose64_unsigned_num_types +
    builtin_moose64_signed_num_types

func is_pos_inside_func_return_type(
        tokens, pos, max_len=none, is_moose64=no) {
    if max_len == none {
        max_len = tokens.len
    }
    func pos_is_type_kw(pos) {
        if pos < 1 or pos > max_len {
            return no
        }
        if {token.T_KEYWORD, token.T_IDENT}.has(
                tokens[pos].kind) and
                ((is_moose64 and
                 (builtin_moose64_types.has(tokens[pos].str) or
                  builtin_moose64_type_modifiers.has(
                      tokens[pos].str))) or
                 (not is_moose64 and
                  (builtin_horse64_types.has(tokens[pos].str) or
                   builtin_horse64_type_modifiers.has(
                       tokens[pos].str)))
                ) {
            return yes
        }
        return no
    }
    var i = pos
    if not pos_is_type_kw(i) {
        return no
    }
    while i >= 1 and tokens[i].kind != token.T_RIGHTPTR and
            pos_is_type_kw(i) {
        i -= 1
    }
    if i < 1 or tokens[i].kind != token.T_RIGHTPTR {
        return no
    }
    return yes
}

type TypeRefModProp {
    var prop_name = "unknown"
}

type TypeRefModProp_Range base TypeRefModProp {
    var prop_name = "range"
    var range_value_num
    var range_value_label
}

func TypeRefModProp_Range.as_str {
    var t = "["
    if self.range_value_num != none {
        t += self.range_value_num.as_str()
    } else {
        t += self.range_value_label.as_str()
    }
    t += "]"
    return t
}

func TypeRefModProp_Range.is_equivalent_prop_to(
        other_mod, is_moose64=no
        ) {
    if other_mod.prop_name != self.prop_name {
        return no
    }
    if self.range_value_num != none {
        if self.range_value_num !=
                other_mod.range_value_num {
            return no
        }
    } else {
        return no
    }
    return yes
}

func TypeRefModProp_Range.as_array_key {
    var t = "m64_mod_prop_range_"
    if self.range_value_num != none {
        t += self.range_value_num.as_str()
    } else {
        t += self.range_value_label.as_str()
    }
    return t
}

type TypeRefMod {
    var name
    var props = []
}

func TypeRefMod.init(name) {
    self.name = name + ""
}

func TypeRefMod.copy {
    var result = base.copy()
    result.props = []
    for prop in self.props {
        result.props.add(prop.copy())
    }
    return result
}

func TypeRefMod.as_str {
    var t = self.name + ""
    for prop in self.props {
        t += prop.as_str()
    }
    return t
}

func TypeRefMod.as_array_key {
    var t = self.name + ""
    for prop in self.props {
        t += prop.as_array_key()
    }
    return t
}

func TypeRefMod.as_c_code(
        indent=0, global_name_assign_callback=none,
        project=none, project_file=none, is_moose64=no
        ) {
    if self.name == "readonly" {
        return "const"
    }
    if {"ref", "c_array", "implicit ref"}.has(self.name) {
        return "*"
    }
    for prop in self.props {
        t += prop.as_c_code(indent=0,
            global_name_assign_callback=
                global_name_assign_callback,
            project=project, project_file=project_file,
            is_moose64=is_moose64)
    }
    return self.name
}

func TypeRefMod.is_equivalent_mod(
        other_mod, is_moose64=no
        ) {
    if self.name != other_mod.name and
            (not {"ref", "c_array"}.has(self.name) or
            not {"ref", "c_array"}.has(other_mod.name)) {
        return no
    }

    var claimed_indexes = {}
    for prop in self.props {
        var found_equivalent = no
        var idx = 0
        for other_prop in other_mod.props {
            idx += 1
            if claimed_indexes.has(idx) {
                continue
            }
            if other_prop.is_equivalent_prop_to(
                    prop, is_moose64=is_moose64
                    ) {
                claimed_indexes.add(idx)
                found_equivalent = yes
                break
            }
        }
        if not found_equivalent {
            if self.name == "c_array" and
                    {"ref", "c_array"}.has(
                        other_mod.name) and
                    prop.prop_name == "range" {
                # Allow this to be not present
                # on the other modifier.
                continue
            }
            return no
        }
    }
    var idx = 0
    for other_prop in other_mod.props {
        idx += 1
        if claimed_indexes.has(idx) {
            continue
        }
        if {"ref", "c_array"}.has(self.name) and
                other_mod.name == "c_array" and
                other_prop.prop_name == "range" {
            # Allow this to be not present
            # on the other modifier.
            continue
        }
        return no
    }
    return yes
}

type TypeRefFuncExpr base TypeRefExpr {
    var arg_typeref_exprs = []
    var return_typeref_expr
    var func_storage_ref
    var is_failable = no
    var is_autoprop_func = no
    var is_func_attr = no
}

func TypeRefFuncExpr.init {
    base.init()
    self.is_func_ref = yes
    self.is_multi_type = no
    self.is_list_arg = no
    self.name = none
    self.type_path = none
}

func TypeRefFuncExpr.as_json_obj {
    var output = base.as_json_obj()
    if output.has("storage_ref") {
        output.del("storage_ref")
    }
    output["arg_typeref_exprs"] = []
    for arg_typeref in self.arg_typeref_exprs {
        output["arg_typeref_exprs"].add(
            arg_typeref.as_json_obj())
    }
    output["return_typeref_expr"] = none
    if self.return_typeref_expr != none {
        output["return_typeref_expr"] =
            self.return_typeref_expr.copy()
    }
    output["func_storage_ref"] = none
    if self.func_storage_ref != none {
        output["func_storage_ref"] =
            self.func_storage_ref.as_str()
    }
    output["is_failable"] =
        self.is_failable.as_str()
    output["is_autoprop_func"] =
        self.is_autoprop_func.as_str()
    output["is_func_attr"] =
        self.is_func_attr.as_str()
    return output
}

func TypeRefExpr.is_equivalent(
        other_type_expr, is_moose64=no
        ) {
    assert(not self.is_func_ref)
    if other_type_expr.is_func_ref {
        return no
    }
    var tinfo_self = typeinfo.create_typeinfo_from_typeexpr(
        self, is_moose64=is_moose64,
    )
    var tinfo_other = typeinfo.create_typeinfo_from_typeexpr(
        other_type_expr, is_moose64=is_moose64,
    )
    return tinfo_self.is_equivalent(
        tinfo_other, is_moose64=is_moose64,
    )
}

func TypeRefFuncExpr.is_user_type {
    return yes
}

func TypeRefFuncExpr.is_equivalent(
        other_func_expr, is_moose64=no
        ) {
    if not other_func_expr.is_func_ref {
        return no
    }
    if self.func_storage_ref != none and
            other_func_expr.func_storage_ref != none {
        return (self.func_storage_ref.alike(
            other_func_expr.func_storage_ref))
    }
    if not self.cmp_signature(other_func_expr) {
        return no
    }
    if self.modifiers.len != other_func_expr.modifiers.len {
        return no
    }
    var modidx = 1
    while modidx <= self.modifiers.len {
        if not self.modifiers[modidx].is_equivalent_mod(
                other_func_expr.modifiers[modidx],
                is_moose64=is_moose64,
                ) {
            return no
        }
        modidx += 1
    }
    return yes
}

func TypeRefFuncExpr.cmp_signature(
        other_type_expr, is_moose64=no
        ) {
    if not other_type_expr.is_func_ref {
        return no
    }
    if self.arg_typeref_exprs.len !=
            other_type_expr.arg_typeref_exprs.len {
        return no
    }
    if self.return_typeref_expr != none and
            (self.return_typeref_expr.name != "empty" or
             self.return_typeref_expr.is_user_type()) {
        if other_type_expr.return_typeref_expr == none or
                (other_type_expr.return_typeref_expr.name ==
                    "empty" and
                 not other_type_expr.return_typeref_expr.
                    is_user_type()) or
                not self.return_typeref_expr.is_equivalent(
                    other_type_expr.return_typeref_expr,
                    is_moose64=is_moose64,
                ) {
            return no
        }
    } else {
        if other_type_expr.return_typeref_expr != none and
                (other_type_expr.return_typeref_expr.
                    name != "empty" or
                 other_type_expr.return_typeref_expr.
                    is_user_type()) {
            return no
        }
    }
    var idx = 1
    while idx <= self.arg_typeref_exprs.len {
        if not self.arg_typeref_exprs[idx].is_equivalent(
                other_type_expr.arg_typeref_exprs[idx],
                is_moose64=is_moose64,
                ) {
            return no
        }
        idx += 1
    }
    return yes
}

func TypeRefFuncExpr.as_str(indent=0) {
    if self.damaged {
        return "(damaged type ref func expr.)"
    }
    var prefix_mod_names = {"readonly"}
    var t = ""
    for mod in self.modifiers {
        if prefix_mod_names.has(mod.name) {
            if t != "" {
                t += " "
            }
            t += mod.as_str()
        }
    }
    if t != "" {
        t += " "
    }
    t += "(("
    var is_first_param = yes
    for param_type in self.arg_typeref_exprs {
        if is_first_param {
            is_first_param = no
        } else {
            t += ", "
        }
        t += "_<-" + param_type.as_str()
    }
    t += ")->"
    if self.return_typeref_expr != none {
        t += self.return_typeref_expr.as_str()
    }
    t += ")"
    for mod in self.modifiers {
        if not prefix_mod_names.has(mod.name) {
            t += " " + mod.as_str()
        }
    }
    if self.has_init_expr {
        assert(self.subexprs.len == 1)
        t += self.subexprs[1].as_str(indent=indent)
    }
    return t
}

func TypeRefFuncExpr.as_c_code(
        indent=0, global_name_assign_callback=none,
        global_register_m64_array_callback=none,
        c_name_to_insert_if_func_ptr=none,
        project=none, project_file=none,
        is_moose64=no
        ) {
    if self.damaged {
        return "(damaged type ref func expr.)"
    }
    var prefix_mod_names = {"readonly"}
    var t = ""

    for mod in self.modifiers {
        if prefix_mod_names.has(mod.name) {
            if t != "" {
                t += " "
            }
            t += mod.as_c_code(indent=(indent + 4),
                global_name_assign_callback=
                    global_name_assign_callback,
                project=project, project_file=project_file,
                is_moose64=is_moose64)
        }
    }
    if self.return_typeref_expr != none and
            (self.return_typeref_expr.is_user_type() or
            self.return_typeref_expr.name != "empty") {
        t += self.return_typeref_expr.as_c_code(
            indent=(indent + 4),
            global_name_assign_callback=
                global_name_assign_callback,
            global_register_m64_array_callback=
                global_register_m64_array_callback,
            project=project, project_file=project_file,
            is_moose64=is_moose64)
    } else {
        t += "void"
    }
    t += " (*"
    if c_name_to_insert_if_func_ptr != none {
        t += c_name_to_insert_if_func_ptr
    } elseif self.name != none {
        # FIXME: Handle global name adjustment here.
        t += self.name
    }
    t += ")"

    if t != "" {
        t += " "
    }
    t += "("
    var is_first_param = yes
    for param_type in self.arg_typeref_exprs {
        if is_first_param {
            is_first_param = no
        } else {
            t += ", "
        }
        t += param_type.as_c_code(indent=(indent + 4),
            global_name_assign_callback=
                global_name_assign_callback,
            global_register_m64_array_callback=
                global_register_m64_array_callback,
            project=project, project_file=project_file,
            is_moose64=is_moose64)
    }
    t += ")"
    for mod in self.modifiers {
        if not prefix_mod_names.has(mod.name) {
            t += " " + mod.as_c_code(indent=(indent + 4),
                global_name_assign_callback=
                    global_name_assign_callback,
                project=project, project_file=project_file,
                is_moose64=is_moose64)
        }
    }
    return t
}

func TypeRefFuncExpr.copy {
    var self_copy = base.copy()
    var old_args = self_copy.arg_typeref_exprs
    self_copy.arg_typeref_exprs = []
    for old_arg in old_args {
        self_copy.arg_typeref_exprs.add(old_arg.copy())
    }
    self_copy.return_typeref_expr =
        self_copy.return_typeref_expr.copy()
    if self_copy.func_storage_ref != none {
        self_copy.func_storage_ref =
            self_copy.func_storage_ref.copy()
    }
    if self.name != none {
        self_copy.name = self.name
    }
    return self_copy
}

func TypeRefFuncExpr.try_resolve_param_types(
        project_file, recursive=no, force_recompute=no,
        is_moose64=no, debug=no
        ) {
    var had_error = no
    var error_result = none

    var builtin_names =
        if is_moose64 (builtin_moose64_types)
            else (builtin_horse64_types)
    func resolve_item(item) {
        if not item.is_func_ref {
            var result = item.try_resolve_to_user_type(
                project_file, force_recompute=force_recompute,
                is_moose64=is_moose64, debug=debug,
            ) later:

            await result
            if result.had_error {
                had_error = yes
                error_result = result
            }
            return later
        }
        var result = item.try_resolve_to_user_type(
            project_file, recursive=recursive,
            skip_params=(not recursive),
            force_recompute=force_recompute,
            is_moose64=is_moose64, debug=debug,
        ) later:

        await result
        # Func typerefs may not point to any specific actual
        # defined function, so we ignore if this fails.
        # We just call it anyway to store the result for
        # later use.
    }

    var final_result = new TryResolveUserTypeResult()
    var queue = self.arg_typeref_exprs.copy()
    if self.return_typeref_expr != none {
        queue.add(self.return_typeref_expr)
    }
    if queue.len == 0 {
        if had_error {
            return error_result
        }
        return later final_result
    }
    var item = queue.pop()
    var _unused = resolve_item(item)
    later:

    await _unused

    if queue.len == 0 {
        if had_error {
            return error_result
        }
        return later final_result
    }
    item = queue.pop()
    _unused = resolve_item(item) later repeat
}

func TypeRefFuncExpr.try_resolve_to_user_type(
        project_file, recursive=no, skip_params=no,
        force_recompute=no,
        is_moose64=no,
        debug=no
        ) {
    var param_error_result = none

    func run_concurrent {
        if skip_params {
            return later yes
        }
        var result = self.try_resolve_param_types(
            project_file, recursive=recursive,
            force_recompute=force_recompute,
            is_moose64=is_moose64
        ) later:

        await result
        if result.had_error {
            param_error_result = result
            return later no
        }
        return later yes
    }
    var success = run_concurrent()

    later:
    await success
    if not success {
        if param_error_result != none {
            return later param_error_result
        }
        var result = new TryResolveUserTypeResult()
        result.had_error = yes
        result.error_ast_typeref = self
        return later result
    }
    if self.func_storage_ref == none {
        var result = new TryResolveUserTypeResult()
        return later result
    }
    var result = new TryResolveUserTypeResult()
    result.resolved_storage_ref =
        self.func_storage_ref.copy()
    return result
}

func create_typeref_from_func_node(
        project_file, node, debug=no
        ) {
    var is_moose64 = project_file.project.is_moose64
    if node.damaged {
        return none
    }
    assert(node.extended_final_arg_count() >=
        node.arg_labels.len)
    assert(node.kind == ast.N_STMT_FUNC)
    assert(node.extended_final_arg_count() == 0 or
        not is_moose64 or node.extended_final_has_arg_types())
    assert(node.extended_final_arg_count() == 0 or
        not is_moose64 or node.was_ever_extended() or
        node.has_arg_types)
    if node.symbol_info != none and
            node.symbol_info.typeref_expr != none {
        if debug {
            print(if is_moose64 ("moosec: ") else ("horsec: ") +
                "debug: "
                "create_typeref_from_func_node(): " +
                "We're returning the pre-existing "
                "typeref_expr.")
        }
        var result = node.symbol_info.typeref_expr.copy()
        if result.name == none and node.name != none {
            result.name = node.name
        }
        return result
    }
    var type_expr = new TypeRefFuncExpr()
    type_expr.is_func_attr = no
    if node.type_path != none and node.type_path.len > 0 {
        var anscope =
            project_file.make_attr_names_scope_from_funcattr(
                node, def_project_file=project_file,
                msgs=none, is_moose64=is_moose64
            )
        if anscope == none {
            throw new RuntimeError("Failed to get attr names scope.")
        }
        assert(not anscope.is_enum)
        if project_file.project == none {
            throw new RuntimeError("Unexpectedly, there's no "
                "project_file.project set which is required for "
                "this computation.")
        }
        var import_typepath = project_file.global_scope.
            get_import_path_for_global(
                project_file, anscope.storage_id)
        if import_typepath.len > 0 {
            type_expr.type_path = import_typepath
        }
        var self_type_expr = new TypeRefExpr()
        var gscope = none
        if not project_file.project.
                storage_id_to_global_scope_map.has(
                    anscope.storage_id
                ) {
            gscope = project_file.global_scope
        } else {
            gscope = project_file.project.
                storage_id_to_global_scope_map[
                    anscope.storage_id
                ]
        }
        assert(gscope.storage_id_to_entry.has(
            anscope.storage_id
        ))
        self_type_expr.name = gscope.storage_id_to_entry[
            anscope.storage_id
        ].label
        self_type_expr.storage_ref = new st_ref.StorageRef(
            st_ref.ST_GLOBAL, anscope.storage_id
        )
        if import_typepath.len > 0 {
            self_type_expr.type_path = import_typepath.copy()
        }
        self_type_expr.modifiers.add(
            new TypeRefMod("implicit ref"))
        if node.extended_final_is_readonly() {
            self_type_expr.modifiers.add_at(
                1, new TypeRefMod("readonly"))
        }
        type_expr.arg_typeref_exprs.add(self_type_expr)
        type_expr.is_func_attr = yes
        if (is_moose64 and
                moose64_forced_autoprop_names.has(
                    node.label)) or
                (not is_moose64 and
                 horse64_forced_autoprop_names.has(
                     node.label)) {
            type_expr.is_autoprop_func = yes
        }
    }
    if node.label != none {
        type_expr.name = node.label
    }
    if node.extended_final_has_arg_types() {
        var arg_count = node.extended_final_arg_count()
        if debug {
            print(if is_moose64 ("moosec: ") else ("horsec: ") +
                "debug: "
                "create_typeref_from_func_node(): " +
                "node.extended_final_arg_count()=" +
                    node.extended_final_arg_count().as_str())
        }
        var i = 1
        while i <= arg_count {
            type_expr.arg_typeref_exprs.add(
                node.extended_final_arg_type_exprs()[i]
            )
            i += 1
        }
    } elseif not is_moose64 and
            (node.extended_final_arg_count() > 0 or
             not node.extended_final_has_return_type()) {
        # For now, we don't support returning any signature
        # for Horse64, unless it's very clear everything
        # was specified.
        return none
    }
    if node.has_failable and is_moose64 {
        var failable_type_expr = new TypeRefExpr()
        failable_type_expr.name = "moose64_failed_result_t"
        failable_type_expr.modifiers.add(
            new TypeRefMod("ref")
        )
        type_expr.arg_typeref_exprs.add(failable_type_expr)
        type_expr.is_failable = yes
    }
    if node.extended_final_has_return_type() {
        type_expr.return_typeref_expr =
            node.extended_final_return_type_expr()
    } else {
        if not is_moose64 {
            # FIXME: For Horse64, we could scan if any return inside
            # the function has an expression argument, and then
            # still allow the type signature to be completed.
            # For now, however, we don't allow this.
            return none
        }
    }
    if debug {
        print(if is_moose64 ("moosec: ") else ("horsec: ") +
            "debug: "
            "create_typeref_from_func_node(): " +
            "Got result: "
            "node.label='" + node.label + "' "
            "node.type_path=" + node.type_path.as_str() + " "
            "type_expr.is_autoprop_func=" +
                type_expr.is_autoprop_func.as_str() + " "
            "type_expr.is_func_attr=" +
                type_expr.is_func_attr.as_str() + " "
            "node.extended_final_has_arg_types()=" +
                node.extended_final_has_arg_types().as_str() + " "
            "node.extended_final_arg_count()=" +
                node.extended_final_arg_count().as_str() + " "
            "node=" + node.as_str().sub(1, 200) + "... " +
            "type_expr=" + type_expr.as_str())
    }
    return type_expr
}

type TypeRefExpr base ast.TreeNode {
    var type_path
    var name
    var modifiers = []
    var has_init_expr
    var is_func_ref = no
    var is_multi_type = no
    var is_list_arg = no
    var storage_ref = none

    var is_special_madeup_builtin = no  # Like .len, etc.
    var special_madeup_builtin_base_expr = none

    var is_autoprop_func_result = no  # Like user-defined .len, etc.
    var autoprop_func_base_expr = none
}

func TypeRefExpr.init {
    base.init()
    self.kind = ast.N_EXPR_TYPEREF
}

func TypeRefExpr.as_json_obj {
    var output = base.as_json_obj()
    if self.is_func_ref {
        output["is_func_ref"] = yes
    } elseif self.is_multi_type {
        output["is_multi_type"] = yes
    } elseif self.is_list_arg {
        output["is_list_arg"] = yes
    } else {
        output["storage_ref"] = none
        if self.storage_ref != none {
            output["storage_ref"] = self.storage_ref.as_str()
        }
    }
    output["modifiers"] = []
    for mod in self.modifiers {
        output["modifiers"].add(mod.as_str())
    }
    output["name"] = self.name
    output["type_path"] = none
    if self.type_path != none {
        output["type_path"] = self.type_path.copy()
    }
    if self.has_init_expr {
        output["has_init_expr"] = yes
    }
    if self.is_special_madeup_builtin {
        output["is_special_madeup_builtin"] = yes
    }
    if self.is_autoprop_func_result {
        output["is_autoprop_func_result"] = yes
    }
    return output
}

type MultiTypeRefExpr base TypeRefExpr {
    var sub_type_refs = []
}

func MultiTypeRefExpr.init {
    base.init()
    self.is_multi_type = yes
    self.name = "multi"
}

func MultiTypeRefExpr.as_json_obj {
    var output = base.as_json_obj
    if output.has("name") {
        output.del("name")
    }
    output["sub_type_refs"] = []
    for sub_type in self.sub_type_refs {
        output["sub_type_refs"].add(
            sub_type.as_json_obj())
    }
    return output
}

func MultiTypeRefExpr.is_equivalent(
        other_expr, is_moose64=no
        ) {
    if not other_expr.is_multi_type {
        return no
    }
    if self.sub_type_refs.len !=
            other_expr.sub_type_refs {
        return no
    }
    var idx = 0
    for sub_type in self.sub_type_refs {
        idx += 1
        if not other_expr.sub_type_refs[idx].
                is_equivalent(
                    sub_type) {
            return no
        }
    }
    return yes
}

func MultiTypeRefExpr.is_user_type {
    return no
}

func MultiTypeRefExpr.try_resolve_to_user_type(
        project_file, force_recompute=no,
        is_moose64=no, debug=no,
        ) {
    var final_result = new TryResolveUserTypeResult()

    func handle_item(sub_type_ref) {
        var inner_result =
            sub_type_ref.try_resolve_to_user_type(
                project_file,
                force_recompute=force_recompute,
                is_moose64=is_moose64,
                debug=debug,
            )
            later:

        await inner_result
        if inner_result.had_error {
            final_result = inner_result
            return later no
        }
        return later yes
    }

    var queue = self.sub_type_refs.copy()
    if queue.len == 0 {
        return later final_result
    }
    var item = queue.pop()
    var success = handle_item(item)
    later:

    await success
    if queue.len == 0 or not success {
        return final_result
    }
    item = queue.pop()
    success = handle_item(item) later repeat
}

type ListArgTypeRefExpr base TypeRefExpr {
    var arg_type
}

func ListArgTypeRefExpr.init {
    base.init()
    self.is_list_arg = yes
    self.name = "..."
}

func ListArgTypeRefExpr.is_equivalent(
        other_expr, is_moose64=no
        ) {
    if not other_expr.is_list_arg {
        return no
    }
    if self.arg_type == none {
        return other_expr.arg_type == none
    }
    if other.arg_type == none or
            self.arg_type.is_equivalent(
                other_expr.arg_type) {
        return no
    }
    return yes
}

func ListArgTypeRefExpr.as_code(indent=0) {
    if self.damaged {
        return "(damaged type ref expr.)"
    }
    var t = ""
    t += self.arg_type.as_code(indent=indent)
    return t
}

func ListArgTypeRefExpr.is_user_type {
    return no
}

func ListArgTypeRefExpr.try_resolve_to_user_type(
        project_file, force_recompute=no,
        is_moose64=no, debug=no,
        ) {
    func resolve_inner {
        if self.arg_type == none {
            return later none
        }
        var inner_result = self.arg_type.try_resolve_to_user_type(
            project_file, force_recompute=force_recompute,
            is_moose64=is_moose64, debug=debug
        ) later:

        await inner_result
        if inner_result.had_error {
            return later inner_result
        }
        return later none
    }
    var result_inner = resolve_inner() later:

    await result_inner
    if result_inner != none {
        return result_inner
    }
    var result = new TryResolveUserTypeResult()
    return later result
}

func TypeRefFuncExpr.is_equivalent(
        other_expr, require_same_storage=yes,
        is_moose64=no,
        ) {
    if not other_expr.is_func_ref {
        return no
    }

    if require_same_storage {
        if self.name != none and
                other_expr.name != none {
            if other_expr.name != self.name {
                return no
            }
        }
    }

    if self.is_special_madeup_builtin !=
            other_expr.is_special_madeup_builtin {
        return no
    }
    if self.special_madeup_builtin_base_expr !=
            other_expr.special_madeup_builtin_base_expr {
        return no
    }

    if require_same_storage {
        if self.storage_ref != none {
            if other_expr.storage_ref == none {
                return no
            }
            if not other_expr.storage_ref.alike(
                    self.storage_ref) {
                return no
            }
        } elseif other_expr.storage_ref != none {
            return no
        }
    }

    if self.type_path == none or self.type_path.len == 0 {
        if other_expr.type_path != none and
                other_expr.type_path.len != 0 {
            return no
        }
    } else {
        if self.type_path.len != other_expr.type_path.len {
            return no
        }
        var type_path_idx = 1
        while type_path_idx <= type_path.len {
            if self.type_path[type_path_idx] !=
                    other_expr.type_path[type_path_idx] {
                return no
            }
            type_path_idx += 1
        }
    }

    if self.modifiers.len != other_expr.modifiers.len {
        return no
    }
    var modidx = 1
    while modidx <= self.modifiers.len {
        if not self.modifiers[modidx].is_equivalent_mod(
                other_expr.modifiers[modidx],
                is_moose64=is_moose64,
                ) {
            return no
        }
        modidx += 1
    }

    return yes
}

func TypeRefExpr.as_code(indent=0) {
    if self.damaged {
        return "(damaged type ref expr.)"
    }
    var prefix_mod_names = {}
    var has_array = no
    for mod in self.modifiers {
        if mod.name == "array" {
            has_array = yes
        }
    }
    if not has_array {
        prefix_mod_names.add("readonly")
    }

    var printed_mods = self.modifiers.copy()
    
    var t = ""
    for mod in printed_mods {
        if prefix_mod_names.has(mod.name) {
            if t != "" {
                t += " "
            }
            t += mod.as_str()
        }
    }
    if t != "" {
        t += " "
    }
    if self.type_path != none and self.type_path.len > 0 {
        t = self.type_path.join(".") + "." + t
    }
    if self.name == none {
        t += "(unnamed type)"
    } else {
        t += self.name
    }
    for mod in printed_mods {
        if not prefix_mod_names.has(mod.name) {
            t += " " + mod.as_str()
        }
    }
    if self.has_init_expr {
        assert(self.subexprs.len == 1)
        t += self.subexprs[1].as_code(indent=(indent + 4))
    }
    return t
}

func TypeRefExpr.is_array_with_readonly_data {
    var found_array = no
    var idx = self.modifiers.len
    while idx >= 1 {
        var mod = self.modifiers[idx]
        if {"array"}.has(mod.name) {
            found_array = yes
        } elseif mod.name == "readonly" and
                found_array {
            return yes
        }
        idx -= 1
    }
    return no
}

func TypeRefExpr.is_readonly {
    var has_outer_readonly = no
    for mod in self.modifiers {
        if {"array"}.has(mod.name) {
            has_outer_readonly = no
        } elseif mod.name == "readonly" {
            has_outer_readonly = yes
        }
    }
    return has_outer_readonly
}

func get_array_suffix_from_c_type(
        c_type_str,
        error_if_non_numeric=no,
        error_damaged_node=none,
        at_line=none, at_col=none,
        project_file=none,
        msgs=msgs, is_moose64=is_moose64,
        ) {
    var result = none
    if c_type_str.ends("]") {
        var idx = c_type_str.len - 1
        while idx >= 1 {
            if c_type_str[idx] == "[" {
                break
            }
            idx -= 1
        }
        if idx >= 1 {
            result = [c_type_str.sub(
                1, idx - 1), c_type_str.sub(idx)]
        }
    }
    if result == none {
        result = [c_type_str, none]
    }
    if error_if_non_numeric and
            result[2] != none {
        var potential_num_str = result[2].sub(
            2, result[2].len - 1
        ).trim()
        if not text.is_digits(potential_num_str) {
            if error_damaged_node == none or
                    not error_damaged_node.damaged {
                if msgs == none {
                    throw new ValueError(
                        "Found array value with "
                        "unexpected non-digits."
                    )
                } else {
                    msgs.add(new msg.FileMsg(
                        "Unexpected array range value that "
                        "couldn't be resolved on type " +
                        textfmt.as_escaped_code_string(
                            c_type_str
                        ) + ". Please insert "
                        "a plain number, or an expression "
                        "that can be resolved at compile time.",
                        source_file=project_file,
                        line=at_line, col=at_col,
                    ))
                }
            }
            if error_damaged_node != none {
                error_damaged_node.damaged = yes
            }
        }
    }
    return result
}

func TypeRefExpr.as_c_code(
        indent=0, global_name_assign_callback=none,
        global_register_m64_array_callback=none,
        c_name_to_insert_if_func_ptr=none,
        project=none, project_file=none,
        is_moose64=no
        ) {
    if self.damaged {
        return "(damaged type ref expr.)"
    }

    if project_file != none and project == none {
        project = project_file.project
    }

    var outer_sized_c_array_idx = none
    var outer_sized_c_array_range = none
    var idx = self.modifiers.len
    while idx >= 1 {
        var mod = self.modifiers[idx]
        if {"ref", "implicit ref", "array"}.has(mod) {
            break
        }
        if mod.name == "c_array" {
            for prop in mod.props {
                if prop.prop_name == "range" {
                    outer_sized_c_array_idx = idx
                    if prop.range_value_num != none {
                        outer_sized_c_array_range =
                            prop.range_value_num
                    } elseif prop.range_value_label != none {
                        outer_sized_c_array_range =
                            prop.range_value_label
                    }
                    if outer_sized_c_array_range == none {
                        throw new RuntimeError(
                            "Damaged mod range property found "
                            "with no range value."
                        )
                    }
                    break
                }
            }
            break
        }
        idx -= 1
    }

    var prefix_mod_names = {"readonly"}
    func filter_mods(mod_list) {
        var skip_array_mod_names = {"readonly"}
        var saw_array = no
        var result = mod_list.copy()
        var idx = mod_list.len
        while idx >= 1 {
            if mod_list[idx].name == "array" {
                saw_array = yes
            } elseif saw_array and
                    skip_array_mod_names.has(
                        mod_list[idx].name) {
                result[idx] = none
                idx -= 1
                continue
            }
            idx -= 1
        }
        return result
    }
    if self.is_array() {
        assert(outer_sized_c_array_range == none)
        var ainfo = self.get_array_info(
            global_register_m64_array_callback=
                global_register_m64_array_callback,
            project=project,
            project_file=project_file,
            is_moose64=is_moose64)
        assert(ainfo != none)
        var inner_tinfo = ainfo[2]
        var mods = filter_mods(ainfo[3])
        var t = ""
        var idx = 0
        for mod in mods {
            idx += 1
            if mod == none {
                continue
            }
            if skip_array_mod_names.has(mod.name) {
                continue
            }
            if prefix_mod_names.has(mod.name) {
                if t != "" {
                    t += " "
                }
                t += mod.as_c_code(indent=indent,
                    global_name_assign_callback=
                        global_name_assign_callback,
                    project=project, project_file=project_file,
                    is_moose64=is_moose64)
            }
        }
        if t != "" {
            t += " "
        }
        t += "struct __m64arraystruct__" + ainfo[1] + "*"
        for mod in mods {
            if skip_array_mod_names.has(mod.name) {
                continue
            }
            if not prefix_mod_names.has(mod.name) {
                if t != "" {
                    t += " "
                }
                t += mod.as_c_code(indent=indent,
                    global_name_assign_callback=
                        global_name_assign_callback,
                    project=project,
                    project_file=project_file,
                    is_moose64=is_moose64)
            }
        }
        return t
    }

    var mods = filter_mods(self.modifiers)
    var t = ""
    idx = 0
    for mod in mods {
        idx += 1
        if mod == none or
                idx == outer_sized_c_array_idx {
            continue
        }
        if prefix_mod_names.has(mod.name) {
            if t != "" {
                t += " "
            }
            t += mod.as_c_code(indent=indent,
                global_name_assign_callback=
                    global_name_assign_callback,
                project=project, project_file=project_file,
                is_moose64=is_moose64)
        }
    }
    if t != "" {
        t += " "
    }
    if self.is_user_type() or
            not _m64_to_c_name_map.has(self.name) {
        var sinfo = none
        if global_name_assign_callback != none and
                self.storage_ref != none {
            sinfo = st_ref.ref_to_symbol_info(
                self.storage_ref,
                project=project,
                is_moose64=is_moose64
            )
            if sinfo.def_file == none {
                sinfo = none
            }
        }
        if sinfo != none {
            t += global_name_assign_callback(sinfo.name,
                project_file=sinfo.def_file)
        } else {
            t += self.name
        }
    } else {
        t += _m64_to_c_name_map[self.name]
    }
    idx = 0
    for mod in mods {
        idx += 1
        if mod == none or
                idx == outer_sized_c_array_idx {
            continue
        }
        if not prefix_mod_names.has(mod.name) {
            t += " " + mod.as_c_code(indent=indent,
                global_name_assign_callback=
                    global_name_assign_callback,
                project=project, project_file=project_file,
                is_moose64=is_moose64)
        }
    }
    if outer_sized_c_array_range != none {
        t += "[" + outer_sized_c_array_range.as_str() + "]"
    }
    if self.has_init_expr {
        assert(self.subexprs.len == 1)
        t += self.subexprs[1].as_c_code(indent=(indent + 4),
            global_name_assign_callback=
                global_name_assign_callback,
            project=project, project_file=project_file,
            is_moose64=is_moose64)
    }
    return t
}

func TypeRefExpr.copy {
    var self_copy = base.copy()
    var old_modifiers = self.modifiers
    self_copy.modifiers = []
    for item in old_modifiers {
        self_copy.modifiers.add(item.copy())
    }
    return self_copy
}

func TypeRefExpr.adjust_type_path_for_use_in_file(pfile) {
    if self.storage_ref == none {
        return
    }
    if self.storage_ref.kind == st_ref.ST_GLOBAL {
        var ipath = pfile.global_scope.get_import_path_for_global(
            pfile, self.storage_ref.id
        )
        assert(typename(ipath) == "list")
        self.type_path = ipath
    }
}

func TypeRefExpr.is_readonly {
    var t = typeinfo.TypeInfo(typeinfo.TI_USERTYPE)
    t.modifiers = self.modifiers.copy()
    return t.is_readonly()
}

func TypeRefExpr.is_array {
    var t = typeinfo.TypeInfo(typeinfo.TI_USERTYPE)
    t.modifiers = self.modifiers.copy()
    return t.is_array()
}

func TypeRefExpr.get_array_info(
        global_register_m64_array_callback=none,
        project=none, project_file=none,
        is_moose64=no) {
    var t = typeinfo.create_typeinfo_from_typeexpr(
        self, is_moose64=is_moose64)
    return typeinfo.get_array_type_info(
        t, global_register_m64_array_callback=
            global_register_m64_array_callback,
        project=project, project_file=project_file,
        is_moose64=is_moose64)
}

func TypeRefExpr.ref_count(
        include_c_arrays=yes,
        include_arrays=no,
        include_implicit_refs=no,
        include_explicit_refs=yes,
        ) {
    var t = typeinfo.TypeInfo(typeinfo.TI_USERTYPE)
    t.modifiers = self.modifiers.copy()
    return t.ref_count(
        include_c_arrays=include_c_arrays,
        include_arrays=include_arrays,
        include_implicit_refs=include_implicit_refs,
        include_explicit_refs=include_explicit_refs,
    )
}

func get_known_c_type_size(c_type) {
    if {"int32_t", "uint32_t", "_m64_float32_t"}.has(c_type) {
        return 4
    } elseif {"int64_t", "uint64_t",
            "_m64_float64_t"
            }.has(c_type) {
        return 8
    } elseif {"signed char", "unsigned char"}.has(c_type) {
        return 4
    }
    return none
}

const _m64_to_c_name_map = {
    "f32"-> "_m64_float32_t",
    "f64"-> "_m64_float64_t",
    "i8"-> "signed char",
    "i16"-> "int16_t",
    "i32"-> "int32_t",
    "i64"-> "int64_t",
    "bool"-> "signed char",
    "u8"-> "unsigned char",
    "byte"-> "unsigned char",
    "u16"-> "uint16_t",
    "u32"-> "uint32_t",
    "u64"-> "uint64_t",
    "size"-> "uint64_t",
    "addr_diff"-> "intptr_t",
    "addr"-> "uintptr_t",
    "moose64_failed_result_t"-> "uint32_t",
    "any"->"void",
    "empty"-> "void",
}

func get_c_builtin_for_m64_base_type(name) {
    if not builtin_moose64_types.has(name) {
        return none
    }
    if _m64_to_c_name_map.has(name) {
        return _m64_to_c_name_map[name]
    } else {
        print("horsec: error: Internal error, "
            "encountered unhandled C builtin type: " +
            name.as_str())
        throw new NotImplementedError(
            "Unhandled builtin type."
        )
    }
}

type TryResolveUserTypeResult {
    var had_error = no
    var error_ast_typeref = none

    var resolved_storage_ref = none
    var resolved_to_nonuser_type = no
}

func TryResolveUserTypeResult.as_str {
    return "TryResolveUserTypeResult{" +
        "had_error=" +
            self.had_error.as_str() + ","
        "error_ast_typeref=" +
            self.error_ast_typeref.as_str() + ","
        "resolved_storage_ref=" +
            self.resolved_storage_ref.as_str() + ","
        "resolved_to_nonuser_type=" +
            self.resolved_to_nonuser_type.as_str() +
    "}"
}

func TypeRefExpr.try_resolve_to_user_type_nonrecursive(
        project_file, force_recompute=no,
        is_moose64=no, debug=no,
        ) {
    var builtin_names =
        if is_moose64 (builtin_moose64_types)
            else (builtin_horse64_types)
    if self.is_func_ref or (
            not self.is_user_type() and
            builtin_names.has(self.name)) {
        if self.is_func_ref {
            if self.storage_ref == none and
                    self.func_storage_ref != none {
                self.storage_ref = self.func_storage_ref.copy()
            }
            var result = new TryResolveUserTypeResult()
            result.resolved_storage_ref = self.storage_ref.copy()
            return result
        }

        if not self.is_func_ref {
            var result = new TryResolveUserTypeResult()
            result.resolved_to_nonuser_type = yes
            return result
        }
        var result = new TryResolveUserTypeResult()
        result.had_error = yes
        result.error_ast_typeref = self
        return result
    }
    if self.storage_ref != none and not force_recompute {
        var result = new TryResolveUserTypeResult()
        result.resolved_storage_ref = self.storage_ref.copy()
        return result
    }
    self.adjust_type_path_for_use_in_file(project_file)
    var type_path = self.type_path
    if type_path != none and type_path.len == 0 {
        type_path = none
    }

    if self.name == none {
        print("horsec: error: Fatal internal error, "
            "trying to resolve type ref with no name: " +
            self.as_str())
        throw new RuntimeError(
            "Encountered broken AST typeref with "
            "no name.")
    }
    assert(self.name != none)
    var result_ref = project_file.try_lookup_symbol_path(
        none, name=self.name, type_path=type_path,
        is_write_access=no, is_moose64=is_moose64
    )
    if result_ref == none {
        var result = new TryResolveUserTypeResult()
        result.had_error = yes
        result.error_ast_typeref = self
        return result
    }
    self.storage_ref = result_ref.copy()
    var result = new TryResolveUserTypeResult()
    result.resolved_storage_ref = result_ref
    return result
}

func TypeRefExpr.try_resolve_to_user_type(
        project_file, force_recompute=no,
        is_moose64=no, debug=no,
        ) {
    return later self.try_resolve_to_user_type_nonrecursive(
        project_file, force_recompute=force_recompute,
        is_moose64=is_moose64, debug=debug,
    )
}

func TypeRefExpr.get_c_builtin_for_m64_base_type {
    if self.type_path != none and
            self.type_path.len > 0 {
        return none
    }
    return get_c_builtin_for_m64_base_type(self.name)
}

func TypeRefExpr.is_user_type {
    if self.is_special_madeup_builtin {
        return no
    }
    return not builtin_moose64_types.has(self.name)
}

func TypeRefExpr.may_have_data_attr {
    if not builtin_moose64_types.has(self.name) {
        return yes
    }
    if self.is_array() {
        return yes
    }
    return no
}

func TypeRefExpr.may_have_len_attr {
    if not builtin_moose64_types.has(self.name) {
        return yes
    }
    if self.is_array() {
        return yes
    }
    return no
}

func TypeRefExpr.as_str {
    var t = "TypeRefExpr<" + self.as_code() + ">"
    return t
}

type TypeRefAndExprResult {
    var storage_ref
    var type_expr
    var resolved_func_is_override = no
    var has_self_expr = no
}

## Based on a node that is some identifier ref AST node,
## and a maybe already known reference for its origin,
## this returns the AST typeref expression and the
## storage reference for the type of the referenced value.
## For a referenced function as part of a call, it can
## also figure out if it should be redirected to an override.
func resolve_st_ref_to_type_ref_and_expr(
        project_file, value_ref,
        node=none, node_parents=none,
        apply_func_override_for_args_node=none,
        apply_func_override_for_func_type_expr=none,
        ignore_if_ref_none=no,
        msgs=none, is_moose64=no,
        debug=no,
        ) {
    var dbg_header = if is_moose64
        ("moosec: debug: ") else ("horsec: debug: ")

    if debug {
        print(dbg_header +
            "resolve_st_ref_to_type_ref_and_expr() "
            "called on: node=" + node.as_str() + " "
            "apply_func_override_for_args_node=" +
                apply_func_override_for_args_node.as_str() + " "
            "apply_func_override_for_func_type_expr=" +
                apply_func_override_for_func_type_expr.as_str() + " "
            "value_ref=" + value_ref.as_str() + " "
            "node_parents.len=" + if node_parents != none
                (node_parents.len.as_str())
                else ("<parents unset>") + " "
            "is_moose64=" + is_moose64.as_str())
    }
    if apply_func_override_for_args_node != none and
            (apply_func_override_for_args_node.kind !=
                ast.N_EXPR_CALLARGS or
             node == none or
             node_parents == none or node_parents.len == 0 or
             node_parents[node_parents.len].kind !=
                ast.N_EXPR_BINOP or
             node_parents[node_parents.len].optoken.str != "(" or
             node_parents[node_parents.len].subexprs[1] != node or
             node_parents[node_parents.len].subexprs[2] !=
                apply_func_override_for_args_node) {
        throw new RuntimeError(
            "Internal error: "
            "Invalid apply_func_override_for_args_node "
            "parameter not matching node_parents chain, or "
            "node is unset. One of those three parameters "
            "is bugged. Please report this error to the "
            "compiler makers.")
    }

    var override_resolution_result = none
    func try_resolve_override_if_needed {
        if apply_func_override_for_args_node == none and
                apply_func_override_for_func_type_expr == none {
            return later none
        }
        # In this case, delegate to get_called_or_assigned_func_types()
        # which can resolve func overrides.
        var result = ast_analyze.
            get_called_or_assigned_func_types(
                project_file, node,
                node_parents,
                allow_noncall_ref=(
                    apply_func_override_for_func_type_expr != none and
                    apply_func_override_for_args_node == none
                ),
                allow_matching_func_override=(
                    node.kind ==
                        ast.N_EXPR_IDREF or
                    (node.kind == ast.N_EXPR_BINOP and
                    node.optoken.str == "." and
                    node.subexprs[2].kind == ast.N_EXPR_IDREF)
                ),
                try_to_match_func_type_expr=
                    apply_func_override_for_func_type_expr,
                msgs=msgs,
                is_moose64=is_moose64,
                debug=debug,
            ) later:

        await result
        if debug {
            var have_known_error_msg = no
            if msgs != none {
                for m in msgs {
                    if m.kind == msg.M_ERROR {
                        have_known_error_msg = yes
                        break
                    }
                }
            }
            print(dbg_header +
                "resolve_st_ref_to_type_ref_and_expr(): "
                "Got get_called_or_assigned_func_types result, "
                "result=" + result.as_str() +
                " (is msgs set: " +
                    (msgs != none).as_str() + ", "
                "node.damaged: " + node.damaged.as_str() + ", "
                "have_known_error_msg=" +
                    have_known_error_msg.as_str() + ")")
        }
        if result == none or
                result.func_var_name == none or
                result.func_ref == none or
                result.func_var_type_expr == none {
            # Couldn't be resolved to exact known function
            # and therefore also guaranteed not identified as
            # any override.
            return later none
        }
        # This function may be an override, so update
        # our info from what we obtained above:
        var result_ref = result.func_ref
        var result_type_expr = result.func_var_type_expr
        override_resolution_result = new TypeRefAndExprResult()
        override_resolution_result.storage_ref =
            result_ref.copy()
        override_resolution_result.type_expr =
            result_type_expr.copy()
        if result.func_was_overridden {
            override_resolution_result.
                resolved_func_is_override = yes
        }
        if result.self_var_type_expr != none {
            override_resolution_result.has_self_expr = yes
        }
    }
    try_resolve_override_if_needed() later:

    if override_resolution_result != none {
        return later override_resolution_result
    }
    if value_ref == none and node != none and
            node.kind == ast.N_EXPR_IDREF and
            node.ref != none {
        value_ref = node.ref
    }
    if value_ref == none {
        if not ignore_if_ref_none {
            throw new ValueError("Need value_ref parameter set, "
                "since the AST node doesn't have any ref info.")
        }
        if debug {
            print(dbg_header +
                "resolve_st_ref_to_type_ref_and_expr() "
                "result: Nothing, since value_ref is none.")
        }

        var result = new TypeRefAndExprResult()
        return later result
    }
    var lookup_label = none
    if node != none and has_attr(node, "label") {
        lookup_label = node.label
    }
    var result_ref = none
    var result_expr = none
    var var_node = none
    if value_ref.kind == st_ref.ST_LOCAL and
            lookup_label != none and
            node_parents != none and
            node_parents.len > 0 {
        var_node =
            st_scope.find_def_node_from_idref_node(
                node, node_parents
            )
        if var_node == none {
            if debug {
                print(dbg_header +
                    "resolve_st_ref_to_type_ref_and_expr() "
                    "result: Nothing, since local var "
                    "def node wasn't found.")
            }
            var result = new TypeRefAndExprResult()
            return later result
        }
        assert(typename(var_node) != "bool")
        if var_node.has_type_expr {
            result_expr =
                var_node.subexprs[var_node.subexprs.len]
        }
        var idx = var_node.var_labels.find(lookup_label)
        assert(idx != none)
        if result_expr == none and
                not var_node.is_empty and
                (var_node.is_const or
                 (var_node.vars_autoconst_list != none and
                  var_node.vars_autoconst_list[idx])) {
            var assigned_values = var_node.subexprs.copy()
            if var_node.has_type_expr {
                assigned_values = assigned_values.sub(
                    1, assigned_values.len - 1
                )
            }
            var value = assigned_values[idx]
            if value.kind == ast.N_EXPR_IDREF and
                    value.ref != none {
                result_ref = value.ref.copy()
            }
        }
    } elseif value_ref.kind == st_ref.ST_ARG and
            node.scope != none and node.scope.func_scope != none {
        var arg_type_exprs =
            node.scope.func_scope.extended_final_arg_type_exprs()
        if value_ref.id >= 1 and
                value_ref.id <= arg_type_exprs.len {
            result_expr = arg_type_exprs[
                value_ref.id]
        }
    } elseif value_ref.kind == st_ref.ST_SELF and
            node_parents != none {
        var i = node_parents.len
        while i >= 1 and (
                node_parents[i].kind != ast.N_STMT_FUNC or
                node_parents[i].type_path == none or
                node_parents[i].type_path.len == 0) {
            i -= 1
        }
        if i < 1 {
            if debug {
                print(dbg_header +
                    "resolve_st_ref_to_type_ref_and_expr() "
                    "result: Nothing, since self parent func "
                    "lookup failed.")
            }
            var result = new TypeRefAndExprResult()
            return later result
        }
        var anscope = project_file.
            make_attr_names_scope_from_funcattr(
                node_parents[i], msgs=msgs, is_moose64=is_moose64,
                def_project_file=project_file
            )
        assert(anscope.storage_id != none)
        result_ref = new st_ref.StorageRef(
            st_ref.ST_GLOBAL, anscope.storage_id
        )
    } elseif value_ref.kind == st_ref.ST_GLOBAL or
            value_ref.kind == st_ref.ST_GLOBALATTR {
        result_ref = value_ref.copy()
    }
    if result_expr == none and
            result_ref != none and
            result_ref.kind == st_ref.ST_GLOBAL {
        assert(result_expr == none)
        var gscope = project_file.project.
            storage_id_to_global_scope_map[result_ref.id]
        assert(gscope != none)
        var gnode = gscope.storage_id_to_entry[result_ref.id]
        assert(typename(gnode) != "list")
        var_node = gnode
        if debug {
            print(dbg_header +
                "resolve_st_ref_to_type_ref_and_expr(): "
                "Obtained global node: gnode=" + gnode.as_str())
        }
        if gnode.kind == ast.N_STMT_FUNC {
            result_expr = create_typeref_from_func_node(
                project_file, gnode
            ).copy()
            assert(result_expr != gnode)
        } elseif gnode.kind == ast.N_STMT_VAR and
                gnode.has_type_expr and gnode.subexprs.len > 0 {
            result_expr = gnode.subexprs[gnode.subexprs.len].copy()
        } elseif is_moose64 and gnode.kind == ast.N_STMT_STRUCT {
            result_expr = new TypeRefExpr()
            result_expr.name = gnode.label
            result_expr.storage_ref = result_ref.copy()
        }
    } elseif result_expr == none and
            result_ref != none and
            result_ref.kind == st_ref.ST_GLOBALATTR and
            lookup_label != none {
        var anscope =
            project_file.project.storage_id_to_anscope_map[
                result_ref.id[1]
            ]
        if debug {
            print(dbg_header +
            "resolve_st_ref_to_type_ref_and_expr() "
            "type scope obtained: anscope=" + anscope.as_str())
        }
        if anscope.is_struct or anscope.is_type {
            if not anscope.name_to_symbol_map.has(
                lookup_label) {
                if debug {
                    print(dbg_header +
                    "resolve_st_ref_to_type_ref_and_expr() "
                    "result: Nothing, since global attribute "
                    "member lookup failed.")
                }
                return later [none, none]
            }
            var sinfo = anscope.
            name_to_symbol_map[lookup_label]
            if debug {
                print(dbg_header +
                "resolve_st_ref_to_type_ref_and_expr() "
                "got member symbol info: "
                "sinfo=" + sinfo.as_str() + " "
                "lookup_label='" + lookup_label.as_str() + "'")
            }
            if sinfo.typeref_expr != none {
                result_expr = sinfo.typeref_expr
            } elseif is_moose64 {
                print(if is_moose64 ("moosec")
                else ("horsec") + ": error: "
                    "Found global attribute with no "
                    "type expr, this is an "
                    "internal error. Please report "
                    "this to the compiler makers: " +
                    "left_of_us=" +
                    left_of_us.as_str() + " "
                    "sinfo=" + sinfo.as_str())
                throw new RuntimeError("Internal error.")
            }
        }
    }

    func resolve_self_ref_if_needed {
        if result_ref == none or
                result_ref.kind != st_ref.ST_SELF {
            return later
        }
        result = resolve_st_ref_to_type_ref_and_expr(
            project_file, result_ref, node=var_node,
            is_moose64=is_moose64, debug=debug,
        )
        if result.storage_ref != none {
            result_ref = result.storage_ref.copy()
            result_expr = result.type_expr
        }
    }
    resolve_self_ref_if_needed()
    later:

    func obtain_result_ref_if_needed {
        if result_ref != none or
                result_expr == none {
            return later
        }
        var result = result_expr.try_resolve_to_user_type(
            project_file, force_recompute=no,
            is_moose64=is_moose64,
        ) later:

        await result
        if not result.had_error {
            result_ref = result.resolved_storage_ref
        }
    }
    obtain_result_ref_if_needed()
    later:

    if result_ref != none and
            {st_ref.ST_LOCAL, st_ref.ST_SELF,
            st_ref.ST_CCAPTURE,
            st_ref.ST_ARG}.has(result_ref.kind) {
        # This isn't a useful end result here.
        result_ref = none
    }
    if result_ref == none and
            value_ref != none and
            {st_ref.ST_MCREF, st_ref.ST_CEXT}.has(
            value_ref.kind) {
        result_ref = value_ref.copy()
    }
    if debug {
        print(dbg_header +
            "resolve_st_ref_to_type_ref_and_expr() "
            "result: " + [result_ref, result_expr].as_str())
    }
    var result = new TypeRefAndExprResult()
    result.storage_ref = result_ref  # XXX: Copied above.
    result.type_expr = result_expr.copy()
    return result
}

func TypeRefExpr.describe_to_user(
        project=none, add_quotes_where_useful=no,
        is_moose64=no) {
    var tinfo = typeinfo.create_typeinfo_from_typeexpr(
        self, is_moose64=is_moose64, debug=no
    )
    if tinfo == none {
        if not self.is_func_ref and
                self.is_user_type() and
                self.storage_ref == none {
            # We can't convert this special case in a
            # non-later function. Print this manually:
            var t = self.as_code()
            if add_quotes_where_useful and
                    self.is_user_type() {
                t = "'" + t + "'"
            }
            return t
        }
        print(if is_moose64 ("moosec") else ("horsec") +
            ": error: Fatal internal error, failed to "
            "convert typeref expr to type info. "
            "self=" + self.as_str() + " "
            "self.line=" + self.line.as_str() + " "
            "self.col=" + self.col.as_str() + " "
            "self.is_multi_type=" +
                self.is_multi_type.as_str() + " "
            "self.is_func_ref=" +
                self.is_func_ref.as_str() + " "
            "self.is_list_arg=" +
                self.is_list_arg.as_str() + " "
            "self.is_user_type()=" +
                self.is_user_type().as_str() + " "
            "self.storage_ref=" +
                if not self.is_user_type() ("not user type")
                    else (self.storage_ref.as_str()))
        throw new RuntimeError("Unexpectedly failed to "
            "convert AST typeref expression, this "
            "shouldn't be possible.")
    }
    return tinfo.describe_to_user(
        project=project, add_quotes_where_useful=
            add_quotes_where_useful,
        is_moose64=is_moose64
    )
}

func _parse_typeref_notlater(
        tokens, pos, msgs, extend_typeref_expr=none,
        project_file=none,
        max_len=none, max_depth=64, is_nested_in_type=no,
        is_moose64=no, debug=no
        ) {
    var program_name = if is_moose64 ("moosec") else ("horsec")
    var startpos = pos
    if max_len == none {
        max_len = tokens.len
    }
    if debug {
        print(program_name + ": debug: _parse_typeref_notlater(): " +
            "Called on " + tokens.len.as_str() + " token(s) with "
            "tokens.sub(1, 5)=" + tokens.sub(1, 5).as_str() + " "
            "pos=" + pos.as_str() + " max_len=" +
            max_len.as_str() + " "
            "max_depth=" + max_depth.as_str() + " "
            "is_moose64=" + is_moose64.as_str() + " "
            "extend_typeref_expr=" +
                extend_typeref_expr.as_str())
    }
    if extend_typeref_expr != none {
        assert(extend_typeref_expr.token_len != none and
            extend_typeref_expr.token_len > 0)
    }
    if pos > max_len {
        if debug {
            print(program_name + ": debug: "
                "_parse_typeref_notlater(): " +
                "No tokens to parse, bailing early.")
        }
        return none
    }
    var start_line = tokens[pos].line
    var start_col = tokens[pos].col

    func check_if_func_type(tokens, pos, max_len=none,
            is_nested_in_type=no, debug=no) {
        var startpos = pos
        if pos > max_len or
                tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != "(" {
            if debug {
                print(program_name + ": debug: "
                    "_parse_typeref_notlater(): " +
                    "In check_if_func_type(): "
                    "Early bail since no '(' at "
                    "the start.")
            }
            return none
        }
        var could_be_func = no
        pos += 1
        var bdepth = 1
        if debug {
            print(program_name + ": debug: "
                "_parse_typeref_notlater(): " +
                "In check_if_func_type(): "
                "pos=" + pos.as_str() + " "
                "max_len=" + max_len.as_str() + " "
                "is_nested_in_type=" +
                    is_nested_in_type.as_str())
        }
        while pos <= max_len and
                bdepth >= 1 {
            if tokens[pos].kind == token.T_ENCLOSE and
                    {'(', '[', '{'}.has(tokens[pos].str) {
                bdepth += 1
                pos += 1
                continue
            } elseif tokens[pos].kind == token.T_ENCLOSE and
                    {')', ']', '}'}.has(tokens[pos].str) {
                bdepth -= 1
                pos += 1
                if bdepth == 0 and (could_be_func or
                        (not is_nested_in_type and
                        pos <= max_len and
                        tokens[pos].kind == token.T_RIGHTPTR)) {
                    if pos > max_len or
                            tokens[pos].kind != token.T_RIGHTPTR {
                        var nested = yes
                        return [(pos - startpos), nested]
                    }
                    var inner_bdepth = 0
                    while pos <= max_len and
                            (tokens[pos].kind !=
                                token.T_ENCLOSE or
                             not {")", "}", "]"}.has(
                                 tokens[pos].str
                            ) or inner_bdepth > 0) {
                        if tokens[pos].kind == token.T_ENCLOSE {
                            if {"(", "{", "["}.has(
                                    tokens[pos].str) {
                                inner_bdepth += 1
                            } elseif {")", "}", "]"}.has(
                                    tokens[pos].str) {
                                inner_bdepth = math.max(
                                    0, inner_bdepth - 1)
                            }
                        }
                        pos += 1
                    }
                    var nested = no
                    return [(pos - startpos), nested]
                }
                continue
            }
            if bdepth == 1 and
                    tokens[pos].kind == token.T_RIGHTPTR {
                if debug {
                    print(program_name + ": debug: "
                        "_parse_typeref_notlater(): " +
                        "check_if_func_type(): We detected a "
                        "likely func. Scanning ahead to find "
                        "out if this fits our suspicion.")
                }
                could_be_func = yes
            }
            pos += 1
        }
        return none
    }
    func parse_multi_args(tokens, pos,
            project_file=none,
            max_depth=none, outer_startpos=none,
            msgs=none, max_len=none,
            is_moose64=no, debug=no) {
        assert(max_len == none or pos <= max_len)
        assert(tokens[pos].kind == token.T_ENCLOSE and
               tokens[pos].str == "(")
        var ast_typeref_list = []
        var startpos = pos
        pos += 1
        if max_depth <= 0 {
            var type_startpos = pos
            msgs.add(new msg.FileMsg(
                "Invalid " + token.describe_token_at(
                    tokens, pos) + " "
                ", exceeds maximum nesting depth "
                "for type expression starting "
                "in line " +
                token.get_line(tokens,
                    outer_startpos).as_str() +
                ", column " +
                token.get_col(tokens,
                    outer_startpos).as_str() + ".",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            var bdepth = 1
            while pos <= tokens.len and (
                        max_len == none or
                        pos <= max_len) and
                    bdepth > 0 {
                if token.surely_to_toplevel_even_in_bad_code(
                        tokens, pos, is_moose64=is_moose64
                        ) {
                    pos -= 1
                    break
                }
                if tokens[pos].kind == token.T_ENCLOSE and
                        {"(", "{", "["}.has(tokens[pos].str) {
                    bdepth += 1
                } elseif tokens[pos].kind == token.T_ENCLOSE and
                        {")", "}", "]"}.has(tokens[pos].str) {
                    bdepth -= 1
                    if bdepth <= 0 {
                        break
                    }
                }
                pos += 1
            }
            pos += 1
            var expr_len = (pos - type_startpos)
            var closed_correctly = no
            if bdepth <= 0 and pos - 1 >= startpos and
                    tokens[pos - 1].kind == token.T_ENCLOSE and
                    tokens[pos - 1].str == ")" {
                closed_correctly = yes
                expr_len -= 1
            }
            var inner_type = new ast_expr.InvalidExpr(expr_len)
            return [pos, [inner_type], closed_correctly]
        }
        while pos <= tokens.len and
                (max_len == none or
                 pos <= max_len) {
            if tokens[pos].kind == token.T_ENCLOSE and
                    {")", "}", "]"}.has(
                        tokens[pos].str) {
                break
            }
            var ast_typeref = _parse_typeref_notlater(
                tokens, pos, msgs,
                extend_typeref_expr=none,
                project_file=project_file,
                max_len=max_len, max_depth=(
                    max_depth - 1
                ), is_nested_in_type=yes,
                is_moose64=is_moose64,
                debug=debug
            )
            if ast_typeref == none {
                break
            }
            pos += ast_typeref.token_len
            ast_typeref_list.add(ast_typeref)
            if pos < tokens.len and (
                    max_len == none or
                    pos <= max_len) {
                if tokens[pos].kind != token.T_COMMA {
                    break
                }
                pos += 1
            }
        }
        var missed_closing_bracket = no
        if pos > tokens.len or (
                max_len != none and
                pos > max_len) or
                tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != ")" {
            missed_closing_bracket = yes
            msgs.add(new msg.FileMsg(
                "Invalid " + token.describe_token_at(
                    tokens, pos) + " "
                ", expected ',' to continue or "
                "')' to close the '(' "
                "found in line " +
                token.get_col(tokens,
                    startpos).as_str() +
                ", column " +
                token.get_col(tokens,
                    startpos).as_str() + ".",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
        } else {
            pos += 1  # Go past ')'
        }
        if missed_closing_bracket or
                ast_typeref_list.len == 0 {
            if ast_typeref_list.len == 0 {
                var errorpos = pos
                if not missed_closing_bracket {
                    errorpos -= 1
                }
                msgs.add(new msg.FileMsg(
                    "Invalid " + token.describe_token_at(
                        tokens, errorpos) + " "
                    ", expected type for 'multi' "
                    "type starting in line " +
                    token.get_col(tokens,
                        startpos).as_str() +
                    ", column " +
                    token.get_col(tokens,
                        startpos).as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, errorpos),
                    col=token.get_col(tokens, errorpos),
                ))
                var inner_type = new ast_expr.InvalidExpr(
                    math.max(1, errorpos - (startpos + 1)))
                ast_typeref_list.add(inner_type)
            }
            assert(ast_typeref_list.len > 0)
            for item in ast_typeref_list {
                item.damaged = yes
            }
            return [pos, ast_typeref_list,
                not missed_closing_bracket]
        }
        return [pos, ast_typeref_list, yes]
    }
    func parse_func_type(tokens, pos, max_len=none,
            nested_in_parens=no, debug=no) {
        if debug {
            print(program_name + ": debug: "
                "_parse_typeref_notlater(): " +
                "parse_func_type(): Now starting at "
                "pos=" + pos.as_str() + " with "
                "max_len=" + max_len.as_str() + "...")
        }
        if max_len == none {
            max_len = tokens.len - pos
        }
        func had_error(at_pos, description) {
            if not description.ends(" ") {
                description += " "
            }
            msgs.add(new msg.FileMsg(
                description + "func type in line " +
                token.get_line(tokens,
                    startpos).as_str() +
                ", column " +
                token.get_col(tokens,
                    startpos).as_str() + ".",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            var skiplen = token.get_naive_stmt_or_expr_len(
                tokens, startpos, max_len=max_len,
                for_expr=yes, is_moose64=is_moose64
            )
            var expr = new ast_expr.InvalidExpr(skiplen)
            return expr
        }
        var startpos = pos
        if pos > max_len or (nested_in_parens and (
                tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != "(")) {
            if nested_in_parens {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected '(' to begin ")
            }
            return had_error(pos,
                "Invalid " + token.describe_token_at(
                    tokens, pos) + " "
                ", expected start of ")
        }
        if nested_in_parens {
            assert(tokens[pos].kind == token.T_ENCLOSE)
            pos += 1
        }
        if pos > max_len or
                tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != "(" {
            return had_error(pos,
                "Invalid " + token.describe_token_at(
                    tokens, pos) + " "
                ", expected '(' to start args for ")
        }
        pos += 1

        # Parse argument list:
        var arg_types = []
        while pos <= max_len and
                (tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != ")") {
            if tokens[pos].kind != token.T_IDENT and
                    tokens[pos].kind != token.T_LEFTPTR {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected identifier (T_IDENT) to "
                    "start next argument, or '<-' (T_LEFTPTR) "
                    "for an anonymous argument, or ')' to end "
                    "arguments for ")
            }
            if tokens[pos].kind != token.T_LEFTPTR {
                assert(tokens[pos].kind == token.T_IDENT)
                pos += 1
            }
            if pos > max_len or
                    tokens[pos].kind != token.T_LEFTPTR {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected '<-' (T_LEFTPTR) to "
                    "continue argument for ")
            }
            pos += 1
            if pos > max_len or (
                    tokens[pos].kind == token.T_ENCLOSE and
                    {")", "]", "}"}.has(tokens[pos].str)) {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected type following '<-' (T_LEFTPTR) "
                    "to describe argument type for ")
            }
            assert(typeref_token_len != none)
            var inner_expr = _parse_typeref_notlater(
                tokens, pos, msgs, project_file=project_file,
                max_len=max_len, is_nested_in_type=yes,
                max_depth=(max_depth - 1),
                is_moose64=is_moose64,
                debug=debug,
            )
            if inner_expr == none {
                var had_error = no
                for m in msgs {
                    if m.kind == msg.M_ERROR {
                        had_error = yes
                    }
                }
                if not had_error {
                    throw new RuntimeError("Internal error, "
                        "nested AST typeref parsing returned "
                        "no result but without any error.")
                }
                var skiplen = token.get_naive_stmt_or_expr_len(
                    tokens, startpos, max_len=max_len,
                    for_expr=yes, is_moose64=is_moose64
                )
                var expr = new ast_expr.InvalidExpr(skiplen)
                return expr
            }
            assert(inner_expr.token_len != none)
            arg_types.add(inner_expr)
            pos += inner_expr.token_len
            if debug {
                print(program_name + ": debug: "
                    "_parse_typeref_notlater(): " +
                    "parse_func_type(): Parsed arg with type "
                    "inner_expr=" + inner_expr.as_str() + " "
                    "and we're now at pos=" + pos.as_str() + " "
                    "at this token: " + (
                        if pos <= max_len (tokens[pos].as_str())
                            else ("<end of tokens>")))
            }
            if pos > max_len or
                    (tokens[pos].kind != token.T_COMMA and
                     (tokens[pos].kind != token.T_ENCLOSE or
                      tokens[pos].str != ')')) {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected ')' or ',' to end previous "
                    "argument")
            }
            if tokens[pos].kind == token.T_COMMA {
                pos += 1
            } else {
                assert(tokens[pos].kind == token.T_ENCLOSE)
            }
            continue
        }
        if pos <= max_len {
            assert(tokens[pos].kind == token.T_ENCLOSE and
                tokens[pos].str == ')')
            pos += 1
        }
        if debug {
            print(program_name + ": debug: "
                "_parse_typeref_notlater(): " +
                "parse_func_type(): Completed parsing args, "
                "we're now at pos=" + pos.as_str() + " "
                "at this token: " + (
                    if pos <= max_len (tokens[pos].as_str())
                        else ("<end of tokens>")))
        }
        if pos > max_len or
                tokens[pos].kind != token.T_RIGHTPTR {
            return had_error(pos,
                "Invalid " + token.describe_token_at(
                    tokens, pos) + " "
                ", expected '->' (T_RIGHTPTR) to "
                "specify return type for ")
        }
        pos += 1
        var return_type = none
        if pos > max_len or
                ({token.T_KEYWORD,
                token.T_IDENT}.has(tokens[pos].kind) and
                tokens[pos].str == "empty") {
            # We got no return value.
            if pos < max_len {
                pos += 1
            }
        } else {
            return_type = _parse_typeref_notlater(
                tokens, pos, msgs, project_file=project_file,
                max_len=max_len, is_nested_in_type=yes,
                max_depth=(max_depth - 1),
                is_moose64=is_moose64,
                debug=debug
            )
            if return_type == none {
                var had_error = no
                for m in msgs {
                    if m.kind == msg.M_ERROR {
                        had_error = yes
                    }
                }
                if not had_error {
                    throw new RuntimeError("Internal error, "
                        "nested AST typeref parsing returned "
                        "no result but without any error.")
                }
                var skiplen = token.get_naive_stmt_or_expr_len(
                    tokens, startpos, max_len=max_len,
                    for_expr=yes, is_moose64=is_moose64
                )
                var expr = new ast_expr.InvalidExpr(skiplen)
                return expr
            }
            assert(return_type.token_len != none)
            pos += return_type.token_len
        }
        if nested_in_parens {
            if pos > max_len or
                    tokens[pos].kind != token.T_ENCLOSE or
                    tokens[pos].str != ')' {
                return had_error(pos,
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected ')' (T_ENCLOSE) to "
                    "end ")
            }
            pos += 1
        }
        var func_ref = new TypeRefFuncExpr()
        func_ref.arg_typeref_exprs = arg_types
        func_ref.return_typeref_expr = return_type
        func_ref.token_len = pos - startpos
        if debug {
            print(program_name + ": debug: "
                "_parse_typeref_notlater(): " +
                "parse_func_type(): Finished assembling "
                "func typeref expr. Result is: "
                "func_ref=" + func_ref.as_str() + " "
                "func_ref.token_len=" +
                    func_ref.token_len.as_str() + " "
                "pos=" + pos.as_str() + " "
                "line=" + start_line.as_str() + " "
                "col=" + start_col.as_str())
        }
        return func_ref
    }

    var typeref_expr = extend_typeref_expr
    var start_token_len = 0
    if typeref_expr != none {
        start_token_len = typeref_expr.token_len
        assert(start_token_len != none)
    }
    var typeref_token_len = start_token_len
    var typeref_damaged = no
    var mods = []
    while yes {
        const iterationstartpos = pos
        # First parse nestings that could be 1. multi type
        # parameters, 2. a func type, or 3. just arbitrary
        # nesting by the user:
        if pos <= max_len and
                tokens[pos].kind == token.T_ENCLOSE and
                tokens[pos].str == "(" {
            if debug {
                print(program_name + ": debug: "
                    "_parse_typeref_notlater(): " +
                    "Encountered a '(' that could "
                    "either be an inner nesting or a func. "
                    "tokens.sub(pos, pos + 5)=" +
                    tokens.sub(pos, pos + 5).as_str())
            }
            var bracket_open_pos = pos
            if max_depth <= 0 {
                msgs.add(new msg.FileMsg(
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", exceeds maximum nesting depth "
                    "for type expression starting "
                    "in line " +
                    token.get_line(tokens, startpos).as_str() +
                    ", column " +
                    token.get_col(tokens, startpos).as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                pos += 1
                var expr_len = start_token_len + (pos - startpos)
                if debug {
                    print(program_name + ": debug: "
                        "_parse_typeref_notlater(): " +
                        "Bailing with invalid expr.")
                }
                return new ast_expr.InvalidExpr(expr_len)
            }
            var func_type_token_len = 0
            var func_type_nested = no
            var func_type_check_result = check_if_func_type(
                tokens, pos, max_len=max_len,
                is_nested_in_type=is_nested_in_type,
                debug=debug,
            )
            if func_type_check_result != none {
                func_type_token_len =
                    func_type_check_result[1]
                func_type_nested =
                    func_type_check_result[2]
            }
            if debug {
                print(program_name + ": debug: "
                    "_parse_typeref_notlater(): " +
                    "(func_type_check_result != none)=" +
                        (func_type_check_result !=
                        none).as_str() + " " +
                    "func_type_token_len=" +
                        func_type_token_len.as_str() + " "
                    "tokens[pos + func_type_token_len]=" +
                        tokens[pos + func_type_token_len -
                            1].as_str() + " "
                    "func_type_nested=" +
                        func_type_nested.as_str())
            }
            if typeref_expr == none and
                    func_type_token_len != none {
                typeref_expr = parse_func_type(
                    tokens, pos, max_len=func_type_token_len,
                    nested_in_parens=func_type_nested,
                    debug=debug,
                )
                if debug {
                    print(program_name + ": debug: "
                        "_parse_typeref_notlater(): " +
                        "Got inner func, typeref_expr=" +
                            typeref_expr.as_str())
                }
                assert(typeref_expr.token_len != none and
                    typeref_expr.token_len > 0)
                if typeref_expr.kind == ast.N_EXPR_INVALID {
                    var have_error = no
                    for m in msgs {
                        if m.kind == msg.M_ERROR {
                            have_error = yes
                            break
                        }
                    }
                    assert(have_error)
                }
                pos += typeref_expr.token_len
                typeref_token_len =
                    start_token_len + (pos - startpos)
                continue
            }
            pos += 1  # Go past '('.
            assert(typeref_token_len != none)
            typeref_expr.token_len = typeref_token_len
            var inner_expr = _parse_typeref_notlater(
                tokens, pos, msgs,
                extend_typeref_expr=typeref_expr,
                project_file=project_file,
                is_nested_in_type=yes,
                max_len=max_len, max_depth=(max_depth - 1),
                is_moose64=is_moose64, debug=debug
            )
            if inner_expr == none {
                # Revert back to before bracket.
                pos = bracket_open_pos
                break
            }
            pos += inner_expr.token_len
            if pos > max_len or
                    tokens[pos].kind != token.T_ENCLOSE or
                    tokens[pos].str != ")" {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected ')' "
                    "for '(' found "
                    "in line " +
                    token.get_line(tokens,
                                bracket_open_pos).as_str() +
                    ", column " +
                    token.get_col(tokens,
                                bracket_open_pos).as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                var expr_len = start_token_len + (pos - startpos)
                if debug {
                    print(program_name + ": debug: "
                        "_parse_typeref_notlater(): " +
                        "Bailing with invalid expr.")
                }
                return new ast_expr.InvalidExpr(expr_len)
            }
            typeref_expr = inner_expr
            assert(typeref_expr.token_len != none)
            pos += 1  # Go past ')'
            typeref_token_len = start_token_len + (pos - startpos)
        }

        func is_implicit_ref(tokens, pos, max_len) {
            return (is_moose64 and
                pos + 1 <= max_len and
                (tokens[pos].kind == token.T_IDENT or
                 tokens[pos].kind == token.T_KEYWORD) and
                (tokens[pos + 1].kind == token.T_IDENT or
                 tokens[pos + 1].kind == token.T_KEYWORD) and
                tokens[pos].str == "implicit" and
                tokens[pos + 1].str == "ref")
        }
        if typeref_expr == none and pos <= max_len and
                (tokens[pos].kind == token.T_IDENT or
                tokens[pos].kind == token.T_KEYWORD) and
                tokens[pos].str != "multi" and
                not is_implicit_ref(tokens, pos, max_len) and
                ((is_moose64 and
                  builtin_moose64_types.has(tokens[pos].str)) or
                 (not is_moose64 and
                  builtin_horse64_types.has(tokens[pos].str))) {
            typeref_expr = new TypeRefExpr()
            typeref_expr.name = tokens[pos].str
            typeref_expr.line = token.get_line(tokens, pos)
            typeref_expr.col = token.get_col(tokens, pos)
            pos += 1
            typeref_token_len =
                start_token_len + (pos - startpos)
        }
        if typeref_expr == none and pos <= max_len and
                (tokens[pos].kind == token.T_IDENT or
                tokens[pos].kind == token.T_KEYWORD) and
                tokens[pos].str == "multi" {
            typeref_expr = new MultiTypeRefExpr()
            typeref_expr.name = tokens[pos].str
            typeref_expr.line = token.get_line(tokens, pos)
            typeref_expr.col = token.get_col(tokens, pos)
            pos += 1
            if pos > max_len or
                    tokens[pos].kind != token.T_ENCLOSE or
                    tokens[pos].str != "(" {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected '(' "
                    "to specify types for 'multi' found "
                    "in line " +
                    typeref_expr.line.as_str() +
                    ", column " +
                    typeref_expr.col.as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                var expr_len = start_token_len + (pos - startpos)
                if debug {
                    print(program_name + ": debug: "
                        "_parse_typeref_notlater(): " +
                        "Bailing with invalid expr.")
                }
                return new ast_expr.InvalidExpr(expr_len)
            }
            var inner_ast_typerefs_result = parse_multi_args(
                tokens, pos,
                project_file=project_file,
                max_depth=max_depth,
                outer_startpos=startpos,
                msgs=msgs, max_len=max_len,
                is_moose64=is_moose64, debug=debug)
            var inner_ast_typerefs =
                inner_ast_typerefs_result[2]
            pos = inner_ast_typerefs_result[1]
            var closed_correctly =
                inner_ast_typerefs_result[3]

            typeref_expr.sub_type_refs = inner_ast_typerefs
            typeref_token_len =
                start_token_len + (pos - startpos)
            typeref_expr.token_len = typeref_token_len
            for inner_typeref in typeref_expr.sub_type_refs {
                if inner_typeref.damaged {
                    typeref_expr.damaged = yes
                }
            }
            if not closed_correctly {
                typeref_expr.damaged = yes
                if debug {
                    print(program_name + ": debug: "
                        "_parse_typeref_notlater(): " +
                        "Bailing with incomplete expr.")
                }
                return typeref_expr
            }
        }
        if typeref_expr == none and pos <= max_len and
                tokens[pos].kind == token.T_IDENT and
                not is_implicit_ref(tokens, pos, max_len) and
                ((is_moose64 and
                  not builtin_moose64_type_modifiers.has(
                      tokens[pos].str)) or
                 (not is_moose64 and
                  not builtin_horse64_type_modifiers.has(
                      tokens[pos].str))) {
            typeref_expr = new TypeRefExpr()
            typeref_expr.name = tokens[pos].str
            typeref_expr.line = token.get_line(tokens, pos)
            typeref_expr.col = token.get_col(tokens, pos)
            pos += 1
            typeref_token_len =
                start_token_len + (pos - startpos)
            while pos + 1 <= max_len and
                    tokens[pos].kind == token.T_DOT and
                    tokens[pos + 1].kind == token.T_IDENT {
                if typeref_expr.type_path == none {
                    typeref_expr.type_path = []
                }
                typeref_expr.type_path.add(typeref_expr.name)
                typeref_expr.name = tokens[pos + 1].str
                typeref_token_len += 2
                pos += 2
            }
        }
        var had_mods = no
        while pos <= max_len and
                (tokens[pos].kind == token.T_IDENT or
                tokens[pos].kind == token.T_KEYWORD) and
                (is_implicit_ref(tokens, pos, max_len) or
                 (is_moose64 and
                  builtin_moose64_type_modifiers.has(
                      tokens[pos].str
                  )) or
                 (not is_moose64 and
                  builtin_horse64_type_modifiers.has(
                      tokens[pos].str
                  ))) {
            had_mods = yes
            var modifier_name = tokens[pos].str
            if modifier_name == "implicit" and
                    is_implicit_ref(tokens, pos, max_len) {
                modifier_name = "implicit ref"
                pos += 2
            } else {
                pos += 1
            }
            var modifier = new TypeRefMod(modifier_name)
            mods.add(modifier)
            typeref_token_len = start_token_len + (pos - startpos)
            if {"array", "c_array"}.has(modifier_name) and
                    is_moose64 {
                while pos + 2 <= max_len and
                        tokens[pos].kind == token.T_ENCLOSE and
                        tokens[pos].str == '[' and
                        tokens[pos + 2].kind == token.T_ENCLOSE and
                        tokens[pos + 2].str == ']' {
                    if tokens[pos + 1].kind == token.T_IDENT {
                        var prop = new TypeRefModProp_Range()
                        prop.range_value_label =
                            tokens[pos + 1].str
                        modifier.props.add(prop)
                    } elseif {token.T_NUM, token.T_BIGNUM}.has(
                            tokens[pos + 1].kind
                            ) {
                        var prop = new TypeRefModProp_Range()
                        prop.range_value_num =
                            tokens[pos + 1].str.to_num()
                        modifier.props.add(prop)
                    } else {
                        msgs.add(new msg.FileMsg(
                            "Unexpected '[' followed by " +
                                token.describe_token_at(
                                    tokens, pos + 1) + " "
                            ", expected valid range expression "
                            "for array modifier.",
                            source_file=project_file,
                            line=token.get_line(tokens, pos),
                            col=token.get_col(tokens, pos),
                        ))
                        typeref_damaged = yes
                        typeref_expr.token_len = typeref_token_len
                        assert(typeref_expr.token_len != none)
                        return typeref_expr
                    }
                    pos += 3
                    typeref_token_len =
                        start_token_len + (pos - startpos)
                }
            }
        }
        if not had_mods and (
                pos <= iterationstartpos or
                (pos > max_len or
                 tokens[pos].kind != token.T_ENCLOSE or
                 tokens[pos].str != "(")) {
            break
        }
    }
    if typeref_expr == none or
            typeref_token_len <= start_token_len {
        if debug {
            print(program_name + ": debug: "
                "_parse_typeref_notlater(): " +
                "Bailing with no expr.")
        }
        return none
    }
    assert(typeref_expr != none)
    assert(typeref_token_len > 0)
    typeref_expr.damaged = typeref_damaged
    typeref_expr.modifiers = mods
    typeref_expr.token_len = typeref_token_len
    assert(typeref_expr.token_len != none)
    if debug {
        print(program_name + ": debug: "
            "_parse_typeref_notlater(): " +
            "Result: " +
                typeref_expr.as_str() + " "
            "(typeref_expr.is_user_type()=" +
                typeref_expr.is_user_type().as_str() + ", "
            "typeref.is_func_ref=" +
                typeref_expr.is_func_ref.as_str() + ", "
            "typeref.is_multi_type=" +
                typeref_expr.is_multi_type.as_str() + ", "
            "typeref.is_list_arg=" +
                typeref_expr.is_list_arg.as_str() + "")
    }

    return typeref_expr
}

func parse_typeref(
        tokens, pos, msgs, extend_typeref_expr=none,
        project_file=none, max_len=none, is_moose64=no,
        debug=no
        ) {
    if max_len == none {
        max_len = tokens.len
    }
    if extend_typeref_expr != none {
        assert(extend_typeref_expr.token_len != none and
            extend_typeref_expr.token_len > 0)
    }
    var expr = _parse_typeref_notlater(
        tokens, pos, msgs,
        extend_typeref_expr=extend_typeref_expr,
        project_file=project_file,
        max_len=max_len, is_moose64=is_moose64,
        debug=debug
    )
    return later expr
}

