# @module compiler.project
# Copyright (c) 2020-2023, ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import confparse from core.horse64.org
import io from core.horse64.org
import net.fetch from core.horse64.org
import path from core.horse64.org
import text from core.horse64.org
import uri from core.horse64.org

import compiler.ast as ast
import compiler.comment.command as command_comment
import compiler.token as token

var _known_readable_files = []

type Project {
    var base_dir_uri = none

    var allow_disk_access = yes

    var allow_vfs_access = yes

    var debug_modules = yes
}

type ModuleInfo {
    var module_name

    var rel_path

    var package_name

    var package_dir_uri
}

func ModuleInfo.as_json_obj(project=none, project_file=none) {
    var result = {
        "module_name" -> self.module_name,
        "rel_path" -> self.rel_path,
        "package_name" -> self.package_name,
        "package_dir" -> self.package_dir_uri,
    }
    if project != none and project.base_dir_uri != none {
        result["base_dir_uri"] = project.base_dir_uri
    }
    if project_file != none and project_file.imports != none {
        result["imports"] = []
        for importst in project_file.imports {
            assert(importst != none)
            result["imports"].add({
                "module_name" -> importst.module_path.join("."),
                "named_as" -> if importst.renamed_as != none
                    (importst.renamed_as) else (importst.module_path[1]),
                "package_name" -> if importst.library_name != none
                    (importst.library_name) else (self.package_name),
            })
        }
    }
    return result
}

func ModuleInfo.as_terminal_str(project=none, project_file=none) {
    var data = self.as_json_obj(
        project=project, project_file=project_file)
    var t = ""
    var title = "Module: " + self.module_name
    t += title + "\n" + "-".rep(title.len) + "\n\n"
    t += "Relative path: " + self.rel_path + "\n"
    t += "Package name: " + self.package_name.as_str() + "\n"
    t += "Package directory URI: " + self.package_dir_uri + "\n"
    if data.has("base_dir_uri") {
        t += "Project directory URI: " + data["base_dir_uri"] + "\n"
    }
    if data.has("imports") {
        t += "Imports:\n"
        for importst in data["imports"] {
            t += "  -> import " + importst["module_name"] +
                " as " + importst["named_as"] +
                " from " + importst["package_name"] + "\n"
        }
        if data["imports"].len == 0 {
            t += "   (none)\n"
        }
    }

    return t
}

func check_is_project_dir_check_files(dir_uri) {
    var test_files = [
        ".git", "horp.conf",
    ]
    var next_file = test_files.pop()
    var can_read = net.fetch.try_readable(uri.add_part(dir_uri, "/" + next_file))
    later:

    await can_read
    if can_read {
        return yes
    }
    if test_files.len == 0 {
        return no
    }
    next_file = test_files.pop()
    can_read = net.fetch.try_readable(
        uri.add_part(dir_uri, "/" + next_file)
    ) later repeat
}

func check_is_project_dir(dir_uri) {
    var files_say_yes = check_is_project_dir_check_files(
        dir_uri
    ) later:

    await files_say_yes
    if files_say_yes {
        return yes
    }
    if not {"file", "vfs"}.has(uri.get_protocol(dir_uri))  {
        # Checking dirs remotely not implemented, so we give up.
        return no
    }

    var dir_exists = io.exists(
        uri.add_part(dir_uri, "/horse_modules")
    ) later:

    await dir_exists
    return dir_exists
}

func find_project_base(file_uri) {
    file_uri = uri.normalize(file_uri)
    var dir_uri = uri.dirname(file_uri)
    var can_be_project = check_is_project_dir(
        dir_uri
    ) later:

    await can_be_project
    if can_be_project {
        return uri.normalize(
            dir_uri, abs_disk_paths=yes
        )
    }
    var new_dir_uri = uri.traverse_up(dir_uri)
    if new_dir_uri == dir_uri {
        return none
    }
    dir_uri = new_dir_uri
    can_be_project = check_is_project_dir(
        dir_uri
    ) later repeat
}

func Project.guess_base_from_file_uri(source_uri) {
    var base_dir = find_project_base(source_uri)
    later:

    await base_dir
    if base_dir == none {
        throw new ValueError("Failed to locate project "
            "directory for file: " + source_uri)
    }
    self.base_dir_uri = base_dir
}

func Project.get_rel_dir_of_file(file_uri) {
    file_uri = uri.normalize(file_uri)
    if self.base_dir_uri == none {
        throw new ValueError("Project has no base directory.")
    }
    if uri.get_protocol(self.base_dir_uri) !=
            uri.get_protocol(file_uri) {
        return none
    }
    var base_norm = uri.normalize(self.base_dir_uri, abs_disk_paths=yes)
    var furi_norm = uri.normalize(file_uri, abs_disk_paths=yes)
    if not furi_norm.starts(base_norm) {
        return none
    }

    var rel_dir = uri.unencode_path(furi_norm.sub(
        base_norm.len + 1
    ))
    while rel_dir.starts("/") {
        rel_dir = rel_dir.sub(2)
    }
    while rel_dir.starts("./") {
        rel_dir = rel_dir.sub(3)
    }
    if rel_dir == "." or rel_dir == "/" {
        rel_dir = ""
    }
    return rel_dir.replace("/", path.sep)
}

func Project.get_modinfo_for_file(file_uri) {
    var rel_path = self.get_rel_dir_of_file(
        file_uri
    )
    if rel_path == none {
        throw new ValueError("Failed to get relative path "
            "for file.")
    }
    if not rel_path.lower().endswith(".h64") {
        throw new ValueError("Code files must have "
            ".h64 file extension.")
    }
    rel_path = rel_path.sub(1, rel_path.len - ".h64".len)
    var code_a = text.code('a')
    var code_z = text.code('z')
    var code_cap_a = text.code('A')
    var code_cap_z = text.code('Z')
    var code_0 = text.code('0')
    var code_9 = text.code('0')
    var pos = 1
    while pos <= rel_path.len {
        if {"_", "/"}.has(rel_path[pos]) {
            pos += 1
            continue
        }
        var cp = text.code(rel_path[pos])
        if (cp < code_a or cp > code_z) and
                (cp < code_cap_a or cp > code_cap_z) and
                (cp < code_0 or cp > code_9) and
                cp <= 127 {
            throw new ValueError("File is inside dir "
                "with invalid module name with forbidden "
                "character: " +
                token.describe_char_at(rel_path, pos,
                    maybe_cutoff_glyph=no
                ))
        }
        pos += 1
    }
    var package_name = none
    var package_dir_uri = self.base_dir_uri
    if rel_path.startswith("horse_modules" + path.sep) or
            rel_path == "horse_modules" {
        rel_path = rel_path.sub(
            ("horse_modules" + path.sep).len + 1)
        while rel_path.starts(path.sep) {
            rel_path = rel_path.sub(2)
        }
        var pos = rel_path.find(path.sep)
        if pos == none {
            return none
        } else {
            assert(pos > 1)
            var component = rel_path.sub(1, pos - 1)
            rel_path = rel_path.sub(pos + 1)
            package_name = component
            package_dir_uri = uri.add_part(
                package_dir_uri, "/horse_modules/" + component
            )
        }
    } else {
        var source_dirs = ["source", "src"]
        for source_dir in source_dirs {
            if rel_path.lower().starts(source_dir + path.sep) or
                    rel_path.lower() == source_dir {
                rel_path = rel_path.sub(
                    (source_dir + path.sep).len + 1)
                break
            }
        }
        if rel_path == "" {
            return later none
        }
    }

    var modinfo = new ModuleInfo()
    modinfo.module_name = rel_path.replace(path.sep, ".")
    modinfo.package_dir_uri = package_dir_uri
    modinfo.rel_path = rel_path
    modinfo.package_name = package_name

    var horp_conf_uri = uri.add_part(package_dir_uri, "horp.conf")
    var conf_exists = check_file_existence(
        horp_conf_uri, project=self
    ) later:

    await conf_exists
    if not conf_exists {
        return modinfo
    }
    var conf_contents = confparse.parse_from_uri(
        horp_conf_uri, error_on_mistakes=no
    ) later:

    await conf_contents
    if conf_contents.has("package") and
            conf_contents["package"].has("name") and
            typename(conf_contents["package"]["name"]) == "str" {
        modinfo.package_name = conf_contents["package"]["name"]
    }

    return later modinfo
}

type ProjectFile {
    ## @types (str, none)
    var source_uri protect = none

    var wants_debug_modules = no

    ## @types (Project, none)
    var project protect = none

    var modinfo = none

    var is_entrypoint = no
    var _is_single_file = none

    var imports = none
}

func ProjectFile.init(
        source_uri=none, is_entrypoint=no,
        force_single_file=no, project=none,
        request_debug_modules=no) {
    self.wants_debug_modules = request_debug_modules
    if source_uri != none {
        source_uri = uri.normalize(source_uri)
    }
    self.source_uri = source_uri
    self.is_entrypoint = is_entrypoint
    self.project = project
    if force_single_file {
        self._is_single_file = yes
    } elseif is_entrypoint {
        self._is_single_file = no
    }
}

func ProjectFile.open {
    if self.source_uri == none {
        throw new ValueError("project file has no source")
    }
    var result = net.fetch.open(
        self.source_uri, allow_vfs=yes, allow_disk=yes
    ) later:

    await result
    return result
}

func ProjectFile.set_imports_from_ast_result(result) {
    self.imports = []
    for name in result.global_scope.name_to_stmt_map {
        var entry = result.global_scope.name_to_stmt_map[name]
        if typename(entry) != "list" or
                entry[1].kind != ast.N_STMT_IMPORT {
            continue
        }
        for importst in entry {
            assert(importst != none)
            self.imports.add(importst.copy())
        }
    }
}

func ProjectFile.parse_for_imports_if_needed {
    if self.imports != none {
        return later
    }
    var force_single_file = (
        if self._is_single_file == yes (yes) else (no)
    )
    var allow_disk_access =
        if self.project != none (self.project.allow_disk_access)
            else (no)
    var allow_vfs_access =
        if self.project != none (self.project.allow_vfs_access)
            else (no)
    var astresult = ast.parse_to_ast_from_uri(
        self.source_uri, project_file=self,
        is_entrypoint=self.is_entrypoint,
        force_single_file=force_single_file,
        allow_disk_access=allow_disk_access,
        allow_vfs_access=allow_vfs_access
    ) later:

    await astresult
    self.set_imports_from_ast_result(astresult)
}

func ProjectFile.check_is_single_file {
    if self._is_single_file != none {
        return self._is_single_file == yes
    }
    if self.source_uri == none {
        self._is_single_file = yes
        return yes
    }
    var contents = none
    with self.open() later as f {
        contents = f.read()
    }
    var opts = command_comment.get_build_options_from_str(
        contents
    )
    self._is_single_file = opts.has("--single-file")
    return self._is_single_file
}

func check_file_existence_diskpath(
        disk_path, project=none, is_known_vfs=no
        ) {
    var allow_vfs = yes
    var allow_disk = yes
    if project != none {
        allow_vfs = project.allow_vfs_access
        allow_disk = project.allow_disk_access
    }
    if is_known_vfs {
        allow_disk = no
        if not allow_vfs {
            return no
        }
    }

    var result = io.exists(
        disk_path, allow_vfs=allow_vfs, allow_disk=allow_disk
    ) later:
    await result
    return result
}

func check_file_existence(file_uri, project=none) {
    var allow_vfs = yes
    var allow_disk = yes
    if project != none {
        allow_vfs = project.allow_vfs_access
        allow_disk = project.allow_disk_access
    }

    file_uri = uri.normalize(file_uri)
    if _known_readable_files.has(file_uri) {
        return _known_readable_files[file_uri]
    }
    var protocol = uri.get_protocol(file_uri).lower()
    var result
    if protocol == "file" or protocol == "vfs" {
        var upath = uri.to_file_or_vfs_path(file_uri)
        var result = check_file_existence_diskpath(
            upath, project=project, is_known_vfs=no
        ) later:
        await rsult
        return result
    }
    var result = net.fetch.test_readable(uri) later:

    await result
    _known_readable_files[file_uri] = result
    return result
}

func ProjectFile.ensure_project_base_dir {
    if self.source_uri == none or self.project.base_dir_uri != none {
        return later none
    }
    self.project.guess_base_from_file_uri(self.source_uri) later:
    if self.wants_debug_modules {
        print("compiler.project: ensure_project_base_dir() " +
            "detected project dir: " +
            self.project.base_dir_uri.as_str() +
            " (from file: " + self.source_uri.as_str() + ")")
    }
}

func ProjectFile.ensure_project {
    if self.project == none {
        self.project = new Project()
        if self.wants_debug_modules {
            self.project.debug_modules = yes
        }
    }
    self.ensure_project_base_dir() later:

    if self.source_uri == none or self.modinfo != none {
        return later none
    }
    var modinfo = self.project.get_modinfo_for_file(
        self.source_uri
    ) later:

    await modinfo
    self.modinfo = modinfo
    if self.wants_debug_modules {
        print("compiler.project: ensure_project() " +
            "detected module info: module_name='" +
            self.modinfo.module_name + "', package_name=" +
            if self.modinfo.package_name != none ("'" +
                self.modinfo.package_name + "'") else ("none") +
            ", from file: " + self.source_uri.as_str())
    }
}

func ProjectFile.get_relative_imports_to_test(
        full_original_import
        ) {
    self.ensure_project() later:
    return none
}

func ProjectFile.resolve_import(name_of_type, path_of_type) {
    if self._is_single_file == none {
        throw new RuntimeError("Must call "
            "check_is_single_file() first.")
    }
    self.ensure_project() later:
    return none
}

