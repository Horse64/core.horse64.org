# @module compiler.project
# Copyright (c) 2020-2023, ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import confparse from core.horse64.org
import io from core.horse64.org
import net.fetch from core.horse64.org
import path from core.horse64.org
import text from core.horse64.org
import uri from core.horse64.org

import compiler.ast as ast
import compiler.comment.command as command_comment
import compiler.ast.import_stmt as import_stmt
import compiler.token as token

var _known_readable_files = []

type InvalidModuleNameError base ValueError {
}

type Project {
    var tried_loading_package_name = no

    var base_dir_uri = none

    var package_name = none

    var allow_disk_access = yes

    var allow_vfs_access = yes

    var debug_modules = yes

    var modules_dir_uri = none

    var tried_find_modules_dir = no

    var module_to_file_map = {->}
}

type ModuleInfo {
    var module_name

    var rel_path

    var package_name

    var package_dir_uri
}

func ModuleInfo.as_str {
    return "<ModuleInfo for module '" +
        self.module_name + "' with rel_path '" +
        self.rel_path + "'>"
}

func ModuleInfo.as_json_obj(project=none, project_file=none) {
    var result = {
        "module_name" -> self.module_name,
        "rel_path" -> self.rel_path,
        "package_name" -> self.package_name,
        "package_dir" -> self.package_dir_uri,
        "horse_modules_dir" -> none,
        "base_dir_uri" -> none,
    }
    if project != none and project.base_dir_uri != none {
        result["base_dir_uri"] = project.base_dir_uri
    }
    if project != none and project.modules_dir_uri != none {
        result["horse_modules_dir"] = project.modules_dir_uri
    }
    if project_file != none and project_file.imports != none {
        result["imports"] = []
        for importst in project_file.imports {
            assert(importst != none)
            var entry = {
                "module_name" -> importst.module_path.join("."),
                "named_as" -> if importst.renamed_as != none
                    (importst.renamed_as) else (importst.module_path[1]),
                "package_name" -> if importst.package_name != none
                    (importst.package_name) else (self.package_name),
            }
            if importst.project_file != none and
                    importst.project_file.source_uri != none {
                entry["file_uri"] = importst.project_file.source_uri
            }
            result["imports"].add(entry)
        }
    }
    return result
}

func ModuleInfo.as_terminal_str(project=none, project_file=none) {
    var data = self.as_json_obj(
        project=project, project_file=project_file)
    var t = ""
    var title = "Module: " + self.module_name
    t += title + "\n" + "-".rep(title.len) + "\n\n"
    t += "Relative path: " + self.rel_path + "\n"
    t += "Package name: " + self.package_name.as_str() + "\n"
    t += "Package directory URI: " + self.package_dir_uri + "\n"
    if data["base_dir_uri"] != none {
        t += "Project directory URI: " + data["base_dir_uri"] + "\n"
    }
    if data["horse_modules_dir"] != none {
        t += "Horse modules directory URI: " +
            data["horse_modules_dir"] + "\n"
    }
    if data.has("imports") {
        t += "Imports:\n"
        for importst in data["imports"] {
            t += "  -> import " + importst["module_name"] +
                " as " + importst["named_as"] +
                " from " + importst["package_name"] + "\n"
            if importst.has("file_uri") {
                t += "      -> " + importst["file_uri"] + "\n"
            }
        }
        if data["imports"].len == 0 {
            t += "   (none)\n"
        }
    }

    return t
}

func check_is_project_dir_check_files(dir_uri) {
    var test_files = [
        ".git", "horp.conf",
    ]
    var next_file = test_files.pop()
    var can_read = net.fetch.try_readable(uri.add_part(dir_uri, "/" + next_file))
    later:

    await can_read
    if can_read {
        return yes
    }
    if test_files.len == 0 {
        return no
    }
    next_file = test_files.pop()
    can_read = net.fetch.try_readable(
        uri.add_part(dir_uri, "/" + next_file)
    ) later repeat
}

func check_is_project_dir(dir_uri) {
    var files_say_yes = check_is_project_dir_check_files(
        dir_uri
    ) later:

    await files_say_yes
    if files_say_yes {
        return yes
    }
    if not {"file", "vfs"}.has(uri.get_protocol(dir_uri))  {
        # Checking dirs remotely not implemented, so we give up.
        return no
    }

    var dir_exists = io.exists(
        uri.add_part(dir_uri, "/horse_modules")
    ) later:

    await dir_exists
    return dir_exists
}

func find_project_base(file_uri) {
    file_uri = uri.normalize(file_uri)
    var dir_uri = uri.dirname(file_uri)
    var can_be_project = check_is_project_dir(
        dir_uri
    ) later:

    await can_be_project
    if can_be_project {
        return uri.normalize(
            dir_uri, abs_disk_paths=yes
        )
    }
    var new_dir_uri = uri.traverse_up(dir_uri)
    if new_dir_uri == dir_uri {
        return none
    }
    dir_uri = new_dir_uri
    can_be_project = check_is_project_dir(
        dir_uri
    ) later repeat
}

func Project.guess_base_from_file_uri(source_uri) {
    self.tried_find_modules_dir = yes
    var base_dir_uri = find_project_base(source_uri)
    later:

    await base_dir_uri
    if base_dir_uri == none {
        throw new ValueError("Failed to locate project "
            "directory for file: " + source_uri)
    }
    self.base_dir_uri = base_dir_uri
    self.modules_dir_uri = uri.add_part(
        base_dir_uri, "horse_modules"
    )
}

func Project.get_rel_dir_of_file(file_uri) {
    file_uri = uri.normalize(file_uri)
    if self.base_dir_uri == none {
        throw new ValueError("Project has no base directory.")
    }
    if uri.get_protocol(self.base_dir_uri) !=
            uri.get_protocol(file_uri) {
        return none
    }
    var base_norm = uri.normalize(self.base_dir_uri, abs_disk_paths=yes)
    var furi_norm = uri.normalize(file_uri, abs_disk_paths=yes)
    if not furi_norm.starts(base_norm) {
        return none
    }

    var rel_dir = uri.unencode_path(furi_norm.sub(
        base_norm.len + 1
    ))
    while rel_dir.starts("/") {
        rel_dir = rel_dir.sub(2)
    }
    while rel_dir.starts("./") {
        rel_dir = rel_dir.sub(3)
    }
    if rel_dir == "." or rel_dir == "/" {
        rel_dir = ""
    }
    return rel_dir.replace("/", path.sep)
}

const valid_source_nesting_dirs = {
    "source", "src"
}

func check_valid_rel_module_path(modpath, msgs=none,
        orig_file_uri=none,
        is_import=yes, import_line=none, import_col=none
        ) {
    if modpath.ends(".h64") {
        modpath = modpath.sub(1, modpath.len - ".h64".len)
    }
    var code_a = text.code('a')
    var code_z = text.code('z')
    var code_cap_a = text.code('A')
    var code_cap_z = text.code('Z')
    var code_0 = text.code('0')
    var code_9 = text.code('0')
    var pos = 1
    while pos <= modpath.len {
        if {"_", path.sep}.has(modpath[pos]) {
            pos += 1
            continue
        }
        var cp = text.code(modpath[pos])
        if (cp < code_a or cp > code_z) and
                (cp < code_cap_a or cp > code_cap_z) and
                (cp < code_0 or cp > code_9) and
                cp <= 127 {
            if msgs != none {
                var fake_source_file = new ProjectFile(
                    source_uri=orig_file_uri)
                if is_import {
                    msgs.add(new msg.FileMsg(
                        "Failed to process import due to invalid "
                        "folder name in path.",
                        source_file=fake_source_file,
                        line=import_line, col=import_col,
                    ))
                } else {
                    msgs.add(new msg.FileMsg(
                        "Failed to load file due to invalid "
                        "folder name in path.",
                        source_file=fake_source_file
                    ))
                }
            } else {
                throw new InvalidModuleNameError("File is inside dir "
                    "with invalid module name with forbidden "
                    "character: " +
                    token.describe_char_at(modpath, pos,
                        maybe_cutoff_glyph=no
                ))
            }
            return no
        }
        pos += 1
    }
    return yes
}

func Project.get_modinfo_for_file(file_uri) {
    var rel_path = self.get_rel_dir_of_file(
        file_uri
    )
    if rel_path == none {
        throw new ValueError("Failed to get relative path "
            "for file.")
    }
    if not rel_path.lower().endswith(".h64") {
        throw new InvalidModuleNameError("Code files must have "
            ".h64 file extension.")
    }
    var no_ext_rel_path = rel_path.sub(1, rel_path.len - ".h64".len)
    if not check_valid_rel_module_path(no_ext_rel_path,
            orig_file_uri=file_uri, is_import=no) {
        return none
    }
    var package_name = none
    var package_dir_uri = self.base_dir_uri
    var is_external_package = no
    var module_name = none
    if rel_path.starts("horse_modules" + path.sep) or
            rel_path == "horse_modules" {
        is_external_package = yes
        rel_path = rel_path.sub(
            ("horse_modules" + path.sep).len + 1)
        while rel_path.starts(path.sep) {
            rel_path = rel_path.sub(2)
        }
        var pos = rel_path.find(path.sep)
        if pos == none {
            return none
        } else {
            assert(pos > 1)
            var component = rel_path.sub(1, pos - 1)
            rel_path = rel_path.sub(pos + 1)
            package_name = component
            package_dir_uri = uri.add_part(
                package_dir_uri, "/horse_modules/" + component
            )
        }
        no_ext_rel_path = rel_path.sub(1, rel_path.len - ".h64".len)
    }
    module_name = no_ext_rel_path.replace(path.sep, ".")
    if module_name.split(".").has("horse_modules") {
        throw new InvalidModuleNameError("File is inside dir "
            "with invalid reserved name 'horse_modules', "
            "while not in the actual packages directory.")
    }
    for source_dir in valid_source_nesting_dirs {
        if module_name.lower().starts(source_dir + ".") {
            module_name = module_name.sub(
                (source_dir + ".").len + 1)
            break
        } elseif module_name.lower() == source_dir.lower() {
            return later none
        }
    }
    if module_name.has(".") {
        var last_component = module_name.sub(module_name.rfind(".") + 1)
        if module_name == last_component + "." + last_component or
                module_name.ends("." + last_component +
                    "." + last_component) {
            module_name = module_name.sub(1, module_name.rfind(".") - 1)
        }
    }

    var modinfo = new ModuleInfo()
    modinfo.module_name = module_name
    modinfo.package_dir_uri = package_dir_uri
    modinfo.rel_path = rel_path
    modinfo.package_name = package_name
    modinfo.is_external_package = is_external_package

    var horp_conf_uri = uri.add_part(package_dir_uri, "horp.conf")
    var conf_exists = check_file_existence(
        horp_conf_uri, project=self
    ) later:

    await conf_exists
    if not conf_exists {
        return modinfo
    }
    var conf_contents = confparse.parse_from_uri(
        horp_conf_uri, error_on_mistakes=no
    ) later:

    await conf_contents
    if conf_contents.has("package") and
            conf_contents["package"].has("name") and
            typename(conf_contents["package"]["name"]) == "str" {
        modinfo.package_name = conf_contents["package"]["name"]
    }
    if self.package_name == none and not is_external_package {
        self.package_name = modinfo.package_name
    }
    if self.package_name != none or
            self.tried_loading_package_name {
        return later modinfo
    }
    self.ensure_package_name() later:
    return later modinfo
}

func Project.ensure_package_name {
    if self.package_name != none or
            self.tried_loading_package_name {
        return later
    }
    self.tried_loading_package_name = yes
    var conf_contents = confparse.parse_from_uri(
        horp_conf_uri, error_on_mistakes=no
    ) later:

    await conf_contents
    if conf_contents.has("package") and
            conf_contents["package"].has("name") and
            typename(conf_contents["package"]["name"]) == "str" {
        self.package_name = conf_contents["package"]["name"]
    }
}

func try_workspace_modules_dir_for_single_file(file_uri) {
    var base_dir_uri = find_project_base(file_uri)
    later:

    await base_dir_uri
    if base_dir_uri == none {
        return later none
    }
    var test_path = uri.add_part(base_dir_uri, "horse_modules")
    if {"file", "vfs"}.has(uri.get_protocol(test_path).lower()) {
        return none
    }
    var is_vfs = (uri.get_protocol(test_path).lower() == "vfs")
    var result = io.exists(uri.to_file_or_vfs_path(test_path),
        allow_vfs=is_vfs, allow_disk=(not is_vfs))
    later:

    await result
    if result {
        if not is_vfs {
            return later uri.from_disk_path(test_path)
        } else {
            return later uri.from_vfs_path(test_path)
        }
    }
    return later none
}

func guess_horse_modules_for_single_file(file_uri) {
    var modules_dir = try_workspace_modules_dir_for_single_file(
        file_uri
    ) later:

    await modules_dir
    if modules_dir != none {
        return modules_dir
    }

    # Otherwise, try working directory:
    var test_path = path.join(io.working_dir(), "horse_modules")
    var result = io.exists(test_path, allow_vfs=no) later:

    await result
    if result {
        return later uri.from_disk_path(test_path)
    }
    return later none
}

type ProjectFile {
    ## @types (str, none)
    var source_uri protect = none

    var wants_debug_modules = no

    ## @types (Project, none)
    var project protect = none

    var modinfo = none

    var is_entrypoint = no
    var is_external_package = no
    var _is_single_file = none

    var imports = none
}

func ProjectFile.init(
        source_uri=none, is_entrypoint=no,
        force_single_file=no, project=none,
        request_debug_modules=no) {
    self.wants_debug_modules = request_debug_modules
    if source_uri != none {
        source_uri = uri.normalize(source_uri)
    }
    self.source_uri = source_uri
    self.is_entrypoint = is_entrypoint
    self.project = project
    if force_single_file {
        self._is_single_file = yes
    } elseif is_entrypoint {
        self._is_single_file = no
    }
}

func ProjectFile.open {
    if self.source_uri == none {
        throw new ValueError("project file has no source")
    }
    var result = net.fetch.open(
        self.source_uri, allow_vfs=yes, allow_disk=yes
    ) later:

    await result
    return result
}

func ProjectFile.set_imports_from_ast_result(result) {
    self.imports = []
    for name in result.global_scope.name_to_stmt_map {
        var entry = result.global_scope.name_to_stmt_map[name]
        if typename(entry) != "list" or
                entry[1].kind != ast.N_STMT_IMPORT {
            continue
        }
        for importst in entry {
            assert(importst != none)
            self.imports.add(importst.copy())
        }
    }
}

func ProjectFile.parse_for_imports_if_needed {
    if self.imports != none {
        return later
    }
    var force_single_file = (
        if self._is_single_file == yes (yes) else (no)
    )
    var allow_disk_access =
        if self.project != none (self.project.allow_disk_access)
            else (no)
    var allow_vfs_access =
        if self.project != none (self.project.allow_vfs_access)
            else (no)
    self.imports = []
    var astresult = ast.parse_to_ast_from_uri(
        self.source_uri, project_file=self,
        is_entrypoint=self.is_entrypoint,
        force_single_file=force_single_file,
        allow_disk_access=allow_disk_access,
        allow_vfs_access=allow_vfs_access
    ) later:

    await astresult
    self.set_imports_from_ast_result(astresult)
}

func ProjectFile.check_is_single_file {
    if self._is_single_file != none {
        return later self._is_single_file == yes
    }
    sekf.ensure_known_single_file_status() later:
    return later self._is_single_file == yes
}

func ProjectFile.ensure_known_single_file_status {
    if self.source_uri == none {
        return later
    }

    var contents = none
    with self.open() later as f {
        contents = f.read() later:
        await contents

        var opts = command_comment.get_build_options_from_str(
            contents
        )
        self._is_single_file = opts.has("--single-file")
    }
}

func check_file_existence_diskpath(
        disk_path, project=none, is_known_vfs=no
        ) {
    var allow_vfs = yes
    var allow_disk = yes
    if project != none {
        allow_vfs = project.allow_vfs_access
        allow_disk = project.allow_disk_access
    }
    if is_known_vfs {
        allow_disk = no
        if not allow_vfs {
            return no
        }
    }

    var result = io.exists(
        disk_path, allow_vfs=allow_vfs, allow_disk=allow_disk
    ) later:
    await result
    return result
}

func check_file_existence(file_uri, project=none) {
    var allow_vfs = yes
    var allow_disk = yes
    if project != none {
        allow_vfs = project.allow_vfs_access
        allow_disk = project.allow_disk_access
    }

    file_uri = uri.normalize(file_uri)
    if _known_readable_files.has(file_uri) {
        return _known_readable_files[file_uri]
    }
    var protocol = uri.get_protocol(file_uri).lower()
    var result
    if protocol == "file" or protocol == "vfs" {
        var upath = uri.to_file_or_vfs_path(file_uri)
        var result = check_file_existence_diskpath(
            upath, project=project, is_known_vfs=no
        ) later:
        await rsult
        return result
    }
    var result = net.fetch.test_readable(uri) later:

    await result
    _known_readable_files[file_uri] = result
    return result
}

func ProjectFile.ensure_modules_dir {
    if self.tried_find_modules_dir {
        return later
    }
    self.ensure_known_single_file_status() later:
    if self._is_single_file != yes {
        return later
    }
    self.tried_find_modules_dir = yes
    var dir_uri = guess_horse_modules_for_single_file(self.source_uri)
    later:

    await dir_uri
    if dir_uri != none {
        self.project.modules_dir_uri = dir_uri
    }
}

func ProjectFile.ensure_project_base_dir {
    if self.source_uri == none or self.project.base_dir_uri != none {
        return later
    }
    self.ensure_known_single_file_status() later:
    assert(self._is_single_file != none or self.source_uri == none)
    if self._is_single_file == yes {
        return later
    }
    self.project.guess_base_from_file_uri(self.source_uri) later:
    if self.wants_debug_modules {
        print("compiler.project: ensure_project_base_dir() " +
            "detected project dir: " +
            self.project.base_dir_uri.as_str() +
            " (from file: " + self.source_uri.as_str() + ")")
    }
}

func ProjectFile.ensure_project {
    if self.project == none {
        self.project = new Project()
        if self.wants_debug_modules {
            self.project.debug_modules = yes
        }
    }
    self.ensure_project_base_dir() later:

    if self.source_uri == none or self.modinfo != none {
        return later none
    }
    var modinfo = self.project.get_modinfo_for_file(
        self.source_uri
    ) later:

    await modinfo
    self.project.module_to_file_map[modinfo.module_name + "@" +
        modinfo.package_name] = self
    self.is_external_package = modinfo.is_external_package
    self.modinfo = modinfo
    if self.wants_debug_modules {
        print("compiler.project: ensure_project() " +
            "detected module info: module_name='" +
            self.modinfo.module_name + "', package_name=" +
            if self.modinfo.package_name != none ("'" +
                self.modinfo.package_name + "'") else ("none") +
            ", from file: " + self.source_uri.as_str())
    }
}

func ProjectFile.get_relative_imports_to_test(
        full_original_import, msgs=none, external_package_name=none,
        import_line=none, import_col=none,
        ) {
    if external_package_name != none and (
            external_package_name.startswith(".") or
            external_package_name.endswith(".") or
            external_package_name.find("/") != none or
            external_package_name.find("\\") != none or
            external_package_name.find("..") != none) {
        if msgs != none {
            msgs.add(new msg.FileMsg(
                "Failed to process import due to invalid "
                "package name.",
                source_file=self,
                line=import_line, col=import_col,
            ))
        } else {
            throw new ValueError("Invalid external_package_name given.")
        }
    }
    if typename(full_original_import) != "list" {
        full_original_import = full_original_import.split(".")
    }
    if full_original_import.len == 0 or
            full_original_import[1].len == 0 or
            self.source_uri is none {
        return []
    }
    self.ensure_project() later:
    if self.modinfo == none or self.modinfo.rel_path == none {
        return []
    }
    var rel_path = self.modinfo.rel_path
    while rel_path.starts(path.sep) {
        rel_path = rel_path.sub(1)
    }
    while rel_path.ends(path.sep) {
        rel_path = rel_path.sub(1, rel_path.len - 1)
    }
    if rel_path == "" or not rel_path.ends(".h64") {
        return []
    }
    var package_dir_uri = self.project.modules_dir_uri
    var folder_path = path.dirname(path.normalize(rel_path))
    while folder_path.ends(path.sep) {
        folder_path = folder_path.sub(1, folder_path.len - 1)
    }
    var levels_up = 0
    if folder_path != "" {
        levels_up = folder_path.split(path.sep).len
    }
    var try_list = []
    if external_package_name != none {
        if package_dir_uri == none {
            return none
        }
        try_list += [
            "horse_modules" + path.sep + external_package_name +
                path.sep + full_original_import.join(path.sep) +
                path.sep + full_original_import[
                    full_original_import.len] + ".h64",
            "horse_modules" + path.sep + external_package_name +
                path.sep + full_original_import.join(path.sep) + ".h64"
        ]
        return try_list
    } else {
        try_list += [
            folder_path + path.sep + full_original_import.join(path.sep) +
                path.sep + full_original_import[
                    full_original_import.len] + ".h64",
            folder_path + path.sep +
                full_original_import.join(path.sep) + ".h64"
        ]
    }

    var i = levels_up
    while i > 0 {
        if i > 1 {
            assert(folder_path.find(path.sep) != none)
            folder_path = folder_path.sub(
                1, folder_path.rfind(path.sep) - 1
            )
            assert(folder_path.len > 0)
            try_list += [
                folder_path + path.sep + full_original_import.join(path.sep) +
                    path.sep + full_original_import[
                        full_original_import.len] + ".h64",
                folder_path + path.sep +
                    full_original_import.join(path.sep) + ".h64"
            ]
        } else {
            assert(folder_path.len > 0 and folder_path.find(path.sep) == none)
            var skip_because_source_folder = no
            for source_dir in valid_source_nesting_dirs {
                if source_dir.lower() == folder_path.lower() {
                    skip_because_source_folder = yes
                    break
                }
            }
            if not skip_because_source_folder {
                try_list += [
                    full_original_import.join(path.sep) +
                        path.sep + full_original_import[
                            full_original_import.len] + ".h64",
                    full_original_import.join(path.sep) + ".h64"
                ]
            }
        }
        i -= 1
    }
    return later try_list
}

extend import_stmt.ImportStmt {
    var resolve_attempted = no
    var project_file = none
}

func get_source_nesting_dir(project_folder_uri) {
    var protocol = uri.get_protocol(project_folder_uri).lower()
    if not {"vfs", "file"}.has(protocol) {
        throw new NotImplementedError("Probing directory "
            "structure for remote dependency not support.")
    }
    var base_path = uri.to_file_or_vfs_path(project_folder_uri)
    var try_list = valid_source_nesting_dirs.copy()
    var next_name = try_list.pop()
    var exists = io.exists(path.join(
        base_path, next_name)) later:

    await exists
    if exists {
        return later next_name
    }
    if try_list.len == 0 {
        return later none
    }
    next_name = try_list.pop()

    exists = io.exists(path.join(
        base_path, next_name)) later repeat
}

func ProjectFile.get_target_uri_for_import(
        import_rel_path, external_package_name=none
        ) {
    func get_uri_for_external(import_rel_path) {
        var source_nest_dir = get_source_nesting_dir(
            uri.add_part(
                self.project.modules_dir_uri,
                import_rel_path.split(path.sep)[2]
            )) later:

        await source_nest_dir
        assert(external_package_name != none)
        if source_nest_dir != none {
            import_rel_path = (
                import_rel_path.split(path.sep)[2] +
                "/" + source_nest_dir + "/" +
                import_rel_path.split(path.sep).sub(3).join("/")
            )
        }
        var new_uri = uri.add_part(
            self.project.modules_dir_uri,
            import_rel_path.replace(path.sep, "/")
        )
        return later uri.normalize(new_uri)
    }
    if import_rel_path.starts("horse_modules" + path.sep) {
        var result_uri = get_uri_for_external(import_rel_path) later:

        await result_uri
        return result_uri
    }
    if self.project.base_dir_uri == none {
        throw new RuntimeError("Internal error, "
            "somehow asked to find place of internal project "
            "file without project root.")
    }
    var new_uri = uri.add_part(
        self.project.base_dir_uri,
        import_rel_path.replace(path.sep, "/")
    )
    return later uri.normalize(new_uri)
}

type ProcessModuleFileResult {
    var project_file = none
    var neighbor_rel_path_list = []
    var neighbor_project_files = []
}

func add_neighbor_modules_to_result(
        result, file_uri, msgs=none,
        import_line=none, import_col=none,
        debug=no
        ) {
    var folder_uri = uri.dirname(file_uri)
    if not {"file", "vfs"}.has(uri.get_protocol(file_uri)) {
        if msgs != none {
            msgs.add(new msg.FileMsg(
                "Failed to process neighbor imports in "
                "folder " + uri.normalize(file_uri) + ", since "
                "folder listing isn't supported for this type "
                "of URI.",
                source_file=self,
                line=import_line, col=import_col,
            ))
        } else {
            throw new ValueError("Folder listing not supported for "
                "this type of import, can't process neighbors.")
        }
    }
    var is_vfs = (uri.get_protocol(file_uri) == "vfs")
    func process_neighbor_import(neighbor_file_name) {
        if not neighbor_file_name.endswith(".h64") {
            return later
        }
        var neighbor_uri = uri.add_part(folder_uri,
            neighbor_file_name)
        assert({"file", "vfs"}.has(
            uri.get_protocol(neighbor_uri).lower()
        ))
        var is_dir_result = io.is_dir(
            uri.to_file_or_vfs_path(neighbor_uri),
            allow_vfs=is_vfs, allow_disk=(not is_vfs)) later:

        await is_dir_result
        if not is_dir_result {
            return later
        }
        if not check_valid_rel_module_path(
                neighbor_file_name, msgs=msgs,
                orig_file_uri=file_uri, is_import=yes,
                import_line=import_line, import_col=import_col
                ) {
            return later
        }

        var neighbor_rel_path = result.project_file.modinfo.rel_path
        var neighbor_project_file = new ProjectFile(
            source_uri=neighbor_uri, is_entrypoint=no,
            force_single_file=no, project=result.project_file.project,
            request_debug_modules=debug)
        result.neighbor_rel_path_list.add(neighbor_rel_path)
        result.neighbor_project_files.add(neighbor_project_file)
    }
    var folder_disk_path = uri.to_file_or_vfs_path(folder_uri)
    var entries = io.list_dir(folder_disk_path,
        allow_vfs=is_vfs, allow_disk=(not is_vfs)) later:

    await entries
    if entries.len == 0 {
        return
    }
    var next_file = entries.pop()
    var _unused = process_neighbor_import(next_file) later:

    await _unused
    if entries.len == 0 {
        return
    }
    var next_file = entries.pop()
    _unused = process_neighbor_import(next_file) later repeat
}

func ProjectFile.process_first_working_module_file(
        try_list, external_package_name=none,
        msgs=none, import_line=none, import_col=none,
        debug=no
        ) {
    try_list = try_list.copy()
    try_list.reverse()
    if try_list.len == 0 {
        return none
    }
    func test_and_get_project_file(try_entry) {
        var file_uri = self.get_target_uri_for_import(
            try_entry, external_package_name=
                external_package_name) later:

        await file_uri
        if debug {
            print("compiler.project: process_first_working_module_file() "
                "testing import target location: " + file_uri)
        }
        var readable = net.fetch.try_readable(file_uri) later:

        await readable
        if readable {
            var mod_rel_path = try_entry
            var mod_name
            if external_package_name != none {
                assert(mod_rel_path.starts("horse_modules"))
                var split_path = mod_rel_path.split(path.sep)
                mod_name = split_path.sub(3).join(".")
            } else {
                mod_name = mod_rel_path.split(path.sep).join(".")
            }
            for src_dir in valid_source_nesting_dirs {
                if mod_name.lower().startswith(src_dir + ".") {
                    mod_name = mod_name.sub((src_dir + ".").len + 1)
                    break
                }
            }
            assert(mod_name.ends(".h64"))
            mod_name = mod_name.sub(1, mod_name.len - ".h64".len)
            var last_component = if mod_name.rfind(".") != none
                (mod_name.sub(mod_name.rfind(".") + 1)) else (mod_name)
            if mod_name == last_component + "." + last_component or
                    mod_name.ends("." + last_component +
                                  "." + last_component) {
                # Need to strip the last component:
                mod_name = mod_name.sub(1, mod_name.rfind(".") - 1)
            }

            var modinfo = new ModuleInfo()
            modinfo.module_name = mod_name
            modinfo.rel_path = mod_rel_path
            modinfo.package_name = external_package_name
            if modinfo.package_name == none {
                modinfo.package_name = self.project.package_name
            }
            var key = (modinfo.module_name + "@" +
                modinfo.package_name)
            var pfile = none
            if not self.project.module_to_file_map.has(key) {
                pfile = new ProjectFile(file_uri)
                pfile.project = self.project
                pfile.modinfo = modinfo
                self.project.module_to_file_map[key] = pfile
            } else {
                pfile = self.project.module_to_file_map[key]
            }
            assert(pfile.source_uri != none)

            var result = new ProcessModuleFileResult()
            result.project_file = pfile

            add_neighbor_modules_to_result(
                result, file_uri, msgs=msgs, import_line=import_line,
                import_col=import_col, debug=debug) later:

            return later result
        }
        return later none
    }
    var next_entry = try_list.pop()
    var process_result = test_and_get_project_file(next_entry) later:

    await process_result
    if process_result != none {
        return later process_result
    }
    if try_list.len == 0 {
        var result = new ProcessModuleFileResult()
        return later result
    }
    next_entry = try_list.pop()
    process_result = test_and_get_project_file(next_entry) later repeat
}

func ProjectFile.resolve_all_imports(msgs=none, debug=no) {
    if self.project == none {
        throw new RuntimeError("Must call "
            "ensure_project() first.")
    }
    if self._is_single_file == none {
        throw new RuntimeError("Must call "
            "ensure_known_single_file_status() first.")
    }
    self.parse_for_imports_if_needed() later:

    self.project.ensure_package_name() later:

    var imports_to_process = self.imports.copy()

    var file_rel_path = "<not on disk>"
    if self.source_uri != none {
        assert(self.modinfo != none)
        file_rel_path = self.modinfo.rel_path
        assert(file_rel_path != none)
    }

    func resolve_next_import_if_needed(msgs=none) {
        if imports_to_process.len == 0 {
            return no
        }
        var importst = imports_to_process.pop()
        if importst.resolve_attempted {
            return yes
        }
        importst.resolve_attempted = yes
        var external_name = importst.package_name
        if external_name == self.project.package_name {
            external_name = none
        }
        var try_list = self.get_relative_imports_to_test(
            importst.module_path, msgs=msgs,
            external_package_name=external_name,
            import_line=importst.line, import_col=importst.col
        ) later:

        await try_list
        var process_result = self.process_first_working_module_file(
            try_list, external_package_name=external_name,
            msgs=msgs, import_line=importst.line,
            import_col=importst.col,
            debug=debug
        ) later:

        await process_result
        var project_file = none
        if process_result != none {
            project_file = process_result.project_file
        }
        if debug {
            print("compiler.project: resolve_all_imports() "
                "resolved import " + importst.module_path.as_str() + " "
                "from package " + if external_name != none
                    (external_name) else ("<same project>") + " "
                "issued from file: " + file_rel_path +
                " => files to try: " +
                try_list.as_str() + " => result: " +
                if project_file != none (project_file.source_uri +
                    " (full module: " +
                        project_file.modinfo.module_name + ")")
                    else ("<not found>")
            )
        }
        importst.project_file = project_file
        return yes
    }

    var do_continue = resolve_next_import_if_needed(msgs=msgs)
    later:

    await do_continue
    if not do_continue {
        return no
    }
    do_continue = resolve_next_import_if_needed(msgs=msgs)
    later repeat
}

