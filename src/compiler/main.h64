## @module compiler.main
# Copyright (c) 2020-2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import argparse from core.horse64.org
import io from core.horse64.org
import json from core.horse64.org
import path from core.horse64.org
import system from core.horse64.org
import time from core.horse64.org
import uri from core.horse64.org

import compiler.ast
import compiler.ast.transform as ast_transform
import compiler.ast.analyze as analyze
import compiler.build_options as build_options
import compiler.compiler_log as clog
import compiler.moose64.build.c_build as m64_c_build
import compiler.moose64.codegen.c_gen as m64_c_gen
import compiler.msg as msg
import compiler.project as project
import compiler.storage.scope
import compiler.token
import compiler.typeinfo as typeinfo

func version_output_for_terminal(is_moosec=no) {
    var program_name = if is_moosec ("moosec") else ("horsec")
    var t = program_name + " v" + system.program_version
    prep{ if package.is_dep_in_pkg_mod_dir(
              HORP_INFO_PROJECT_DIR, "horp.horse64.org"
          ) }
    t += ", built with horp support enabled"
    prep{ else }
    t += ", built without any horp support"
    prep{ endif }
    t += ", built by " +
        system.program_compiler_name + ", running on " +
        system.osname + ".\n" +
        "Copyright (c) 2020-2024, ellie/@ell1e & Horse64 authors."
    return later t
}

func license_output_for_terminal {
    var t = "All horsec license info, no guarantee of "
        "completeness or accuracy:\n"
    var t2 = system.program_license_text(layout_width=79)
    later:

    await t2
    t += t2
    return t
}

func tokenize_target_from_args(args) {
    if args["--code"] != none {
        var tresult = compiler.token.tokenize_str(
            args["--code"], keep_whitespace=no
        )
        return later tresult
    } else {
        var src_path = args["source file"]

        var tresult = compiler.token.tokenize_from_uri(
            src_path, project_file=none,
            keep_whitespace=no,
            default_to_diskpath=yes,
            require_detect_project_dir=no
        ) later:

        await tresult
        return tresult
    }
}

func parse_ast_target_from_args(args, checked_ast=no,
        force_single_file=no, build_options=none,
        debug=no, debug_modules=no, debug_storage=no,
        debug_global_storage=no, debug_failed_lookups=no) {
    if build_options.print_stages {
        print(build_options.build_program_name +
            ": info: stage tokens: "
            "Dispatching for parsing first file... "
            "[t=" + time.ticks().as_str() + "]")
    }
    func get_ast {
        if args["--code"] != none {
            # Note: force_single_file=yes is implied and not a parameter,
            # since this is "str_to_ast":
            var tresult = compiler.ast.parse_str_to_ast(
                args["--code"], is_entrypoint=yes,
                allow_disk_access=yes, allow_vfs_access=no,
                require_detect_project_dir=yes,
                build_options=build_options,
                debug=debug, debug_modules=debug_modules,
                debug_global_storage=debug_global_storage,
            ) later:

            await tresult
            return tresult
        }
        var src_path = args["source file"]

        var tresult = compiler.ast.parse_to_ast_from_uri(
            src_path, default_to_diskpath=yes, is_entrypoint=yes,
            force_single_file=force_single_file, allow_disk_access=yes,
            allow_vfs_access=no,
            require_detect_project_dir=yes,
            build_options=build_options,
            debug=debug, debug_modules=debug_modules,
            debug_global_storage=debug_global_storage,
        ) later:

        await tresult
        return later tresult
    }
    var tresult = get_ast() later:

    await tresult
    if not checked_ast {
        return later tresult
    }

    tresult.project_file.set_data_from_ast_result(
        tresult
    )
    if build_options.print_stages {
        print(build_options.build_program_name +
            ": info: stage checked-ast: "
            "Now starting to ensure all files are parsed... "
            "[t=" + time.ticks().as_str() + "]")
    }
    tresult.project_file.project.build_options = build_options
    tresult.project_file.project.ensure_global_scope_for_full_project(
        msgs=tresult.msgs, debug=debug_modules
    ) later:

    if build_options.print_stages {
        print(build_options.build_program_name +
            ": info: stage checked-ast: "
            "Done ensuring all files are parsed. "
            "[t=" + time.ticks().as_str() + "]")
    }
    if debug_modules {
        print("compiler.main: parse_ast_target_from_args() " +
            "full list of project files that were processed: " +
            tresult.project_file.project.
                module_uri_to_file_map.values().as_str())
    }
    var had_error = no
    for m in tresult.msgs {
        if m.kind == msg.M_ERROR {
            had_error = yes
            break
        }
    }
    if had_error {
        return tresult
    }

    ast_transform.do_all_pre_nameres_transformations(
        tresult.project_file.project, tresult.msgs,
        build_options=build_options
    )
    later:

    if build_options.print_stages {
        print(build_options.build_program_name +
            ": info: stage checked-ast: "
            "Now computing and checking all storage... "
            "[t=" + time.ticks().as_str() + "]")
    }
    var success = tresult.project_file.project.
        compute_and_check_all_storage(
            tresult.msgs, build_options=build_options,
            debug=debug_storage,
            debug_global_storage=debug_global_storage,
            debug_failed_lookups=debug_failed_lookups)
    later:

    await success
    if build_options.print_stages {
        print(build_options.build_program_name +
            ": info: stage checked-ast: "
            "Done computing storage for all files. "
            "[t=" + time.ticks().as_str() + "]")
    }
    had_error = no
    for m in tresult.msgs {
        if m.kind == msg.M_ERROR {
            had_error = yes
            break
        }
    }
    assert(success == yes or had_error)
    return tresult
}

func show_intermediate_compile_result_to_terminal_or_file(
        msgs, ast_result=none,
        literal_value_result=none,
        build_options=none, for_script=no,
        is_global_scope=no, is_code_file=no,
        omit_result=no,
        fail_reason="Code compilation has failed."
        ) {
    var had_error = no
    for m in msgs {
        if m.kind == msg.M_ERROR {
            had_error = yes
        }
    }
    var actual_result_contents = none
    func obtain_result_contents {
        if had_error or omit_result {
            return later
        }
        if literal_value_result != none {
            actual_result_contents = literal_value_result
            return later
        }
        if ast_result == none {
            return later
        }
        if is_code_file and has_attr(
                ast_result, "dump_as_code") {
            var result = ast_result.dump_as_code()
            actual_result_contents = result
            return later
        }
        if is_global_scope {
            if for_script {
                actual_result_contents = ast_result.as_json_obj()
            } else {
                actual_result_contents = ast_result.as_str()
            }
            return later
        }
        var result = ""
        for stmt in ast_result.stmts {
            if result.len > 0 {
                result += ",\n"
            }
            result += stmt.as_str()
        }
        actual_result_contents = result
        return later
    }
    obtain_result_contents()
    later:

    if for_script or (build_options.output_file != none and
            not omit_result) {
        var output = {
            "error"-> none,
            "msgs"-> [],
        }
        if not omit_result and (
                actual_result_contents != none or
                not had_error) {
            output["result"] = actual_result_contents
        }
        for m in msgs {
            output["msgs"].add(m.as_json_obj())
        }
        if had_error {
            output["error"] = fail_reason
            output["success"] = no
            print(json.dump(output))
            return later 1
        }
        output["success"] = yes
        if build_options.output_file == none or
                omit_result {
            print(json.dump(output))
            return later 0
        }
        var f = io.open(build_options.output_file, "w") later:

        await f
        do {
            f.write(json.dump(output)) later:
        } finally {
            f.close()
        }
        return later 0
    }
    for m in msgs {
        print(m.as_terminal_str(prefix=
            build_options.build_program_name))
    }
    if not omit_result and actual_result_contents != none {
        print(actual_result_contents)
    }
    return later 0
}

func actionparser_modinfo(args, is_moose64=no) {
    var program_name = if is_moose64 ("moosec") else ("horsec")
    var command_name = if is_moose64 ("moosec modinfo")
                       else ("horsec modinfo")
    var file_ext = if is_moose64 (".m64") else (".h64")
    var defs = new argparse.ArgumentDefs(program_name=command_name)
    defs.add_arg(
        "module path",
        description="The target path for which to print module info, "
            "must have a " + file_ext +
            " file extension if it's a file (and not "
            "a directory).")
    defs.add_switch(
        "--for-script",
        description="This switch formats the compiler's terminal "
            "output (like e.g. the errors when compiling) as JSON.")
    defs.add_switch(
        "--resolve-imports",
        description="When enabled, the module info will include "
            "file paths to the corresponding target file for each "
            "import found.")
    defs.add_switch(
        "--debug-modules",
        description="Enable debug module discovery. Prints out "
            "all file paths and associated modules when processing.")
    var result = argparse.parse(arg_defs=defs, args=args) later:

    await result
    if result.output != "" {
        assert(result.output != none)
        print(result.output)
        return result.exit_code
    }
    var resolve_imports = no
    if result.args["--resolve-imports"] {
        resolve_imports = yes
    }
    var target = result.args["module path"]
    var pfile = new project.ProjectFile(
        target, request_debug_modules=result.args["--debug-modules"],
        is_moose64=is_moose64
    )
    pfile.ensure_project() later:
    pfile.parse_for_imports_if_needed() later:
    if pfile.modinfo == none {
        throw new RuntimeError("Internal error, "
            "unexpectedly failed to obtain module info.")
    }
    func resolve_imports_if_needed {
        if not resolve_imports {
            return
        }
        pfile.resolve_all_imports(
            ignore_missing=yes,
            debug=result.args["--debug-modules"]
        ) later:
    }
    resolve_imports_if_needed() later:

    if result.args["--for-script"] {
        print(json.dump(
            pfile.modinfo.as_json_obj(project=pfile.project,
                project_file=pfile)))
    } else {
        print(pfile.modinfo.as_terminal_str(project=pfile.project,
            project_file=pfile))
    }
    return 0
}

func action_compile_do(
        args_parse_result, stage, build_options=none,
        prepend_msgs=none,
        cmd_name="compile", is_moose64=no
        ) {
    if not has_attr(args_parse_result, "args") {
        throw new TypeError("Argument args_parse_result "
            "doesn't seem to be valid argparse result object.")
    }
    var result = args_parse_result
    var boptions = build_options
    if boptions == none {
        boptions = new build_options.BuildOptions()
    }
    boptions.is_moose64 = is_moose64
    if not apply_compile_cmd_options_to_build_options(
            result, boptions, cmd_name=cmd_name,
            is_moose64=is_moose64
            ) {
        return later 1
    }
    var opt_is_single_file =
        result.args.has("--single-file") and
        result.args["--single-file"]
    var opt_for_script =
        result.args.has("--for-script") and
        result.args["--for-script"]
    var program_name = if is_moose64 ("moosec") else ("horsec")

    var aresult = parse_ast_target_from_args(
        result.args, checked_ast=yes,
        force_single_file=opt_is_single_file,
        build_options=boptions,
        debug=result.args["--debug-ast"],
        debug_modules=result.args["--debug-modules"],
        debug_storage=result.args["--debug-storage"],
        debug_global_storage=
            result.args["--debug-global-storage"],
        debug_failed_lookups=
            result.args["--debug-failed-lookups"],
    )
    later:

    await aresult
    if prepend_msgs != none and prepend_msgs.len > 0 {
        aresult.msgs = prepend_msgs + aresult.msgs
    }

    # Helper functions:
    func print_stage_info(stage_name, info_text) {
        if not boptions.print_stages {
            return
        }
        clog.log_or_print(new msg.FileMsg(
            "stage " + stage_name + ": " +
            info_text + " "
            "[t=" + time.ticks().as_str() + "]",
            kind=msg.M_INFO,
        ), msgs=aresult.msgs, program_name=program_name,
        force_print=not opt_for_script)
    }

    # Apply code check and do basic analysis:
    var success = analyze.do_basic_check_and_analysis(
        aresult.project_file.project,
        aresult.msgs, is_moose64=is_moose64) later:

    await success
    if stage == "checked-ast" or not success {
        var finalresult =
            show_intermediate_compile_result_to_terminal_or_file(
                aresult.msgs,
                ast_result=aresult,
                build_options=boptions,
                for_script=opt_for_script,
                is_global_scope=no, is_code_file=no,
                omit_result=no,
            ) later:

        await finalresult
        return later finalresult
    }

    # Analyze the type info from type annotations if we have any:
    print_stage_info("transformed-code",
            "Deduce and verify types...")
    success = typeinfo.ensure_all_type_info(
        aresult.project_file.project,
        aresult.msgs, is_moose64=is_moose64) later:
    await success

    # Continuing here, we want to transform the code.

    print_stage_info("transformed-code",
        "Now applying code transformations...")

    # Apply code transformation:
    ast_transform.do_all_post_nameres_transformations(
        aresult.project_file.project,
        aresult.msgs, build_options=boptions
    ) later:

    # If we had an error at this stage then we need to abort:
    var had_error = no
    for m in aresult.msgs {
        if m.kind == msg.M_ERROR {
            had_error = yes
            break
        }
    }
    var omit_result_in_output = (
        boptions.output_file != none or
        boptions.output_dir != none
    )
    func get_ast_result(pfile) {
        var inner_ast_result = none
        if pfile == none {
            inner_ast_result = aresult
        } else {
            inner_ast_result = pfile.ast
        }
        if is_code_file {
            var result = inner_ast_result.dump_as_code()
            later:

            await result
            return later result
        }
        if is_global_scope {
            if for_script {
                return later inner_ast_result.as_json_obj()
            } else {
                return later inner_ast_result.as_str()
            }
        }
        return later
    }
    if not had_error and (stage == "transformed-code" or
            stage == "transformed-ast") and
            (boptions.output_file != none or
                boptions.output_dir != none) {
        print_stage_info("transformed-code",
            "Preparing to output result to files...")
        omit_result_in_output = yes
        func output_code {
            if boptions.output_file != none {
                assert(boptions.output_dir == none)
                var result = get_ast_result() later:

                await result
                var f = io.open(boptions.output_file, "w") later:

                await f
                do {
                    f.write(result) later:
                } finally {
                    f.close()
                }
                return later
            }
            boptions.output_dir = uri.normalize(
                boptions.output_dir, absolute_file=yes)
            func output_to_folder(pfile) {
                var furi = pfile.source_uri
                var rel_path
                if furi == none {
                    var ext = if is_moose64 (".m64") else (".h64")
                    furi = uri.add_part(
                        boptions.output_dir, "(inline)." + ext
                    )
                    rel_path = "(inline)." + ext
                } elseif pfile.modinfo == none {
                    furi = uri.add_part(
                        boptions.output_dir, uri.basename(furi)
                    )
                    rel_path = uri.basename(furi)
                } else {
                    assert(pfile.modinfo != none)
                    rel_path = pfile.modinfo.rel_path
                    if pfile.modinfo.package_name != none and
                            pfile.modinfo.package_name !=
                            aresult.project_file.
                                project.package_name and
                            not rel_path.lower().starts(
                                "horse_modules") {
                        rel_path = "horse_modules" + path.sep +
                            pfile.modinfo.package_name +
                            path.sep + rel_path
                    }
                }
                var fname = uri.basename(furi)
                var write_folder_uri = uri.add_part(
                    boptions.output_dir,
                    path.dirname(rel_path))
                var write_furi = uri.add_part(
                    write_folder_uri, fname)
                if uri.get_protocol(write_folder_uri).lower() !=
                        "file" {
                    throw new NotImplementedError(
                        "Can't make directory using this "
                        "remote protocol.")
                }
                var write_folder_path = uri.to_file_or_vfs_path(
                    write_folder_uri)
                io.make_dir(uri.to_file_or_vfs_path(
                    write_folder_uri), allow_vfs=no,
                    allow_nested=yes, ignore_exists=yes
                ) later:

                var code = pfile.dump_as_code() later:

                await code
                var f = io.open(uri.to_file_or_vfs_path(
                    write_furi), "w") later:

                await f
                f.write(code) later:

                f.close()
                return later yes
            }
            assert(boptions.output_dir != none)
            var success = aresult.project_file.project.
                do_for_all_files(output_to_folder)
            later:

            await success
            return later
        }
        output_code() later:
    }
    if had_error or stage == "transformed-code" or
            stage == "transformed-ast" {
        var result = get_ast_result() later:

        await result
        var finalresult =
            show_intermediate_compile_result_to_terminal_or_file(
                aresult.msgs,
                literal_value_result=result,
                build_options=boptions,
                for_script=opt_for_script,
                is_global_scope=no,
                is_code_file=(stage == "transformed-code"),
                omit_result=omit_result_in_output,
            ) later:

        await finalresult
        return later finalresult
    }
    assert(
        (not is_moose64 and
            {"bytecode", "run"}.has(stage)) or
        (is_moose64 and
            {"c"}.has(stage)) or
        {"binary", "run"}.has(stage)
    )
    # If this is moose64, embark on our path toward C:
    if is_moose64 {
        print_stage_info("c",
            "Now transforming result to C.")

        var export_result = m64_c_gen.export_moose_project_to_c(
            aresult.project_file.project,
            write_to_temp_files=(stage != "c"),
            limit_to_entrypoint_file=
                (stage == "c" and
                    (boptions.output_file != none or
                    boptions.output_dir == none)),
            msgs=aresult.msgs, build_options=boptions,
        ) later:

        await export_result
        var had_c_gen_error = no
        for m in aresult.msgs {
            if m.kind == msg.M_ERROR {
                had_c_gen_error = yes
            }
        }
        if not had_c_gen_error and export_result == none {
            aresult.msgs.add(new msg.FileMsg("Internal error, "
                "C generation returned failure without any "
                "error message. Please report this bug to "
                "the compiler makers."))
            had_c_gen_error = yes
        }
        if stage == "c" or had_c_gen_error {
            if boptions.output_file == none and
                    boptions.output_dir == none {
                assert(export_result == none or
                    stage != "c" or
                    typename(export_result) == "str")
                var literal_result = export_result
                if typename(literal_result) != "str" or
                        had_c_gen_error {
                    literal_result = none
                }
                var finalresult =
                    show_intermediate_compile_result_to_terminal_or_file(
                        aresult.msgs,
                        literal_value_result=export_result,
                        build_options=boptions,
                        for_script=opt_for_script,
                        is_global_scope=no,
                        is_code_file=no,
                        omit_result=no,
                    ) later:

                await finalresult
                return later finalresult
            }
            if not had_c_gen_error {
                print_stage_info("c",
                    "Done writing files.")
            }
            var finalresult =
                show_intermediate_compile_result_to_terminal_or_file(
                    aresult.msgs,
                    build_options=boptions,
                    for_script=opt_for_script,
                    is_global_scope=no,
                    is_code_file=no,
                    omit_result=yes,
                ) later:

            await finalresult
            if had_c_gen_error {
                return later 1
            }
            return later finalresult
        }

        print_stage_info("binary",
            "Preparing to compile binary, build dir: " +
            export_result.build_base_dir_uri.as_str())
        var build_result = m64_c_build.build_project(
            export_result, boptions, msgs=aresult.msgs
        ) later:

        await build_result
        assert(typename(build_result) == "bool")
        var had_build_error = no
        for m in aresult.msgs {
            if m.kind == msg.M_ERROR {
                had_build_error = yes
            }
        }
        if not had_build_error and not build_result {
            aresult.msgs.add(new msg.FileMsg("Internal error, "
                "binary build returned failure without any "
                "error message. Please report this bug to "
                "the compiler makers."))
            had_build_error = yes
        }
        if not had_build_error {
            print_stage_info("binary",
                "Done compiling final binary.")
        }
        var finalresult =
            show_intermediate_compile_result_to_terminal_or_file(
                aresult.msgs,
                build_options=boptions,
                for_script=opt_for_script,
                is_global_scope=no,
                is_code_file=no,
                omit_result=yes,
                fail_reason="Creation of the output "
                "binary has failed.",
            ) later:

        await finalresult
        if had_build_error {
            return later 1
        }
        return later finalresult
    }
    # Continuing here, we want Horse64 byte code.
    # Apply bytecode transformation:
    return later 0
}

func apply_compile_cmd_options_to_build_options(
        args_parse_result, build_options_ref, cmd_name="compile",
        is_moose64=no
        ) {
    var program_name = if is_moose64 ("moosec") else ("horsec")
    if not has_attr(args_parse_result, "args") {
        throw new TypeError("Argument args_parse_result "
            "doesn't seem to be valid argparse result object.")
    }
    var result = args_parse_result
    var boptions = build_options_ref
    boptions.optimize_level = build_options.OPTIMIZE_ALL_BUT_ASSERTS
    boptions.print_stages =
        result.args.has("--print-stages") and
        result.args["--print-stages"]
    boptions.build_program_name = program_name
    boptions.is_moose64 = is_moose64
    boptions.verbose_mode =
        result.args.has("--verbose") and result.args["--verbose"]
    boptions.moose64_build_dir =
        if is_moose64 and result.args.has("--c-build-dir") and
            result.args["--c-build-dir"] != none
            (uri.normalize(result.args["--c-build-dir"]))
            else (none)
    boptions.force_as_single_file = no
    if result.args.has("--single-file") and
            result.args["--single-file"] {
        boptions.force_as_single_file = yes
    } else {
        if result.args.has("--code") and
                result.args["--code"] != none {
            boptions.force_as_single_file = yes
        }
    }

    if result.args.has("--optimize-level") {
        if result.args["--optimize-level"] == none {
            result.args["--optimize-level"] = "all-but-asserts"
        }
        if result.args["--optimize-level"] == "none" {
            boptions.optimize_level = build_options.OPTIMIZE_NONE
        } elseif result.args["--optimize-level"] == "all-but-asserts" {
            boptions.optimize_level = build_options.OPTIMIZE_ALL_BUT_ASSERTS
        } elseif result.args["--optimize-level"] == "all" {
            boptions.optimize_level = build_options.OPTIMIZE_ALL
        } else {
            print(program_name + ": error: Unsupported "
                "optimization level: " +
                result.args["--optimize-level"].as_str())
            print("Use " + program_name + " " +
                cmd_name.as_str() + " --help to show "
                "available optimization levels.")
            return no
        }
    }
    if result.args.has("--code") and
            result.args["--code"] != none and
            result.args.has("source file") and
            result.args["source file"] != none {
        print(program_name + ": error: Must specify "
            "either a source file, or --code option, but not both.")
        print("Use " + program_name + " " +
            cmd_name.as_str() + " --help to show usage.")
        return no
    }
    return yes
}

func actionparser_compile_or_run(
        args, is_run_cmd=no, is_moose64=no
        ) {
    var program_name = if is_moose64 ("moosec") else ("horsec")
    var command_name = if is_moose64 ("moosec compile")
                       else ("horsec compile")
    if is_run_cmd {
        command_name = if is_moose64 ("moosec run")
                       else ("horsec run")
    }
    var file_ext = if is_moose64 (".m64") else (".h64")
    var defs = new argparse.ArgumentDefs(program_name=command_name)
    defs.add_arg(
        "source file", optional=yes,
        description="The target file to " +
            if is_run_cmd ("run") else ("compile") + ", "
            "must have a " + file_ext + " file extension.")
    defs.add_switch(
        "--code", aliases=["-c"], takes_arg=yes,
        description="A code line which to " +
            if is_run_cmd ("run") else ("compile") + " instead of "
            "a file on disk.")
    defs.add_switch(
        "--debug-ast",
        description="Enable debug mode for the AST parser. "
            "Be warned, this will result in a lot of output.")
    defs.add_switch(
        "--debug-modules",
        description="Enable debugging module discovery. Prints out "
        "all file paths and associated modules when processing.")
    defs.add_switch(
        "--debug-failed-lookups",
        description="Enable debugging failed storage lookups. "
        "Prints out internal compiler details whenever a lookup "
        "fails.")
    defs.add_switch(
        "--print-stages",
        description="Announce the various stages as they "
            "are entered.")
    defs.add_switch(
        "--verbose",
        description="Be verbose about what the compiler is doing.")
    defs.add_switch(
        "--debug-global-storage",
        description="Enable debugging global storage assignments.")
    defs.add_switch(
        "--debug-storage",
        description="Enable debug scope and storage computation. "
        "Be warned, this debugs all local scopes and will result "
        "in a lot of output.")
    if not is_run_cmd {
        defs.add_switch(
            "--stage", takes_arg=yes,
            description="At which stage to stop. The default is "
                "\"binary\" which means full compilation, other "
                "available stages are: "
                "tokens, ast, global-scope, checked-ast, "
                "transformed-code, transformed-ast, " +
                if is_moose64 ("c, binary") else ("bytecode") + ".")
        defs.add_switch(
            "--output-file", takes_arg=yes,
            description="Where to write the resulting binary, or "
                "horseasm for stage setting \"bytecode\", or json "
                "file for any other stage that isn't \"binary\".")
        defs.add_switch(
            "--output-dir", takes_arg=yes,
            description="Can be used for the \"transformed-code\", "
                "\"checked-ast\", \"transformed-ast\" stages to "
                "write out an output file corresponding to each "
                "module in the project (rather than just the "
                "entrypoint module).")
    }
    if is_moose64 {
        defs.add_switch(
            "--c-build-dir", takes_arg=yes,
            description="Override in which directory to run the "
                "C compiler when creating the binary from your "
                "moose64 program. Unless you also overrode the "
                "--output-dir then it's best not to use this option.")
    }
    defs.add_switch(
        "--optimize-level", takes_arg=yes,
        description="Specify the levels of optimizations to use. "
            "Possible levels are \"none\", \"all-but-asserts\", "
            "and \"all\". The default is \"all-but-asserts\", "
            "which applies all known optimizations but keeps "
            "asserts. The \"all\" setting will also remove asserts, "
            "and \"none\" won't optimize at all.")
    if not is_run_cmd {
        defs.add_switch(
            "--for-script",
            description="This switch formats horsec's terminal output "
                "(like e.g. the errors when compiling) as JSON.")
    }
    defs.add_switch(
        "--single-file",
        description="Always treat the target file not as part of a "
            "project, but rather as a single standalone script file, "
            "even if it wasn't auto-detected as a script file.")
    var result = argparse.parse(arg_defs=defs, args=args) later:

    await result
    if result.output != "" {
        print(result.output)
        return result.exit_code
    }
    const possible_stages = if is_moose64 ([
        "tokens", "ast", "global-scope", "checked-ast",
        "transformed-code", "transformed-ast", "c",
        "binary"
    ]) else ([
        "tokens", "ast", "global-scope", "checked-ast",
        "transformed-code", "transformed-ast", "bytecode",
        "binary"
    ])

    # Sanity check the provided options first:

    if result.args["--code"] == none and
            result.args["source file"] == none {
        print(program_name + ": error: Must specify "
            "either a source file, or --code option, but neither "
            "were given.")
        print("Use " + program_name + " compile --help to show "
            "usage.")
        return later 1
    }
    var boptions = new build_options.BuildOptions()
    if not apply_compile_cmd_options_to_build_options(
            result, boptions, cmd_name="compile",
            is_moose64=is_moose64
            ) {
        return later 1
    }

    var opt_is_single_file = boptions.force_as_single_file
    var msgs = []
    if not is_run_cmd {
        if result.args["--stage"] == none {
            result.args["--stage"] = "binary"
        }
        if not possible_stages.has(result.args["--stage"]) {
            print(program_name + ": error: Unsupported "
                "stage: " + result.args["--stage"])
            print("Use " + program_name + " compile --help to show "
                "available stages.")
            return later 1
        }
        if result.args["--output-dir"] != none and
                result.args["--output-file"] != none {
            print(program_name + ": error: Can't combine "
                "--output-file and --output-dir options.")
            print("Use " + program_name + " compile --help to show usage.")
            return later 1
        }
        if result.args["--output-dir"] != none and
                not {"transformed-code", "checked-ast", "c",
                    "transformed-ast"}.has(result.args["--stage"]) {
            print(program_name + ": error: This stage doesn't support "
                "the --output-dir option.")
            print("Use " + program_name + " compile --help to show "
                "usage.")
            return later 1
        }
        if result.args["--output-file"] != none {
            if {"checked-ast", "ast", "transformed-ast",
                        "global-scope"}.has(
                    result.args["--stage"]) and
                    not result.args["--output-file"].lower().ends(".json") {
                print(program_name + ": error: Expected "
                    "--output-file to be a .json file for this stage.")
                print("Use " + program_name + " compile --help to "
                    "show usage.")
                return later 1
            } elseif {"transformed-code"}.has(
                    result.args["--stage"]) and
                    not result.args["--output-file"].lower().ends(file_ext) {
                print(program_name + ": error: Expected "
                    "--output-file to be a " + file_ext + " "
                    "file for this stage.")
                print("Use " + program_name + " compile --help to "
                    "show usage.")
                return later 1
            } elseif {"c"}.has(result.args["--stage"]) and
                    not result.args["--output-file"].lower().ends(".c") {
                print(program_name + ": error: Expected "
                    "--output-file to be a .c "
                    "file for this stage.")
                print("Use " + program_name + " compile --help to "
                    "show usage.")
                return later 1
            } elseif {"bytecode"}.has(
                    result.args["--stage"]) and
                    not result.args["--output-file"].lower().ends(".hasm") {
                print(program_name + ": error: Expected "
                    "--output-file to be a .hasm file for this stage.")
                print("Use " + program_name + " compile --help to "
                    "show usage.")
                return later 1
            }
        }
        boptions.output_file = result.args["--output-file"]
        boptions.output_dir = result.args["--output-dir"]
    }
    var opt_for_script =
        not is_run_cmd and result.args["--for-script"]
    if boptions.print_stages {
        clog.log_or_print(new msg.FileMsg(
            "stage init: "
            "Launched & done parsing options. "
            "[t=" + time.ticks().as_str() + "]",
            kind=msg.M_INFO,
        ), msgs=msgs, program_name=program_name)
    }
    if boptions.verbose_mode {
        clog.log_or_print(new msg.FileMsg(
            "Now beginning to compile program.",
            kind=msg.M_INFO,
        ), msgs=msgs, program_name=program_name)
    }
    if not is_run_cmd {
        if boptions.output_file != none {
            boptions.output_file = uri.normalize(boptions.output_file)
            var prot = uri.get_protocol(boptions.output_file)
            if {"file", "vfs"}.has(prot) {
                var fpath = path.make_abs(uri.to_file_or_vfs_path(
                    boptions.output_file
                ))
                boptions.output_file =
                    if prot == "vfs" (uri.from_vfs_path(fpath))
                        else (uri.from_disk_path(fpath))
            }
        }
        if boptions.output_dir != none {
            boptions.output_dir = uri.normalize(boptions.output_dir)
            var prot = uri.get_protocol(boptions.output_dir)
            if {"file", "vfs"}.has(prot) {
                var fpath = path.make_abs(uri.to_file_or_vfs_path(
                    boptions.output_dir
                ))
                boptions.output_dir =
                    if prot == "vfs" (uri.from_vfs_path(fpath))
                        else (uri.from_disk_path(fpath))
            }
        }
    }

    # Actually execute what was asked of us:

    if not is_run_cmd and
            result.args["--stage"] == "tokens" {
        if boptions.print_stages {
            clog.log_or_print(new msg.FileMsg(
                "stage tokens: "
                "Tokenizing first target file. "
                "[t=" + time.ticks().as_str() + "]",
                kind=msg.M_INFO,
            ), msgs=msgs, program_name=program_name)
        }
        var tresult = tokenize_target_from_args(result.args)
        later:

        await tresult
        tresult.msgs = msgs + tresult.msgs
        if boptions.print_stages {
            clog.log_or_print(new msg.FileMsg(
                "stage tokens: "
                "Printing result "
                " [t=" + time.ticks().as_str() + ".",
                kind=msg.M_INFO,
            ), msgs=tresult.msgs, program_name=program_name)
        }
        var had_error = no
        for m in tresult.msgs {
            if m.kind == msg.M_ERROR {
                had_error = yes
            }
        }
        if result.args["--for-script"] {
            var output = {
                "error"-> none,
                "msgs"-> [],
                "result"-> tresult.as_json_obj(),
            }
            for m in tresult.msgs {
                output["msgs"].add(m.as_json_obj())
            }
            if had_error {
                output["error"] = "Code has errors."
                print(json.dump(output))
                return later 1
            }
            print(json.dump(output))
            return later 0
        } else {
            for m in tresult.msgs {
                print(m.as_terminal_str(prefix=program_name))
            }
            if not had_error {
                var output = ""
                for t in tresult.tokens {
                    if output.len > 0 {
                        output += ", "
                    }
                    output += compiler.token.
                        describe_token_str(t.str)
                }
                print(output)
                return later 0
            }
            return later 1
        }
    } elseif not is_run_cmd and (
            result.args["--stage"] == "ast" or
            result.args["--stage"] == "global-scope") {
        var aresult = parse_ast_target_from_args(
            result.args, checked_ast=no,
            force_single_file=opt_is_single_file,
            build_options=boptions,
            debug=result.args["--debug-ast"],
            debug_modules=result.args["--debug-modules"],
            debug_failed_lookups=
                result.args["--debug-failed-lookups"],
        )
        later:

        await aresult
        aresult.msgs = msgs + aresult.msgs
        var is_global_scope = (
            result.args["--stage"] == "global-scope")
        var to_be_printed_obj = if is_global_scope
           (aresult.global_scope) else (aresult)
        var finalresult =
            show_intermediate_compile_result_to_terminal_or_file(
                aresult.msgs,
                ast_result=to_be_printed_obj,
                build_options=boptions,
                for_script=opt_for_script,
                is_global_scope=is_global_scope
            ) later:

        await finalresult
        return later finalresult
    } elseif is_run_cmd or
            result.args["--stage"] == "checked-ast" or
            result.args["--stage"] == "transformed-code" or
            result.args["--stage"] == "transformed-ast" or
            result.args["--stage"] == "c" or
            result.args["--stage"] == "bytecode" or
            result.args["--stage"] == "binary" {
        var stage = if is_run_cmd ("run")
            else (result.args["--stage"])
        var compile_result = action_compile_do(
            result, stage,
            build_options=boptions, prepend_msgs=msgs,
            cmd_name="compile", is_moose64=is_moose64
        ) later:

        await compile_result
        return compile_result
    } else {
        throw new NotImplementedError("Compiler "
            "stage not implemented.")
    }
}

func do_main(is_moose64=no) {
    var program_name = if is_moose64 ("moosec") else ("horsec")
    var defs = new argparse.ArgumentDefs(
        program_name=program_name
    )
    defs.add_arg(
        "action", description="Pick one of the available actions: "
        "compile, modinfo, or run. To see details for an action, "
        "use it with --help like e.g.: " + program_name + " compile "
        "--help")
    defs.add_catchall(
        "action args", description="List of "
        "arguments for the specified action.", can_be_empty=yes)
    func get_license_output {
        var result = license_output_for_terminal(
            is_moosec=is_moose64
        ) later:

        await result
        return later result
    }
    defs.add_switch(
        "--license",
        description="Print out the program's licensing.",
        action_func=get_license_output)
    func get_version_output {
        var result = version_output_for_terminal(
            is_moosec=is_moose64
        ) later:

        await result
        return later result
    }
    defs.add_switch(
        "--version", aliases=["-V", "-version"],
        description="Print out the program version.",
        action_func=get_version_output)
    var result = argparse.parse(arg_defs=defs) later:

    await result
    if result.output != "" {
        print(result.output)
        return later result.exit_code
    }
    if result.args["action"] == "compile" {
        var compile_result = actionparser_compile_or_run(
            result.args["action args"],
            is_run_cmd=no,
            is_moose64=is_moose64
        ) later:

        await compile_result
        return later compile_result
    }
    if result.args["action"] == "run" {
        var run_result = actionparser_compile_or_run(
            result.args["action args"],
            is_run_cmd=yes,
            is_moose64=is_moose64
        ) later:

        await run_result
        return later run_result
    }
    if result.args["action"] == "modinfo" {
        var modinfo_result = actionparser_modinfo(
            result.args["action args"],
            is_moose64=is_moose64
        ) later:

        await modinfo_result
        return later modinfo_result
    }
    print(program_name + ": error: unknown action: " +
          result.args["action"])
    print("Use " + program_name + " --help to show usage.")
    return later 1
}

func main {
    var result = do_main(is_moose64=no)
    later:

    await result
    return later result
}

