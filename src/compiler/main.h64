# @module compiler.main
# Copyright (c) 2020-2023, ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import argparse from core.horse64.org
import json from core.horse64.org
import system from core.horse64.org

import compiler.ast
import compiler.msg as msg
import compiler.project as project
import compiler.token

func version_output_for_terminal {
    return "horsec v" + system.program_version() + ", built by " +
        system.program_compiled_with() + ".\n" +
        "Copyright (c) 2020-2023, ellie/@ell1e & Horse64 Team."
}

func license_output_for_terminal {
    return "All horsec license info, no guarantee of "
        "completeness or accuracy:\n" +
        system.program_license_text(layout_width=79)
}

func tokenize_target_from_args(args) {
    if args["--code"] != none {
        var tresult = compiler.token.tokenize_str(
            args["--code"], keep_whitespace=no
        )
        return tresult
    } else {
        var src_path = args["source file"]

        var tresult = compiler.token.tokenize_from_uri(
            src_path, project_file=none,
            keep_whitespace=no,
            default_to_diskpath=yes,
            require_detect_project_dir=no
        ) later:

        await tresult
        return tresult
    }
}

func parse_ast_target_from_args(args, debug=no,
        debug_modules=no) {
    if args["--code"] != none {
        var tresult = compiler.ast.parse_str_to_ast(
            args["--code"], is_entrypoint=yes,
            force_single_file=yes, allow_disk_access=yes,
            allow_vfs_access=no,
            require_detect_project_dir=yes,
            debug=debug, debug_modules=no
        ) later:

        await tresult
        return tresult
    }
    var src_path = args["source file"]

    var tresult = compiler.ast.parse_to_ast_from_uri(
        src_path, default_to_diskpath=yes, is_entrypoint=yes,
        force_single_file=no, allow_disk_access=yes,
        allow_vfs_access=no,
        require_detect_project_dir=yes,
        debug=debug, debug_modules=debug_modules
    ) later:

    await tresult
    return tresult
}

func show_ast_or_global_scope_result_to_terminal(
        aresult, msgs, program_name=none, for_script=no,
        is_global_scope=no
        ) {
    var had_error = no
    for m in msgs {
        if m.kind == msg.M_ERROR {
            had_error = yes
        }
    }
    if for_script {
        var output = {
            "error": none,
            "result": aresult.as_json_obj(),
        }
        if had_error {
            output["error"] = "Code has errors."
            print(json.dump(output))
            return 1
        }
        print(json.dump(output))
        return 0
    } else {
        for m in msgs {
            print(m.as_terminal_str(prefix=program_name))
        }
        if not had_error {
            var output = ""
            if is_global_scope {
                output += aresult.as_str()
            } else {
                for stmt in aresult.stmts {
                    if output.len > 0 {
                        output += ",\n"
                    }
                    output += stmt.as_str()
                }
            }
            print(output)
            return 0
        }
        return 1
    }
}

func actionparser_modinfo(args) {
    var program_name = "horsec modinfo"
    var defs = argparse.ArgumentDefs(program_name=program_name)
    defs.add_arg(
        "module path",
        description="The target path for which to print module info, "
            "must have a .h64 file extension if it's a file (and not "
            "a directory).")
    defs.add_switch(
        "--for-script",
        description="This switch formats horsec's terminal output (like"
            "e.g. the errors when compiling) as JSON.")
    var result = argparse.parse(defs, args)
    if result.output != "" {
        print(result.output)
        return result.exit_code
    }
    var target = result.args["module path"]
    var pfile = new project.ProjectFile(target)
    pfile.ensure_project() later:
    pfile.parse_for_imports_if_needed() later:
    if pfile.modinfo == none {
        throw new RuntimeError("Internal error, "
            "unexpectedly failed to obtain module info.")
    }
    if result.args["--for-script"] {
        print(json.dump(
            pfile.modinfo.as_json_obj(project=pfile.project,
                project_file=pfile)))
    } else {
        print(pfile.modinfo.as_terminal_str(project=pfile.project,
            project_file=pfile))
    }
    return 0
}

func actionparser_compile(args) {
    var program_name = "horsec compile"
    var defs = argparse.ArgumentDefs(program_name=program_name)
    defs.add_arg(
        "source file", optional=yes,
        description="The target file to compile, "
            "must have a .h64 file extension.")
    defs.add_switch(
        "--code", aliases=["-c"], takes_arg=yes,
        description="A code line which to compile instead of "
            "a file on disk.")
    defs.add_switch(
        "--debug-ast",
        description="Enable debug mode for the AST parser. "
            "Be warned, this will result in a lot of output.")
    defs.add_switch(
        "--debug-modules",
        description="Enable debug module discovery. Prints out "
        "all file paths and associated modules when processing.")
    defs.add_switch(
        "--stage", takes_arg=yes,
        description="At which stage to stop. The default is "
            "\"binary\" which means full compilation, other "
            "available stages are: "
            "tokens, ast, global-scope, ast-scope, bytecode.")
    defs.add_switch(
        "--output-file", takes_arg=yes,
        description="Where to write the resulting binary, or "
            "horseasm for stage setting \"bytecode\", or json file "
            "for any other stage that isn't \"binary\".")
    defs.add_switch(
        "--for-script",
        description="This switch formats horsec's terminal output (like"
            "e.g. the errors when compiling) as JSON.")
    var result = argparse.parse(defs, args)
    if result.output != "" {
        print(result.output)
        return result.exit_code
    }
    if result.args["--code"] == none and
            result.args["source file"] == none {
        print(program_name + ": error: Must specify "
            "source file or --code option.")
        print("Use " + program_name + " --help to show usage.")
        return 1
    }

    if result.args["--stage"] == "tokens" {
        var tresult = tokenize_target_from_args(result.args)
        later:

        await tresult
        var had_error = no
        for m in tresult.msgs {
            if m.kind == msg.M_ERROR {
                had_error = yes
            }
        }
        if result.args["--for-script"] {
            var output = {
                "error": none,
                "result": tresult.as_json_obj(),
            }
            if had_error {
                output["error"] = "Code has errors."
                print(json.dump(output))
                return 1
            }
            print(json.dump(output))
            return 0
        } else {
            for m in tresult.msgs {
                print(m.as_terminal_str(prefix=program_name))
            }
            if not had_error {
                var output = ""
                for t in tresult.tokens {
                    if output.len > 0 {
                        output += ", "
                    }
                    output += compiler.token.
                        describe_token_str(t.str)
                }
                print(output)
                return 0
            }
            return 1
        }
    } elseif result.args["--stage"] == "ast" or
            result.args["--stage"] == "global-scope" {
        var had_error = no
        var aresult = parse_ast_target_from_args(
            result.args, debug=result.args["--debug-ast"],
            debug_modules=result.args["--debug-modules"],
        )
        later:

        await aresult
        var is_global_scope = (
            result.args["--stage"] == "global-scope")
        return show_ast_or_global_scope_result_to_terminal(
            if is_global_scope
                (aresult.global_scope) else (aresult),
            aresult.msgs,
            program_name=program_name,
            for_script=result.args["--for-script"],
            is_global_scope=is_global_scope,
        )
    }
}

func main {
    var defs = argparse.ArgumentDefs(program_name="horsec")
    defs.add_arg(
        "action", description="Pick an available actions: "
        "compile, run. To see details for an action, use it with --help "
        "like e.g.: horse compile --help")
    defs.add_catchall(
        "action args", description="List of "
        "arguments for the specified action")
    defs.add_switch(
        "--license",
        description="Print out the program's licensing.",
        action_func=license_output_for_terminal)
    defs.add_switch(
        "--version", aliases=["-V", "-version"],
        description="Print out the program version.",
        action_func=version_output_for_terminal)
    var result = argparse.parse(defs)
    if result.output != "" {
        print(result.output)
        return result.exit_code
    }
    if result.args["action"] == "compile" {
        var result = actionparser_compile(
            result.args["action args"]
        ) later:

        await result
        return result
    }
    if result.args["action"] == "modinfo" {
        var result = actionparser_modinfo(
            result.args["action args"]
        ) later:

        await result
        return result
    }
    print("horsec: error: unknown action: " + result.args["action"])
    print("Use horsec --help to show usage.")
    return 1
}

