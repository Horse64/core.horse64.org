# @module compiler.ast
# Copyright (c) 2020-2023, ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import json from core.horse64.org
import uri from core.horse64.org

import compiler.ast.call_or_assign_stmt as call_or_assign_stmt
import compiler.ast.func_stmt as func_stmt
import compiler.ast.if_stmt as if_stmt
import compiler.ast.import_stmt as import_stmt
import compiler.ast.invalid_stmt as invalid_stmt
import compiler.ast.return_stmt as return_stmt
import compiler.ast.var_stmt as var_stmt
import compiler.msg as msg
import compiler.token as token

type TreeNode {
    var kind

    var sibling_pos = 1

    ## @types (TreeNode, none)
    var parent = none

    ## @type [TreeNode]
    var subexprs = []

    ## @type [TreeNode]
    var subblocks = []

    ## @attr damaged
    ## Whether this tree node had some sort of parse error inside,
    ## meaning that more parse errors relating to it might just be
    ## useless indirect follow-up errors.
    ## @type bool
    var damaged = no

    var line, col

    var token_len
}

func TreeNode.as_str {
    return "TreeNode" + json.dump(self.as_json_obj())
}

func TreeNode.has_damage {
    if self.damaged {
        return yes
    }
    for subexpr in self.subexprs {
        if subexpr.has_damage() {
            return yes
        }
    }
    for subblock in self.subblocks {
        if subblock.has_damage() {
            return yes
        }
    }
    return no
}

func TreeNode.as_json_obj {
    var output = {
        "kind"-> NodeKind.num_label(self.kind),
        "line"-> self.line,
        "col"-> self.col,
        "token_len"-> self.token_len,
    }
    if self.subexprs.len > 0 {
        output["subexprs"] = []
        for subexpr in self.subexprs {
            output["subexprs"].add(subexpr.as_json_obj())
        }
    }
    if self.subblocks.len > 0 {
        output["subblocks"] = []
        for subblock in self.subblocks {
            block_statements = []
            for statement in subblock {
                block_statements.add(statement.as_json_obj())
            }
            output["subblocks"].add(block_statements)
        }
    }
    return output
}

type StmtNode base TreeNode {
}

func StmtNode.as_json_obj {
    var output = base.as_json_obj()
    output["subblocks"] = []
    for blocks in self.subblocks {
        var inner_blocks_objs = []
        for block in blocks {
            inner_blocks_objs.add(
                block.as_json_obj()
            )
        }
        output["subblocks"].add(inner_blocks_objs)
    }
    return output
}

enum NodeKind {
    N_EXPR_ARGNAME,
    N_EXPR_BINOP,
    N_EXPR_CALLKWARG,
    N_EXPR_CALLORDEFARGS,
    N_EXPR_CONTAINER,
    N_EXPR_INVALID,
    N_EXPR_LIT,
    N_EXPR_UNOP,
    N_EXPR_IDREF,
    N_EXPR_IFELSECLAUSE,
    N_STMT_FUNC,
    N_STMT_CALL,
    N_STMT_ASSIGN,
    N_STMT_VAR,
    N_STMT_IMPORT,
    N_STMT_RETURN,
    N_STMT_IF,
    N_STMT_INVALID,
}

type ASTResult {
    ## @type [TreeNode]
    var nodes = []

    ## @type [msg.FileMsg]
    var msgs = []

    ## @types (project.ProjectFile, none)
    var project_file

    ## @type num
    var token_len
}

func ASTResult.as_json_obj {
    var output = {
        "messages"-> [],
        "nodes"-> [],
    }
    for m in self.msgs {
        var mjson = {
            "message"-> m.message,
            "kind"-> msg.MsgKind.num_label(m.kind),
            "line"-> m.line,
            "col"-> m.col,
            "file"-> none,
        }
        if m.source_file != none {
            mjson["file"] = m.source_file.source_uri
        }
        output["messages"].add(mjson)
    }
    for node in self.nodes {
        output["nodes"].append(node.as_json_obj())
    }
    return output
}

var stmt_parse_funcs = [
    call_or_assign_stmt.parse,
    if_stmt.parse,
    func_stmt.parse,
    import_stmt.parse,
    return_stmt.parse,
    var_stmt.parse,
]

func parse_statement(
        tokens, pos, msgs, project_file=none, debug=no
        ) {
    var remaining_funcs = stmt_parse_funcs.copy()

    var next_func = remaining_funcs.pop()
    var stmt = next_func(tokens, pos, msgs,
        project_file=project_file, debug=debug)
    later:

    await stmt
    if stmt != none {
        return stmt
    }
    if remaining_funcs.len == 0 {
        var line = tokens[pos].line
        var col = tokens[pos].col
        msgs.add(new msg.FileMsg(
            "Unexpected token " +
            token.describe_token(tokens[pos]) +
            ", expected start of any recognized statement.",
            kind=msg.M_ERROR, source_file=project_file,
            line=line, col=col)
        )
        return none
    }

    next_func = remaining_funcs.pop()
    stmt = next_func(
        tokens, pos, msgs, project_file=project_file,
        debug=debug
    ) later repeat
}

func parse_to_ast_ex(
        tokens, pos, project_file=none,
        is_inside_block=no, debug=debug
        ) {
    var result = new ASTResult()
    const startpos = pos
    result.project_file = project_file

    # See if we're already at the end of statements:
    if pos > tokens.len or
            (is_inside_block and (
             (pos <= tokens.len and
              tokens[pos].kind == token.T_BRACKET and
              tokens[pos].str == "}") or
             token.surely_to_toplevel_even_in_bad_code(tokens, pos))) {
        return result
    }

    # Get next statement:
    var stmt = parse_statement(
        tokens, pos, result.msgs,
        project_file=project_file, debug=debug
    ) later:

    await stmt
    if stmt == none {
        # We completely failed to parse the next statement.
        # Skip to the next one:
        var skiplen = token.get_naive_stmt_or_expr_len(
            tokens, pos, for_expr=no
        )
        assert(skiplen > 0)
        var invalid_st = new invalid_stmt.InvalidStmt(skiplen)
        invalid_st.line = token.get_line(tokens, pos)
        invalid_st.col = token.get_col(tokens, pos)
        result.nodes.add(invalid_st)
        pos += skiplen
    } else {
        # Extracted a new statement.
        result.nodes.add(stmt)
        pos += stmt.token_len
    }

    if pos > tokens.len or
            (is_inside_block and (
             (pos <= tokens.len and
              tokens[pos].kind == token.T_BRACKET and
              tokens[pos].str == "}") or
             token.surely_to_toplevel_even_in_bad_code(tokens, pos))) {
        # We reached the end!
        result.token_len = pos - startpos
        return result
    }
    stmt = parse_statement(
        tokens, pos, result.msgs,
        project_file=project_file, debug=debug
    ) later repeat
}

func parse_to_ast(
        tokens, project_file=none, debug=no
        ) {
    var contents = parse_to_ast_ex(
        tokens, 1, project_file=project_file,
        is_inside_block=no, debug=debug
    ) later:

    await contents
    return contents
}

func _tokenize_this_file_for_ast(
        source, project_file=none, source_is_uri=no
        ) {
    if not source_is_uri {
        var tresult = token.tokenize_str(
            source, project_file=project_file, keep_whitespace=no
        )
        return tresult
    } else {
        var tresult = token.tokenize_from_uri(
            source, project_file=project_file,
            keep_whitespace=no
        ) later:

        await tresult
        return tresult
    }
}

func _parse_tokens_file_to_ast_ex(
        tokens_source, project_file=project_file,
        source_is_uri=no, debug=no
        ) {
    var tresult = _tokenize_this_file_for_ast(
        tokens_source, project_file=project_file,
        source_is_uri=source_is_uri
    )
    later:

    await tresult
    var aresult = parse_to_ast(
        tresult.tokens,
        project_file=tresult.project_file, debug=debug
    ) later:

    await aresult
    aresult.msgs = tresult.msgs + aresult.msgs
    return aresult
}

## @func parse_str_to_ast
## Parse the given code string to an @{Abstract Syntax
## Tree result|ASTResult}.
##
## @param codestr str The code @{str} containing Horse64 code.
## @param project_file (none, project.ProjectFile) If the string
##   originates from a known @{project file|project.ProjectFile},
##   specify it here to be set in the resulting diagnostic messages.
## @returns ASTResult The resulting syntax tree and diagnostic messages,
##   like parse errors or warnings.
func parse_str_to_ast(
        codestr, project_file=none, debug=no
        ) {
    var result = _parse_tokens_file_to_ast_ex(
        codestr, project_file=project_file, source_is_uri=no,
        debug=debug
    ) later:

    await result
    return result
}

## @func parse_to_ast_from_uri
## Parse the file referenced to by the URI to an @{Abstract Syntax
## Tree result|ASTResult}.
##
## @param fileuri str The URI of the target file.
## @param project_file (none, project.ProjectFile) If the string
##   originates from a known @{project file|project.ProjectFile},
##   specify it here to be set in the resulting diagnostic messages.
## @param default_to_diskpath bool If set to @{no} (default), a string
##   that isn't clearly an URI like `"example.com:443"` will be smartly
##   guessed as either remote or disk path and converted to a full URI.
##   If set to @{yes}, anything not clearly an URI will always be
##   considered a disk path and converted to a `file://` URI.
## @returns ASTResult The resulting syntax tree and diagnostic messages,
##   like parse errors or warnings.
func parse_to_ast_from_uri(
        fileuri, project_file=none, default_to_diskpath=no,
        debug=no
        ) {
    var result = _parse_tokens_file_to_ast_ex(
        uri.normalize(fileuri,
        guess_nonfiles=(not default_to_diskpath)),
        project_file=project_file,
        source_is_uri=yes, debug=debug
    ) later:

    await result
    return result
}

