## @module compiler.ast.builder
# Copyright (c) 2024, ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import random from core.horse64.org

import compiler.ast.call_or_assign_stmt as call_or_assign_stmt
import compiler.ast.expr as ast_expr
import compiler.ast.func_stmt as func_stmt
import compiler.ast.import_stmt as import_stmt
import compiler.ast.var_stmt as var_stmt
import compiler.cext as cext
import compiler.storage.ref as storage_ref
import compiler.storage.scope as st_scope
import compiler.token as token

type ASTBuilder {
    var project_file
    var project
}

func ASTBuilder.init(project_file) {
    self.project = project_file.project
    self.project_file = project_file
}

func ASTBuilder.make_unlock_hvm_lock_node(
        in_inner_scope, lock_name, lock_ref,
        line=none, col=none) {
    var optoken = new token.Token(
        "(", token.T_ENCLOSE, line, col
    )
    var lockexpr = new ast_expr.BinopExpr(optoken)
    lockexpr.line = line
    lockexpr.col = col
    var lockfuncexpr = new ast_expr.IdRefExpr()
    lockfuncexpr.scope = in_inner_scope
    lockfuncexpr.line = line
    lockfuncexpr.col = col
    lockfuncexpr.label = "$hvm_unlock_sync_lock"
    lockfuncexpr.ref = new storage_ref.StorageRef(
        storage_ref.ST_CEXT,
        cext.get_cext_item_storage_info(
            lockfuncexpr.label, project=self.project,
            can_match_moduleless=yes
        ).storage_id
    )
    var lockrefexpr = new ast_expr.IdRefExpr()
    lockrefexpr.scope = in_inner_scope
    lockrefexpr.line = line
    lockrefexpr.col = col
    lockrefexpr.label = lock_name
    lockrefexpr.ref = new storage_ref.StorageRef(
        lock_ref.kind, lock_ref.id
    )
    var lockargsexpr = new ast_expr.CallArgsExpr()
    lockargsexpr.scope = in_inner_scope
    lockargsexpr.line = line
    lockargsexpr.col = col
    lockargsexpr.subexprs = [lockrefexpr]
    lockexpr.subexprs = [lockfuncexpr, lockargsexpr]
    var call_stmt_node = new call_or_assign_stmt.CallStmt()
    call_stmt_node.subexprs = [lockexpr]
    return call_stmt_node
}

func ASTBuilder.make_lock_hvm_lock_node(
        in_inner_scope, lock_name, lock_ref,
        line=none, col=none) {
    var optoken = new token.Token(
        "(", token.T_ENCLOSE, line, col
    )
    var lockexpr = new ast_expr.BinopExpr(optoken)
    lockexpr.line = line
    lockexpr.col = col
    var lockfuncexpr = new ast_expr.IdRefExpr()
    lockfuncexpr.scope = in_inner_scope
    lockfuncexpr.line = line
    lockfuncexpr.col = col
    lockfuncexpr.label = "$hvm_lock_sync_lock"
    lockfuncexpr.ref = new storage_ref.StorageRef(
        storage_ref.ST_CEXT,
        cext.get_cext_item_storage_info(
            lockfuncexpr.label, project=self.project,
            can_match_moduleless=yes
        ).storage_id
    )
    var lockrefexpr = new ast_expr.IdRefExpr()
    lockrefexpr.scope = in_inner_scope
    lockrefexpr.line = line
    lockrefexpr.col = col
    lockrefexpr.label = lock_name
    lockrefexpr.ref = new storage_ref.StorageRef(
        lock_ref.kind, lock_ref.id
    )
    var lockargsexpr = new ast_expr.CallArgsExpr()
    lockargsexpr.scope = in_inner_scope
    lockargsexpr.line = line
    lockargsexpr.col = col
    lockargsexpr.subexprs = [lockrefexpr]
    lockexpr.subexprs = [lockfuncexpr, lockargsexpr]
    var call_stmt_node = new call_or_assign_stmt.CallStmt()
    call_stmt_node.subexprs = [lockexpr]
    return call_stmt_node
}

func ASTBuilder.make_create_lock_node(
        in_inner_scope, name_prefix,
        add_unique_suffix=no,
        line=none, col=none) {
    var optoken = new token.Token(
        "(", token.T_ENCLOSE, line, col
    )
    var lockexpr = new ast_expr.BinopExpr(optoken)
    lockexpr.line = line
    lockexpr.col = col
    var lockfuncexpr = new ast_expr.IdRefExpr()
    lockfuncexpr.scope = in_inner_scope
    lockfuncexpr.line = line
    lockfuncexpr.col = col
    lockfuncexpr.label = "$hvm_make_sync_lock"
    lockfuncexpr.ref = new storage_ref.StorageRef(
        storage_ref.ST_CEXT,
        cext.get_cext_item_storage_info(
            lockfuncexpr.label, project=self.project,
            can_match_moduleless=yes
        ).storage_id
    )
    var lockcallexpr = new ast_expr.CallArgsExpr()
    lockcallexpr.scope = in_inner_scope
    lockcallexpr.line = line
    lockcallexpr.col = col
    lockexpr.subexprs = [lockfuncexpr, lockcallexpr]
    return self.make_var_node(
        in_inner_scope, name_prefix,
        expr=lockexpr,
        add_unique_suffix=add_unique_suffix,
        line=line, col=col
    )
}

func ASTBuilder.make_add_to_named_list_node(
        in_inner_scope, list_name, list_ref,
        add_unique_suffix=no,
        line=none, col=none) {
    var optoken = new token.Token(
        "(", token.T_ENCLOSE, line, col
    )
    var lockexpr = new ast_expr.BinopExpr(optoken)
    lockexpr.line = line
    lockexpr.col = col
    var lockfuncexpr = new ast_expr.IdRefExpr()
    lockfuncexpr.scope = in_inner_scope
    lockfuncexpr.line = line
    lockfuncexpr.col = col
    lockfuncexpr.label = list_name
    lockfuncexpr.ref = list_ref
    var lockargexpr = new ast_expr.CallArgsExpr()
    lockargexpr.scope = in_inner_scope
    lockargexpr.line = line
    lockargexpr.col = col
    lockexpr.subexprs = [lockfuncexpr, lockargexpr]
    var call_stmt = new call_or_assign_stmt.CallStmt()
    call_stmt.scope = in_inner_scope
    call_stmt.line = line
    call_stmt.col = col
    call_stmt.subexprs = [lockexpr]
    return call_stmt
}

func ASTBuilder.make_var_node(
        in_inner_scope, name_prefix, expr=none,
        line=none, col=none, add_unique_suffix=no) {
    var new_name = name_prefix
    if add_unique_suffix {
        new_name = name_prefix + random.gen_id()
        while not in_inner_scope.name_is_free(new_name,
                self.project_file.global_scope) or
                self.project_file.
                    global_scope.name_to_stmt_map.has(new_name) {
            new_name = name_prefix + random.gen_id()
        }
    }
    var func_scope = none
    if in_inner_scope != none {
        func_scope = in_inner_scope.func_scope
    }
    var ref = none
    if func_scope == none {
        self.project.last_global_storage_id += 1
        var storage_id = self.project.last_global_storage_id
        ref = new storage_ref.StorageRef(
            storage_ref.ST_GLOBAL, storage_id
        )
        # FIXME: Register this in the global_scope.
        throw new RuntimeError("Not fully implemented.")
    } else {
        ref = in_inner_scope.add_symbol(new_name, line, col)
    }
    if expr == none {
        expr = new ast_expr.LiteralExpr()
        expr.scope = in_inner_scope
        expr.value = none
        expr.line = line
        expr.col = col
    }
    var var_node = new var_stmt.VarStmt()
    var_node.is_const = no
    var_node.scope = in_inner_scope
    var_node.func_scope = func_scope
    var_node.line = line
    var_node.col = col
    var_node.var_labels = [new_name]
    var_node.subexprs = [expr]
    var_node.var_has_protect = [no]
    if func_scope != none {
        var symbol_info = new st_scope.SymbolInfo(new_name)
        symbol_info.def_line = line
        symbol_info.def_col = col
        symbol_info.def_file = self
        symbol_info.storage_id =
            ref.id
        var_node.symbol_info = [
            symbol_info
        ]
    }
    return var_node
}

func ASTBuilder.make_func_node(
        in_inner_scope, name_prefix, line=none, col=none) {
    var new_name = name_prefix + random.gen_id()
    while not in_inner_scope.name_is_free(new_name,
            self.project_file.global_scope) {
        new_name = name_prefix + random.gen_id()
    }
    var func_scope = new st_scope.FuncScope()
    func_scope.inner_scope = new st_scope.LocalScope()
    func_scope.inner_scope.func_scope = func_scope
    func_scope.inner_scope.start_line = line
    func_scope.inner_scope.start_col = col
    func_scope.inner_scope.parent = in_inner_scope
    self.project.last_global_storage_id += 1
    func_scope.storage_id = self.project.last_global_storage_id
    var func_node = new func_stmt.FuncStmt()
    func_node.scope = in_inner_scope
    func_node.func_scope = func_scope
    func_node.line = line
    func_node.col = col
    func_node.label = new_name
    return func_node
}

