# @module compiler.ast.expr
# Copyright (c) 2020-2022,  ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import math from core.horse64.org

import compiler.ast as ast
import compiler.msg as msg
import compiler.token as token


enum ContainerKind {
    C_SET,
    C_MAP,
    C_VEC,
    C_LIST,
}

func container_kind_to_name(k) {
    if k == C_SET {
        return "set"
    } elseif k == C_MAP {
        return "map"
    } elseif k == C_VEC {
        return "vec"
    } elseif k == C_LIST {
        return "list"
    }
    throw new ValueError("Unexpected container kind.")
}

type ContainerExpr extends ast.TreeNode {
    ## @type ContainerKind
    var kind
    var values
}

func ContainerExpr.init {
    base.init()
    self.value = ast.N_EXPR_CONTAINER
}

type InvalidExpr extends ast.TreeNode {
}

func InvalidExpr.init(tlen) {
    base.init()
    self.value = ast.N_EXPR_INVALID
    self.token_len = tlen
}

type UnopExpr extends ast.TreeNode {
    var optoken
}

func UnopExpr.init {
    base.init()
    self.kind = ast.N_EXPR_UNOP
}

type BinopExpr extends ast.TreeNode {
    var optoken
}

func UnopExpr.init {
    base.init()
    self.kind = ast.N_EXPR_BINOP
}

type IdentExpr extends ast.TreeNode {
    var label
}

func IdentExpr.init {
    base.init()
    self.kind = ast.N_EXPR_IDENT
}

type LiteralExpr extends ast.TreeNode {
    var value
}

func LiteralExpr.init {
    base.init()
    self.kind = ast.N_EXPR_LIT
}

func token_continues_expr(t) {
    if t.kind == T_BRACKET {
        return (t.str == "(" or t.str == "[")
    }
    if {T_MATH, T_COMPARE, T_DOT}.has(t.kind) {
        return yes
    }
    if t.kind == T_BOOLCOMP and t.str != "not" {
        return yes
    }
    return no
}

func parse_container_entry(
        tokens, pos, msgs, container_kind,
        container_start_line=none, container_start_col=none,
        project_file=none, max_len=none, debug=no
        ) {
    var tokens_len = tokens.len
    if max_len != none {
        tokens_len = math.min(tokens_len, max_len)
    }
    var expr_1 = parse_expression(
        tokens, pos, msgs, project_file=project_file,
        max_len=tokens_len, debug=debug
    ) later:

    await expr_1
    if expr1 == none {
        return none
    }
    if container_kind != C_MAP and container_kind != C_VEC {
        return [expr1, none]
    }
    pos += expr_1.token_len
    if pos >= tokens_len or (container_type == C_MAP and
            tokens[pos].kind != C_MAPARROW) or
            (container_type == C_VEC and
            tokens[pos].kind != C_COLON) {
        var expected = "'->' (T_MAPARROW) for map"
        if container_type == C_VEC {
            expected = "':' (T_COLON) for vector"
        }
        msgs.add(new FileMsg(
            "Unexpected " + token.describe_token_at(
                tokens, pos) +
            ", expected " + expected + " "
            "in line " +
            container_start_line.as_str() +
            ", col " +
            container_start_col.as_str() + ".",
            source_file=project_file,
            line=token.get_line(tokens, pos),
            col=token.get_col(tokens, pos),
        ))
        return [expr1, none]
    }
    pos += 1
    var expr2 = parse_expression(
        tokens, pos, msgs, project_file=project_file,
        max_len=tokens_len, debug=debug
    ) later:

    await expr2
    return [expr1, expr2]
}

func parse_expression(
        tokens, pos, msgs, project_file=none,
        max_len=none, debug=no
        ) {
    if tokens.len > 0 and typename(tokens[1]) == "str" {
        tokens = token.token_list_from_str_list(tokens)
    }
    var tokens_len = tokens.len
    if max_len != none {
        tokens_len = math.min(max_len, tokens_len)
    }
    if debug {
        print("compiler.ast.expr: parse_expression() on " +
            tokens.sub(1, math.min(10, tokens_len)).as_str() +
            "...")
    }

    var inner_expr = parse_expression_unwrapped(
        tokens, pos, msgs, project_file=project_file,
        max_len=tokens_len, debug=debug
    ) later:

    await inner_expr
    if debug {
        print("compiler.ast.expr: parse_expression() on " +
            tokens.sub(1, math.min(10, tokens_len)).as_str() +
            "... fetched inner_expr -> " + inner_expr.as_str() +
            " (with token after: " + token.describe_token_at(
                tokens, pos + if inner_expr != none
                (inner_expr.token_len) else (0)
            ) + ")")
    }
    if inner_expr == none {
        return inner_expr
    }
    pos += inner_expr.token_len
    if pos <= tokens_len and token_continues_expr(tokens[pos]) {
        var wrapped_expr = parse_expression_unwrapped(
            tokens, pos, msgs, project_file=project_file,
            left_hand=inner_expr,
            max_len=tokens_len, debug=debug,
        ) later:

        await wrapped_expr
        return wrapped_expr
    }
    return inner_expr
}

func parse_expression_unwrapped(
        tokens, pos, msgs, project_file=none,
        left_hand=none, max_len=none, debug=no
        ) {
    var startpos = pos
    var startline = token.get_line(tokens, startpos)
    var startcol = token.get_col(tokens, startpos)
    var tokens_len = tokens.len
    if max_len != none {
        tokens_len = math.min(max_len, tokens_len)
    }

    if debug {
        print("compiler.ast.expr: parse_expression_unwrapped() on " +
            tokens.sub(pos, math.min(pos + 10, tokens_len)).as_str() +
            "...  with left_hand=" + left_hand.as_str())
    }

    if pos > tokens_len {
        return none
    }
    if left_hand == none {
        # Try to parse it as a single standalone expression
        # (which isn't combined by operators).

        # First, handle the most trivial literals:
        if tokens[pos].kind == token.T_STR {
            var node = LiteralExpr()
            node.value = token.parse_token_value(tokens[pos])
            node.token_len = 1
            node.line = startline
            node.col = startcol
            while pos + 1 <= tokens_len and
                    tokens[pos + 1].kind == token.T_STR {
                node.value += token.parse_token_value(tokens[pos + 1])
                node.token_len += 1
            }
            return node
        } elseif tokens[pos].kind == token.T_BYTES {
            var node = LiteralExpr()
            node.value = token.parse_token_value(tokens[pos])
            node.token_len = 1
            node.line = startline
            node.col = startcol
            while pos + 1 <= tokens_len and
                    tokens[pos + 1].kind == token.T_BYTES {
                node.value += token.parse_token_value(tokens[pos + 1])
                node.token_len += 1
            }
            return node
        } elseif {token.T_NUM, token.T_BOOL,
                  token.T_NONE}.has(tokens[pos].kind) {
            var node = LiteralExpr()
            node.value = token.parse_token_value(tokens[pos])
            node.token_len = 1
            node.line = startline
            node.col = startcol
            return node
        } elseif tokens[pos].kind == token.T_IDENT {
            var node = IdentExpr()
            node.label = tokens[pos].str
            node.token_len = 1
            node.line = startline
            node.col = startcol
            return node
        }
        # Handle bracketed expressions, like `(1 + 2)`:
        if tokens[pos].kind == token.T_BRACKET and
                tokens[pos].str == "(" {
            pos += 1
            var inner_expr = parse_expression(
                tokens, pos, msgs, project_file=none,
                left_hand=none, max_len=tokens_len,
                debug=debug,
            ) later:

            await inner_expr
            if inner_expr == none {
                msgs.add(new FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) +
                    ", expected any inner nested expression "
                    "following '(' in line " +
                    startline.as_str() +
                    ", col " +
                    startcol.as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                var preskippos = pos
                var skiplen = token.go_to_expr_end(
                    tokens, pos, max_len=tokens_len
                )
                inner_expr = new InvalidExpr(skiplen)
                inner_expr.line = token.get_line(
                    tokens, preskippos
                )
                inner_expr.col = token.get_col(
                    tokens, preskippos
                )
            }
            pos += inner_expr.token_len
            if pos >= tokens_len or
                    tokens[pos].kind != token.T_BRACKET or
                    tokens[pos].str != ")" {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) +
                    ", expected ')' (T_BRACKET) closing the "
                    "opening bracket '(' in line " +
                    startline.as_str() + 
                    ", col " +
                    startcol.as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
            } else {
                pos += 1
            }
            inner_expr.token_len = (pos - start_pos)
            return inner_expr
        }
        # Handle container constructors for map, list, set, vector:
        if tokens[pos].kind == token.T_BRACKET and
                {"{", "["}.has(tokens[pos].str) {
            var openbracket = tokens[pos].str
            pos += 1
            var node = ContainerExpr()
            node.line = startline
            node.col = startcol

            var ckind = C_LIST
            if openbracket == "{" {
                ckind = C_SET
            }
            var closebracket = reverse_brackets(tokens[pos].str)

            # Handle special cases: [], {}, [,], {,}, {->}
            if pos <= tokens_len and (
                    tokens[pos].kind == token.T_COMMA or
                    (tokens[pos].kind == token.T_BRACKET and
                     tokens[pos].str == closebracket) or
                    (openbracket == "{" and
                     tokens[pos].kind == token.T_MAPASSIGN)) {
                if openbracket == "{" {
                    if (tokens[pos].kind != token.T_MAPASSIGN) {
                        node.kind = C_SET
                    } else {
                        node.kind = C_MAP
                    }
                } else {
                    node.kind = C_LIST
                }
                pos += 1
                if pos > tokens_len or
                        tokens[pos].kind != token.T_BRACKET or
                        tokens[pos].str != closebracket {
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, pos) +
                        ", expected ')' (T_BRACKET) closing the "
                        "opening bracket '" +
                        openbracket + "' in line " +
                        startline.as_str() +
                        ", col " +
                        startcol.as_str() + ".",
                        source_file=project_file,
                        line=token.get_line(tokens, pos),
                        col=token.get_col(tokens, pos),
                    ))
                } else {
                    pos += 1
                }
                if node.is_set {
                    node.value = {}
                } elseif node.is_map {
                    node.value = {->}
                } else {
                    node.value = []
                }
                return node
            }

            # First, determine what type of container this is:
            var bdepth = 0
            var i = pos
            while i <= tokens_len and
                    (bdepth > 0 or
                    tokens[i].kind != token.T_BRACKET or
                    tokens[i].str != closebracket) {
                if tokens[i].kind == token.T_BRACKET {
                    if {"(", "[", "{"}.has(tokens[i].str) {
                        bdepth += 1
                    } else {
                        bdepth = math.max(0, bdepth - 1)
                    }
                }
                if bdepth > 0 {
                    i += 1
                    continue
                }
                if tokens[i].kind == token.T_MAPARROW and
                        openbracket == "{" {
                    ckind = C_MAP
                    break
                } elseif tokens[i].kind == token.T_COLON and
                        openbracket == "[" {
                    ckind = C_VEC
                    break
                } elseif tokens[i].kind == token.T_COMMA {
                    break
                }
                i += 1
            }

            var next_expr = parse_container_entry(
                tokens, pos, msgs, ckind,
                container_start_line=startline,
                container_start_col=startcol,
                project_file=project_file,
                max_len=tokens_len,
                debug=debug
            ) later:

            await next_expr
            var had_fatal_error = yes
            if next_expr == none {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) +
                    ", expected next entry for " +
                    container_kind_to_name(c_kind) +
                    " in line " +
                    startline.as_str() +
                    ", col " +
                    startcol.as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                had_fatal_error = yes
            }
            if not had_fatal_error {
                if ckind == C_MAP or ckind == C_VEC {
                    node.subexprs.add(next_expr[1])
                    pos += next_expr[1].token_len
                    pos += 1  # -> or : separator
                    if next_expr[2] == none {
                        # Means we had an inner parse error!
                        had_fatal_error = yes
                    } else {
                        node.subexprs.add(next_expr[2])
                        pos += next_expr[2].token_len
                    }
                } else {
                    node.subexprs.add(next_expr[1])
                    pos += next_expr[1].token_len
                }
            }
            if not had_fatal_error and (pos > tokens_len or
                    ((tokens[pos].kind != token.T_BRACKET or
                      tokens[pos].str != close_bracket) and
                     tokens[pos].kind != token.T_COMMA)) {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) +
                    ", expected ',' (T_COMMA) or '" +
                    close_bracket + "' to resume or end " +
                    container_kind_to_name(c_kind) +
                    " started in line " +
                    startline.as_str() +
                    ", col " +
                    startcol.as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                node.token_len = (pos - startpos)
                return node
            }
            if had_fatal_error {
                # Forward to final closing bracket and abort.
                bdepth = 0
                while pos <= tokens_len and
                        (bdepth > 0 or
                        tokens[pos].kind != token.T_BRACKET or
                        not {")", "]", "}"}.has(tokens[pos].str)) {
                    if tokens[pos].kind == token.T_BRACKET {
                        if {")", "]", "}"}.has(tokens[pos].str) {
                            bdepth -= 1
                        } else {
                            bdepth += 1
                        }
                    }
                    pos += 1
                }
                if pos <= tokens_len {
                    pos += 1  # Go past closing bracket.
                }
                node.token_len = (pos - startpos)
                return node
            }
            if tokens[pos].kind != T_COMMA or
                    (pos + 1 <= tokens_len and
                    tokens[pos + 1].kind == token.T_BRACKET and
                    tokens[pos + 1].str == closingbracket) {
                # We're at the closing bracket.
                if tokens[pos].kind == T_COMMA {
                    pos += 2  # Past ',' and past '}'/']'.
                } else {
                    pos += 1  # Past '}'/']'.
                }
                node.token_len = (pos - startpos)
                return node
            }
            pos += 1  # Go past ',' to next entry.

            # Resume with next entry:
            next_expr = parse_container_entry(
                tokens, pos, msgs, ckind,
                container_start_line=startline,
                container_start_col=startcol,
                project_file=project_file,
                max_len=tokens_len,
                debug=debug,
            ) later repeat
        }
        return none
    }
    # Handle call, member access, and indexing operators:
    if lefthand != none and
            (tokens[pos].kind == token.T_DOT or
             (tokens[pos].kind == token.T_BRACKET and
              {"(", "["}.has(tokens[pos].str))) {
        var openbracket =
            if tokens[pos].kind == token.T_BRACKET
            (tokens[pos].str) else (none)
        pos += 1  # Go past opening bracket.
        var node = new BinopExpr()
        node.line = startline
        node.col = startcol
        var inner_expr = parse_expression(
            tokens, pos, msgs, project_file=none,
            left_hand=none, max_len=tokens_len,
            debug=debug,
        ) later:

        await inner_expr
        if inner_expr == none {
            msgs.add(new msg.FileMsg(
                "Unexpected " + token.describe_token_at(
                    tokens, pos) +
                ", expected operand expression following "
                "binary operator " + token.describe_token_at(
                    tokens, startpos) + " "
                "found in line " +
                startline.as_str() +
                ", col " +
                startcol.as_str() + ".",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            # Go past whatever nonsense we can't parse:
            var preskippos = pos
            var skiplen = token.go_to_expr_end(
                tokens, pos, max_len=tokens_len
            )
            if pos + skiplen <= tokens_len and
                    openbracket != none and
                    tokens[pos + skiplen].kind ==
                        token.T_BRACKET and
                    token.reverse_brackets(
                        tokens[pos + skiplen].str
                    ) == openbracket {
                # Include the closing bracket to our '['/'(' too:
                skiplen += 1
            }
            node.subexprs.add(new InvalidExpr(skiplen))
            node.subexprs.last().line = token.get_line(
                tokens, preskippos
            )
            node.subexprs.last().col = token.get_col(
                tokens, preskippos
            )
        } else {
            node.subexprs.add(inner_expr)
            pos += inner_expr.token_len
            if openbracket != none and
                    (pos >= tokens_len or
                    tokens[pos].kind != token.T_BRACKET or
                    reverse_bracket(openbracket) != tokens[pos].str) {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) +
                    ", expected '" + reverse_bracket(openbracket) +
                    "' to close '" + openbracket + "' "
                    "found in line " +
                    startline.as_str() +
                    ", col " +
                    startcol.as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
            } elseif openbracket != none {
                pos += 1  # Go past closing bracket.
            }
        }
        node.token_len = (pos - startpos)
        return node
    }
    # Handle expressions prefixed by unary operators:
    if lefthand == none and
            (tokens[pos].kind == token.T_UNARYMATH or
             tokens[pos].kind == token.T_NEWOP or (
             tokens[pos].kind == token.T_BOOLCOMP and
             tokens[pos].str == "not")) {
        pos += 1  # Go past the unary operator itself.
        var node = new UnopExpr()
        node.line = startline
        node.col = startcol
        var inner_expr = parse_expression(
            tokens, pos, msgs, project_file=none,
            left_hand=none, max_len=tokens_len,
            debug=debug,
        ) later:

        await inner_expr
        if inner_expr == none {
            msgs.add(new msg.FileMsg(
                "Unexpected " + token.describe_token_at(
                    tokens, pos) +
                ", expected operand expression following "
                "unary operator " + token.describe_token_at(
                    tokens, startpos) + " "
                "found in line " +
                startline.as_str() +
                ", col " +
                startcol.as_str() + ".",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            # Skip past whatever we can't parse:
            var preskippos = pos
            var skiplen = token.go_to_expr_end(
                tokens, pos, max_len=tokens_len
            )
            node.subexprs.add(new InvalidExpr(skiplen))
            node.subexprs.last().line = token.get_line(
                tokens, preskippos
            )
            node.subexprs.last().col = token.get_col(
                tokens, preskippos
            )
            pos += skiplen
        } else {
            node.subexprs.add(inner_expr)
            pos += inner_expr.token_len
        }
        node.token_len = (pos - startpos)
        return node
    }
    # Handle expressions combined by binary operators:
    if (lefthand != none and (
             {T_MATH, T_COMPARE}.has(tokens[pos].kind) or
             (tokens[pos].kind == token.T_BOOLCOMP and
              tokens[pos].str != "not"))) {
        var outer_level_ops_operands = []
        if lefthand != none {
            outer_level_ops_operands.add(lefthand)
        }
        var outer_level_ops_at = [pos]

        # First, collect all operators for precedence ordering:
        var bdepth = 0
        var i = pos + 1
        while i <= tokens_len {
            if tokens[i].kind == token.T_BRACKET {
                if {"{", "(", "["}.has(tokens[i].str) {
                    bdepth += 1
                } else {
                    bdepth -= 1
                }
            } elseif {T_MATH, T_COMPARE,
                    T_BOOLCOMP}.has(tokens[i].kind) and
                    (tokens[i].kind != token.T_UNARYMATH and
                     (tokens[i].kind != token.T_BOOLCOMP or
                      tokens[i].str != "not")) {
                outer_level_ops_at.add(i)
            }
            i += 1
        }

        # 
    }
}

