# @module compiler.ast.expr
# Copyright (c) 2020-2023, ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import base64 from core.horse64.org
import math from core.horse64.org
import random from core.horse64.org

import compiler.ast as ast
import compiler.msg as msg
import compiler.operator as operator
import compiler.token as token

enum ContainerKind {
    C_SET,
    C_MAP,
    C_VEC,
    C_LIST,
}

func container_kind_to_name(k) {
    if k == C_SET {
        return "set"
    } elseif k == C_MAP {
        return "map"
    } elseif k == C_VEC {
        return "vec"
    } elseif k == C_LIST {
        return "list"
    }
    throw new ValueError("Unexpected container kind.")
}

type ContainerExpr base ast.TreeNode {
    ## @type ContainerKind
    var kind
    var values
}

func ContainerExpr.init {
    base.init()
    self.kind = ast.N_EXPR_CONTAINER
}

type InvalidExpr base ast.TreeNode {
}

func InvalidExpr.init(tlen) {
    base.init()
    self.kind = ast.N_EXPR_INVALID
    self.token_len = tlen
    self.damaged = yes
}

type UnopExpr base ast.TreeNode {
    var optoken
}

func UnopExpr.init(optoken) {
    base.init()
    self.kind = ast.N_EXPR_UNOP
    self.optoken = optoken
}

func UnopExpr.as_json_obj {
    var output = base.as_json_obj()
    output["optoken"] = self.optoken.str
    return output
}

type BinopExpr base ast.TreeNode {
    var optoken
}

func BinopExpr.init(optoken) {
    base.init()
    self.kind = ast.N_EXPR_BINOP
    self.optoken = optoken
}

func BinopExpr.as_json_obj {
    var output = base.as_json_obj()
    output["optoken"] = self.optoken.str
    return output
}

type IdRefExpr base ast.TreeNode {
    var label
    var typepath
}

func IdRefExpr.init {
    base.init()
    self.kind = ast.N_EXPR_IDREF
}

func IdRefExpr.as_json_obj {
    var output = base.as_json_obj()
    output["label"] = self.label
    return output
}

type BaseRefExpr base ast.TreeNode {
}

func BaseRefExpr.init {
    base.init()
    self.kind = ast.N_EXPR_BASEREF
}

type LiteralExpr base ast.TreeNode {
    var value
}

func LiteralExpr.init {
    base.init()
    self.kind = ast.N_EXPR_LIT
}

func LiteralExpr.as_json_obj {
    var output = base.as_json_obj()
    if typename(self.value) == "bytes" {
        output["value-base64"] = base64.dump(self.value)
    } else {
        output["value"] = self.value
    }
    return output
}

type InlineIfExpr base ast.TreeNode {
}

func InlineIfExpr.init {
    base.init()
    self.kind = ast.N_EXPR_INLINEIF
}

func InlineIfExpr.as_json_obj {
    var output = base.as_json_obj()
    return output
}

func token_continues_expr(t) {
    if t.kind == token.T_BRACKET {
        return (t.str == "(" or t.str == "[")
    }
    if {token.T_MATH, token.T_COMPARE, token.T_DOT}.has(t.kind) {
        return yes
    }
    if t.kind == token.T_BOOLCOMP and t.str != "not" {
        return yes
    }
    return no
}

func parse_container_entry(
        tokens, pos, msgs, container_kind,
        container_start_line=none, container_start_col=none,
        project_file=none, max_len=none, debug=no
        ) {
    var tokens_len = tokens.len
    if max_len != none {
        tokens_len = math.min(tokens_len, max_len)
    }
    var expr1 = parse_expression(
        tokens, pos, msgs, project_file=project_file,
        max_len=tokens_len, debug=debug
    ) later:

    await expr1
    if expr1 == none {
        return none
    }
    if container_kind != C_MAP and container_kind != C_VEC {
        return [expr1, none]
    }
    pos += expr1.token_len
    if pos >= tokens_len or (container_kind == C_MAP and
            tokens[pos].kind != token.T_MAPASSIGN) or
            (container_kind == C_VEC and
            tokens[pos].kind != token.T_COLON) {
        var expected = "'->' (T_MAPASSIGN) for map"
        if container_kind == C_VEC {
            expected = "':' (T_COLON) for vector"
        }
        msgs.add(new msg.FileMsg(
            "Unexpected " + token.describe_token_at(
                tokens, pos) +
            ", expected " + expected + " "
            "in line " +
            container_start_line.as_str() +
            ", col " +
            container_start_col.as_str() + ".",
            source_file=project_file,
            line=token.get_line(tokens, pos),
            col=token.get_col(tokens, pos),
        ))
        expr1.damaged = yes
        return [expr1, none]
    }
    pos += 1
    var expr2 = parse_expression(
        tokens, pos, msgs, project_file=project_file,
        max_len=tokens_len, debug=debug
    ) later:

    await expr2
    return [expr1, expr2]
}

func parse_expression(
        tokens, pos, msgs, project_file=none,
        max_len=none, debug=no
        ) {
    var tokens_len = tokens.len
    if max_len != none {
        tokens_len = math.min(max_len, tokens_len)
    }
    if pos > tokens_len {
        return later none
    }
    var debug_id = none
    if debug {
        debug_id = random.gen_id()
        print("compiler.ast.expr: parse_expression() " +
            debug_id + " on " +
            tokens.sub(pos, math.min(pos + 10, tokens_len)).as_str() +
            "... with pos=" + pos.as_str() + ", "
            "tokens.len=" + tokens.len.as_str() + ", "
            "max_len=" + max_len.as_str())
    }
    var origpos = pos
    var inner_expr = none

    var wrapping_expr = parse_expression_unwrapped(
        tokens, pos, msgs, project_file=project_file,
        left_hand=inner_expr,
        max_len=tokens_len, debug=debug
    ) later:

    await wrapping_expr
    if debug {
        print("compiler.ast.expr: parse_expression() " +
            debug_id + " "
            "fetched wrapping_expr -> " + wrapping_expr.as_str() + " "
            "(with len " + if wrapping_expr != none (
                wrapping_expr.token_len.as_str()) else ("<none>") + " "
            "token after: " + token.describe_token_at(
                tokens, origpos + if wrapping_expr != none
                (wrapping_expr.token_len) else (0)
            ) + ")")
    }
    assert(wrapping_expr == none or wrapping_expr.token_len != none)
    if wrapping_expr == none or
            origpos + wrapping_expr.token_len > tokens_len or
            not token_continues_expr(tokens[
                origpos + wrapping_expr.token_len
            ]) {
        if debug {
            print("compiler.ast.expr: parse_expression() " +
                debug_id + " returning result.")
        }
        return wrapping_expr
    }
    if debug {
        print("compiler.ast.expr: parse_expression() " +
            debug_id + " trying to wrap further...")
    }
    inner_expr = wrapping_expr
    pos = origpos + inner_expr.token_len

    wrapped_expr = parse_expression_unwrapped(
        tokens, pos, msgs, project_file=project_file,
        left_hand=inner_expr,
        max_len=tokens_len, debug=debug,
    ) later repeat
}

func parse_expression_unwrapped(
        tokens, pos, msgs, project_file=none,
        left_hand=none, max_len=none, debug=no
        ) {
    var startpos = pos
    var startline = token.get_line(tokens, startpos)
    var startcol = token.get_col(tokens, startpos)
    var tokens_len = tokens.len
    if max_len != none {
        tokens_len = math.min(max_len, tokens_len)
    }

    var debug_id = none
    if debug {
        debug_id = random.gen_id()
        print("compiler.ast.expr: parse_expression_unwrapped() " +
            debug_id + " on " +
            tokens.sub(pos, math.min(pos + 10, tokens_len)).as_str() +
            "...  with left_hand=" + left_hand.as_str())
    }

    if pos > tokens_len {
        return none
    }
    if left_hand == none {
        # Try to parse it as a single standalone expression
        # (which isn't combined by operators).

        # First, handle the most trivial literals:
        if tokens[pos].kind == token.T_STR {
            # A string literal, e.g. "'test''
            var node = LiteralExpr()
            node.value = token.parse_token_value(tokens[pos])
            node.token_len = 1
            node.line = startline
            node.col = startcol
            while pos + 1 <= tokens_len and
                    tokens[pos + 1].kind == token.T_STR {
                node.value += token.parse_token_value(tokens[pos + 1])
                node.token_len += 1
                pos += 1
            }
            return node
        } elseif tokens[pos].kind == token.T_BYTES {
            # A bytes literal, e.g. "b'test'"
            var node = LiteralExpr()
            node.value = token.parse_token_value(tokens[pos])
            node.token_len = 1
            node.line = startline
            node.col = startcol
            while pos + 1 <= tokens_len and
                    tokens[pos + 1].kind == token.T_BYTES {
                node.value += token.parse_token_value(tokens[pos + 1])
                node.token_len += 1
            }
            return node
        } elseif {token.T_NUM, token.T_BOOL,
                  token.T_NONE}.has(tokens[pos].kind) {
            # Bool, number, and none literals.
            var node = new LiteralExpr()
            node.value = token.parse_token_value(tokens[pos])
            node.token_len = 1
            node.line = startline
            node.col = startcol
            return node
        } elseif tokens[pos].kind == token.T_IDENT {
            # An identifier expression.
            var node = new IdRefExpr()
            node.label = tokens[pos].str
            node.token_len = 1
            node.line = startline
            node.col = startcol
            return node
        } elseif tokens[pos].kind == token.T_KEYWORD and
                tokens[pos].str == "base" {
            # A "base" referencing expression
            var node = new BaseRefExpr()
            node.token_len = 1
            node.line = startline
            node.col = startcol
            return node
        }
        # Handle bracketed expressions, like `(1 + 2)`:
        if tokens[pos].kind == token.T_BRACKET and
                tokens[pos].str == "(" {
            pos += 1
            var inner_expr = parse_expression(
                tokens, pos, msgs, project_file=none,
                 max_len=tokens_len, debug=debug,
            ) later:

            await inner_expr
            if inner_expr == none {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) +
                    ", expected any inner nested expression "
                    "following '(' in line " +
                    startline.as_str() +
                    ", col " +
                    startcol.as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                var preskippos = pos
                var skiplen = token.get_naive_stmt_or_expr_len(
                    tokens, pos, max_len=tokens_len,
                    for_expr=yes
                )
                inner_expr = new InvalidExpr(skiplen)
                inner_expr.line = token.get_line(
                    tokens, preskippos
                )
                inner_expr.col = token.get_col(
                    tokens, preskippos
                )
            }
            assert(inner_expr.token_len != none)
            pos += inner_expr.token_len
            if pos > tokens_len or
                    tokens[pos].kind != token.T_BRACKET or
                    tokens[pos].str != ")" {
                if not inner_expr.has_damage() {
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, pos) +
                        ", expected ')' (T_BRACKET) closing the "
                        "opening bracket '(' in line " +
                        startline.as_str() +
                        ", col " +
                        startcol.as_str() + ".",
                        source_file=project_file,
                        line=token.get_line(tokens, pos),
                        col=token.get_col(tokens, pos),
                    ))
                }
                inner_expr.damaged = yes

                # Try to find actual closing bracket:
                pos = token.skip_garbage_to_closing_item(
                    tokens, pos, token.T_BRACKET, "(",
                    max_len=tokens_len,
                )
                # If we're at a proper closing bracket, consume it:
                if pos <= tokens_len and
                        tokens[pos].kind == token.T_BRACKET and
                        {")", "]", "}"}.has(token[pos].str) {
                    pos += 1  # Past whatever closing thing we found.
                }
            } else {
                pos += 1  # Past closing ')'.
                assert(tokens[startpos].str == "(")
                assert(tokens[pos - 1].str == ")")
            }
            inner_expr.token_len = (pos - startpos)
            return inner_expr
        }
        # Handle container constructors for map, list, set, vector:
        if tokens[pos].kind == token.T_BRACKET and
                {"{", "["}.has(tokens[pos].str) {
            var openbracket = tokens[pos].str
            pos += 1
            var node = new ContainerExpr()
            node.line = startline
            node.col = startcol

            var ckind = C_LIST
            if openbracket == "{" {
                ckind = C_SET
            }
            var closebracket = token.reverse_brackets(tokens[pos - 1].str)

            # Handle special cases: [], {}, [,], {,}, {->}
            if pos <= tokens_len and (
                    tokens[pos].kind == token.T_COMMA or
                    (tokens[pos].kind == token.T_BRACKET and
                     tokens[pos].str == closebracket) or
                    (openbracket == "{" and
                     tokens[pos].kind == token.T_MAPASSIGN)) {
                if openbracket == "{" {
                    if (tokens[pos].kind != token.T_MAPASSIGN) {
                        node.kind = C_SET
                        if (tokens[pos].kind == token.T_COMMA) {
                            pos += 1
                        }
                    } else {
                        ckind = C_MAP
                        pos += 1
                    }
                } else {
                    ckind = C_LIST
                    if (tokens[pos].kind == token.T_COMMA) {
                        pos += 1
                    }
                }
                if pos > tokens_len or
                        tokens[pos].kind != token.T_BRACKET or
                        tokens[pos].str != closebracket {
                    if not node.has_damage() {
                        msgs.add(new msg.FileMsg(
                            "Unexpected " + token.describe_token_at(
                                tokens, pos) +
                            ", expected ')' (T_BRACKET) closing the "
                            "opening bracket '" +
                            openbracket + "' in line " +
                            startline.as_str() +
                            ", col " +
                            startcol.as_str() + ".",
                            source_file=project_file,
                            line=token.get_line(tokens, pos),
                            col=token.get_col(tokens, pos),
                        ))
                    }
                    node.damaged = yes
                } else {
                    pos += 1
                }
                if ckind == C_SET {
                    node.value = {}
                } elseif ckind == C_MAP {
                    node.value = {->}
                } else {
                    node.value = []
                }
                node.token_len = (pos - startpos)
                return node
            }

            # First, determine what type of container this is:
            var bracket_depth = 0
            var i = pos
            while i <= tokens_len and
                    (bracket_depth > 0 or
                    tokens[i].kind != token.T_BRACKET or
                    tokens[i].str != closebracket) {
                if tokens[i].kind == token.T_BRACKET {
                    if {"(", "[", "{"}.has(tokens[i].str) {
                        bracket_depth += 1
                    } else {
                        bracket_depth = math.max(0, bracket_depth - 1)
                    }
                }
                if bracket_depth > 0 {
                    i += 1
                    continue
                }
                if tokens[i].kind == token.T_MAPASSIGN and
                        openbracket == "{" {
                    ckind = C_MAP
                    break
                } elseif tokens[i].kind == token.T_COLON and
                        openbracket == "[" {
                    ckind = C_VEC
                    break
                } elseif tokens[i].kind == token.T_COMMA {
                    break
                }
                i += 1
            }

            var next_expr = parse_container_entry(
                tokens, pos, msgs, ckind,
                container_start_line=startline,
                container_start_col=startcol,
                project_file=project_file,
                max_len=tokens_len,
                debug=debug
            ) later:

            await next_expr
            var had_fatal_error = yes
            if next_expr == none {
                if pos > tokens_len or
                        tokens[pos] != token.T_BRACKET or
                        tokens[pos].str != closingbracket {
                    if not node.has_damage() {
                        msgs.add(new msg.FileMsg(
                            "Unexpected " + token.describe_token_at(
                                tokens, pos) +
                            ", expected next entry for " +
                            container_kind_to_name(ckind) +
                            " in line " +
                            startline.as_str() +
                            ", col " +
                            startcol.as_str() + ".",
                            source_file=project_file,
                            line=token.get_line(tokens, pos),
                            col=token.get_col(tokens, pos),
                        ))
                    }
                    had_fatal_error = yes
                }
            }
            if not had_fatal_error and next_expr != none {
                if ckind == C_MAP or ckind == C_VEC {
                    node.subexprs.add(next_expr[1])
                    pos += next_expr[1].token_len
                    pos += 1  # -> or : separator
                    if next_expr[2] == none {
                        # Means we had an inner parse error!
                        had_fatal_error = yes
                    } else {
                        node.subexprs.add(next_expr[2])
                        pos += next_expr[2].token_len
                    }
                } else {
                    node.subexprs.add(next_expr[1])
                    pos += next_expr[1].token_len
                }
            }
            if not had_fatal_error and (pos > tokens_len or
                    ((tokens[pos].kind != token.T_BRACKET or
                      tokens[pos].str != close_bracket) and
                     tokens[pos].kind != token.T_COMMA)) {
                if not node.has_damage() {
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, pos) +
                        ", expected ',' (T_COMMA) or '" +
                        close_bracket + "' to resume or end " +
                        container_kind_to_name(c_kind) +
                        " started in line " +
                        startline.as_str() +
                        ", col " +
                        startcol.as_str() + ".",
                        source_file=project_file,
                        line=token.get_line(tokens, pos),
                        col=token.get_col(tokens, pos),
                    ))
                }
                node.damaged = yes
                node.token_len = (pos - startpos)
                return node
            }
            if had_fatal_error {
                # Forward to final closing bracket and abort.
                bdepth = 0
                while pos <= tokens_len and
                        (bdepth > 0 or
                        tokens[pos].kind != token.T_BRACKET or
                        not {")", "]", "}"}.has(tokens[pos].str)) {
                    if tokens[pos].kind == token.T_BRACKET {
                        if {")", "]", "}"}.has(tokens[pos].str) {
                            bdepth -= 1
                        } else {
                            bdepth += 1
                        }
                    }
                    pos += 1
                }
                if pos <= tokens_len {
                    pos += 1  # Go past closing bracket.
                }
                node.damaged = yes
                node.token_len = (pos - startpos)
                return node
            }
            if tokens[pos].kind != token.T_COMMA or
                    (pos + 1 <= tokens_len and
                    tokens[pos + 1].kind == token.T_BRACKET and
                    tokens[pos + 1].str == closingbracket) {
                # We're at the closing bracket.
                if tokens[pos].kind == token.T_COMMA {
                    pos += 2  # Past ',' and past '}'/']'.
                } else {
                    pos += 1  # Past '}'/']'.
                }
                node.token_len = (pos - startpos)
                return node
            }
            pos += 1  # Go past ',' to next entry.

            # Resume with next entry:
            next_expr = parse_container_entry(
                tokens, pos, msgs, ckind,
                container_start_line=startline,
                container_start_col=startcol,
                project_file=project_file,
                max_len=tokens_len,
                debug=debug,
            ) later repeat
        }
    }
    # Handle inline 'if':
    if left_hand == none and
            tokens[pos].kind == token.T_KEYWORD and
            tokens[pos].str == "if" {
        var if_idx = pos
        var past_cond_idx = token.get_inline_if_conditional_end(
            tokens, pos, max_len=tokens_len
        )
        assert(past_cond_idx <= tokens_len)
        if past_cond_idx >= 1 {  # This means it's an actual inline 'if'.
            assert(tokens[past_cond_idx].kind == token.T_BRACKET and
                   tokens[past_cond_idx].str == "(")
            pos += 1
            var had_error = no

            var cond_expr = parse_expression(
                tokens, pos, msgs, project_file=project_file,
                max_len=(past_cond_idx - 1), debug=debug,
            ) later:

            await cond_expr
            if cond_expr == none {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) +
                    ", expected conditional for inline if "
                    "expression.",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                had_error = yes
                cond_expr = new InvalidExpr(
                    math.max(1, past_cond_idx - pos)
                )
            }
            pos = past_cond_idx + 1

            func extract_return_bracket_expr(pos, max_idx=none) {
                var value_start = pos
                var value_expr = parse_expression(
                    tokens, pos, msgs, project_file=project_file,
                    max_len=max_idx, debug=debug,
                ) later:

                await value_expr
                if value_expr == none {
                    if not had_error {
                        msgs.add(new msg.FileMsg(
                            "Unexpected " + token.describe_token_at(
                                tokens, pos) +
                            ", expected bracketed return value "
                            "for inline if starting in line " +
                            token.get_line(tokens, if_idx).as_str() +
                            ", column " +
                            token.get_col(tokens, if_idx).as_str() +
                            ".",
                            source_file=project_file,
                            line=token.get_line(tokens, pos),
                            col=token.get_col(tokens, pos),
                        ))
                    }
                    had_error = yes
                    value_expr = new InvalidExpr(1)
                } else {
                    pos += value_expr.token_len
                }
                if pos > tokens_len or
                        tokens[pos].kind != token.T_BRACKET or
                        tokens[pos].str != ")" {
                    if not had_error {
                        msgs.add(new msg.FileMsg(
                            "Unexpected " + token.describe_token_at(
                                tokens, pos) +
                            ", expected ')' to end bracketed return "
                            "value for inline if starting in "
                            "line " +
                            token.get_line(tokens, if_idx).as_str() +
                            ", column " +
                            token.get_col(tokens, if_idx).as_str() +
                            ".",
                            source_file=project_file,
                            line=token.get_line(tokens, pos),
                            col=token.get_col(tokens, pos),
                        ))
                    }
                    had_error = yes
                    var bracket_depth = 1
                    while pos <= tokens_len {
                        if tokens[pos].kind == token.T_BRACKET {
                            if {"(", "[", "{"}.has(tokens[pos].str) {
                                bracket_depth += 1
                            } else {
                                assert({")", "]", "}"}.has(
                                    tokens[pos].str))
                                bracket_depth -= 1
                                if bracket_depth <= 0 {
                                    break
                                }
                            }
                        }
                        pos += 1
                    }
                    value_expr.token_len = (pos - value_start)
                }
                assert(value_expr != none)
                return later value_expr
            }

            # Get first return expression for 'yes' branch:
            var value1_expr = extract_return_bracket_expr(
                pos
            ) later:

            await value1_expr
            assert(value1_expr != none)
            pos += value1_expr.token_len
            if pos < past_cond_idx {
                pos = past_cond_idx
            }
            if pos <= tokens_len and
                    tokens[pos].kind == token.T_BRACKET and
                    tokens[pos].str == ")" {
                pos += 1
            }
            if pos > tokens_len or
                    tokens[pos].kind != token.T_KEYWORD or
                    tokens[pos].str != "else" {
                if not had_error {
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, pos) +
                        ", expected 'else' to continue the "
                        "inline if starting in line " +
                        token.get_line(tokens, if_idx).as_str() +
                        ", column " +
                        token.get_col(tokens, if_idx).as_str() +
                        ".",
                        source_file=project_file,
                        line=token.get_line(tokens, pos),
                        col=token.get_col(tokens, pos),
                    ))
                }
                had_error = yes
            } else {
                pos += 1  # Go past 'else'.
            }
            if pos > tokens_len or
                    tokens[pos].kind != token.T_BRACKET or
                    tokens[pos].str != "(" {
                if not had_error {
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, pos) +
                        ", expected '(' for second bracketed "
                        "return value of the "
                        "inline if starting in line " +
                        token.get_line(tokens, if_idx).as_str() +
                        ", column " +
                        token.get_col(tokens, if_idx).as_str() +
                        ".",
                        source_file=project_file,
                        line=token.get_line(tokens, pos),
                        col=token.get_col(tokens, pos),
                    ))
                }
                had_error = yes
            } else {
                pos += 1  # Go past '('.
            }
            var value2_expr = extract_return_bracket_expr(
                pos
            ) later:

            await value2_expr
            assert(value2_expr != none)
            pos += value2_expr.token_len
            if pos <= tokens_len and
                    tokens[pos].kind == token.T_BRACKET and
                    tokens[pos].str == ")" {
                pos += 1
            }
            var node = new InlineIfExpr()
            node.line = token.get_line(tokens, if_idx)
            node.col = token.get_col(tokens, if_idx)
            node.subexprs.add(value1_expr)
            node.subexprs.add(value2_expr)
            node.token_len = (pos - if_idx)
            return node
        }
    }
    # Handle 'new' operator:
    if left_hand == none and
            tokens[pos].kind == token.T_NEWOP {
        pos += 1  # Go past opening bracket.
        var node = new BinopExpr(tokens[pos - 1])
        node.line = startline
        node.col = startcol

        var inner_expr = parse_expression(
            tokens, pos, msgs, project_file=none,
            max_len=tokens_len, debug=debug,
        ) later:

        await inner_expr
        node.subexprs.add(inner_expr)
        node.token_len = (inner_expr.token_len - 1) +
            (pos - startpos) + 1
        return node
    }
    # Handle call, member access, and indexing operators:
    if left_hand != none and
            (tokens[pos].kind == token.T_DOT or
             (tokens[pos].kind == token.T_BRACKET and
              {"(", "["}.has(tokens[pos].str))) {
        if debug {
            print("compiler.ast.expr: parse_expression_unwrapped() " +
                debug_id + " discovered call/member/index op " +
                token.describe_token(tokens[pos]) + " at index=" +
                pos.as_str())
        }

        var orig_left_hand_len = left_hand.token_len
        var openbracket =
            if tokens[pos].kind == token.T_BRACKET
            (tokens[pos].str) else (".")
        var op_pos = pos
        pos += 1  # Go past opening bracket.
        var node = new BinopExpr(tokens[pos - 1])
        node.line = startline
        node.col = startcol
        if left_hand and left_hand.line != none {
            node.line = left_hand.line
            node.col = left_hand.col
        }
        node.subexprs.add(left_hand)

        ## Helper function to either parse a right-hand item as
        ## call args for '(', or generic bracketed expression for
        ## '[' and '.' operands.
        func get_bracketed_expression {
            if openbracket == '(' {
                var parse_pos = pos - 1  # Revert back onto bracket
                var inner_expr = parse_call_or_funcdef_args(
                    tokens, parse_pos, msgs, project_file=project_file,
                    is_call=yes,
                    callordef_line=token.get_line(tokens, op_pos),
                    callordef_col=token.get_col(tokens, op_pos)
                ) later:

                await inner_expr
                assert(inner_expr != none)
                inner_expr.token_len -= 1  # Due to parse_pos = pos - 1.
                if inner_expr.token_len > 0 and
                        pos + inner_expr.token_len - 1 <= tokens_len and
                        tokens[pos + inner_expr.token_len - 1].kind ==
                            token.T_BRACKET and
                        tokens[pos + inner_expr.token_len - 1].str == ")" {
                    inner_expr.token_len -= 1  # Exclude closing ')'.
                }
                return inner_expr
            } elseif openbracket == '.' {
                # We only shall consume a following identifier, not
                # more. Otherwise, nesting precedence is messed up.
                if pos > tokens_len or
                        tokens[pos].kind != token.T_IDENT {
                    return none
                }
                var iep = new IdRefExpr()
                iep.label = tokens[pos].str
                iep.col = tokens[pos].col
                iep.line = tokens[pos].line
                iep.token_len = 1
                return iep
            }
            # Parse until the expression naturally ends for '[':
            assert(openbracket == '[')
            var inner_expr = parse_expression(
                tokens, pos, msgs, project_file=project_file,
                max_len=tokens_len, debug=debug,
            ) later:

            await inner_expr
            return inner_expr
        }

        var inner_expr = get_bracketed_expression() later:

        await inner_expr
        if debug {
            print("compiler.ast.expr: parse_expression_unwrapped() " +
                debug_id + " got call/member/index inner_expr=" +
                if inner_expr != none (inner_expr.as_json_obj().as_str())
                    else ("none"))
        }
        if inner_expr == none {
            msgs.add(new msg.FileMsg(
                "Unexpected " + token.describe_token_at(
                    tokens, pos) +
                ", expected operand expression following "
                "binary operator " + token.describe_token_at(
                    tokens, startpos) + " "
                "found in line " +
                token.get_line(tokens, op_pos).as_str() +
                ", col " +
                token.get_col(tokens, op_pos).as_str() + ".",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            var preskippos = pos
            if openbracket != "." {
                # Try to find actual closing bracket:
                pos = token.skip_garbage_to_closing_item(
                    tokens, pos, token.T_BRACKET,
                    token.reverse_brackets(openbracket),
                    max_len=tokens_len,
                    skip_closing_item_itself=yes,
                )
                # If we're at a proper closing bracket, consume it:
                if pos <= tokens_len and
                        tokens[pos].kind == token.T_BRACKET and
                        {")", "]", "}"}.has(token[pos].str) {
                    pos += 1  # Past whatever closing thing we found.
                }
                node.subexprs.add(new InvalidExpr(pos - preskippos))
            } else {
                # Go past whatever nonsense we can't parse:
                var skiplen = token.get_naive_stmt_or_expr_len(
                    tokens, pos, max_len=tokens_len,
                    for_expr=yes
                )
                node.subexprs.add(new InvalidExpr(skiplen))
                pos += skiplen
            }
            node.subexprs.last().line = token.get_line(
                tokens, preskippos
            )
            node.subexprs.last().col = token.get_col(
                tokens, preskippos
            )
        } else {
            node.subexprs.add(inner_expr)
            pos += inner_expr.token_len
            if openbracket != "." and
                    (pos > tokens_len or
                    tokens[pos].kind != token.T_BRACKET or
                    token.reverse_brackets(openbracket) !=
                        tokens[pos].str) {
                if not node.has_damage() {
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, pos) +
                        ", expected '" + token.reverse_brackets(
                            openbracket
                        ) +
                        "' to close '" + openbracket + "' "
                        "found in line " +
                        token.get_line(tokens, op_pos).as_str() +
                        ", col " +
                        token.get_col(tokens, op_pos).as_str() + ".",
                        source_file=project_file,
                        line=token.get_line(tokens, pos),
                        col=token.get_col(tokens, pos),
                    ))
                }
                node.damaged = yes
                pos = token.skip_garbage_to_closing_item(
                    tokens, pos, token.T_BRACKET,
                    token.reverse_brackets(openbracket),
                    max_len=tokens_len,
                    skip_closing_item_itself=yes
                )
            } elseif openbracket != "." {
                pos += 1  # Go past closing bracket.
            }
        }
        node.token_len = orig_left_hand_len + (pos - startpos)
        if pos >= tokens_len or (
                tokens[pos].kind != token.T_DOT and
                (tokens[pos].kind != token.T_BRACKET or
                 not {"(", "["}.has(tokens[pos].str))) {
            if debug {
                print("compiler.ast.expr: parse_expression_unwrapped() " +
                    debug_id + " completed call/member/index node=" +
                    if inner_expr != none (node.as_json_obj().as_str())
                        else ("none"))
            }
            # End of call/member access/index chain!
            return node
        }
        # More things are chained, continue:
        if debug {
            print("compiler.ast.expr: parse_expression_unwrapped() " +
                debug_id + " continuing call/member/index chain")
        }
        left_hand = node
        openbracket =
            if tokens[pos].kind == token.T_BRACKET
            (tokens[pos].str) else (".")
        node = new BinopExpr(tokens[pos])
        node.line = left_hand.line
        node.col = left_hand.col
        node.subexprs.add(left_hand)
        op_pos = pos
        pos += 1  # Go past opening bracket.

        # Parse and jump back to handle next chained item:
        inner_expr = get_bracketed_expression() later repeat
    }
    # Handle expressions combined by unary or binary operators:
    if (left_hand != none and (
            {token.T_MATH, token.T_COMPARE}.has(tokens[pos].kind) or
            (tokens[pos].kind == token.T_BOOLCOMP and
             tokens[pos].str != "not"))) or
            (left_hand == none and
             (tokens[pos].kind == token.T_UNARYMATH or
              tokens[pos].kind == token.T_NEWOP or (
              tokens[pos].kind == token.T_BOOLCOMP and
              tokens[pos].str == "not"))) {
        # This is an expression with 1+ operators that needs untangling.
        # Our goal is to nest all operators with right order in a tree.
        var precedence_map = operator.op_str_to_precedence_map
        var outer_level_ops_operands = []  # Parsed in-between operands.
        var outer_level_ops_at = []  # Positions of all ops in this expr.
        var outer_level_ops_exprs = {->}  # Map of op pos to expr node.
        var expr_len = token.get_naive_stmt_or_expr_len(
            tokens, pos, max_len=tokens_len, for_expr=yes
        )
        assert(expr_len + pos - 1 <= tokens_len)
        tokens_len = pos + math.max(0, expr_len - 1)
        if expr_len > 2 and tokens_len >= 2 and
                tokens[tokens_len - 1].kind == token.T_KEYWORD and
                tokens[tokens_len - 1].str == "later" {
            # Stop before trailing later since that's parsed on
            # a statement level.
            expr_len -= 2
            tokens_len -= 2
        }

        # First, collect all operators for precedence ordering:
        outer_level_ops_operands.add(left_hand)
        outer_level_ops_at.add([
            pos,  # The position.
            precedence_map[tokens[pos].str]
                [tokens[pos].kind],  # The precedence.
            1  # The left operand index.
        ])
        var bracket_depth = 0
        var operandstart = pos + 1
        var inline_if_depth = 0
        var i = pos + 1
        while i <= tokens_len {
            if tokens[i].kind == token.T_BRACKET {
                if {"{", "(", "["}.has(tokens[i].str) {
                    bracket_depth += 1
                } else {
                    bracket_depth -= 1
                }
            } elseif bracket_depth == 0 {
                if inline_if_depth == 0 and
                        {token.T_MATH, token.T_UNARYMATH,
                        token.T_COMPARE,
                        token.T_BOOLCOMP}.has(tokens[i].kind) {
                    # Found a relevant operator!
                    outer_level_ops_at.add([
                        i,  # The position.
                        precedence_map[tokens[i].str]
                            [tokens[i].kind],  # The precedence.
                        outer_level_ops_operands.len +
                        1,  # Left operand index.
                    ])
                    if i > operandstart {  # Collect range of operand:
                        outer_level_ops_operands.add([
                            operandstart, i - 1
                        ])
                    } else {
                        outer_level_ops_operands.add(none)
                    }
                    operandstart = i + 1
                } elseif tokens[i].kind == token.T_KEYWORD and
                        tokens[i].str == "if" {
                    inline_if_depth += 1
                } elseif tokens[i].kind == token.T_KEYWORD and
                        tokens[i].str == "else" {
                    inline_if_depth = math.max(0, inline_if_depth - 1)
                }
            }
            i += 1
        }
        if i > operandstart {  # Collect final trailing operand:
            outer_level_ops_operands.add([
                operandstart, i - 1
            ])
        } else {
            outer_level_ops_operands.add(none)
        }

        # For each operator collected, add positions of neighbors:
        i = 1
        while i <= outer_level_ops_at.len {
            var prev = none
            if i > 1 {
                prev = outer_level_ops_at[i - 1][1]
            }
            var next = none
            if i < outer_level_ops_at.len {
                next = outer_level_ops_at[i + 1][1]
            }
            # After the next code line, each entry will look like this:
            # [operator token pos, operator precd.,
            # left-hand operand idx,
            # previous op token pos, next operator token pos]
            assert(outer_level_ops_at[i].len == 3)
            outer_level_ops_at[i] += [prev, next]
            assert(outer_level_ops_at[i].len == 5)
            i += 1
        }

        # Sort operators by precedence (and secondarily the position):
        func sort_op_positions(a, b) {
            if a[2] > b[2] {  # Precedence comp.
                return yes
            } elseif a[2] == b[2] and a[1] > b[1] {  # Tok. pos comp.
                return yes
            }
            return no
        }
        outer_level_ops_at.sort(cmp=sort_op_positions)
        if debug {
            var debugmsg = "compiler.ast.expr: "
                "parse_expression_unwrapped() " +
                debug_id + " parsing operators expression " +
                tokens.sub(pos, tokens_len).as_str() +
                " with outer_level_ops_at="
            for op_entry in outer_level_ops_at {
                debugmsg += "(pos=" + op_entry[1].as_str() +
                    ", precedence=" + op_entry[2].as_str() +
                    ", op=" + token.describe_token(
                    tokens[op_entry[1]]) + ")"
            }
            print(debugmsg)
        }

        # Convert all the in-between operands into expressions:
        var operand_pos = outer_level_ops_operands.len
        var operands_queue = outer_level_ops_operands.copy()
        func parse_operand_if_needed(operand) {
            if typename(operand) != "list" {
                # Either 'none' or already transformed.
                return later operand
            }
            # Get expression node for this operand's range:
            assert(operand[2] >= operand[1])
            var operand_parsed = parse_expression(
                tokens, operand[1], msgs, project_file=project_file,
                max_len=operand[2], debug=debug
            ) later:

            await operand_parsed
            if operand_parsed == none or
                    (operand[1] + operand_parsed.token_len - 1 <
                    operand[2]) {
                assert(operand_parsed == none or
                       operand_parsed.token_len > 0)
                var after_pos = operand[1] + (
                    if operand_parsed != None
                        (operand_parsed.token_len) else (0)
                )
                if operand_parsed == none or
                        not operand_parsed.has_damage() {
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, after_pos) +
                        ", expected any valid operator to "
                        "follow up " + token.describe_token_at(
                            tokens, after_pos - 1) + " "
                        "found in line " +
                        token.get_line(tokens, after_pos - 1
                                      ).as_str() + ", col " +
                        token.get_col(tokens, after_pos - 1
                                     ).as_str() + ".",
                        source_file=project_file,
                        line=token.get_line(tokens, after_pos),
                        col=token.get_col(tokens, after_pos),
                    ))
                }
                if operand_parsed == none {
                    operand_parsed = new InvalidExpr(
                        after_pos - operand[1]
                    )
                }
                operand_parsed.damaged = yes
            }
            return operand_parsed
        }
        assert(operands_queue.len > 0)
        var next_operand = operands_queue.pop()
        var operand_parsed = parse_operand_if_needed(next_operand)
        later:

        await operand_parsed  # Get operand conversion result.
        outer_level_ops_operands[operand_pos] = operand_parsed
        if operands_queue.len == 0 {
            # We're done converting operands.
            if debug {
                print("compiler.ast.expr: parse_expression_unwrapped() " +
                    debug_id + " parsed operands RESULT: " +
                    outer_level_ops_operands.as_str())
            }

            # Now, assemble the actual final expression tree:
            var resulting_node = none
            var op_assemble_queue = outer_level_ops_at.copy()
            while op_assemble_queue.len > 0 {  # Iterate in nesting order.
                var op_entry = op_assemble_queue.pop()
                var op_has_lefthand = token.token_has_lefthand(
                    tokens[op_entry[1]]
                )
                var op_left_child = none
                var op_right_child = none
                if op_has_lefthand {
                    # A binary operator. Get left-hand subtree:
                    var prev_op_pos = op_entry[4]
                    if prev_op_pos != none and
                            outer_level_ops_exprs.has(prev_op_pos) {
                        # The left-hand child is a nested operator:
                        op_left_child = outer_level_ops_exprs[
                            prev_op_pos
                        ]
                    } else {
                        # The left-hand child is a bare operand:
                        var left_operand_no = op_entry[3]
                        op_left_child = outer_level_ops_operands[
                            left_operand_no
                        ]
                    }
                }
                if op_has_lefthand and op_left_child == none {
                    # Example for this error: '+', '+' in a row.
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, op_entry[1] - 1) +
                        ", expected valid left-hand operand "
                        "for operator " + token.describe_token_at(
                            tokens, op_entry[1]) + " "
                        "found in line " +
                        token.get_line(tokens, op_entry[1]
                                      ).as_str() + ", col " +
                        token.get_col(tokens, op_entry[1]
                                     ).as_str() + ".",
                        source_file=project_file,
                        line=token.get_line(tokens, pos),
                        col=token.get_col(tokens, pos),
                    ))
                    op_left_child = new InvalidExpr(1)
                }
                # Now, get right-hand subtree:
                var next_op_pos = op_entry[5]
                if outer_level_ops_exprs.has(next_op_pos) {
                    # The right-hand child is a nested operator:
                    op_right_child = outer_level_ops_exprs[
                        next_op_pos
                    ]
                } else {
                    # The right-hand child is a bare operand:
                    var left_operand_no = op_entry[3]
                    if left_operand_no + 1 <=
                            outer_level_ops_operands.len {
                        op_right_child = outer_level_ops_operands[
                            # Add 1 to this for right-hand side:
                            left_operand_no + 1
                        ]
                    }
                }
                if op_right_child == none {
                    # Example for this error: '+', '+' in a row.
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, op_entry[1] + 1) +
                        ", expected valid right-hand operand "
                        "for operator " + token.describe_token_at(
                            tokens, op_entry[1]) + " "
                        "found in line " +
                        token.get_line(tokens, op_entry[1]
                                      ).as_str() + ", col " +
                        token.get_col(tokens, op_entry[1]
                                     ).as_str() + ".",
                        source_file=project_file,
                        line=token.get_line(tokens, pos),
                        col=token.get_col(tokens, pos),
                    ))
                    op_right_child = new InvalidExpr(1)
                }
                # Create the operator's expression node:
                var op_node
                if op_has_lefthand {
                    op_node = BinopExpr(tokens[op_entry[1]])
                    op_node.subexprs.add(op_left_child)
                } else {
                    op_node = UnopExpr(tokens[op_entry[1]])
                }
                op_node.subexprs.add(op_right_child)
                op_node.line = token.get_line(tokens, op_entry[1])
                op_node.col = token.get_line(tokens, op_entry[2])
                # If this is the last one, bail here:
                if op_assemble_queue.len == 0 {
                    resulting_node = op_node
                    break
                }
                # If not the last one, store intermediate result:
                outer_level_ops_exprs[op_entry[1]] = op_node
            }
            assert(resulting_node != none)
            resulting_node.token_len = (tokens_len - pos) + 1
            if left_hand != none {
                resulting_node.token_len += left_hand.token_len
            }
            return resulting_node
        }
        # If we arrive here, we got operands left to convert:
        operand_pos -= 1
        next_operand = operands_queue.pop()
        operand_parsed = parse_operand_if_needed(
            next_operand
        ) later repeat  # Jump back up to contineu conversion.
    }
}

type CallKWArgExpr base ast.TreeNode {
    var label
}

func CallKWArgExpr.init {
    base.init()
    self.kind = ast.N_EXPR_CALLKWARG
}

func CallKWArgExpr.as_json_output {
    var output = base.as_json_output()
    output["label"] = self.label
    return output
}

type ArgNameExpr base ast.TreeNode {
    var label
}

func ArgNameExpr.init {
    base.init()
    self.kind = ast.N_EXPR_ARGNAME
}

func ArgNameExpr.as_json_output {
    var output = base.as_json_output()
    output["label"] = self.label
    return output
}

type CallOrDefArgsExpr base ast.TreeNode {
}

func CallOrDefArgsExpr.init {
    base.init()
    self.kind = ast.N_EXPR_CALLORDEFARGS
}

func call_ast_error_info_suffix(call_line, call_pos, is_call=yes) {
    if call_line == none {
        return ""
    }
    return " for call in line " + call_line.as_str() +
        ", col " + call_pos.as_str()
}

func parse_single_call_or_funcdef_arg(
        tokens, pos, msgs, is_call=no, project_file=none,
        callordef_line=none, callordef_col=none,
        max_len=none, debug=no
        ) {
    var startpos = pos
    var tokens_len = tokens.len
    if max_len != none {
        tokens_len = math.min(tokens_len, max_len)
    }

    # Get the initial assigned thing or name label:
    var can_be_assign = yes
    var pre_assign_expr = none
    pre_assign_expr = parse_expression(
        tokens, pos, msgs, project_file=project_file,
        max_len=tokens_len
    ) later:

    await pre_assign_expr
    if pre_assign_expr != none {
        pos += pre_assign_expr.token_len
    }
    if pre_assign_expr != none and
            pre_assign_expr.kind != ast.N_EXPR_IDREF {
        if not is_call {
            pre_assign_expr = none
        }
        can_be_assign = no
    }

    # Make sure we got the initial expression:
    if pre_assign_expr == none {
        msgs.add(new msg.FileMsg(
            "Unexpected " + token.describe_token_at(
                tokens, pos) +
            ", expected " + if is_call ("call")
                else ("func def") + " argument" +
            call_ast_error_info_suffix(callordef_line, callordef_col,
                is_call=is_call) + ".",
            source_file=project_file,
            line=token.get_line(tokens, pos),
            col=token.get_col(tokens, pos),
        ))
        pos = token.skip_garbage_to_closing_item(
            tokens, pos, token.T_COMMA, ",",
            skip_closing_item_itself=yes,
        )
        var node = new InvalidExpr(pos - startpos)
        node.line = token.get_line(tokens, startpos)
        node.col = token.get_col(tokens, startpos)
        node.token_len = pos - startpos
        return node
    }

    # Now, see if there's anything assigned:
    func parse_assigned_if_needed {
        if pos > tokens_len or not can_be_assign or
                tokens[pos].kind != token.T_ASSIGN {
            return none
        }
        assert(tokens[pos].kind == token.T_ASSIGN)
        pos += 1
        var assigned_expr = parse_expression(
            tokens, pos, msgs, project_file=project_file,
            max_len=tokens_len
        ) later:

        await assigned_expr
        if assigned_expr == none {
            msgs.add(new msg.FileMsg(
                "Unexpected " + token.describe_token_at(
                    tokens, pos) +
                ", expected assigned expression for " +
                if is_call ("call")
                    else ("func def") + " argument "
                "starting in line " +
                token.get_line(tokens, startpos).as_str() +
                ", col " +
                token.get_col(tokens, startpos).as_str() + ".",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            assigned_expr = new InvalidExpr(1)
            assigned_expr.line = token.get_line(tokens, pos)
            assigned_expr.col = token.get_col(tokens, pos)
        } else {
            assert(assigned_expr.token_len >= 0)
            pos += assigned_expr.token_len
        }
        return assigned_expr
    }
    var assigned_expr = parse_assigned_if_needed()
    later:
    await assigned_expr

    # Make sure we reached the proper ending:
    var had_damage = no
    if pos > tokens_len or (
            tokens[pos].kind != token.T_COMMA and
            (tokens[pos].kind != token.T_BRACKET or
             tokens[pos].str != ")")) {
        if assigned_expr == none or
                not assigned_expr.has_damage() {
            msgs.add(new msg.FileMsg(
                "Unexpected " + token.describe_token_at(
                    tokens, pos) +
                ", expected final ending ',' (T_COMMA) or "
                "')' (T_BRACKET)" +
                call_ast_error_info_suffix(
                    callordef_line, callordef_col,
                    is_call=is_call) + ".",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
        }
        had_damage = yes
        var preskippos = pos
        if pos < tokens_len {
            var newpos = token.skip_garbage_to_closing_item(
                tokens, pos, token.T_COMMA, ",",
                skip_closing_item_itself=yes,
            )
            assert(newpos >= pos)
            pos = newpos
        }
    }
    #print("parse_single_call_or_funcdef_arg() past "
    #    "arg at pos " + pos.as_str() + " -> " +
    #    if pos <= tokens.len (tokens[pos].as_str()) else ("eof"))

    # If we're at a closing ',' + ')' then forward to final ')':
    if pos + 1 <= tokens_len and
            tokens[pos].kind == token.T_COMMA and
            tokens[pos + 1].kind == token.T_BRACKET and
            tokens[pos + 1].str == ")" {
        pos += 1
    }

    # Compose final return value:
    assert(pre_assign_expr != none)
    if assigned_expr != none {
        var result_node = new CallKWArgExpr()
        result_node.damaged = had_damage
        result_node.token_len = (pos - startpos)
        result_node.line = token.get_line(tokens, startpos)
        result_node.col = token.get_col(tokens, startpos)
        assert(pre_assign_expr.kind == ast.N_EXPR_IDREF)
        result_node.label = pre_assign_expr.label
        result_node.subexprs.add(assigned_expr)
        return result_node
    } else {
        if is_call {
            pre_assign_expr.damaged = had_damage
            return pre_assign_expr
        }
        var result_node = new ArgNameExpr()
        result_node.damaged = had_damage
        result_node.token_len = (pos - startpos)
        result_node.line = token.get_line(tokens, startpos)
        result_node.col = token.get_col(tokens, startpos)
        result_node.label = pre_assign_expr.label
        return result_node
    }
}

## Parse a func call or func definition argument expression,
## which must start with a '(' opening bracket.
## @returns CallOrDefArgsExpr
func parse_call_or_funcdef_args(
        tokens, pos, msgs, is_call=no, project_file=none,
        callordef_line=none, max_len=none,
        callordef_col=none, debug=no
        ) {
    var tokens_len = tokens.len
    if tokens.len > 0 and typename(tokens[1]) == "str" {
        tokens = token.token_list_from_str_list(tokens)
    }
    if max_len != none and max_len < tokens_len {
        tokens_len = max_len
    }

    if debug {
        print("compiler.ast.expr: parse_call_or_funcdef_args() on " +
            tokens.sub(pos, math.min(pos + 10, tokens_len)).as_str() +
            "... with pos=" + pos.as_str() + ", "
            "tokens.len=" + tokens.len.as_str() + ", "
            "max_len=" + max_len.as_str())
    }

    # Preparations:
    var node = new CallOrDefArgsExpr()
    node.line = token.get_line(tokens, pos)
    node.col = token.get_col(tokens, pos)
    var startpos = pos
    if pos > tokens_len or
            tokens[pos].kind != token.T_BRACKET or
            tokens[pos].str != "(" {
        node.token_len = 0
        return node
    }
    pos += 1  # Past '(' opening bracket
    if pos <= tokens_len and ((  # Empty arguments expression:
            tokens[pos].kind == token.T_BRACKET and
            tokens[pos].str == ")") or
            (tokens[pos].kind == token.T_COMMA and
             pos + 1 <= tokens_len and
             tokens[pos + 1].kind == token.T_BRACKET and
             tokens[pos + 1].str == ")")) {
        if tokens[pos].kind == token.T_COMMA {
            pos += 1  # Advance ONTO actual closing ')'.
        }
        # The pos var now points to last contained token.
        node.token_len = (pos - startpos) + 1
        return node
    }

    # Now parse first argument:
    var arg = parse_single_call_or_funcdef_arg(
        tokens, pos, msgs, is_call=is_call,
        project_file=project_file,
        callordef_line=callordef_line,
        callordef_col=callordef_col
    ) later:

    await arg
    assert(arg != none)
    node.subexprs.add(arg)
    assert(pos >= 1)
    assert(arg.token_len >= 1)
    pos += arg.token_len
    if pos > tokens_len or tokens[pos].kind != token.T_COMMA {
        # We reached the end. If this isn't ')', then
        # parse_single_call_or_funcdef_arg() should have already
        # added an error to the msgs list.
        if pos > tokens_len or
                tokens[pos].kind != token.T_BRACKET or
                tokens[pos].str != ")" {
            pos -= 1  # Revert onto last valid contained token.
        }
        node.token_len = (pos - startpos) + 1
        return node
    }
    assert(tokens[pos].kind == token.T_COMMA)
    pos += 1  # Go past ','.

    # Next argument:
    arg = parse_single_call_or_funcdef_arg(
        tokens, pos, msgs, is_call=is_call,
        project_file=project_file,
        callordef_line=callordef_line,
        callordef_col=callordef_col
    ) later repeat
}

