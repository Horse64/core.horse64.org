## @module compiler.ast.expr
# Copyright (c) 2020-2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import base64 from core.horse64.org
import math from core.horse64.org
import random from core.horse64.org

import compiler.ast as ast
import compiler.ast.expr_cast as ast_expr_cast
import compiler.limit as climit
import compiler.msg as msg
import compiler.operator as operator
import compiler.token as token
import compiler.typeinfo.ast_typeref as ast_typeref

enum ContainerKind {
    C_SET,
    C_MAP,
    C_VEC,
    C_LIST,
}

func container_kind_to_name(k) {
    if k == C_SET {
        return "set"
    } elseif k == C_MAP {
        return "map"
    } elseif k == C_VEC {
        return "vec"
    } elseif k == C_LIST {
        return "list"
    }
    throw new ValueError("Unexpected container kind.")
}

type ContainerExpr base ast.TreeNode {
    ## @type ContainerKind
    var container_kind
}

func ContainerExpr.init {
    base.init()
    self.kind = ast.N_EXPR_CONTAINER
}

func ContainerExpr.as_code(indent=0) {
    if self.damaged {
        return "(damaged container expr.)"
    }
    var t = ""
    if self.container_kind == C_SET {
        t += "{"
        var is_first = yes
        for item in self.subexprs {
            if is_first {
                is_first = no
            } else {
                t += ","
            }
            t += item.as_code(indent=indent)
        }
        return t + "}"
    } elseif self.container_kind == C_MAP {
        if self.subexprs.len == 0 {
            return "{->}"
        }
        t += "{"
        var pair_count = self.subexprs.len / 2
        var is_first = yes
        var i = 1
        while i <= pair_count {
            if is_first {
                is_first = no
            } else {
                t += ","
            }
            t += self.subexprs[i * 2 - 1].as_code(
                    indent=indent) + " -> " +
                self.subexprs[i * 2].as_code(indent=indent)
            i += 1
        }
        return t + "}"
    } elseif self.container_kind == C_LIST {
        t += "["
        var is_first = yes
        for item in self.subexprs {
            if is_first {
                is_first = no
            } else {
                t += ","
            }
            t += item.as_code(indent=indent)
        }
        return t + "]"
    } else {
        assert(self.container_kind == C_VEC)
        if self.subexprs.len < 2 {
            return "[x: 0, y: 0]"
        }
        if self.subexprs.len == 2 {
            return "[x:" + self.subexprs[1].as_code(indent=indent) +
                ",y: " + self.subexprs[2].as_code(indent=indent) + "]"
        } elseif self.subexprs.len == 3 {
            return "[x:" + self.subexprs[1].as_code(indent=indent) +
                ",y: " + self.subexprs[2].as_code(indent=indent) +
                ",z: " + self.subexprs[3].as_code(indent=indent) +"]"
        } else {
            assert(self.subexprs.len == 4)
            return "[x:" + self.subexprs[1].as_code(indent=indent) +
                ",y: " + self.subexprs[2].as_code(indent=indent) +
                ",z: " + self.subexprs[3].as_code(indent=indent) +
                ",w: " + self.subexprs[4].as_code(indent=indent) +"]"
        }
    }
}

type InvalidExpr base ast.TreeNode {
}

func InvalidExpr.init(tlen) {
    base.init()
    self.kind = ast.N_EXPR_INVALID
    assert(tlen != none)
    self.token_len = tlen
    self.damaged = yes
}

func InvalidExpr.as_code(indent=0) {
    return "(invalid expr.)"
}

type FailedCheckExpr base ast.TreeNode {
    var check_expr   # XXX: Not a subexprs since without storage.
}

func FailedCheckExpr.init {
    base.init()
    self.kind = ast.N_EXPR_FAILEDCHECK
}

func FailedCheckExpr.as_code(indent=0) {
    if self.damaged {
        return "(damaged failed check expr)"
    }
    var t = "failed(" +
        self.check_expr.as_code(indent=indent) + ")"
    return t
}

type UnopExpr base ast.TreeNode {
    var optoken
}

func UnopExpr.init(optoken) {
    base.init()
    self.kind = ast.N_EXPR_UNOP
    self.optoken = optoken
}

func UnopExpr.as_code(indent=0) {
    if self.damaged {
        return "(damaged unop expr)"
    }
    return self.optoken.str + " " +
        self.subexprs[1].as_code(indent=indent)
}

func UnopExpr.as_json_obj {
    var output = base.as_json_obj()
    output["optoken"] = self.optoken.str
    return output
}

type BinopExpr base ast.TreeNode {
    var optoken
}

func BinopExpr.init(optoken) {
    base.init()
    self.kind = ast.N_EXPR_BINOP
    self.optoken = optoken
}

func BinopExpr.as_json_obj {
    var output = base.as_json_obj()
    output["optoken"] = self.optoken.str
    return output
}

func BinopExpr.as_code(indent=0) {
    if self.damaged {
        return "(damaged binop expr.)"
    }
    if self.optoken.str == "(" {
        if self.subexprs[2].kind == ast.N_EXPR_CALLARGS {
            return self.subexprs[1].as_code(indent=indent) +
                self.subexprs[2].as_code(indent=indent)
        }
        return self.subexprs[1].as_code(indent=indent) + "(" +
            self.subexprs[2].as_code(indent=indent) + ")"
    } elseif self.optoken.str == "[" {
        return self.subexprs[1].as_code(indent=indent) + "[" +
            self.subexprs[2].as_code(indent=indent) + "]"
    } elseif self.optoken.str == "." {
        return self.subexprs[1].as_code(indent=indent) + "." +
            self.subexprs[2].as_code(indent=indent)
    }
    return self.subexprs[1].as_code(indent=indent) + " " +
        self.optoken.str + " " +
        self.subexprs[2].as_code(indent=indent)
}

type IdRefExpr base ast.TreeNode {
    var label
    var type_path
}

func IdRefExpr.init {
    base.init()
    self.kind = ast.N_EXPR_IDREF
}

func IdRefExpr.copy {
    assert(self.type_path == none or
        typename(self.type_path) == "list")
    var self_copy = base.copy()
    self_copy.type_path = self.type_path.copy()
    return self_copy
}

func IdRefExpr.as_json_obj {
    var output = base.as_json_obj()
    output["label"] = self.label
    if self.type_path != none {
        output["type_path"] = self.type_path
    }
    return output
}

func IdRefExpr.as_code(indent=0) {
    assert(self.type_path == none or
        typename(self.type_path) == "list")
    var t = ""
    if self.type_path != none and self.type_path.len > 0 {
        for item in self.type_path {
            assert(typename(item) == "str")
            assert(item.len > 0)
        }
        t += self.type_path.join(".") + "."
    }
    assert(self.label != none and self.label.len > 0)
    t += self.label
    return t
}

type BaseRefExpr base ast.TreeNode {
}

func BaseRefExpr.init {
    base.init()
    self.kind = ast.N_EXPR_BASEREF
}

func BaseRefExpr.as_code(indent=0) {
    return "base"
}

type LiteralExpr base ast.TreeNode {
    var value
    var is_big_num
}

func LiteralExpr.init {
    base.init()
    self.kind = ast.N_EXPR_LIT
}

func LiteralExpr.copy {
    var self_copy = base.copy()
    self_copy.value = self.value.copy()
    return self_copy
}

func LiteralExpr.as_code(indent=0) {
    if {"bytes", "str"}.has(typename(self.value)) {
        return token.as_escaped_code_string(self.value)
    }
    return self.value.as_str()
}

func LiteralExpr.as_json_obj {
    var output = base.as_json_obj()
    if self.is_big_num {
        assert(typename(self.value) == "str")
        output["value"] = self.value
        output["is_big_num"] = yes
        return output
    }
    output["is_big_num"] = no
    if typename(self.value) == "bytes" {
        output["value-base64"] = base64.dump(self.value)
    } else {
        if typename(self.value) == "list" {
            output["value"] = {"list"->self.value}
        } elseif typename(self.value) == "set" {
            output["value"] = {"set"->self.value.as_list()}
        } elseif typename(self.value) == "map" {
            output["value"] = {"map"->self.value}
        } elseif typename(self.value) == "vec" {
            var vlen = self.value.len
            if vlen == 4 {
                output["value"] = {"vec"->[self.value[1],
                    self.value[2], self.value[3], self.value[4]]}
            } elseif vlen == 3 {
                output["value"] = {"vec"->[self.value[1],
                    self.value[2], self.value[3]]}
            } else {
                output["value"] = {
                    "vec"->[self.value[1], self.value[2]]}
            }
        } else {
            output["value"] = self.value
        }
    }
    return output
}

type InlineIfExpr base ast.TreeNode {
}

func InlineIfExpr.init {
    base.init()
    self.kind = ast.N_EXPR_INLINEIF
}

func InlineIfExpr.as_json_obj {
    var output = base.as_json_obj()
    return output
}

func InlineIfExpr.as_code(indent=0) {
    if self.damaged {
        return "(damaged inline if expr.)"
    }
    return "if " + self.subexprs[1].as_code(indent=indent) + " (" +
        self.subexprs[2].as_code(indent=indent) + ") else (" +
        self.subexprs[3].as_code(indent=indent) + ")"
}

func token_continues_expr(t) {
    if t.kind == token.T_ENCLOSE {
        return (t.str == "(" or t.str == "[")
    }
    if {token.T_MATH, token.T_COMPARE, token.T_DOT}.has(t.kind) {
        return yes
    }
    if t.kind == token.T_BOOLCOMP and t.str != "not" {
        return yes
    }
    return no
}

func parse_container_entry(
        tokens, pos, nesting_depth, container_kind, msgs,
        container_start_line=none, container_start_col=none,
        project_file=none, max_len=none, debug=no
        ) {
    var tokens_len = tokens.len
    if max_len != none {
        tokens_len = math.min(tokens_len, max_len)
    }
    var expr1 = _parse_expression_notlater(
        tokens, pos, nesting_depth, msgs,
        project_file=project_file, max_len=tokens_len, debug=debug
    )

    if expr1 == none {
        return none
    }
    if container_kind != C_MAP and container_kind != C_VEC {
        return [expr1, none]
    }
    pos += expr1.token_len
    if pos >= tokens_len or (container_kind == C_MAP and
            tokens[pos].kind != token.T_RIGHTPTR) or
            (container_kind == C_VEC and
            tokens[pos].kind != token.T_COLON) {
        var expected = "'->' (T_RIGHTPTR) for map"
        if container_kind == C_VEC {
            expected = "':' (T_COLON) for vector"
        }
        msgs.add(new msg.FileMsg(
            "Unexpected " + token.describe_token_at(
                tokens, pos) +
            ", expected " + expected + " "
            "in line " +
            container_start_line.as_str() +
            ", column " +
            container_start_col.as_str() + ".",
            source_file=project_file,
            line=token.get_line(tokens, pos),
            col=token.get_col(tokens, pos),
        ))
        expr1.damaged = yes
        return [expr1, none]
    }
    pos += 1
    var expr2 = _parse_expression_notlater(
        tokens, pos, nesting_depth, msgs, project_file=project_file,
        max_len=tokens_len, debug=debug
    )

    return [expr1, expr2]
}

func parse_expression(
        tokens, pos, msgs, project_file=none,
        max_len=none, is_moose64=no, debug=no
        ) {
    var result = _parse_expression_notlater(
        tokens, pos, 0, msgs, project_file=project_file,
        max_len=max_len, is_moose64=is_moose64, debug=debug
        )
    # XXX: If we ever support inline code blocks, they will
    # have to be handled here. This is because the statement
    # parser uses later calls, while the regular expression parser
    # does not.
    return later result
}

func _parse_expression_notlater(
        tokens, pos, nesting_depth, msgs, project_file=none,
        max_len=none, is_moose64=no, debug=no
        ) {
    nesting_depth += 1
    if nesting_depth > climit.max_expression_nesting {
        msgs.add(new msg.FileMsg(
            "Nesting of expressions too deep here, "
            "exceeds maximum supported depth.",
            source_file=project_file,
            line=token.get_line(tokens, pos),
            col=token.get_col(tokens, pos),
        ))
        return none
    }
    var tokens_len = tokens.len
    if max_len != none {
        tokens_len = math.min(max_len, tokens_len)
    }
    if pos > tokens_len {
        return none
    }
    var debug_id = none
    if debug {
        debug_id = random.gen_id()
        print("compiler.ast.expr: _parse_expression_notlater() " +
            debug_id + " on " +
            tokens.sub(pos, math.min(pos + 10, tokens_len)).as_str() +
            "... with pos=" + pos.as_str() + ", "
            "tokens.len=" + tokens.len.as_str() + ", "
            "max_len=" + max_len.as_str())
    }
    var origpos = pos
    var inner_expr = none

    while yes {
        var wrapping_expr = parse_expression_unwrapped(
            tokens, pos, nesting_depth, msgs,
            project_file=project_file, left_hand=inner_expr,
            max_len=tokens_len, is_moose64=is_moose64,
            debug=debug
        )

        if debug {
            print("compiler.ast.expr: _parse_expression_notlater() " +
                debug_id + " "
                "fetched wrapping_expr -> " + wrapping_expr.as_str() + " "
                "(with len " + if wrapping_expr != none (
                    wrapping_expr.token_len.as_str()) else ("<none>") + " "
                "token after: " + token.describe_token_at(
                    tokens, origpos + if wrapping_expr != none
                    (wrapping_expr.token_len) else (0)
                ) + ")")
        }
        assert(wrapping_expr == none or wrapping_expr.token_len != none)
        if wrapping_expr == none or
                origpos + wrapping_expr.token_len > tokens_len or
                not token_continues_expr(tokens[
                    origpos + wrapping_expr.token_len
                ]) {
            if debug {
                print("compiler.ast.expr: _parse_expression_notlater() " +
                    debug_id + " returning result.")
            }
            return wrapping_expr
        }
        if debug {
            print("compiler.ast.expr: _parse_expression_notlater() " +
                debug_id + " trying to wrap further...")
        }
        inner_expr = wrapping_expr
        pos = origpos + inner_expr.token_len
    }
}

func parse_expression_unwrapped(
        tokens, pos, nesting_depth, msgs, project_file=none,
        left_hand=none, max_len=none, is_moose64=no,
        debug=no
        ) {
    var startpos = pos
    var startline = token.get_line(tokens, startpos)
    var startcol = token.get_col(tokens, startpos)
    var tokens_len = tokens.len
    if max_len != none {
        tokens_len = math.min(max_len, tokens_len)
    }

    var debug_id = none
    if debug {
        debug_id = random.gen_id()
        print("compiler.ast.expr: parse_expression_unwrapped() " +
            debug_id + " on " +
            tokens.sub(pos, math.min(pos + 10, tokens_len)).as_str() +
            "...  with left_hand=" + left_hand.as_str())
    }

    if pos > tokens_len {
        return none
    }
    if left_hand == none {
        # Try to parse it as a single standalone expression
        # (which isn't combined by operators).

        # First, handle the most trivial literals:
        if tokens[pos].kind == token.T_STR {
            # A string literal, e.g. "'test''
            var node = new LiteralExpr()
            node.value = token.parse_token_value(tokens[pos])
            node.token_len = 1
            node.line = startline
            node.col = startcol
            while pos + 1 <= tokens_len and
                    tokens[pos + 1].kind == token.T_STR {
                node.value += token.parse_token_value(tokens[pos + 1])
                node.token_len += 1
                pos += 1
            }
            return node
        } elseif tokens[pos].kind == token.T_BYTES {
            # A bytes literal, e.g. "b'test'"
            var node = new LiteralExpr()
            node.value = token.parse_token_value(tokens[pos])
            node.token_len = 1
            node.line = startline
            node.col = startcol
            while pos + 1 <= tokens_len and
                    tokens[pos + 1].kind == token.T_BYTES {
                node.value += token.parse_token_value(tokens[pos + 1])
                node.token_len += 1
            }
            return node
        } elseif tokens[pos].kind == token.T_BIGNUM {
            var node = new LiteralExpr()
            node.value = tokens[pos].str
            node.is_big_num = yes
            node.token_len = 1
            node.line = startline
            node.col = startcol
            return node
        } elseif {token.T_NUM, token.T_BOOL,
                  token.T_NONE}.has(tokens[pos].kind) {
            # Bool, number, and none literals.
            var node = new LiteralExpr()
            node.value = token.parse_token_value(tokens[pos])
            node.token_len = 1
            node.line = startline
            node.col = startcol
            return node
        } elseif tokens[pos].kind == token.T_IDENT {
            # An identifier expression.
            var node = new IdRefExpr()
            node.label = tokens[pos].str
            node.token_len = 1
            node.line = startline
            node.col = startcol
            return node
        } elseif tokens[pos].kind == token.T_KEYWORD and
                tokens[pos].str == "base" {
            # A "base" referencing expression
            var node = new BaseRefExpr()
            node.token_len = 1
            node.line = startline
            node.col = startcol
            return node
        }
        # Handle as(...) type casts for moose64:
        if is_moose64 and tokens[pos].kind == token.T_KEYWORD and
                tokens[pos].str == "as" {
            var node = ast_expr_cast.parse_type_cast_expr(
                tokens, pos, nesting_depth + 1, msgs,
                project_file=project_file, max_len=max_len,
                is_moose64=is_moose64, debug=debug
            )
            if node != none {
                return node
            }
        }
        # Handle bracketed expressions, like `(1 + 2)`:
        if tokens[pos].kind == token.T_ENCLOSE and
                tokens[pos].str == "(" {
            pos += 1
            var inner_expr = _parse_expression_notlater(
                tokens, pos, nesting_depth, msgs, project_file=none,
                max_len=tokens_len, debug=debug,
            )

            if inner_expr == none {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) +
                    ", expected any inner nested expression "
                    "following '(' in line " +
                    startline.as_str() +
                    ", column " +
                    startcol.as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                var preskippos = pos
                var skiplen = token.get_naive_stmt_or_expr_len(
                    tokens, pos, max_len=tokens_len,
                    for_expr=yes, is_moose64=is_moose64
                )
                inner_expr = new InvalidExpr(skiplen)
                inner_expr.line = token.get_line(
                    tokens, preskippos
                )
                inner_expr.col = token.get_col(
                    tokens, preskippos
                )
            }
            assert(inner_expr.token_len != none)
            pos += inner_expr.token_len
            if pos > tokens_len or
                    tokens[pos].kind != token.T_ENCLOSE or
                    tokens[pos].str != ")" {
                if not inner_expr.has_damage() {
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, pos) +
                        ", expected ')' (T_ENCLOSE) closing the "
                        "opening bracket '(' in line " +
                        startline.as_str() +
                        ", column " +
                        startcol.as_str() + ".",
                        source_file=project_file,
                        line=token.get_line(tokens, pos),
                        col=token.get_col(tokens, pos),
                    ))
                }
                inner_expr.damaged = yes

                # Try to find actual closing bracket:
                pos = token.skip_garbage_to_closing_item(
                    tokens, pos, token.T_ENCLOSE, "(",
                    max_len=tokens_len,
                )
                # If we're at a proper closing bracket, consume it:
                if pos <= tokens_len and
                        tokens[pos].kind == token.T_ENCLOSE and
                        {")", "]", "}"}.has(tokens[pos].str) {
                    pos += 1  # Past whatever closing thing we found.
                }
            } else {
                pos += 1  # Past closing ')'.
                assert(tokens[startpos].str == "(")
                assert(tokens[pos - 1].str == ")")
            }
            inner_expr.token_len = (pos - startpos)
            return inner_expr
        }
        # Handle container constructors for map, list, set, vector:
        if tokens[pos].kind == token.T_ENCLOSE and
                {"{", "["}.has(tokens[pos].str) {
            var openbracket = tokens[pos].str
            pos += 1
            var node = new ContainerExpr()
            node.line = startline
            node.col = startcol

            var ckind = C_LIST
            if openbracket == "{" {
                ckind = C_SET
            }
            var closebracket = token.reverse_brackets(tokens[pos - 1].str)

            # Handle special cases: [], {}, [,], {,}, {->}
            if pos <= tokens_len and (
                    tokens[pos].kind == token.T_COMMA or
                    (tokens[pos].kind == token.T_ENCLOSE and
                     tokens[pos].str == closebracket) or
                    (openbracket == "{" and
                     tokens[pos].kind == token.T_RIGHTPTR)) {
                if openbracket == "{" {
                    if (tokens[pos].kind != token.T_RIGHTPTR) {
                        node.kind = C_SET
                        if (tokens[pos].kind == token.T_COMMA) {
                            pos += 1
                        }
                    } else {
                        ckind = C_MAP
                        pos += 1
                    }
                } else {
                    ckind = C_LIST
                    if (tokens[pos].kind == token.T_COMMA) {
                        pos += 1
                    }
                }
                if pos > tokens_len or
                        tokens[pos].kind != token.T_ENCLOSE or
                        tokens[pos].str != closebracket {
                    if not node.has_damage() {
                        msgs.add(new msg.FileMsg(
                            "Unexpected " + token.describe_token_at(
                                tokens, pos) +
                            ", expected ')' (T_ENCLOSE) closing the "
                            "opening bracket '" +
                            openbracket + "' in line " +
                            startline.as_str() +
                            ", col " +
                            startcol.as_str() + ".",
                            source_file=project_file,
                            line=token.get_line(tokens, pos),
                            col=token.get_col(tokens, pos),
                        ))
                    }
                    node.damaged = yes
                } else {
                    pos += 1
                }
                node.container_kind = ckind
                node.token_len = (pos - startpos)
                return node
            }

            # First, determine what type of container this is:
            var bracket_depth = 0
            var i = pos
            while i <= tokens_len and
                    (bracket_depth > 0 or
                    tokens[i].kind != token.T_ENCLOSE or
                    tokens[i].str != closebracket) {
                if tokens[i].kind == token.T_ENCLOSE {
                    if {"(", "[", "{"}.has(tokens[i].str) {
                        bracket_depth += 1
                    } else {
                        bracket_depth = math.max(0, bracket_depth - 1)
                    }
                }
                if bracket_depth > 0 {
                    i += 1
                    continue
                }
                if tokens[i].kind == token.T_RIGHTPTR and
                        openbracket == "{" {
                    ckind = C_MAP
                    break
                } elseif tokens[i].kind == token.T_COLON and
                        openbracket == "[" {
                    ckind = C_VEC
                    break
                } elseif tokens[i].kind == token.T_COMMA {
                    break
                }
                i += 1
            }

            while yes {
                var next_expr = parse_container_entry(
                    tokens, pos, nesting_depth, ckind, msgs,
                    container_start_line=startline,
                    container_start_col=startcol,
                    project_file=project_file,
                    max_len=tokens_len,
                    debug=debug
                )

                var had_fatal_error = no
                if next_expr == none {
                    if pos > tokens_len or
                            tokens[pos] != token.T_ENCLOSE or
                            tokens[pos].str != closebracket {
                        if not node.has_damage() {
                            msgs.add(new msg.FileMsg(
                                "Unexpected " + token.describe_token_at(
                                    tokens, pos) +
                                ", expected next entry for " +
                                container_kind_to_name(ckind) +
                                " in line " +
                                startline.as_str() +
                                ", column " +
                                startcol.as_str() + ".",
                                source_file=project_file,
                                line=token.get_line(tokens, pos),
                                col=token.get_col(tokens, pos),
                            ))
                        }
                        had_fatal_error = yes
                    }
                }
                if not had_fatal_error and next_expr != none {
                    if ckind == C_MAP or ckind == C_VEC {
                        node.subexprs.add(next_expr[1])
                        pos += next_expr[1].token_len
                        pos += 1  # -> or : separator
                        if next_expr[2] == none {
                            # Means we had an inner parse error!
                            had_fatal_error = yes
                        } else {
                            node.subexprs.add(next_expr[2])
                            pos += next_expr[2].token_len
                        }
                    } else {
                        node.subexprs.add(next_expr[1])
                        pos += next_expr[1].token_len
                    }
                }
                if not had_fatal_error and (pos > tokens_len or
                        ((tokens[pos].kind != token.T_ENCLOSE or
                        tokens[pos].str != closebracket) and
                        tokens[pos].kind != token.T_COMMA)) {
                    if not node.has_damage() {
                        msgs.add(new msg.FileMsg(
                            "Unexpected " + token.describe_token_at(
                                tokens, pos) +
                            ", expected ',' (T_COMMA) or '" +
                            closebracket + "' to resume or end " +
                            container_kind_to_name(ckind) +
                            " started in line " +
                            startline.as_str() +
                            ", column " +
                            startcol.as_str() + ".",
                            source_file=project_file,
                            line=token.get_line(tokens, pos),
                            col=token.get_col(tokens, pos),
                        ))
                    }
                    had_fatal_error = yes
                }
                if had_fatal_error {
                    # Forward to final closing bracket and abort.
                    var bdepth = 0
                    while pos <= tokens_len and
                            (bdepth > 0 or
                            tokens[pos].kind != token.T_ENCLOSE or
                            not {")", "]", "}"}.has(tokens[pos].str)) and
                            not token.surely_starts_stmt_even_in_bad_code(
                                tokens, pos
                            ) {
                        if tokens[pos].kind == token.T_ENCLOSE {
                            if {")", "]", "}"}.has(tokens[pos].str) {
                                bdepth -= 1
                            } else {
                                bdepth += 1
                            }
                        }
                        pos += 1
                    }
                    if pos <= tokens_len and
                            tokens[pos].kind == token.T_ENCLOSE and
                            tokens[pos].str == closebracket {
                        pos += 1  # Go past closing bracket.
                    }
                    node.damaged = yes
                    node.container_kind = ckind
                    node.token_len = (pos - startpos)
                    return node
                }
                if tokens[pos].kind != token.T_COMMA or
                        (pos + 1 <= tokens_len and
                        tokens[pos + 1].kind == token.T_ENCLOSE and
                        tokens[pos + 1].str == closebracket) {
                    # We're at the closing bracket.
                    if tokens[pos].kind == token.T_COMMA {
                        pos += 2  # Past ',' and past '}'/']'.
                    } else {
                        pos += 1  # Past '}'/']'.
                    }
                    node.token_len = (pos - startpos)
                    node.container_kind = ckind
                    return node
                }
                pos += 1  # Go past ',' to next entry.
            }
        }
    }
    # Handle inline 'if':
    if left_hand == none and
            tokens[pos].kind == token.T_KEYWORD and
            tokens[pos].str == "if" {
        var if_idx = pos
        var past_cond_idx = token.get_inline_if_conditional_end(
            tokens, pos, max_len=tokens_len, is_moose64=is_moose64
        )
        assert(past_cond_idx <= tokens_len)
        if past_cond_idx >= 1 {  # This means it's an actual inline 'if'.
            assert(tokens[past_cond_idx].kind == token.T_ENCLOSE and
                   tokens[past_cond_idx].str == "(")
            pos += 1
            var had_error = no

            var cond_expr = _parse_expression_notlater(
                tokens, pos, nesting_depth, msgs,
                project_file=project_file,
                max_len=(past_cond_idx - 1), debug=debug,
            )

            if cond_expr == none {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) +
                    ", expected conditional for inline if "
                    "expression.",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                had_error = yes
                cond_expr = new InvalidExpr(
                    math.max(1, past_cond_idx - pos)
                )
            }
            pos = past_cond_idx + 1

            func extract_return_bracket_expr(pos, max_idx=none) {
                var value_start = pos
                var value_expr = _parse_expression_notlater(
                    tokens, pos, nesting_depth, msgs,
                    project_file=project_file,
                    max_len=max_idx, debug=debug,
                )

                if value_expr == none {
                    if not had_error {
                        msgs.add(new msg.FileMsg(
                            "Unexpected " + token.describe_token_at(
                                tokens, pos) +
                            ", expected bracketed return value "
                            "for inline if starting in line " +
                            token.get_line(tokens, if_idx).as_str() +
                            ", column " +
                            token.get_col(tokens, if_idx).as_str() +
                            ".",
                            source_file=project_file,
                            line=token.get_line(tokens, pos),
                            col=token.get_col(tokens, pos),
                        ))
                    }
                    had_error = yes
                    value_expr = new InvalidExpr(1)
                } else {
                    pos += value_expr.token_len
                }
                if pos > tokens_len or
                        tokens[pos].kind != token.T_ENCLOSE or
                        tokens[pos].str != ")" {
                    if not had_error {
                        msgs.add(new msg.FileMsg(
                            "Unexpected " + token.describe_token_at(
                                tokens, pos) +
                            ", expected ')' to end bracketed return "
                            "value for inline if starting in "
                            "line " +
                            token.get_line(tokens, if_idx).as_str() +
                            ", column " +
                            token.get_col(tokens, if_idx).as_str() +
                            ".",
                            source_file=project_file,
                            line=token.get_line(tokens, pos),
                            col=token.get_col(tokens, pos),
                        ))
                    }
                    had_error = yes
                    var bracket_depth = 1
                    while pos <= tokens_len {
                        if tokens[pos].kind == token.T_ENCLOSE {
                            if {"(", "[", "{"}.has(tokens[pos].str) {
                                bracket_depth += 1
                            } else {
                                assert({")", "]", "}"}.has(
                                    tokens[pos].str))
                                bracket_depth -= 1
                                if bracket_depth <= 0 {
                                    break
                                }
                            }
                        }
                        pos += 1
                    }
                    value_expr.token_len = (pos - value_start)
                }
                assert(value_expr != none)
                return value_expr
            }

            # Get first return expression for 'yes' branch:
            var value1_expr = extract_return_bracket_expr(
                pos
            )

            assert(value1_expr != none)
            pos += value1_expr.token_len
            if pos < past_cond_idx {
                pos = past_cond_idx
            }
            if pos <= tokens_len and
                    tokens[pos].kind == token.T_ENCLOSE and
                    tokens[pos].str == ")" {
                pos += 1
            }
            if pos > tokens_len or
                    tokens[pos].kind != token.T_KEYWORD or
                    tokens[pos].str != "else" {
                if not had_error {
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, pos) +
                        ", expected 'else' to continue the "
                        "inline if starting in line " +
                        token.get_line(tokens, if_idx).as_str() +
                        ", column " +
                        token.get_col(tokens, if_idx).as_str() +
                        ".",
                        source_file=project_file,
                        line=token.get_line(tokens, pos),
                        col=token.get_col(tokens, pos),
                    ))
                }
                had_error = yes
            } else {
                pos += 1  # Go past 'else'.
            }
            if pos > tokens_len or
                    tokens[pos].kind != token.T_ENCLOSE or
                    tokens[pos].str != "(" {
                if not had_error {
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, pos) +
                        ", expected '(' for second bracketed "
                        "return value of the "
                        "inline if starting in line " +
                        token.get_line(tokens, if_idx).as_str() +
                        ", column " +
                        token.get_col(tokens, if_idx).as_str() +
                        ".",
                        source_file=project_file,
                        line=token.get_line(tokens, pos),
                        col=token.get_col(tokens, pos),
                    ))
                }
                had_error = yes
            } else {
                pos += 1  # Go past '('.
            }
            var value2_expr = extract_return_bracket_expr(
                pos
            )

            assert(value2_expr != none)
            pos += value2_expr.token_len
            if pos <= tokens_len and
                    tokens[pos].kind == token.T_ENCLOSE and
                    tokens[pos].str == ")" {
                pos += 1
            }
            var node = new InlineIfExpr()
            node.line = token.get_line(tokens, if_idx)
            node.col = token.get_col(tokens, if_idx)
            node.subexprs.add(cond_expr)
            node.subexprs.add(value1_expr)
            node.subexprs.add(value2_expr)
            node.token_len = (pos - if_idx)
            return node
        }
    }
    # Handle 'failed(expr)':
    if left_hand == none and is_moose64 and
            tokens[pos].kind == token.T_KEYWORD and
            tokens[pos].str == "failed" {
        var node = new FailedCheckExpr()
        node.line = startline
        node.col = startcol
        pos += 1  # Go past 'failed'.

        if pos > tokens_len or
                tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != '(' {
            msgs.add(new msg.FileMsg(
                "Unexpected " + token.describe_token_at(
                    tokens, pos) +
                ", expected '(' to start argument for 'failed' "
                "expression.",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            var skiplen =
                math.max(1, token.get_naive_stmt_or_expr_len(
                    tokens, pos - 1, max_len=tokens_len,
                    for_expr=yes, is_moose64=is_moose64
                ) + 1)
            pos += skiplen
            node = new InvalidExpr(pos - startpos)
            node.line = startline
            node.col = startcol
            return node
        }
        pos += 1  # Go past '('

        var inner_expr = _parse_expression_notlater(
            tokens, pos, nesting_depth, msgs,
            project_file=project_file,
            max_len=tokens_len, debug=debug,
        )
        if inner_expr == none or
                inner_expr.kind == ast.N_EXPR_FAILEDCHECK {
            msgs.add(new msg.FileMsg(
                "Unexpected " + token.describe_token_at(
                    tokens, pos) +
                ", expected valid argument for 'failed' "
                "expression.",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            var skiplen =
                math.max(1, token.get_naive_stmt_or_expr_len(
                    tokens, pos - 1, max_len=tokens_len,
                    for_expr=yes, is_moose64=is_moose64
                ) + 1)
            pos += skiplen
            node = new InvalidExpr(pos - startpos)
            node.line = startline
            node.col = startcol
            return node
        }
        # XXX: Intentionally not a subexprs, since the expression
        # is matched via literal comparison of the nesting rather
        # than any storage stuff. Hence the storage is meaningless,
        # and we don't want any storage visitors to descned into it.
        node.check_expr = inner_expr
        pos += inner_expr.token_len
        if pos > tokens_len or
                tokens[pos].kind != token.T_ENCLOSE or
                tokens[pos].str != ')' {
            msgs.add(new msg.FileMsg(
                "Unexpected " + token.describe_token_at(
                    tokens, pos) +
                ", expected ')' to end argument for 'failed' "
                "expression.",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            var skiplen =
                math.max(1, token.get_naive_stmt_or_expr_len(
                    tokens, pos - 1, max_len=tokens_len,
                    for_expr=yes,
                    bracket_depth=1,  # <- since ')' is missing.
                    is_moose64=is_moose64,
                ) + 1)
            pos += skiplen
            node.damaged = yes
        } else {
            pos += 1  # Go past ')'
        }
        node.token_len = pos - startpos
        return node
    }

    # Handle 'new' operator:
    if left_hand == none and
            tokens[pos].kind == token.T_NEWOP {
        var node = new UnopExpr(tokens[pos - 1])
        node.optoken = tokens[pos]
        node.line = startline
        node.col = startcol
        pos += 1  # Go past opening bracket.

        var inner_expr = _parse_expression_notlater(
            tokens, pos, nesting_depth, msgs,
            project_file=project_file,
            max_len=tokens_len, debug=debug,
        )
        if inner_expr == none {
            msgs.add(new msg.FileMsg(
                "Unexpected " + token.describe_token_at(
                    tokens, pos) +
                ", expected constructor after new operator.",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            var skiplen = token.get_naive_stmt_or_expr_len(
                tokens, pos, max_len=tokens_len,
                for_expr=yes, is_moose64=is_moose64
            )
            if skiplen < 1 {
                skiplen = 1
            }
            inner_expr = new InvalidExpr(skiplen)
        }

        node.subexprs.add(inner_expr)
        node.token_len = (inner_expr.token_len - 1) +
            (pos - startpos) + 1
        return node
    }
    # Handle call, member access, and indexing operators:
    if left_hand != none and
            (tokens[pos].kind == token.T_DOT or
             (tokens[pos].kind == token.T_ENCLOSE and
              {"(", "["}.has(tokens[pos].str))) {
        if debug {
            print("compiler.ast.expr: parse_expression_unwrapped() " +
                debug_id + " discovered call/member/index op " +
                token.describe_token(tokens[pos]) + " at index=" +
                pos.as_str())
        }

        var orig_left_hand_len = left_hand.token_len
        var openbracket =
            if tokens[pos].kind == token.T_ENCLOSE
            (tokens[pos].str) else (".")
        var op_pos = pos
        pos += 1  # Go past opening bracket.
        var node = new BinopExpr(tokens[pos - 1])
        node.line = startline
        node.col = startcol
        if left_hand and left_hand.line != none {
            node.line = left_hand.line
            node.col = left_hand.col
        }
        assert(not left_hand.is_stmt)
        node.subexprs.add(left_hand)

        ## Helper function to either parse a right-hand item as
        ## call args for '(', or generic bracketed expression for
        ## '[' and '.' operands.
        func get_bracketed_expression {
            if openbracket == '(' {
                var parse_pos = pos - 1  # Revert back onto bracket
                var inner_expr = _parse_call_or_funcdef_args_notlater(
                    tokens, parse_pos, nesting_depth, msgs,
                    project_file=project_file, is_call=yes,
                    is_moose64=is_moose64,
                    callordef_line=token.get_line(tokens, op_pos),
                    callordef_col=token.get_col(tokens, op_pos)
                )

                assert(inner_expr != none)
                inner_expr.token_len -= 1  # Due to parse_pos = pos - 1.
                if inner_expr.token_len > 0 and
                        pos + inner_expr.token_len - 1 <= tokens_len and
                        tokens[pos + inner_expr.token_len - 1].kind ==
                            token.T_ENCLOSE and
                        tokens[pos + inner_expr.token_len - 1].str == ")" {
                    inner_expr.token_len -= 1  # Exclude closing ')'.
                }
                return inner_expr
            } elseif openbracket == '.' {
                # We only shall consume a following identifier, not
                # more. Otherwise, nesting precedence is messed up.
                if pos > tokens_len or
                        tokens[pos].kind != token.T_IDENT {
                    return none
                }
                var iep = new IdRefExpr()
                iep.label = tokens[pos].str
                iep.col = tokens[pos].col
                iep.line = tokens[pos].line
                iep.token_len = 1
                return iep
            }
            # Parse until the expression naturally ends for '[':
            assert(openbracket == '[')
            var inner_expr = _parse_expression_notlater(
                tokens, pos, nesting_depth, msgs,
                project_file=project_file,
                max_len=tokens_len, debug=debug,
            )
            return inner_expr
        }

        while yes {
            var inner_expr = get_bracketed_expression()

            if debug {
                print("compiler.ast.expr: "
                    "parse_expression_unwrapped() " +
                    debug_id + " got call/member/index inner_expr=" +
                    if inner_expr != none
                        (inner_expr.as_json_obj().as_str())
                        else ("none"))
            }
            if inner_expr == none {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) +
                    ", expected operand expression following "
                    "binary operator " + token.describe_token_at(
                        tokens, startpos) + " "
                    "found in line " +
                    token.get_line(tokens, op_pos).as_str() +
                    ", column " +
                    token.get_col(tokens, op_pos).as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                var preskippos = pos
                if openbracket != "." {
                    # Try to find actual closing bracket:
                    pos = token.skip_garbage_to_closing_item(
                        tokens, pos, token.T_ENCLOSE,
                        token.reverse_brackets(openbracket),
                        max_len=tokens_len,
                        skip_closing_item_itself=yes,
                    )
                    # If we're at a proper closing bracket, consume it:
                    if pos <= tokens_len and
                            tokens[pos].kind == token.T_ENCLOSE and
                            {")", "]", "}"}.has(tokens[pos].str) {
                        pos += 1  # Past whatever closing thing we found.
                    }
                    node.subexprs.add(new InvalidExpr(pos - preskippos))
                } else {
                    # Go past whatever nonsense we can't parse:
                    var skiplen = token.get_naive_stmt_or_expr_len(
                        tokens, pos, max_len=tokens_len,
                        for_expr=yes, is_moose64=is_moose64
                    )
                    node.subexprs.add(new InvalidExpr(skiplen))
                    pos += skiplen
                }
                node.subexprs.last().line = token.get_line(
                    tokens, preskippos
                )
                node.subexprs.last().col = token.get_col(
                    tokens, preskippos
                )
            } else {
                node.subexprs.add(inner_expr)
                pos += inner_expr.token_len
                if openbracket != "." and
                        (pos > tokens_len or
                        tokens[pos].kind != token.T_ENCLOSE or
                        token.reverse_brackets(openbracket) !=
                            tokens[pos].str) {
                    if not node.has_damage() {
                        msgs.add(new msg.FileMsg(
                            "Unexpected " + token.describe_token_at(
                                tokens, pos) +
                            ", expected '" + token.reverse_brackets(
                                openbracket
                            ) +
                            "' to close '" + openbracket + "' "
                            "found in line " +
                            token.get_line(tokens, op_pos).as_str() +
                            ", column " +
                            token.get_col(tokens, op_pos).as_str() + ".",
                            source_file=project_file,
                            line=token.get_line(tokens, pos),
                            col=token.get_col(tokens, pos),
                        ))
                    }
                    node.damaged = yes
                    pos = token.skip_garbage_to_closing_item(
                        tokens, pos, token.T_ENCLOSE,
                        token.reverse_brackets(openbracket),
                        max_len=tokens_len,
                        skip_closing_item_itself=yes
                    )
                } elseif openbracket != "." {
                    pos += 1  # Go past closing bracket.
                }
            }
            node.token_len = orig_left_hand_len + (pos - startpos)
            if pos >= tokens_len or (
                    tokens[pos].kind != token.T_DOT and
                    (tokens[pos].kind != token.T_ENCLOSE or
                    not {"(", "["}.has(tokens[pos].str))) {
                if debug {
                    print("compiler.ast.expr: "
                        "parse_expression_unwrapped() " +
                        debug_id + " completed call/member/index node=" +
                        if inner_expr != none (node.as_json_obj().as_str())
                            else ("none"))
                }
                # End of call/member access/index chain!
                return node
            }
            # More things are chained, continue:
            if debug {
                print("compiler.ast.expr: "
                    "parse_expression_unwrapped() " +
                    debug_id + " continuing call/member/index chain")
            }
            left_hand = node
            openbracket =
                if tokens[pos].kind == token.T_ENCLOSE
                (tokens[pos].str) else (".")
            node = new BinopExpr(tokens[pos])
            node.line = left_hand.line
            node.col = left_hand.col
            node.subexprs.add(left_hand)
            op_pos = pos
            pos += 1  # Go past opening bracket.
        }
    }
    # Handle expressions combined by unary or binary operators:
    if (left_hand != none and (
            {token.T_MATH, token.T_COMPARE}.has(tokens[pos].kind) or
            (tokens[pos].kind == token.T_BOOLCOMP and
             tokens[pos].str != "not"))) or
            (left_hand == none and
             (tokens[pos].kind == token.T_UNARYMATH or
              tokens[pos].kind == token.T_NEWOP or (
              tokens[pos].kind == token.T_BOOLCOMP and
              tokens[pos].str == "not"))) {
        # This is an expression with 1+ operators that needs untangling.
        # Our goal is to nest all operators with right order in a tree.
        var precedence_map = operator.op_str_to_precedence_map
        var outer_level_ops_operands = []  # Parsed in-between operands.
        var outer_level_ops_at = []  # Positions of all ops in this expr.
        var outer_level_ops_exprs = {->}  # Map of op pos to expr node.
        var expr_len = token.get_naive_stmt_or_expr_len(
            tokens, pos, max_len=tokens_len, for_expr=yes,
            is_moose64=is_moose64
        )
        assert(expr_len + pos - 1 <= tokens_len)
        tokens_len = pos + math.max(0, expr_len - 1)
        if expr_len > 2 and tokens_len >= 2 and
                tokens[tokens_len - 1].kind == token.T_KEYWORD and
                tokens[tokens_len - 1].str == "later" {
            # Stop before trailing later since that's parsed on
            # a statement level.
            expr_len -= 2
            tokens_len -= 2
        }

        # First, collect all operators for precedence ordering:
        outer_level_ops_operands.add(left_hand)
        outer_level_ops_at.add([
            pos,  # The position.
            precedence_map[tokens[pos].str]
                [tokens[pos].kind],  # The precedence.
            1  # The left operand index.
        ])
        var bracket_depth = 0
        var operandstart = pos + 1
        var inline_if_depth = 0
        var i = pos + 1
        while i <= tokens_len {
            if tokens[i].kind == token.T_ENCLOSE {
                if {"{", "(", "["}.has(tokens[i].str) {
                    bracket_depth += 1
                } else {
                    bracket_depth -= 1
                }
            } elseif bracket_depth == 0 {
                if inline_if_depth == 0 and
                        {token.T_MATH, token.T_UNARYMATH,
                        token.T_COMPARE,
                        token.T_BOOLCOMP}.has(tokens[i].kind) {
                    # Found a relevant operator!
                    outer_level_ops_at.add([
                        i,  # The position.
                        precedence_map[tokens[i].str]
                            [tokens[i].kind],  # The precedence.
                        outer_level_ops_operands.len +
                        1,  # Left operand index.
                    ])
                    if i > operandstart {  # Collect range of operand:
                        outer_level_ops_operands.add([
                            operandstart, i - 1
                        ])
                    } else {
                        outer_level_ops_operands.add(none)
                    }
                    operandstart = i + 1
                } elseif tokens[i].kind == token.T_KEYWORD and
                        tokens[i].str == "if" {
                    inline_if_depth += 1
                } elseif tokens[i].kind == token.T_KEYWORD and
                        tokens[i].str == "else" {
                    inline_if_depth = math.max(0, inline_if_depth - 1)
                }
            }
            i += 1
        }
        if i > operandstart {  # Collect final trailing operand:
            outer_level_ops_operands.add([
                operandstart, i - 1
            ])
        } else {
            outer_level_ops_operands.add(none)
        }

        # For each operator collected, add positions of neighbors:
        i = 1
        while i <= outer_level_ops_at.len {
            var prev = none
            if i > 1 {
                prev = outer_level_ops_at[i - 1][1]
            }
            var next = none
            if i < outer_level_ops_at.len {
                next = outer_level_ops_at[i + 1][1]
            }
            # After the next code line, each entry will look like this:
            # [operator token pos, operator precd.,
            # left-hand operand idx,
            # previous op token pos, next operator token pos]
            assert(outer_level_ops_at[i].len == 3)
            outer_level_ops_at[i] += [prev, next]
            assert(outer_level_ops_at[i].len == 5)
            i += 1
        }

        # Sort operators by precedence (and secondarily the position):
        func sort_op_positions(a, b) {
            if a[2] > b[2] {  # Precedence comp.
                return yes
            } elseif a[2] == b[2] and a[1] > b[1] {  # Tok. pos comp.
                return yes
            }
            return no
        }
        outer_level_ops_at.sort(by=[2, 1])
        if debug {
            var debugmsg = "compiler.ast.expr: "
                "parse_expression_unwrapped() " +
                debug_id + " parsing operators expression " +
                tokens.sub(pos, tokens_len).as_str() +
                " with outer_level_ops_at="
            for op_entry in outer_level_ops_at {
                debugmsg += "(pos=" + op_entry[1].as_str() +
                    ", precedence=" + op_entry[2].as_str() +
                    ", op=" + token.describe_token(
                    tokens[op_entry[1]]) + ")"
            }
            print(debugmsg)
        }

        # Convert all the in-between operands into expressions:
        var operand_pos = outer_level_ops_operands.len
        var operands_queue = outer_level_ops_operands.copy()
        func parse_operand_if_needed(operand) {
            if typename(operand) != "list" {
                # Either 'none' or already transformed.
                return operand
            }
            # Get expression node for this operand's range:
            assert(operand[2] >= operand[1])
            var operand_parsed = _parse_expression_notlater(
                tokens, operand[1], nesting_depth, msgs,
                project_file=project_file,
                max_len=operand[2], debug=debug
            )

            if operand_parsed == none or
                    (operand[1] + operand_parsed.token_len - 1 <
                    operand[2]) {
                assert(operand_parsed == none or
                       operand_parsed.token_len > 0)
                var after_pos = operand[1] + (
                    if operand_parsed != none
                        (operand_parsed.token_len) else (0)
                )
                if operand_parsed == none or
                        not operand_parsed.has_damage() {
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, after_pos) +
                        ", expected any valid operator to "
                        "follow up " + token.describe_token_at(
                            tokens, after_pos - 1) + " "
                        "found in line " +
                        token.get_line(tokens, after_pos - 1
                                       ).as_str() + ", column " +
                        token.get_col(tokens, after_pos - 1
                                      ).as_str() + ".",
                        source_file=project_file,
                        line=token.get_line(tokens, after_pos),
                        col=token.get_col(tokens, after_pos),
                    ))
                }
                if operand_parsed == none {
                    operand_parsed = new InvalidExpr(
                        after_pos - operand[1]
                    )
                }
                operand_parsed.damaged = yes
            }
            return operand_parsed
        }
        assert(operands_queue.len > 0)
        var next_operand = operands_queue.pop()
        while yes {
            var operand_parsed = parse_operand_if_needed(next_operand)

            outer_level_ops_operands[operand_pos] = operand_parsed
            if operands_queue.len > 0 {
                # If we arrive here, we got operands left to convert:
                operand_pos -= 1
                next_operand = operands_queue.pop()
                continue
            }
            # We're done converting operands.
            if debug {
                print("compiler.ast.expr: parse_expression_unwrapped() " +
                    debug_id + " parsed operands RESULT: " +
                    outer_level_ops_operands.as_str())
            }

            # Now, assemble the actual final expression tree:
            var resulting_node = none
            var op_assemble_queue = outer_level_ops_at.copy()
            while op_assemble_queue.len > 0 {  # Iterate in nesting order.
                var op_entry = op_assemble_queue.pop()
                var op_has_lefthand = token.token_has_lefthand(
                    tokens[op_entry[1]]
                )
                var op_left_child = none
                var op_right_child = none
                if op_has_lefthand {
                    # A binary operator. Get left-hand subtree:
                    var prev_op_pos = op_entry[4]
                    if prev_op_pos != none and
                            outer_level_ops_exprs.has(prev_op_pos) {
                        # The left-hand child is a nested operator:
                        op_left_child = outer_level_ops_exprs[
                            prev_op_pos
                        ]
                    } else {
                        # The left-hand child is a bare operand:
                        var left_operand_no = op_entry[3]
                        op_left_child = outer_level_ops_operands[
                            left_operand_no
                        ]
                    }
                }
                if op_has_lefthand and op_left_child == none {
                    # Example for this error: '+', '+' in a row.
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, op_entry[1] - 1) +
                        ", expected valid left-hand operand "
                        "for operator " + token.describe_token_at(
                            tokens, op_entry[1]) + " "
                        "found in line " +
                        token.get_line(tokens, op_entry[1]
                                    ).as_str() + ", column " +
                        token.get_col(tokens, op_entry[1]
                                    ).as_str() + ".",
                        source_file=project_file,
                        line=token.get_line(tokens, pos),
                        col=token.get_col(tokens, pos),
                    ))
                    op_left_child = new InvalidExpr(1)
                }
                # Now, get right-hand subtree:
                var next_op_pos = op_entry[5]
                if outer_level_ops_exprs.has(next_op_pos) {
                    # The right-hand child is a nested operator:
                    op_right_child = outer_level_ops_exprs[
                        next_op_pos
                    ]
                } else {
                    # The right-hand child is a bare operand:
                    var left_operand_no = op_entry[3]
                    if left_operand_no + 1 <=
                            outer_level_ops_operands.len {
                        op_right_child = outer_level_ops_operands[
                            # Add 1 to this for right-hand side:
                            left_operand_no + 1
                        ]
                    }
                }
                if op_right_child == none {
                    # Example for this error: '+', '+' in a row.
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, op_entry[1] + 1) +
                        ", expected valid right-hand operand "
                        "for operator " + token.describe_token_at(
                            tokens, op_entry[1]) + " "
                        "found in line " +
                        token.get_line(tokens, op_entry[1]
                                    ).as_str() + ", column " +
                        token.get_col(tokens, op_entry[1]
                                    ).as_str() + ".",
                        source_file=project_file,
                        line=token.get_line(tokens, pos),
                        col=token.get_col(tokens, pos),
                    ))
                    op_right_child = new InvalidExpr(1)
                }
                # Create the operator's expression node:
                var op_node
                if op_has_lefthand {
                    op_node = new BinopExpr(tokens[op_entry[1]])
                    op_node.subexprs.add(op_left_child)
                } else {
                    op_node = new UnopExpr(tokens[op_entry[1]])
                }
                op_node.subexprs.add(op_right_child)
                op_node.line = token.get_line(tokens, op_entry[1])
                op_node.col = token.get_line(tokens, op_entry[2])
                # If this is the last one, bail here:
                if op_assemble_queue.len == 0 {
                    resulting_node = op_node
                    break
                }
                # If not the last one, store intermediate result:
                outer_level_ops_exprs[op_entry[1]] = op_node
            }
            assert(resulting_node != none)
            resulting_node.token_len = (tokens_len - pos) + 1
            if left_hand != none {
                resulting_node.token_len += left_hand.token_len
            }
            return resulting_node
        }
    }
}

type CallKWArgExpr base ast.TreeNode {
    var label
}

func CallKWArgExpr.init {
    base.init()
    self.kind = ast.N_EXPR_CALLKWARG
}

func CallKWArgExpr.as_json_obj {
    var output = base.as_json_obj()
    output["label"] = self.label
    return output
}

type ArgNameExpr base ast.TreeNode {
    var label
}

func ArgNameExpr.init {
    base.init()
    self.kind = ast.N_EXPR_ARGNAME
}

func ArgNameExpr.as_json_obj {
    var output = base.as_json_obj()
    output["label"] = self.label
    return output
}

func ArgNameExpr.as_code(indent=0) {
    return self.label
}

type CallArgsExpr base ast.TreeNode {
    var has_types = no
}

func CallArgsExpr.init {
    base.init()
    self.kind = ast.N_EXPR_CALLARGS
}

func CallArgsExpr.as_json_obj {
    var output = base.as_json_obj()
    output["has_types"] = self.has_types
    if not output.has("subexprs") {
        output["subexprs"] = []
    }
    return output
}

func CallArgsExpr.as_code(indent=0) {
    if self.damaged {
        return ""
    }
    var t = "("
    var is_first = yes
    var args = self.subexprs
    var argtypes = []
    if self.has_types {
        args = self.subexprs.sub(
            1, self.subexprs.len / 2
        )
        argtypes = self.subexprs.sub(
            self.subexprs.len / 2 + 1
        )
    }
    var idx = 0
    for arg in args {
        idx += 1
        if is_first {
            is_first = no
        } else {
            t += ", "
        }
        if arg.kind == ast.N_EXPR_CALLKWARG {
            t += arg.label
            if self.has_types {
                t += " <- " + argtypes[idx].as_str()
            }
            t += "=" + arg.subexprs[1].as_code(indent=indent)
        } else {
            t += arg.as_code(indent=indent)
            if self.has_types {
                t += " <- " + argtypes[idx].as_str()
            }
        }
    }
    return t + ")"
}

func call_ast_error_info_suffix(call_line, call_pos, is_call=yes) {
    if call_line == none {
        return ""
    }
    return " for call in line " + call_line.as_str() +
        ", column " + call_pos.as_str()
}

func parse_single_call_or_funcdef_arg(
        tokens, pos, nesting_depth, msgs,
        is_call=no, project_file=none,
        callordef_line=none, callordef_col=none,
        max_len=none,
        allow_type_refs=no, require_type_refs=no,
        debug=no
        ) {
    var startpos = pos
    var tokens_len = tokens.len
    if max_len != none {
        tokens_len = math.min(tokens_len, max_len)
    }

    # Get the initial assigned thing or name label:
    var can_be_assign = yes
    var pre_assign_expr = none
    pre_assign_expr = _parse_expression_notlater(
        tokens, pos, nesting_depth, msgs,
        project_file=project_file,
        max_len=tokens_len
    )

    if pre_assign_expr != none {
        pos += pre_assign_expr.token_len
    }
    if pre_assign_expr != none and
            pre_assign_expr.kind != ast.N_EXPR_IDREF {
        if not is_call {
            pre_assign_expr = none
        }
        can_be_assign = no
    }

    # Make sure we got the initial expression:
    if pre_assign_expr == none {
        msgs.add(new msg.FileMsg(
            "Unexpected " + token.describe_token_at(
                tokens, startpos) +
            ", expected " + if is_call ("call")
                else ("func def") + " argument" +
            call_ast_error_info_suffix(callordef_line, callordef_col,
                is_call=is_call) + ".",
            source_file=project_file,
            line=token.get_line(tokens, startpos),
            col=token.get_col(tokens, startpos),
        ))
        pos = token.skip_garbage_to_closing_item(
            tokens, pos, token.T_COMMA, ",",
            skip_closing_item_itself=yes,
        )
        var node = new InvalidExpr(pos - startpos)
        node.line = token.get_line(tokens, startpos)
        node.col = token.get_col(tokens, startpos)
        node.token_len = pos - startpos
        return node
    }

    # Now, see if there's anything assigned:
    func parse_assigned_if_needed {
        if pos > tokens_len or not can_be_assign or
                tokens[pos].kind != token.T_ASSIGN {
            return none
        }
        assert(tokens[pos].kind == token.T_ASSIGN)
        pos += 1
        var assigned_expr = _parse_expression_notlater(
            tokens, pos, nesting_depth, msgs,
            project_file=project_file, max_len=tokens_len
        )

        if assigned_expr == none {
            msgs.add(new msg.FileMsg(
                "Unexpected " + token.describe_token_at(
                    tokens, pos) +
                ", expected assigned expression for " +
                if is_call ("call")
                    else ("func def") + " argument "
                "starting in line " +
                token.get_line(tokens, startpos).as_str() +
                ", col " +
                token.get_col(tokens, startpos).as_str() + ".",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            assigned_expr = new InvalidExpr(1)
            assigned_expr.line = token.get_line(tokens, pos)
            assigned_expr.col = token.get_col(tokens, pos)
        } else {
            assert(assigned_expr.token_len >= 0)
            pos += assigned_expr.token_len
        }
        return assigned_expr
    }
    var assigned_expr = parse_assigned_if_needed()

    # Make sure we reached the proper ending:
    var had_damage = no
    if pos > tokens_len or
            ((not allow_type_refs or
              tokens[pos].kind != token.T_LEFTPTR) and
             (require_type_refs or (
              tokens[pos].kind != token.T_COMMA and
              (tokens[pos].kind != token.T_ENCLOSE or
               tokens[pos].str != ")")))) {
        if assigned_expr == none or
                not assigned_expr.has_damage() {
            var expected_str = "expected ',' (T_COMMA) or "
                "ending ')' (T_ENCLOSE)"
            if require_type_refs {
                expected_str = "expected '<-' (T_LEFTPTR)"
            } elseif allow_type_refs {
                expected_str = "expected ',' (T_COMMA), "
                    "ending ')' (T_ENCLOSE), or "
                    "'<-' (T_LEFTPTR)"
            }
            msgs.add(new msg.FileMsg(
                "Unexpected " + token.describe_token_at(
                    tokens, pos) +
                ", " + expected_str +
                call_ast_error_info_suffix(
                    callordef_line, callordef_col,
                    is_call=is_call) + ".",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
        }
        had_damage = yes
        var preskippos = pos
        if pos < tokens_len {
            var newpos = token.skip_garbage_to_closing_item(
                tokens, pos, token.T_COMMA, ",",
                skip_closing_item_itself=yes,
            )
            assert(newpos >= pos)
            pos = newpos
        }
    }
    #print("parse_single_call_or_funcdef_arg() past "
    #    "arg at pos " + pos.as_str() + " -> " +
    #    if pos <= tokens.len (tokens[pos].as_str()) else ("eof"))

    # If we're at a closing ',' + ')' then forward to final ')':
    if pos + 1 <= tokens_len and
            tokens[pos].kind == token.T_COMMA and
            tokens[pos + 1].kind == token.T_ENCLOSE and
            tokens[pos + 1].str == ")" {
        pos += 1
    }

    # Compose final return value:
    assert(pre_assign_expr != none)
    if assigned_expr != none {
        var result_node = new CallKWArgExpr()
        result_node.damaged = had_damage
        result_node.token_len = (pos - startpos)
        result_node.line = token.get_line(tokens, startpos)
        result_node.col = token.get_col(tokens, startpos)
        assert(pre_assign_expr.kind == ast.N_EXPR_IDREF)
        result_node.label = pre_assign_expr.label
        result_node.subexprs.add(assigned_expr)
        return result_node
    } else {
        if is_call {
            pre_assign_expr.damaged = had_damage
            return pre_assign_expr
        }
        var result_node = new ArgNameExpr()
        result_node.damaged = had_damage
        result_node.token_len = (pos - startpos)
        result_node.line = token.get_line(tokens, startpos)
        result_node.col = token.get_col(tokens, startpos)
        result_node.label = pre_assign_expr.label
        return result_node
    }
}

## Parse a func call or func definition argument expression,
## which must start with a '(' opening bracket.
## @returns CallArgsExpr
func parse_call_or_funcdef_args(
        tokens, pos, msgs, allow_type_refs=no,
        require_type_refs=no,
        is_call=no, is_moose64=no, project_file=none,
        callordef_line=none, max_len=none,
        callordef_col=none, debug=no
        ) {
    var result = _parse_call_or_funcdef_args_notlater(
        tokens, pos, 0, msgs, is_call=is_call,
        allow_type_refs=allow_type_refs,
        require_type_refs=require_type_refs,
        is_moose64=is_moose64,
        project_file=project_file,
        callordef_line=callordef_line, max_len=max_len,
        callordef_col=callordef_col, debug=debug
        )
    # Note/XXX: If we ever support inline code blocks, they will
    # have to be handled here.
    return later result
}

func _parse_call_or_funcdef_args_notlater(
        tokens, pos, nesting_depth, msgs,
        allow_type_refs=no, require_type_refs=no,
        is_call=no, is_moose64=no, project_file=none,
        callordef_line=none, max_len=none,
        callordef_col=none, debug=no
        ) {
    var tokens_len = tokens.len
    if tokens.len > 0 and typename(tokens[1]) == "str" {
        tokens = token.token_list_from_str_list(tokens)
    }
    if max_len != none and max_len < tokens_len {
        tokens_len = max_len
    }
    if require_type_refs {
        allow_type_refs = yes
    }

    if debug {
        print("compiler.ast.expr: "
            "_parse_call_or_funcdef_args_notlater() on " +
            tokens.sub(pos, math.min(pos + 10, tokens_len)).as_str() +
            "... with pos=" + pos.as_str() + ", "
            "tokens.len=" + tokens.len.as_str() + ", "
            "is_moose64=" + is_moose64.as_str() + ", "
            "require_type_refs=" + require_type_refs.as_str() + ", "
            "is_call=" + is_call.as_str() + ", "
            "max_len=" + max_len.as_str())
    }

    # Preparations:
    var node = new CallArgsExpr()
    node.line = token.get_line(tokens, pos)
    node.col = token.get_col(tokens, pos)
    var startpos = pos
    if pos > tokens_len or
            tokens[pos].kind != token.T_ENCLOSE or
            tokens[pos].str != "(" {
        node.token_len = 0
        return node
    }
    pos += 1  # Past '(' opening bracket
    if pos <= tokens_len and ((  # Empty arguments expression:
            tokens[pos].kind == token.T_ENCLOSE and
            tokens[pos].str == ")") or
            (tokens[pos].kind == token.T_COMMA and
             pos + 1 <= tokens_len and
             tokens[pos + 1].kind == token.T_ENCLOSE and
             tokens[pos + 1].str == ")")) {
        if tokens[pos].kind == token.T_COMMA {
            pos += 1  # Advance ONTO actual closing ')'.
        }
        # The pos var now points to last contained token.
        node.token_len = (pos - startpos) + 1
        return node
    }

    # Now parse first argument:
    var type_exprs = []
    while yes {
        var arg = parse_single_call_or_funcdef_arg(
            tokens, pos, nesting_depth, msgs, is_call=is_call,
            project_file=project_file,
            callordef_line=callordef_line,
            callordef_col=callordef_col,
            require_type_refs=require_type_refs,
            allow_type_refs=allow_type_refs,
        )
        if arg != none {
            pos += arg.token_len
        }
        var type_expr = none
        if require_type_refs and (pos > tokens_len or
                tokens[pos].kind != token.T_LEFTPTR) {
            if arg != none and not arg.damaged {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) +
                    ", expected '<-' (T_LEFTPTR) for the "
                    "argument's type.",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                arg.damaged = yes
            }
        } elseif (allow_type_refs or require_type_refs) and
                pos <= tokens_len and
                tokens[pos].kind == token.T_LEFTPTR {
            pos += 1
            var v = ast_typeref._parse_typeref_notlater(
                tokens, pos, msgs, project_file=project_file,
                max_len=tokens_len, is_moose64=is_moose64,
                debug=debug
            )
            if v == none {
                if arg != none and not arg.damaged {
                    msgs.add(new msg.FileMsg(
                        "Unexpected " + token.describe_token_at(
                            tokens, pos) +
                        ", expected type ref expression to "
                        "represent argument's type.",
                        source_file=project_file,
                        line=token.get_line(tokens, pos),
                        col=token.get_col(tokens, pos),
                    ))
                    arg.damaged = yes
                }
            } else {
                pos += v.token_len
                type_expr = v
            }
        }

        assert(arg != none)
        node.subexprs.add(arg)
        if allow_type_refs or require_type_refs {
            type_exprs.add(type_expr)
        }
        assert(pos >= 1)
        assert(arg.token_len >= 1)
        if pos > tokens_len or tokens[pos].kind != token.T_COMMA or
                (tokens[pos].kind == token.T_COMMA and
                pos + 1 <= tokens_len and
                tokens[pos + 1].kind == token.T_ENCLOSE and
                tokens[pos + 1].str == ")") {
            # We reached the end. If this isn't ')', then
            # parse_single_call_or_funcdef_arg() should have already
            # added an error to the msgs list.
            if pos <= tokens_len and tokens[pos].kind == token.T_COMMA {
                pos += 1
            }
            if pos > tokens_len or
                    tokens[pos].kind != token.T_ENCLOSE or
                    tokens[pos].str != ")" {
                pos -= 1  # Revert onto last valid contained token.
            }
            node.token_len = (pos - startpos) + 1

            if type_exprs.len > 0 or allow_type_refs {
                node.has_types = yes
            }
            node.subexprs += type_exprs
            return node
        }
        assert(tokens[pos].kind == token.T_COMMA)
        pos += 1  # Go past ','.
    }
}

