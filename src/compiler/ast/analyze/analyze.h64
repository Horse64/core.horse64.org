## @module compiler.ast.analyze
# Copyright (c) 2023-2025, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import random from core.horse64.org
import textfmt from core.horse64.org

import compiler.ast as ast
import compiler.ast.analyze.eval as ast_eval
import compiler.ast.expr as ast_expr
import compiler.ast.func_stmt as func_stmt
import compiler.ast.transform as ast_transform
import compiler.builtin_syms as builtin_syms
import compiler.limit as compiler_limit
import compiler.moose64.autocast as m64_autocast
import compiler.moose64.ast.analyze as m64_ast_analyze
import compiler.msg as msg
import compiler.storage.scope as st_scope
import compiler.storage.ref as st_ref
import compiler.typeinfo as typeinfo
import compiler.typeinfo.ast_typeref as ast_typeref

extend type func_stmt.FuncStmt {
    var is_later_func
}

func stmt_list_contains_later_call(
        stmts, check_recursive=yes,
        include_later_ignore=no,
        recurse_into_funcs=no) {
    for stmt in stmts {
        if {ast.N_STMT_VAR, ast.N_STMT_ASSIGN,
                ast.N_STMT_CALL}.has(stmt.kind) and
                stmt.has_later and
                (include_later_ignore or
                 not stmt.has_later_ignore) {
            return yes
        } elseif stmt.kind == ast.N_STMT_RETURN and
                stmt.has_later {
            return yes
        } elseif check_recursive {
            if stmt.kind == ast.N_STMT_IF or
                    stmt.kind == ast.N_STMT_DO {
                for clause in stmt.subexprs {
                    for block in clause.subblocks {
                        if stmt_list_contains_later_call(block,
                                check_recursive=yes,
                                include_later_ignore=
                                    include_later_ignore) {
                            return yes
                        }
                    }
                }
            }
            if (recurse_into_funcs or
                    stmt.kind != ast.N_STMT_FUNC) and
                    stmt.subblocks.len > 0 {
                for block in stmt.subblocks {
                    if stmt_list_contains_later_call(block,
                            check_recursive=yes,
                            include_later_ignore=
                                include_later_ignore) {
                        return yes
                    }
                }
            }
        }
    }
    return no
}

func ast_node_is_allowed_to_cause_type_error(
        node, parents, allow_typename_guard=yes,
        allow_attributeerror=no,
        ) {
    func check_expr_for_has_attr(origexpr) {
        func check_expr(expr) {
            if expr.kind == ast.N_EXPR_BINOP and
                    expr.optoken.str == "(" and
                    expr.subexprs.len >= 2 and
                    expr.subexprs[1].kind == ast.N_EXPR_IDREF and
                    expr.subexprs[1].label == "has_attr" and
                    (expr.subexprs[1].type_path == none or
                     expr.subexprs[1].type_path.len == 0) {
                return yes
            }
            for child in expr.subexprs {
                return check_expr(child)
            }
        }
        if origexpr.kind == ast.N_EXPR_IFELSECLAUSE {
            if check_expr(origexpr) {
                return yes
            }
        }
        for expr in origexpr.subexprs {
            if check_expr(expr) {
                return yes
            }
        }
        return no
    }
    func check_expr_for_typename(origexpr) {
        func check_expr(expr) {
            if expr.kind == ast.N_EXPR_BINOP and
                    expr.optoken.str == "(" and
                    expr.subexprs.len >= 2 and
                    expr.subexprs[1].kind == ast.N_EXPR_IDREF and
                    expr.subexprs[1].label == "typename" and
                    (expr.subexprs[1].type_path == none or
                     expr.subexprs[1].type_path.len == 0) {
                return yes
            }
            for child in expr.subexprs {
                return check_expr(child)
            }
        }
        if origexpr.kind == ast.N_EXPR_IFELSECLAUSE {
            if check_expr(origexpr) {
                return yes
            }
        }
        for expr in origexpr.subexprs {
            if check_expr(expr) {
                return yes
            }
        }
        return no
    }
    var i = parents.len
    while i >= 1 {
        if parents[i].kind == ast.N_STMT_IF {
            for clause in parents[i].subexprs {
                if clause.kind != ast.N_EXPR_IFELSECLAUSE or
                        clause.subblocks.len < 1 or
                        not clause.subblocks[1].find(node) {
                    continue
                }
                if check_expr_for_has_attr(clause) or (
                        allow_typename_guard and
                        check_expr_for_typename(clause)) {
                    return yes
                }
            }
        } elseif parents[i].kind == ast.N_STMT_DO {
            for clause in parents[i].subexprs {
                if not {ast.N_EXPR_RESCUECLAUSE,
                        N_EXPR_FINALLYCLAUSE}.has(
                            clause.kind
                        ) or
                        clause.subblocks.len < 1 or
                        not clause.subblocks[1].find(node) {
                    continue
                }
                var idx = 1
                while idx <= self.error_labels.len {
                    if self.subexprs[idx] != none and
                            self.subexprs[idx].kind ==
                                ast.N_EXPR_IDREF and
                            (self.subexprs[idx].str == "TypeError" or
                             (allow_attributeerror and
                              self.subexprs[idx].str ==
                                  "AttributeError")) and
                            (self.subexprs[idx].type_path == none or
                             self.subexprs[idx].type_path.len == 0) {
                        return yes
                    }
                    i += 1
                }
            }
        }
        i -= 1
    }
    return no
}

type FuncInfoResult {
    var name
    var is_func_attr
    var typeref_expr
    var func_scope
    var shallow_node
    var true_node
    var node_global_scope
    var node_project_file
    var storage_ref
    var owning_type_anscope
    var owning_type_storage_ref
    var owning_type_project_file
}

func get_func_info(
        from_node=none, from_node_project_file=none,
        from_type_expr=none, from_storage_ref=none,
        project=none, is_moose64=no) {
    var node = from_node
    var anscope = none
    var gscope = none
    if from_node != none and from_node_project_file == none {
        throw new RuntimeError("If from_node is set, then "
            "from_node_project_file must be set as well.")
    }
    if project == none and from_node_project_file != none {
        project = from_node_project_file.project
    }
    if project == none {
        throw new RuntimeError("Either the from_node_project_file "
            "or project option must be set.")
    }
    if node != none {
        assert(from_node_project_file != none)
        global_scope = from_node_project_file.global_scope
    }
    if node == none and from_storage_ref != none and
            from_storage_ref.kind == st_ref.ST_GLOBAL {
        node = st_scope.global_id_to_item(
            project_file.project, from_storage_ref.id)
        if node == none or typename(node) == "list" or
                node.kind != ast.N_STMT_FUNC {
            node = none
        } else {
            global_scope = project.storage_id_to_global_scope_map[
                from_storage_ref.id
            ]
            from_node_project_file =
                gscope.known_to_be_in_project_file
            assert(from_node_project_file != none)
        }
    } elseif node == none and from_storage_ref != none and
            from_storage_ref.kind == st_ref.ST_GLOBALATTR {
        assert(typename(from_storage_ref.id) == "list")
        var type_node = st_scope.global_id_to_item(
            project, from_storage_ref.id[1])
        if type_node != none and
                typename(type_node) != "list" and
                {ast.N_STMT_STRUCT,
                ast.N_STMT_TYPE}.has(type_node.kind) {
            anscope = type_node.attr_names_scope
            if anscope == none {
                throw new RuntimeError("Unexpectedly failed to "
                    "get AttrNamesScope from type or struct node.")
            }
            node = anscope.get_funcattr_node(
                from_storage_ref.id[2]
            )
            if node == none {
                anscope = none
            } else {
                assert(node.func_scope != none)
                global_scope = anscope.id_to_origin_gscope_map[
                    from_storage_ref.id[2]
                ]
                assert(global_scope != none)
            }
        }
    }
    if node != none and anscope == none and
            node.type_path != none and
            node.type_path.len > 0 {
        anscope = from_node_project_file.
            make_attr_names_scope_from_funcattr(
                node, is_moose64=is_moose64,
                def_project_file=from_node_project_file
            )
        if anscope == none {
            throw new RuntimeError("Unexpectedly failed to "
                "get AttrNamesScope from func node.")
        }
    }
    if node != none and from_storage_ref == none {
        if node.type_path == none or node.type_path.len == 0 {
            from_storage_ref = new st_ref.StorageRef(
                st_ref.ST_GLOBAL, node.symbol_info.storage_id
            )
        } else {
            assert(anscope != none)
            assert(node.symbol_info != none)
            assert(node.symbol_info.storage_id != none)
            from_storage_ref = new st_ref.StorageRef(
                st_ref.ST_GLOBALATTR, [
                    anscope.storage_id, node.symbol_info.storage_id
                ]
            )
        }
    }
    if node == none {
        return none
    }
    if node != none and from_type_expr == none {
        assert(node.symbol_info != none)
        from_type_expr = node.symbol_info.typeref_expr
        assert(from_type_expr.is_func_ref)
    }
    var result = new FuncInfoResult()
    result.name = node.label
    result.is_func_attr = (node.type_path != none and
        node.type_path.len > 0)
    result.func_scope = node.func_scope
    result.typeref_expr = from_type_expr
    result.shallow_node = node
    result.func_scope = node.func_scope
    result.node_global_scope = global_scope
    result.node_project_file =
        global_scope.known_to_be_in_project_file
    result.storage_ref = from_storage_ref
    if anscope != none and result.is_func_attr {
        result.owning_type_anscope = anscope
        result.owning_type_storage_ref = new st_ref.StorageRef(
            st_ref.ST_GLOBAL, anscope.storage_id
        )
        var gscope = project.storage_id_to_global_scope_map[
            anscope.storage_id
        ]
        result.owning_type_project_file =
            gscope.known_to_be_in_project_file
    }
    return result
}

func get_func_info_and_get_true_func_node(
        from_node=none, from_node_project_file=none,
        from_type_expr=none, from_storage_ref=none,
        project=none, is_moose64=no) {
    var result = get_func_info(
        from_node=from_node,
        from_node_project_file=from_node_project_file,
        from_type_expr=from_type_expr,
        from_storage_ref=from_storage_ref,
        project=project, is_moose64=is_moose64
    )
    if result == none {
        return later none
    }
    var project = result.node_project_file.project
    var true_node = project.
        get_true_global_node_from_shallow_node(
            result.shallow_node,
            project_file=result.node_project_file,
            is_moose64=is_moose64
        ) later:

    await true_node
    if true_node == none {
        return later none
    }
    result.true_node = true_node
    return result
}

func find_func_overrides_by_st_ref(
        storage_ref, project,
        error_when_finding_invalid_storage=yes,
        msgs=none, debug=no,
        is_moose64=no) {
    var program_name =
        if is_moose64 ("moosec") else ("horsec")
    var gnode = none
    var gscope = none
    var func_name = none
    var anscope = none
    var is_func_attr = no

    if debug {
        print(program_name + ": debug: "
            "find_func_overrides_by_st_ref(): "
            "Will look up overrides. " +
            "storage_ref=" + storage_ref.as_str())
    }

    if storage_ref.kind == st_ref.ST_GLOBAL {
        gnode = st_scope.global_id_to_item(
            project, storage_ref.id)
        if gnode != none and
                typename(gnode.symbol_info) == "list" {
            gnode = none
        }
        if gnode != none and
                gnode.kind == ast.N_STMT_FUNC {
            var gscope = project.
                storage_id_to_global_scope_map[storage_ref.id]
            if gscope == none {
                gnode = none
            } else {
                func_name = gnode.label
            }
        }
    } elseif storage_ref.kind == st_ref.ST_GLOBALATTR {
        var func_sinfo = st_ref.ref_to_symbol_info(
            storage_ref, project=project,
            is_moose64=is_moose64
        )
        if func_sinfo != none {
            is_func_attr = yes
            anscope = project.get_any_file().
                make_attr_names_scope_from_gid(
                    storage_ref.id[1], msgs=msgs,
                    is_moose64=is_moose64
                )
            if anscope == none {
                if error_when_finding_invalid_storage {
                    print(if is_moose64 ("moosec")
                        else ("horsec") +
                        ": error: Internal error, got attr "
                        "storage ref where we can't get the "
                        "anscope for the base type. "
                        "func_sinfo=" +
                            func_sinfo.as_str() + " "
                        "storage_ref=" +
                            storage_ref.as_str())
                    throw new ValueError("There seems to be "
                        "a broken type where the attr names "
                        "scope can't be acquired.")
                } else {
                    gnode = none
                }
            } else {
                gnode = anscope.get_funcattr_node(
                    storage_ref.id[2]
                )
                if gnode == none and
                        error_when_finding_invalid_storage {
                    print(if is_moose64 ("moosec")
                        else ("horsec") +
                        ": error: Internal error, got func "
                        "attr storage ref where we can't get "
                        "the func attr's global node. "
                        "func_sinfo=" +
                            func_sinfo.as_str() + " "
                        "storage_ref=" +
                            storage_ref.as_str() + " "
                        "anscope=" + anscope.as_str() + " "
                        "anscope.id_to_origin_gscope_map=" +
                            anscope.
                                id_to_origin_gscope_map.as_str())
                    throw new ValueError("There seems to be "
                        "a broken func attr where the attr "
                        "names scope can't return the global "
                        "node associated. The data "
                        "structures might be corrupted.")
                }
            }
            if gnode != none and
                    gnode.kind == ast.N_STMT_FUNC {
                func_name = gnode.label
            } else {
                gnode = none
            }
        }
    } else {
        throw new ValueError("Unsupported kind of "
            "StorageRef was passed in.")
    }
    if gnode == none or gnode.kind != ast.N_STMT_FUNC or
            func_name == none {
        if error_when_finding_invalid_storage {
            print(if is_moose64 ("moosec") else ("horsec") +
                ": error: Internal error, "
                "find_func_overrides_by_st_ref() "
                "used on storage ref that isn't a func. "
                "storage_ref=" + storage_ref.as_str())
            throw new ValueError("The item that was "
                "specified by the storage reference  "
                "doesn't seem to be a function.")
        } else {
            return none
        }
    }

    if debug {
        print(program_name + ": debug: "
            "find_func_overrides_by_st_ref(): "
            "We managed to find the func node. " +
            "gnode=" + gnode.as_str() + " "+
            "anscope=" + anscope.as_str() + " "
            "gscope=" + gscope.as_str())
    }

    # A list of info we want to have:
    var is_in_itself_override = gnode.is_override
    var override_base_name = none
    var all_nonoverridden_names = {}

    # Collect various info:
    if is_func_attr {
        assert(anscope != none)
        for alt_func_name in anscope.name_to_symbol_map {
            var sym = anscope.name_to_symbol_map[alt_func_name]
            if not {st_scope.SINFO_FUNCATTR,
                    st_scope.SINFO_FUNC}.has(sym.kind) {
                continue
            }
            var other_gnode = anscope.get_funcattr_node(
                sym.storage_id
            )
            if other_gnode.is_override {
                continue
            }
            all_nonoverridden_names.add(other_gnode.label)
        }
    } else {
        assert(gscope != none)
        for alt_func_name in gscope.name_to_stmt_map {
            var other_gnode = gscope.name_to_stmt_map[
                alt_func_name
            ]
            if typename(other_gnode) == "list" or
                    other_gnode.kind != ast.N_STMT_FUNC or
                    other_gnode.is_override {
                continue
            }
            all_nonoverridden_names.add(other_gnode.label)
        }
    }
    if is_in_itself_override {
        # We must find the proper override base name first.
        var best_candidate_name = none
        for base_name in all_nonoverridden_names {
            if gnode.label.starts(base_name + "_") and
                    (best_candidate_name == none or
                    base_name.len > best_candidate_name) {
                best_candidate_name = base_name
            }
        }
        override_base_name = best_candidate_name
        if override_base_name == none {
            throw new RuntimeError("Internal error, "
                "failed to determine base name for "
                "overridden func.")
        }
    } else {
        override_base_name = gnode.label
    }
    if debug {
        print(program_name + ": debug: "
            "find_func_overrides_by_st_ref(): "
            "We got all the extra info. "
            "override_base_name=" +
                textfmt.as_escaped_code_string(
                    override_base_name) + " "
            "gnode.label=" + gnode.label.as_str() + " "
            "is_func_attr=" + is_func_attr.as_str() + " "
            "is_in_itself_override=" +
                is_in_itself_override.as_str() + " "
            "all_nonoverridden_names=" +
                all_nonoverridden_names.as_str())
    }

    # Now collect the actual overrides:
    var result = []
    if is_func_attr {
        for alt_func_name in anscope.name_to_symbol_map {
            var expected_override_state = yes
            if not alt_func_name.starts(
                    override_base_name + "_") {
                if alt_func_name != override_base_name {
                    continue
                }
                expected_override_state = no
            }
            var sym = anscope.name_to_symbol_map[alt_func_name]
            if not {st_scope.SINFO_FUNCATTR,
                    st_scope.SINFO_FUNC}.has(sym.kind) {
                continue
            }
            var gnode = anscope.get_funcattr_node(
                sym.storage_id
            )
            if gnode.kind != ast.N_STMT_FUNC or
                    gnode.is_override != expected_override_state {
                continue
            }
            if gnode.is_override {
                var overridden_name = none
                for name in all_nonoverridden_names {
                    if alt_func_name.starts(name + "_") and
                            (overridden_name == none or
                            overridden_name.len < name.len) {
                        overridden_name = name
                    }
                }
                if overridden_name != override_base_name {
                    continue
                }
            }
            result.add([
                sym.typeref_expr.copy(),
                new st_ref.StorageRef(
                    st_ref.ST_GLOBALATTR, [
                        anscope.storage_id, sym.storage_id
                    ]
                ), gnode
            ])
        }
    } else {
        for alt_func_name in gscope.name_to_stmt_map {
            var expected_override_state = yes
            if not alt_func_name.starts(
                    override_base_name + "_") {
                if alt_func_name != override_base_name {
                    continue
                }
                expected_override_state = no
            }
            var gnode = gscope.name_to_stmt_map[
                alt_func_name]
            if typename(gnode) == "list" or
                    gnode.kind != ast.N_STMT_FUNC {
                continue
            }

            var gnode = gscope.name_to_stmt_map[
                alt_func_name]
            if typename(gnode) == "list" or
                    gnode.kind != ast.N_STMT_FUNC {
                continue
            }
            if gnode.is_override != expected_override_state {
                continue
            }
            if gnode.is_override {
                var overridden_name = none
                for name in all_nonoverridden_names {
                    if alt_func_name.starts(name + "_") and
                            (overridden_name == none or
                            overridden_name.len < name.len) {
                        overridden_name = name
                    }
                }
                if overridden_name != override_base_name {
                    continue
                }
            }
            result.add([
                gnode.symbol_info.typeref_expr.copy(),
                new st_ref.StorageRef(
                    st_ref.ST_GLOBAL,
                    gnode.symbol_info.storage_id
                ), gnode
            ])
        }
    }
    return result
}

type CalledFuncTypesResult {
    var called_func_is_attr = no
    var user_facing_called_args_len = 0

    var func_var_type_expr
    var func_var_typeinfo
    var func_var_name
    var func_var_preoverridden_name
    var func_was_overridden = no
    var func_ref
    var is_external = no
    var arg_var_type_exprs = []
    var arg_var_typeinfos = []
    var self_var_type_expr = none
    var self_var_typeinfo = none
    var have_args_mismatch = no
}

func CalledFuncTypesResult.as_str {
    var map = {
        "func_var_type_expr"-> self.func_var_type_expr,
        "func_var_typeinfo"-> self.func_var_typeinfo,
        "func_var_name"-> self.func_var_name,
        "func_var_preoverridden_name"->
            self.func_var_preoverridden_name,
        "func_was_overridden" -> self.func_was_overridden,
        "func_ref"-> self.func_ref,
        "is_external"-> self.is_external,
        "arg_var_type_exprs"-> self.arg_var_type_exprs,
        "arg_var_typeinfos"-> self.arg_var_typeinfos,
        "self_var_type_expr"-> self.self_var_type_expr,
        "self_var_typeinfo"-> self.self_var_typeinfo,
        "have_args_mismatch"-> self.have_args_mismatch,
    }
    return "CalledFuncTypesResult" + map.as_str()
}

func get_called_or_assigned_func_types(
        project_file, called_node, called_node_parents,
        allow_matching_func_override=no,
        allow_noncall_ref=no,
        ignore_arg_mismatch=no,
        verify_external_func_args=no,  # FIXME: Enable once supported!
        _internal_override_called_func_name=none,
        _internal_override_called_func_st_ref=none,
        _internal_override_called_func_typerefexpr=none,
        try_to_match_func_type_expr=none,
        msgs=none, is_moose64=no, debug=no
        ) {
    var prog_name = if is_moose64 ("moosec") else ("horsec")
    var dbg_prefix = if is_moose64 ("moosec: debug:")
        else ("horsec: debug:")

    if debug {
        var t = (dbg_prefix + " get_called_or_assigned_func_types(): "
            "Launched on called_node=" + called_node.as_str())
        if try_to_match_func_type_expr != none {
            t += (", "
                "with: try_to_match_func_type_expr=" +
                try_to_match_func_type_expr.as_str())
        }
        if _internal_override_called_func_typerefexpr != none {
            t += (", "
                "with: _internal_override_called_func_typerefexpr=" +
                    _internal_override_called_func_typerefexpr.as_str() + " "
                "_internal_override_called_func_st_ref=" +
                    _internal_override_called_func_st_ref.as_str() + " "
                "_internal_override_called_func_typerefexpr=" +
                    _internal_override_called_func_typerefexpr.as_str())
        } else {
            t += "."
        }
        print(t)
    }
    assert(typename(called_node_parents) == "list")
    var called_node_parent = if called_node_parents.len > 0
        (called_node_parents[called_node_parents.len]) else (none)

    if allow_noncall_ref and
            (called_node_parent == none or
            called_node_parent.kind != ast.N_EXPR_BINOP or
            called_node_parent.optoken.str != '(' or
            called_node_parent.subexprs[2].kind !=
                ast.N_EXPR_CALLARGS or
            called_node_parent.subexprs[1] != called_node) {
        # Okay, we need to simply directly look up what func
        # this node refers to, and then if needed see about
        # overrides.
        if debug {
            print(dbg_prefix + " "
                "get_called_or_assigned_func_types(): "
                "Examining a non-call node. " +
                "node=" + called_node.as_str())
        }

        var func_ref = none
        if called_node.kind == ast.N_EXPR_IDREF {
            func_ref = called_node.ref
        } elseif called_node.kind == ast.N_EXPR_BINOP and
                called_node.optoken.str == "." and
                called_node.subexprs.len >= 2 and
                called_node.subexprs[2].kind == ast.N_EXPR_IDREF {
            func_ref = called_node.subexprs[2].ref
        }
        if func_ref == none {
            if debug {
                print(dbg_prefix + " "
                    "get_called_or_assigned_func_types(): "
                    "Couldn't extract a usable func ref.")
            }
            return later none
        }
        if debug {
            print(dbg_prefix + " "
                "get_called_or_assigned_func_types(): "
                "Will now resolve the func ref. "
                "func_ref=" + func_ref.as_str())
        }
        var result = ast_typeref.
            resolve_st_ref_to_type_ref_and_expr(
                project_file, func_ref,
                node=called_node,
                node_parents=called_node_parents,
                apply_func_override_for_args_node=none,
                apply_func_override_for_func_type_expr=none,
                ignore_if_ref_none=no,
                msgs=msgs, is_moose64=is_moose64,
                debug=no,
            ) later:

        await result
        if result.storage_ref == none or
                result.type_expr == none or
                not result.type_expr.is_func_ref {
            if debug {
                print(dbg_prefix + " "
                    "get_called_or_assigned_func_types(): "
                    "Couldn't resolve the node, or it didn't "
                    "point to a function.")
            }
            return later none
        }

        # Collect preliminary result:
        var cft_result = new CalledFuncTypesResult()
        cft_result.called_func_is_attr =
            result.type_expr.is_func_attr
        cft_result.func_var_type_expr =
            result.type_expr.copy()
        cft_result.func_var_typeinfo = none
        cft_result.func_var_name = none
        if called_node.kind == ast.N_EXPR_IDREF {
            cft_result.func_var_name = called_node.label
        } elseif called_node.kind == ast.N_EXPR_BINOP and
                called_node.optoken.str == "." and
                called_node.subexprs.len >= 2 and
                called_node.subexprs[2].kind == ast.N_EXPR_IDREF {
            cft_result.func_var_name = called_node.subexprs[2].label
        }
        cft_result.func_var_preoverridden_name =
            cft_result.func_var_name
        cft_result.func_was_overridden = no
        cft_result.func_ref = result.storage_ref.copy()
        cft_result.is_external =
            {st_ref.ST_CEXT, st_ref.ST_MCREF}.has(
                cft_result.func_ref.kind)
        cft_result.arg_var_type_exprs = none
        cft_result.arg_var_typeinfos = none
        cft_result.self_var_type_expr = none
        cft_result.self_var_typeinfo = none
        cft_result.have_args_mismatch = no
        if debug {
            print(dbg_prefix + " "
                "get_called_or_assigned_func_types(): "
                "Preliminary result was assembled.")
        }

        var override_info_list =
            find_func_overrides_by_st_ref(
                cft_result.func_ref,
                project_file.project,
                msgs=msgs,
                is_moose64=is_moose64,
                debug=debug,
            )
        if debug {
            print(dbg_prefix + " "
                "get_called_or_assigned_func_types(): "
                "Got override list. "
                "override_info_list=" +
                    override_info_list.as_str())
        }
        if override_info_list.len > 1 {
            # Determine if currently, the node is already
            # referring to an override:
            var base_name
            for entry in override_info_list {
                if not entry[3].is_override {
                    base_name = entry[3].label
                }
                if entry[3].label ==
                        cft_result.func_var_name and
                        entry[3].is_override {
                    cft_result.func_was_overridden = yes
                }
            }
            if cft_result.func_was_overridden {
                assert(base_name != none)
                cft_result.func_var_preoverridden_name =
                    base_name
            }
            if debug {
                print(dbg_prefix + " "
                    "get_called_or_assigned_func_types(): "
                    "Determined that this is currently an "
                    "overridden func being targeted. "
                    "base_name=" +
                    textfmt.as_escaped_code_string(
                        base_name
                    ))
            }
        }

        # Now pick better override if needed:
        if try_to_match_func_type_expr != none and
                override_info_list.len > 1 and
                not try_to_match_func_type_expr.is_equivalent(
                    result.type_expr, is_moose64=is_moose64) {
            # Try to pick a better alternative in this situation.
            if debug {
                print(dbg_prefix + " "
                    "get_called_or_assigned_func_types(): "
                    "Trying to find better matching override...")
            }
            var found_override = no
            for entry in override_info_list {
                var func_type_expr = entry[1].copy()
                if func_type_expr.is_equivalent(
                        try_to_match_func_type_expr,
                        require_same_storage=no) {
                    cft_result.func_was_overridden =
                        entry[3].is_override
                    cft_result.func_var_name = entry[3].label
                    cft_result.func_ref = entry[2].copy()
                    cft_result.func_var_type_expr =
                        func_type_expr.copy()
                    cft_result.is_external =
                        {st_ref.ST_CEXT, st_ref.ST_MCREF}.has(
                            cft_result.func_ref.kind)
                    found_override = yes
                    if debug {
                        print(dbg_prefix + " "
                            "get_called_or_assigned_func_types(): "
                            "Found new override match.")
                    }
                    break
                }
            }
            if not found_override {
                if debug {
                    print(dbg_prefix + " "
                        "get_called_or_assigned_func_types(): "
                        "Couldn't find new override match.")
                }
            }
        }

        # At the end, collect the proper typeinfo too:
        var tinfo = typeinfo.
            create_typeinfo_from_typeexpr_and_verify(
                cft_result.func_var_type_expr,
                store_self_value_ref_for_funcs=yes,
                base_node_if_known=called_node,
                base_node_parents_if_known=called_node_parents,
                project_file=project_file,
                is_moose64=is_moose64,
                debug=no,
            ) later:

        await tinfo
        if tinfo == none {
            if debug {
                print(dbg_prefix + " "
                    "get_called_or_assigned_func_types(): "
                    "The func type seems invalid, bailing.")
            }
            return later none
        }
        cft_result.func_var_typeinfo = tinfo
        return cft_result
    }
    if not is_moose64 {
        return later none
    }
    if called_node.damaged or called_node_parent.damaged {
        return later none
    }
    var is_call = no
    if called_node_parent.kind != ast.N_EXPR_BINOP or
            called_node_parent.optoken.str != '(' or
            called_node_parent.subexprs.len != 2 or
            called_node_parent.subexprs[2].kind !=
                ast.N_EXPR_CALLARGS or
            called_node_parent.subexprs[1] != called_node {
        throw new RuntimeError("Internal error, "
            "get_called_or_assigned_func_types() called with "
            "called_node_parent not set to valid call "
            "expression.")
    }

    var is_external = no
    var called_node_name = none
    var called_node_ref = none
    if called_node.kind == ast.N_EXPR_IDREF {
        called_node_ref = called_node.ref
        called_node_name = called_node.label
    } else {
        assert(called_node.kind == ast.N_EXPR_BINOP and
               called_node.optoken.str == "." and
               called_node.subexprs.len == 2 and
               called_node.subexprs[2].kind == ast.N_EXPR_IDREF)
        called_node_ref = called_node.subexprs[2].ref
        called_node_name = called_node.subexprs[2].label
    }
    if _internal_override_called_func_name != none {
        called_node_name = _internal_override_called_func_name
    }
    if _internal_override_called_func_st_ref != none {
        called_node_ref = _internal_override_called_func_st_ref
    }
    if called_node_ref != none and
            called_node_ref.kind == st_ref.ST_MCREF {
        is_external = yes
    }

    var call_args_expr = called_node_parent.subexprs[2]
    if debug {
        print(dbg_prefix + " get_called_or_assigned_func_types(): "
            "Found call_args_expr=" + call_args_expr.as_str())
    }
    var func_typeinfo = none
    func obtain_func_info_if_possible {
        if is_external {
            # This might be allowed later in some cases when
            # C header parsing works, but for now, it isn't.
            return later
        }
        if _internal_override_called_func_typerefexpr != none {
            # This is used if we're meant to check out a func
            # override. Retain the self value ref in this case:
            var unaltered_typeinfo =
                m64_ast_analyze.get_c_or_m64_type_of_node(
                    project_file, called_node, called_node_parents,
                    store_self_value_ref_for_funcs=yes,
                    msgs=msgs, debug=debug
                ) later:  # (What we originally would have called.)

            await unaltered_typeinfo
            func_typeinfo = typeinfo.
                create_typeinfo_from_typeexpr_and_verify(
                    _internal_override_called_func_typerefexpr,
                    project_file=project_file, 
                    store_self_value_ref_for_funcs=no,
                    is_moose64=is_moose64,
                ) later:  # (The override.)

            await func_typeinfo
            if debug {
                print(dbg_prefix + " "
                    "get_called_or_assigned_func_types(): "
                    "Examining override with overriden typeref "
                    "expr. Details: " +
                    "unaltered_typeinfo=" +
                        unaltered_typeinfo.as_str() + " "
                    "func_typeinfo=" +
                        func_typeinfo.as_str())
            }
            if unaltered_typeinfo == none or
                    func_typeinfo == none {
                func_typeinfo = none
                return later
            }
            if unaltered_typeinfo.func_self_ref != none {
                func_typeinfo.func_self_ref =
                    unaltered_typeinfo.func_self_ref.copy()
            }
            return later
        }
        func_typeinfo =
            m64_ast_analyze.get_c_or_m64_type_of_node(
                project_file, called_node, called_node_parents,
                store_self_value_ref_for_funcs=yes,
                msgs=msgs, debug=debug
            ) later:  # Get type info from our call node.

        await func_typeinfo
        return later
    }
    obtain_func_info_if_possible()
    later:

    if debug {
        print(dbg_prefix + " "
            "get_called_or_assigned_func_types(): "
            "Got a node type result. func_typeinfo=" +
            func_typeinfo.as_str() + " "
            "func_typeinfo.func_typeexpr.name=" +
                if func_typeinfo != none and
                func_typeinfo.kind == typeinfo.TI_FUNCREF and
                func_typeinfo.func_typeexpr != none
                    (func_typeinfo.func_typeexpr.name.as_str())
                    else ("none"))
    }
    if func_typeinfo == none {
        if is_external and
                not verify_external_func_args {
            var result = new CalledFuncTypesResult()
            result.func_var_name =
                builtin_syms.get_item_name_by_storage_ref(
                    project_file.project, called_node.ref
                )
            assert(result.func_var_name != none)
            result.is_external = yes
            if called_node.kind == ast.N_EXPR_IDREF {
                result.func_ref = called_node.ref.copy()
            } elseif called_node.kind == ast.N_EXPR_BINOP {
                assert(called_node.optoken.str == ".")
                assert(called_node.subexprs[2].kind == ast.N_EXPR_IDREF)
                result.func_ref = called_node.subexprs[2].ref.copy()
            }
            return later result
        }
        if debug {
            print(dbg_prefix +
                " get_called_or_assigned_func_types(): "
                "Unexpectedly don't have func_typeinfo, while "
                "looking at: " +
                "called_node=" +
                    called_node.as_str())
        }
        if msgs == none {
            throw new RuntimeError("Failed to determine node type, "
                "internal error.")
        }
        if not called_node.damaged {
            var desc = "function"
            if called_node_name != none {
                desc = "function " + textfmt.as_escaped_code_string(
                    called_node_name)
                if called_node.kind == ast.N_EXPR_BINOP and
                        called_node.optoken.str == "." and
                        called_node.subexprs.len == 2 and
                        called_node.subexprs[1].kind ==
                            ast.N_EXPR_IDREF {
                    desc = "function " +
                        textfmt.as_escaped_code_string(
                            called_node.subexprs[1].label + "." +
                            called_node_name)
                } elseif called_node.kind == ast.N_EXPR_IDREF and
                        called_node.type_path != none and
                        called_node.type_path.len > 0 {
                    desc = "function " +
                        textfmt.as_escaped_code_string(
                            called_node.
                                type_path.join(".") + "." +
                            called_node_name)
                }
            }
            msgs.add(new msg.FileMsg(
                "Unexpectedly failed to determine full type of "
                "called " + desc + ". Did you use cyclic references?",
                kind=msg.M_ERROR, source_file=project_file,
                line=called_node_parent.line,
                col=called_node_parent.col,
            ))
        }
        called_node.damaged = yes
        return later none
    }
    if func_typeinfo.kind != typeinfo.TI_FUNCREF {
        if msgs == none {
            throw new RuntimeError(
                "The called node isn't a function.")
        }
        msgs.add(new msg.FileMsg(
            "Unexpected call to non-func item, "
            "this isn't allowed.",
            kind=msg.M_ERROR, source_file=project_file,
            line=called_node_parent.line,
            col=called_node_parent.col,
        ))
        called_node.damaged = yes
        return later none
    }
    var m64_type_ref = none
    func recompute_user_type {
        if func_typeinfo.func_typeexpr == none {
            return
        }
        # Try to trace back the actual func we're calling:
        assert(func_typeinfo.func_typeexpr.is_func_ref)
        var m64_type_ref_result = func_typeinfo.func_typeexpr.
            try_resolve_to_user_type(
                project_file, recursive=yes,
                force_recompute=yes,
                is_moose64=is_moose64
            ) later:

        await m64_type_ref_result
        m64_type_ref =
            m64_type_ref_result.resolved_storage_ref
        if m64_type_ref != none and
                func_typeinfo.user_type_ref == none {
            func_typeinfo.user_type_ref =
                m64_type_ref.copy()
        }
    }
    recompute_user_type()
    later:

    var func_changed_to_override = no
    var func_actual_name = none
    if m64_type_ref != none {
        # Not a func pointer, we know the name of
        # what exactly we're calling.
        func_actual_name = st_ref.ref_to_item_name(
            project_file, m64_type_ref)
    }

    # Handle self ref if any:
    var self_value_ref =
        if func_typeinfo.func_self_ref != none
        (func_typeinfo.func_self_ref.copy()) else (none)
    var self_type_typeinfo = none
    var self_type_expr = none
    func handle_extra_for_self_type {
        if (self_value_ref == none and
                not func_typeinfo.func_typeexpr.is_func_attr) or
                called_node.kind != ast.N_EXPR_BINOP {
            return later
        }
        var result = ast_typeref.resolve_st_ref_to_type_ref_and_expr(
            project_file, self_value_ref,
            node=called_node.subexprs[1],
            node_parents=called_node_parents + [called_node],
            is_moose64=is_moose64, msgs=msgs,
        ) later:

        await result
        self_type_expr = result.type_expr
        if self_type_expr == none {
            if msgs == none {
                throw new RuntimeError(
                    "Failed to trace back to self type.")
            }
            msgs.add(new msg.FileMsg(
                "This call is unexpectedly done "
                "on an attribute on an item "
                "with a broken type. "
                "Was the item declared with a "
                "forbidden cyclic type?",
                kind=msg.M_ERROR, source_file=project_file,
                line=called_node_parent.line,
                col=called_node_parent.col,
            ))
            called_node_parent.damaged = yes
            called_node.damaged = yes
            return later none
        }
    }
    handle_extra_for_self_type() later:

    if called_node.damaged {
        return later none
    }

    var func_var_typeref = func_typeinfo.func_typeexpr
    var func_var_typeinfo = func_typeinfo
    var func_st_ref = func_var_typeinfo.user_type_ref
    if func_st_ref == none and func_var_typeref != none {
        func_st_ref = func_var_typeref.func_storage_ref
    }
    var arg_var_types = []
    var arg_var_type_exprs = []

    # Now, collect info about expected vs actually given call signature:
    var expected_args_len =
        func_typeinfo.func_typeexpr.arg_typeref_exprs.len +
        if func_typeinfo.func_typeexpr.is_func_attr (-1) else (0) +
        if func_typeinfo.func_typeexpr.is_failable (-1) else (0)
    assert(expected_args_len >= 0)
    var called_args_exprs = call_args_expr.subexprs.copy()
    var called_args_len = call_args_expr.subexprs.len
    if func_typeinfo.func_typeexpr.is_failable {
        var arg_typeref_exprs =
             func_typeinfo.func_typeexpr.
                arg_typeref_exprs.copy()
        if arg_typeref_exprs.len < 0 or
                arg_typeref_exprs[arg_typeref_exprs.len].is_func_ref or
                arg_typeref_exprs[arg_typeref_exprs.len].
                    name != "moose64_failed_result_t" {
            var last_param_is_func_ref =
                arg_typeref_exprs[arg_typeref_exprs.len].is_func_ref
            var last_param_name =
                arg_typeref_exprs[arg_typeref_exprs.len].name
            print(prog_name + ": error: Internal error, "
                "got invalid func signature, "
                "it's marked failable but has no failable "
                "parameter at the end. Info: "
                "arg_typeref_exprs=" +
                    arg_typeref_exprs.as_str() + " "
                "expected_args_len=" +
                    expected_args_len.as_str() + " "
                "is_func_attr=" +
                    func_typeinfo.func_typeexpr.
                        is_func_attr.as_str() + " "
                "is_failable=" +
                    func_typeinfo.func_typeexpr.
                        is_failable.as_str() + " "
                "last_param_is_func_ref=" +
                    last_param_is_func_ref.as_str() + " "
                "last_param_name=" +
                    last_param_name.as_str())
            throw new RuntimeError("Got invalid func "
                "signature, it's marked failable but has "
                "no failable parameter at the end.")
        }
    }

    var is_self_call =
        is_func_call_node_for_sure_a_self_call(
            project_file, called_node_parent,
            called_node_ref=called_node_ref,
            is_moose64=is_moose64
        )
    var user_facing_called_args_len =
        called_args_len
    var last_param_m64_typeinfo = none
    func determine_last_param_type_if_needed {
        if called_args_exprs.len <= 0 {
            return later
        }
        # If last parameter is a C item, don't try to determine
        # type (since it's not a failable anyway, and we allow
        # for the signature for C externals to be unknown):
        if called_args_exprs[
                    called_args_exprs.len
                ].kind == ast.N_EXPR_IDREF and
                called_args_exprs[
                    called_args_exprs.len
                ].ref != none and
                called_args_exprs[
                    called_args_exprs.len
                ].ref.kind == st_ref.ST_MCREF {
            return later
        } elseif called_args_exprs[
                    called_args_exprs.len
                ].kind == ast.N_EXPR_BINOP and
                called_args_exprs[
                    called_args_exprs.len
                ].optoken.str == "." and
                called_args_exprs[
                    called_args_exprs.len
                ].subexprs[2].kind == ast.N_EXPR_IDREF and
                called_args_exprs[
                    called_args_exprs.len
                ].subexprs[2].ref != none and
                called_args_exprs[
                    called_args_exprs.len
                ].subexprs[2].ref.kind == st_ref.ST_MCREF {
            return later
        }
        # Determine the parameter type:
        last_param_m64_typeinfo =
            m64_ast_analyze.get_c_or_m64_type_of_node(
                project_file, called_args_exprs[
                    called_args_exprs.len
                ], called_node_parents + [call_args_expr],
                store_self_value_ref_for_funcs=no,
                msgs=msgs, debug=no,
            ) later:

        await last_param_m64_typeinfo
        if last_param_m64_typeinfo == none {
            if msgs != none and msg.msgs_contain_error(msgs) {
                last_param_m64_typeinfo = "type-error"
                return later
            }
            print(if is_moose64 ("horsec")
                else ("moosec") + ": "
                "error: Internal error, failed to determine "
                "type of this node: "
                "arg_expr=" +
                called_args_exprs[
                    called_args_exprs.len
                ].as_str() + " (got msgs=" +
                msgs.as_str() + ")")
            throw new RuntimeError(
                "Internal error: Failed to determine "
                "type of last call parameter. Please "
                "report this error to the compiler makers."
            )
        }
    }
    determine_last_param_type_if_needed() later:
    if last_param_m64_typeinfo == "type-error" {
        assert(msgs != none)
        return later none
    }

    var expected_actual_arg_typeexprs =
        func_typeinfo.func_typeexpr.
            arg_typeref_exprs.copy()
    var called_actual_arg_types = []
    var called_actual_arg_user_indexes = []
    var is_failable_call =
        last_param_m64_typeinfo != none and
        last_param_m64_typeinfo.kind == typeinfo.TI_C_TYPE and
        last_param_m64_typeinfo.orig_type_name ==
            "moose64_failed_result_t" and
        last_param_m64_typeinfo.modifiers.len == 1 and
        last_param_m64_typeinfo.modifiers[1].name == "ref"
    if is_failable_call {
        assert(user_facing_called_args_len > 0)
        user_facing_called_args_len -= 1
    }
    var expected_failable_call =
        func_typeinfo.func_typeexpr.is_failable
    if expected_failable_call {
        assert(expected_actual_arg_typeexprs.len > 0)
        expected_actual_arg_typeexprs =
            expected_actual_arg_typeexprs.sub(
                1, expected_actual_arg_typeexprs.len - 1)
    }
    var expected_self_call =
        func_typeinfo.func_typeexpr.is_func_attr
    if expected_self_call {
        assert(expected_actual_arg_typeexprs.len > 0)
        expected_actual_arg_typeexprs =
            expected_actual_arg_typeexprs.sub(2)
    }
    var is_called_with_adhoc_self = no
    var expected_with_self_str =
        if expected_self_call ("with self ref")
        else ("without self ref")
    var called_with_self_str =
        if is_self_call ("with self ref")
        else ("without self ref")

    var called_name = "func"
    if called_node.kind == ast.N_EXPR_BINOP and
            called_node.optoken.str == "." and
            called_node.subexprs.len == 2 and
            called_node.subexprs[2].kind == ast.N_EXPR_IDREF {
        called_name = "'" + called_node.subexprs[2].label + "'"
    } elseif called_node.kind == ast.N_EXPR_IDREF {
        called_name = "'" + called_node.label + "'"
    }

    func determine_adhoc_self_call {
        var could_be_adhoc_self_call = no
        if expected_self_call and not is_self_call and
                called_args_len >= expected_args_len + 1 and
                called_args_exprs.len > 0 {
            could_be_adhoc_self_call = yes
        }
        if not could_be_adhoc_self_call {
            return later
        }

        var potential_self_ref = none
        var arg_type = m64_ast_analyze.
            get_c_or_m64_type_of_node(
                project_file, called_args_exprs[
                    1
                ], called_node_parents + [call_args_expr],
                store_self_value_ref_for_funcs=no,
                msgs=msgs,
            ) later:

        await arg_type
        if arg_type == none {
            return later
        }
        if arg_type.ref_count(
                include_c_arrays=no, include_arrays=no
                ) != 0 or
                arg_type.kind != typeinfo.TI_USERTYPE or
                arg_type.user_type_ref == none {
            return later
        }
        potential_self_ref = arg_type.user_type_ref

        assert(func_typeinfo.func_typeexpr.
                arg_typeref_exprs.len >= 1)
        assert(func_typeinfo.func_typeexpr.
                arg_typeref_exprs[1].ref_count(
                include_c_arrays=no, include_arrays=no,
                include_implicit_refs=no,
                include_explicit_refs=yes,
            ) == 0)
        assert(func_typeinfo.func_typeexpr.
                arg_typeref_exprs[1].is_user_type() and
            func_typeinfo.func_typeexpr.
                arg_typeref_exprs[1].storage_ref != none)

        var func_self_ref = 
            func_typeinfo.func_typeexpr.
            arg_typeref_exprs[1].storage_ref
        if potential_self_ref.alike(
                func_self_ref) {
            is_called_with_adhoc_self = yes
            if debug {
                print(dbg_prefix + " "
                    "get_called_or_assigned_func_types(): "
                    "determine_adhoc_self_call(): "
                    "Self refs are the same.")
            }
            assert(self_value_ref == none)
            sself_value_ref = potential_self_ref.copy()
            assert(self_type_typeinfo == none)
            self_type_typeinfo = arg_type
            assert(self_type_expr == none)
            self_type_expr = called_args_exprs[1]

            called_with_self_str = "with self ref"
            is_self_call = yes
            called_args_exprs = called_args_exprs.sub(2)
            called_args_len -= 1
            expected_args_len += 1
        } else {
            if debug {
                print(dbg_prefix + " "
                    "get_called_or_assigned_func_types(): "
                    "determine_adhoc_self_call(): "
                    "Self refs differ: "
                    "potential_self_ref=" +
                        potential_self_ref.as_str() + " "
                    "func_self_ref=" +
                        func_self_ref.as_str() + " "
                    "called_node.line=" +
                        called_node.line.as_str() + " "
                    "called_node.col=" +
                        called_node.col.as_str())
            }
        }
    }
    determine_adhoc_self_call()
    later:

    # If any mismatched argument is found, this will be
    # set to [idx, signature_typeinfo, actual_arg_typeinfo]:
    var signature_arg_mismatch_info = none

    var signature_mismatch = no
    if user_facing_called_args_len != expected_args_len or
            is_failable_call != expected_failable_call or
            is_self_call != expected_self_call {
        signature_mismatch = yes
    }

    var abort_due_to_param_eval_error = no
    func evaluate_param_types_if_needed {
        if signature_mismatch {
            return later
        }

        var indexes = []
        var i = 1
        while i <= called_args_exprs.len {
            if i == called_args_exprs.len and
                    is_failable_call {
                i += 1
                continue
            }
            indexes.add(i)
            i += 1
        }
        func create_arg_list {
            func obtain_arg(arg_idx) {
                # The argument number the user thinks this is:
                var user_facing_idx = arg_idx
                if is_called_with_adhoc_self {
                    # (Since called_args_exprs is trimmed to
                    # the non-self args even in the ad-hoc case.)
                    user_facing_idx += 1
                }

                # Determine the argument type:
                var arg_type =
                    m64_ast_analyze.get_c_or_m64_type_of_node(
                        project_file, called_args_exprs[
                            arg_idx
                        ], called_node_parents + [call_args_expr],
                        store_self_value_ref_for_funcs=no,
                        msgs=msgs,
                    ) later:

                await arg_type
                if arg_type == none {
                    if msgs != none and
                            msg.msgs_contain_error(msgs) {
                        return later no
                    }
                    print(if is_moose64 ("horsec")
                            else ("moosec") + ": "
                        "error: Internal error, "
                        "failed to determine type of this node: "
                        "called_args_exprs[" +
                            arg_idx.as_str() + "]=" +
                        called_args_exprs[
                            arg_idx
                        ].as_str() +
                        " (got msgs=" + msgs.as_str() + ")")
                    throw new RuntimeError(
                        "Internal error: Failed to determine "
                        "type of call parameter. Please "
                        "report this error to the compiler makers."
                    )
                }
                called_actual_arg_types.add(arg_type)
                called_actual_arg_user_indexes.add(
                    user_facing_idx)
                return yes
            }

            var index_queue = indexes.copy()
            if index_queue.len == 0 {
                return later yes
            }

            var next_idx = index_queue.pop_at(1)
            assert(next_idx >= 1 and
                next_idx <= called_args_exprs.len)
            var result = obtain_arg(next_idx) later:

            await result
            if not result {
                return later no
            }
            if index_queue.len == 0 {
                return later yes
            }

            next_idx = index_queue.pop_at(1)
            assert(next_idx >= 1 and
                next_idx <= called_args_exprs.len)
            result = obtain_arg(next_idx) later repeat
        }
        var result = create_arg_list()
        later:

        await result
        if not result {
            abort_due_to_param_eval_error = yes
            return later
        }
        assert(called_actual_arg_types.len ==
            expected_actual_arg_typeexprs.len)

        func test_arg(idx, user_facing_idx,
                arg_signature_expr, arg_actual_type) {
            var signature_typeinfo =
                typeinfo.create_typeinfo_from_typeexpr(
                    arg_signature_expr, is_moose64=yes
                )
            if signature_typeinfo == none {
                if arg_signature_expr.damaged {
                    return later no
                }
                if msgs != none {
                    for m in msgs {
                        if m.kind == msg.M_ERROR {
                            # In this case, this is
                            # probably a follow-up error.
                            return later no
                        }
                    }
                }
                print(if is_moose64 ("horsec")
                        else ("moosec") + ": "
                    "error: Internal error, "
                    "failed to determine type of this "
                    "func signature arg expr: "
                    "arg_expr=" + arg_signature_expr.as_str() +
                    " (got msgs=" + msgs.as_str() + ")")
                throw new RuntimeError(
                    "Internal error: Failed to determine "
                    "type of arg in func signature. Please "
                    "report this error to the compiler makers."
                )
            }
            assert(is_moose64)
            var allowed = m64_autocast.
                check_if_allowed_implicit_cast_from_to(
                    arg_actual_type, signature_typeinfo,
                )
            if debug {
                print(dbg_prefix + " "
                    "get_called_or_assigned_func_types(): "
                    "Testing arg #" + idx.as_str() + " ("
                    "user-facing #" +
                    user_facing_idx.as_str() + ") which " +
                    if allowed ("fits") else ("doesn't fit") + ". "
                    "arg_actual_type=" +
                        arg_actual_type.as_str() + " "
                    "signature_typeinfo=" +
                        signature_typeinfo.as_str() + " "
                    "called_node.line=" +
                        called_node.line.as_str() + " "
                    "called_node.col=" +
                        called_node.col.as_str())
            }
            if not allowed {
                signature_arg_mismatch_info = [
                    idx, user_facing_idx,
                    signature_typeinfo, arg_actual_type
                ]
                signature_mismatch = yes
                return later no
            }
            return later yes
        }

        var args_queue = []
        var idx = 0
        for arg_expr in
                expected_actual_arg_typeexprs {
            idx += 1
            args_queue.add([idx,
                called_actual_arg_user_indexes[idx],
                arg_expr,
                called_actual_arg_types[idx]])
        }
        if args_queue.len == 0 {
            return later
        }
        var next_arg = args_queue.pop_at(1)
        var does_match = test_arg(
            next_arg[1], next_arg[2], next_arg[3],
            next_arg[4],
        ) later:

        await does_match
        if not does_match {
            signature_mismatch = yes
            return later
        }

        if args_queue.len == 0 {
            return later
        }
        next_arg = args_queue.pop_at(1)
        does_match = test_arg(
            next_arg[1], next_arg[2], next_arg[3],
            next_arg[4],
        ) later repeat
    }
    evaluate_param_types_if_needed()
    later:

    if abort_due_to_param_eval_error {
        assert(msgs != none)
        return later none
    }

    var proper_func_base_name = none
    var override_success_result = none
    func try_finding_override(entry) {
        var typeref_expr = entry[1]
        var storage_ref = entry[2]
        var name = entry[3].label
        if debug {
            print(dbg_prefix + " "
                "get_called_or_assigned_func_types(): "
                "Will now test entry=" + entry.as_str() + " "
                "as an override...")
        }
        var inner_result = get_called_or_assigned_func_types(
            project_file, called_node, called_node_parents,
            allow_matching_func_override=no,
            allow_noncall_ref=no,
            ignore_arg_mismatch=yes,
            verify_external_func_args=
                verify_external_func_args,
            _internal_override_called_func_name=name,
            _internal_override_called_func_st_ref=storage_ref,
            _internal_override_called_func_typerefexpr=
                typeref_expr,
            msgs=msgs, is_moose64=is_moose64, debug=debug
        ) later:

        await inner_result
        if inner_result != none and
                inner_result.have_args_mismatch {
            inner_result = none
        }
        if debug {
            print(dbg_prefix + " "
                "get_called_or_assigned_func_types(): "
                "Override test returned result=" +
                inner_result.as_str() + " (" +
                "success: " +
                (inner_result != none).as_str() + ")")
        }
        if inner_result != none {
            signature_mismatch = no
            assert(proper_func_base_name != none)
            inner_result.func_var_preoverridden_name =
                proper_func_base_name
            inner_result.func_was_overridden =
                entry[3].is_override
            override_success_result = inner_result
            return yes
        }
        return no
    }
    func try_finding_override_if_needed {
        if not signature_mismatch or
                not allow_matching_func_override {
            return later
        }
        if debug {
            print(dbg_prefix + " "
                "get_called_or_assigned_func_types(): "
                "The signature doesn't match and overrides are "
                "allowed. Let's go looking for one. "
                "func_var_typeinfo=" +
                    func_var_typeinfo.as_str() + " "
                "func_var_typeinfo.user_type_ref=" +
                    func_var_typeinfo.user_type_ref.as_str() + " "
                "called_node=" + called_node.as_str())
        }

        var override_info_list =
            find_func_overrides_by_st_ref(
                func_var_typeinfo.user_type_ref,
                project_file.project,
                msgs=msgs,
                is_moose64=is_moose64,
                debug=debug,
            )
        if debug {
            print(dbg_prefix + " "
                "get_called_or_assigned_func_types(): "
                "We got the override list to look at. "
                "override_info_list=" +
                    override_info_list.as_str())
        }
        if override_info_list.len <= 1 {
            if debug {
                print(dbg_prefix + " "
                    "get_called_or_assigned_func_types(): "
                    "There are no overrides, so we bail.")
            }
            return
        }
        for entry in override_info_list {
            if not entry[3].is_override {
                proper_func_base_name = entry[3].label
            }
        }
        var entry = override_info_list.pop()
        var result = try_finding_override(entry)
        later:

        await result
        if result {
            return
        }
        if override_info_list.len == 0 {
            return
        }
        entry = override_info_list.pop()
        result = try_finding_override(entry)
        later repeat
    }
    try_finding_override_if_needed()
    later:

    # If we have an override result, return that instead:
    if override_success_result != none {
        return override_success_result
    }

    # Otherwise, return error if needed:
    var have_args_mismatch = no
    if signature_mismatch {
        have_args_mismatch = yes

        if not ignore_arg_mismatch {
            if msgs == none {
                print(if is_moose64 ("horsec")
                        else ("moosec") + ": "
                    "error: Internal error, "
                    "args mismatch in unexpected context, "
                    "called_node=" +
                        called_node.as_str() + " "
                    "called_node_parent=" +
                        called_node_parent.as_str() + " "
                    "user_facing_called_args_len=" +
                        user_facing_called_args_len.as_str() + " "
                    "expected_args_len=" +
                        expected_args_len.as_str() + " "
                    "signature_arg_mismatch_info=" +
                        signature_arg_mismatch_info.as_str() + " "
                    "is_failable_call=" +
                        is_failable_call.as_str() + " "
                    "is_self_call=" +
                        is_self_call.as_str() + " "
                    "is_called_with_adhoc_self=" +
                        is_called_with_adhoc_self.as_str() + " "
                    "expected_self_call=" +
                        expected_self_call.as_str() + " "
                    "is_func_attr=" +
                        func_typeinfo.func_typeexpr.
                        is_func_attr.as_str())
                throw new RuntimeError("Call has wrong number of "
                    "arguments.")
            }
            var expected_s =
                if expected_args_len != 1
                    ("s") else ("")
            var called_s =
                if user_facing_called_args_len != 1
                    ("s") else ("")
            if debug {
                print(dbg_prefix +
                    " get_called_or_assigned_func_types(): "
                    "Got args mismatch, debug info: "
                    "called_actual_arg_user_indexes=" +
                        called_actual_arg_user_indexes.as_str() + " "
                    "called_actual_arg_types=" +
                        called_actual_arg_types.as_str() + " "
                    "expected_args_len=" +
                        expected_args_len.as_str() + " "
                    "user_facing_called_args_len=" +
                        user_facing_called_args_len.as_str() + " "
                    "is_self_call=" +
                        is_self_call.as_str() + " "
                    "is_called_with_adhoc_self=" +
                        is_called_with_adhoc_self.as_str() + " "
                    "expected_self_call=" +
                        expected_self_call.as_str() + " "
                    "signature_arg_mismatch_info=" +
                        signature_arg_mismatch_info.as_str() + " "
                    "func_typeinfo=" +
                        func_typeinfo.as_str() + " "
                    "func_typeinfo.func_typeexpr=" +
                        func_typeinfo.func_typeexpr.as_str() + " "
                    "called_node=" + called_node.as_str() + " "
                    "called_node_parent=" +
                        called_node_parent.as_str())
            }
            if not called_node.damaged {
                # Emit an error message:
                var arg_count_mismatch = (expected_args_len !=
                    user_facing_called_args_len)
                if not arg_count_mismatch and
                        is_failable_call != expected_failable_call {
                    msgs.add(new msg.FileMsg(
                        "Unexpected " +
                        if is_failable_call ("failable guarded call")
                            else ("regular unguarded call") + " "
                        "of func that " +
                        if expected_failable_call
                            ("is marked failable")
                            else ("is regular non-failable") +
                        ".",
                        kind=msg.M_ERROR,
                        source_file=project_file,
                        line=called_node.line,
                        col=called_node.col
                    ))
                } elseif not arg_count_mismatch and
                        signature_arg_mismatch_info != none {
                    var smmi = signature_arg_mismatch_info
                    var nth = smmi[2].as_str() + "th"
                    if smmi[2] == 1 or
                            (smmi[2] != 11 and
                            smmi[2].as_str().ends("1")) {
                        nth = smmi[2].as_str() + "st"
                    } elseif smmi[2] == 2 or
                            (smmi[2] != 12 and
                            smmi[2].as_str().ends("2")) {
                        nth = smmi[2].as_str() + "nd"
                    }
                    msgs.add(new msg.FileMsg(
                        "Unexpected argument mismatch, " +
                        "the " + nth + " argument was passed type " +
                            smmi[4].describe_to_user(
                                project=project_file.project,
                                add_quotes_where_useful=yes,
                                is_moose64=yes,
                            ) + " which isn't compatible with " +
                        "expected type " +
                            smmi[3].describe_to_user(
                                project=project_file.project,
                                add_quotes_where_useful=yes,
                                is_moose64=yes,
                            ) + ".",
                        kind=msg.M_ERROR, source_file=project_file,
                        line=called_node.line,
                        col=called_node.col,
                    ))
                } elseif is_self_call ==
                    func_typeinfo.func_typeexpr.is_func_attr {
                        # Since self call matches, omit self info:
                        msgs.add(new msg.FileMsg(
                            "Unexpected number of args, " +
                            called_name + " expects " +
                            expected_args_len.as_str() + " "
                            "arg" + expected_s + " " +
                            "but this call provides " +
                            user_facing_called_args_len.as_str() +
                            " arg" + called_s + ".",
                            kind=msg.M_ERROR,
                            source_file=project_file,
                            line=called_node.line,
                            col=called_node.col,
                        ))
                } else {
                    assert(is_self_call !=
                        func_typeinfo.func_typeexpr.is_func_attr)
                    # Due to self-call mismatch, include self info:
                    msgs.add(new msg.FileMsg(
                        "Unexpected number of args, " +
                        called_name + " expects " +
                        expected_args_len.as_str() + " "
                        "arg" + expected_s + " " +
                        expected_with_self_str + " "
                        "but this call provides " +
                        user_facing_called_args_len.as_str() + " "
                        "arg" + called_s + " " +
                        called_with_self_str + ".",
                        kind=msg.M_ERROR,
                        source_file=project_file,
                        line=called_node.line,
                        col=called_node.col,
                    ))
                }
            }
            called_node.damaged = yes
            if debug and signature_arg_mismatch_info != none and
                    is_moose64 and called_args_exprs.len > 0 {
                print(dbg_prefix +
                    " get_called_or_assigned_func_types(): "
                    "Re-tracing first mismatching type "
                    "for debug info...")
                var arg_type = m64_ast_analyze.
                    get_c_or_m64_type_of_node(
                        project_file, called_args_exprs[
                            signature_arg_mismatch_info[1]
                        ], called_node_parents + [call_args_expr],
                        store_self_value_ref_for_funcs=no,
                        msgs=msgs, debug=yes,
                    ) later:

                await arg_type
                return later none
            }
            return later none
        }
    }

    arg_var_type_exprs = func_typeinfo.func_typeexpr.
        arg_typeref_exprs.copy()
    if self_value_ref != none and arg_var_type_exprs.len > 0 {
        arg_var_type_exprs = arg_var_type_exprs.sub(2)
    }
    func handle_args {
        var idx = 0
        func handle_arg(arg) {
            idx += 1
            var scope = called_node.scope
            var tinfo = typeinfo.
                create_typeinfo_from_typeexpr_and_verify(
                    arg,
                    project_file=project_file, 
                    store_self_value_ref_for_funcs=no,
                    is_moose64=yes,
                ) later:

            await tinfo
            if tinfo == none {
                called_node.damaged = yes
            }
            arg_var_types.add(tinfo)
        }
        var queue = arg_var_type_exprs.copy()
        if queue.len == 0 {
            return later
        }
        var item = queue.pop()
        var _unused = handle_arg(item)
        later:

        await _unused

        if queue.len == 0 {
            return later
        }
        item = queue.pop()
        _unused = handle_arg(item) later repeat
    }
    handle_args() later:

    if called_node.damaged {
        return later none
    }

    var result = new CalledFuncTypesResult()
    result.is_external = is_external
    result.called_func_is_attr =
        func_typeinfo.func_typeexpr.is_func_attr
    result.user_facing_called_args_len =
        user_facing_called_args_len
    result.func_var_type_expr = func_var_typeref.copy()
    result.func_var_typeinfo = func_var_typeinfo
    result.func_var_name = func_actual_name
    result.func_ref = m64_type_ref
    result.func_was_overridden = func_changed_to_override
    result.arg_var_type_exprs = arg_var_type_exprs
    result.arg_var_typeinfos = arg_var_types
    result.self_var_type_expr = self_type_expr.copy()
    result.self_var_typeinfo = self_type_typeinfo
    result.have_args_mismatch = have_args_mismatch
    return result
}

func get_global_storage_neighbor_closure(project) {
    func try_get_neighbor_node_value(node_ref) {
        if node_ref == none or node_ref.kind != st_ref.ST_GLOBAL {
            return [ast_eval.AR_UNKNOWN]
        }
        var st_id = node_ref.id
        var gscope_map =
            project.storage_id_to_global_scope_map
        if not gscope_map.has(st_id) {
            return [ast_eval.AR_UNKNOWN]
        }
        var st_id_map = gscope_map[st_id].storage_id_to_entry
        if not st_id_map.has(st_id) {
            return [ast_eval.AR_UNKNOWN]
        }
        var entry = st_id_map[st_id]
        if entry.kind != ast.N_STMT_VAR {
            return [ast_eval.AR_UNKNOWN]
        }
        var entry_idx = none
        var idx = 0
        for sym in entry.symbol_info {
            idx += 1
            if sym.storage_id == st_id {
                entry_idx = idx
                break
            }
        }
        if entry_idx == none or
                entry_idx < 1 or
                entry_idx > entry.initial_values_known or
                not entry.initial_values_known[entry_idx] {
            return [ast_eval.AR_UNKNOWN]
        }
        return [ast_eval.AR_VALUE,
            entry.initial_values[entry_idx]]
    }
    return try_get_neighbor_node_value
}

func advanced_phase2_evaluate_global_scope(
        project_file, is_moose64=no, msgs=none
        ) {
    var globals_value_cb = get_global_storage_neighbor_closure(
        project_file.project)
    var had_error = no
    var had_change = no
    var stmt_map = project_file.global_scope.
        name_to_stmt_map
    for name in stmt_map {
        var stmt = stmt_map[name]
        if typename(stmt) == "list" or
                (has_attr(stmt, "is_enum_entry") and
                 stmt.is_enum_entry) or
                stmt.kind != ast.N_STMT_VAR {
            continue
        }
        assert(stmt.var_labels.len ==
            stmt.initial_values_known.len)
        var idx = 1
        while idx <= stmt.var_labels.len {
            if stmt.initial_values_known[idx] {
                idx += 1
                continue
            }
            var v = ast_eval.try_eval_ast_node_value(
                stmt.subexprs[1], is_moose64=is_moose64,
                eval_by_storage_ref_callback=globals_value_cb)
            if v[1] == ast_eval.AR_VALUE {
                had_change = yes
                stmt.initial_values_known[idx] = yes
                stmt.initial_values[idx] = v[2]
                if stmt.subexprs[1].kind != ast.N_EXPR_LIT {
                    var value_expr = new ast_expr.LiteralExpr()
                    value_expr.line = stmt.subexprs[1].line
                    value_expr.col = stmt.subexprs[1].col
                    value_expr.value = v[2]
                    stmt.subexprs[1] = value_expr
                }
            } elseif v[1] == ast_eval.AR_TYPEERROR {
                if msgs != none {
                    msgs.add(new msg.FileMsg(
                        "Invalid assigned expression containing "
                        "a type mismatch for operands. "
                        "If intended, protect it with "
                        "a rescue block that catches TypeError.",
                        source_file=project_file,
                        line=stmt.subexprs[1].line,
                        col=stmt.subexprs[1].col
                    ))
                }
                had_error = yes
            }
            idx += 1
        }
    }
    if had_change {
        return "changed"
    }
    return not had_error
}

func get_throw_statement_rescue_clause(stmt, parents) {
    var parent_clause = none
    var pos = 1
    while pos <= parents.len {
        if parents[pos].kind == ast.N_STMT_FUNC {
            return none
        } elseif parents[pos].kind == ast.N_EXPR_RESCUECLAUSE {
            return parents[pos]
        }
        pos += 1
    }
    return none
}

func is_idref_readonly_access(node, parent_chain) {
    if node.kind != ast.N_EXPR_IDREF and
            (node.kind != ast.N_EXPR_BINOP or
            node.optoken.str != "." or
            node.subexprs.len != 2 or
            node.subexprs[2].kind != ast.N_EXPR_IDREF) {
        throw new TypeError("Check only valid for identifiers.")
    }
    if parent_chain.len == 0 {
        return no
    }
    var child = node
    var parent_idx = 1
    var parent = parent_chain[parent_idx]
    while yes {
        if parent.kind == ast.N_STMT_VAR {
            return yes
        }
        if parent.kind == ast.N_STMT_ASSIGN {
            var pair_count = parent.subexprs.len / 2
            var pos = pair_count + 1
            assert(pair_count >= 1)
            while pos <= parent.subexprs.len {
                if parent.subexprs[pos] == child {
                    # It's an rvalue, that's a read-only access.
                    return yes
                }
                pos += 1
            }
            return no
        }
        parent_idx += 1
        if parent_idx > parent_chain.len {
            return no
        }
        child = parent
        parent = parent_chain[parent_idx]
    }
}

func analyze_and_configure_newly_added_func(
        node, msgs=none, project_file=none
        ) {
    var is_later_func = no
    for block in node.subblocks {
        if stmt_list_contains_later_call(
                block, check_recursive=yes,
                include_later_ignore=no,
                recurse_into_funcs=no) {
            is_later_func = yes
            break
        }
    }
    node.func_scope.is_later_func = is_later_func
}

func advanced_phase3_h64_later_and_computevals(
        stmts, msgs=none, project_file=none
        ) {
    var globals_value_cb = get_global_storage_neighbor_closure(
        project_file.project)
    var parents = []
    var project = project_file.project
    func check_and_analyze_recurse(
            stmts, parents, msgs
            ) {
        for stmt in stmts {
            if stmt.kind == ast.N_STMT_FUNC {
                analyze_and_configure_newly_added_func(
                    stmt, msgs=msgs, project_file=project_file
                )
            }

            func check_nested_constructors(expr, parents) {
                var parent = if parents.len >= 1 (parents[parents.len])
                    else (none)
                var grandparent = if parents.len >= 2 (parents[parents.len - 1])
                    else (none)
                var grandgrandparent = if parents.len >= 3
                    (parents[parents.len - 2]) else (none)
                if expr.damaged {
                    return expr
                }
                # Replace enum references with their values:
                if expr.kind == ast.N_EXPR_IDREF and
                        expr.ref != none and
                        expr.ref.kind == st_ref.ST_NUMLITERAL {
                    var value_expr = new ast_expr.LiteralExpr()
                    value_expr.scope = expr.scope
                    value_expr.line = expr.line
                    value_expr.col = expr.col
                    value_expr.value = expr.ref.id
                    return value_expr
                }

                # Make sure types can't be directly referenced:
                var is_type_constructor = no
                var is_any_type = expr.kind == ast.N_EXPR_IDREF and
                    expr.ref != none and
                    project.is_ref_a_type(expr.ref)
                var is_error_type = expr.kind == ast.N_EXPR_IDREF and
                    expr.ref != none and is_any_type and
                    project.is_ref_of_given_type_an_error(expr.ref)
                var is_regular_type = is_any_type and not is_error_type
                if expr.kind == ast.N_EXPR_IDREF and
                        expr.ref != none {
                    if parent != none and is_regular_type and
                            parent.kind == ast.N_EXPR_RESCUECLAUSE {
                        if not project.
                                is_ref_of_given_type_an_error(expr.ref) {
                            if msgs != none {
                                msgs.add(new msg.FileMsg(
                                    "Invalid type reference, must be an "
                                    "error type but it's a regular type.",
                                    source_file=project_file,
                                    line=expr.line,
                                    col=expr.col
                                ))
                            }
                            expr.damaged = yes
                        }
                    } elseif parent == none or
                            parent.kind != ast.N_EXPR_BINOP or
                            parent.optoken.str != "(" or
                            expr != parent.subexprs[1] or
                            grandparent == none or
                            grandparent.kind != ast.N_EXPR_UNOP or
                            grandparent.subexprs[1] != parent or
                            grandparent.optoken.str != "new" {
                        if (is_regular_type and (parent == none or
                                not {ast.N_STMT_TYPE,
                                ast.N_STMT_TYPEEXTEND,
                                ast.N_STMT_STRUCTEXTEND,
                                ast.N_STMT_ENUMEXTEND}.has(
                                    parent.kind
                                ))) or
                                (is_error_type
                                 and (parent == none or
                                      not {ast.N_STMT_TYPE,
                                      ast.N_EXPR_RESCUECLAUSE}.has(
                                          parent.kind
                                      ))) {
                            if msgs != none {
                                msgs.add(new msg.FileMsg(
                                    "Invalid type reference, must "
                                    "be part of a new constructor.",
                                    source_file=project_file,
                                    line=expr.line,
                                    col=expr.col
                                ))
                            }
                            expr.damaged = yes
                        }
                    } else {
                        is_type_constructor = yes
                    }
                }

                # Make sure errors are instantiated correctly:
                if is_type_constructor and is_error_type {
                    if grandgrandparent == none or
                            grandgrandparent.kind != ast.N_STMT_THROW {
                        if msgs != none {
                            msgs.add(new msg.FileMsg(
                                "Invalid error constructor call, "
                                "must be part of 'throw' statement.",
                                source_file=project_file,
                                line=callargs.line,
                                col=callargs.col
                            ))
                        }
                        expr.damaged = yes
                        return expr
                    }
                    var callargs = parent.subexprs[2]
                    if callargs.subexprs.len != 1 or
                            callargs.subexprs[1].kind ==
                            ast.N_EXPR_CALLKWARG {
                        if msgs != none {
                            msgs.add(new msg.FileMsg(
                                "Invalid error constructor call, "
                                "must have single positional "
                                "message string argument.",
                                source_file=project_file,
                                line=callargs.line,
                                col=callargs.col
                            ))
                        }
                        expr.damaged = yes
                        return expr
                    }
                }
                return expr
            }
            ast_transform.do_simply_on_all_exprs(
                stmt, check_nested_constructors)

            # Determine error message ahead of time for throws:
            if stmt.kind == ast.N_STMT_THROW and
                    not stmt.error_msg_failed_early_eval and
                    not stmt.has_damage() and
                    stmt.subexprs.len > 0 {
                var has_valid_error_arg = no
                var callargs, callobj
                assert(stmt.subexprs.len == 1)
                if stmt.subexprs[1].kind == ast.N_EXPR_UNOP and
                        stmt.subexprs[1].optoken.str == "new" and
                        stmt.subexprs[1].subexprs[1].kind ==
                            ast.N_EXPR_BINOP and
                        stmt.subexprs[1].subexprs[1].optoken.str == "(" and
                        stmt.subexprs[1].subexprs[1].subexprs[2].kind ==
                            ast.N_EXPR_CALLARGS {
                    callargs = stmt.subexprs[1].subexprs[1].
                        subexprs[2]
                    callobj = stmt.subexprs[1].subexprs[1].subexprs[1]
                    if callobj.kind != ast.N_EXPR_IDREF or
                            not project.is_ref_a_type(callobj.ref) or
                            not project.is_ref_of_given_type_an_error(
                                callobj.ref) {
                        has_valid_error_arg = no
                    } else {
                        has_valid_error_arg = yes
                    }
                } elseif stmt.subexprs[1].kind == ast.N_EXPR_IDREF {
                    has_valid_error_arg = yes
                }
                if not has_valid_error_arg {
                    if msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Invalid throw, must have a new "
                            "constructor as argument that "
                            "directly refers to an error type, "
                            "or a variable containing an "
                            "already thrown error.",
                            source_file=project_file,
                            line=stmt.subexprs[1].line,
                            col=stmt.subexprs[1].col
                        ))
                    }
                    stmt.damaged = yes
                    callargs.damaged = yes
                }
                if not stmt.damaged and callargs != none and (
                        callargs.subexprs.len != 1 or
                        callargs.subexprs[1].kind ==
                            ast.N_EXPR_CALLKWARG) {
                    if msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Invalid error constructor call, "
                            "must have single positional "
                            "message string argument.",
                            source_file=project_file,
                            line=stmt.subexprs[1].line,
                            col=stmt.subexprs[1].col
                        ))
                    }
                    stmt.damaged = yes
                    callargs.damaged = yes
                }
                if not stmt.damaged and callargs != none {
                    var v = ast_eval.try_eval_ast_node_value(
                        callargs.subexprs[1],
                        eval_by_storage_ref_callback=globals_value_cb)
                    if v[1] != ast_eval.AR_VALUE {
                        stmt.error_msg_failed_early_eval = yes
                    } elseif typename(v[2]) != "str" {
                        stmt.damaged = yes
                    } else {
                        stmt.error_msg_failed_early_eval = no
                        stmt.error_msg_aot_evaluated = v[2]
                    }
                    if stmt.damaged and msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Invalid error constructor call, "
                            "message argument must be str.",
                            source_file=project_file,
                            line=stmt.subexprs[1].line,
                            col=stmt.subexprs[1].col
                        ))
                    }
                }
            } elseif stmt.kind == ast.N_STMT_THROW and
                    not stmt.has_damage() and
                    stmt.subexprs.len == 0 {
                # This is an anonymous throw. Transform it to have
                # a named parameter!

                var has_named_label = no
                var parent_clause = get_throw_statement_rescue_clause(
                    stmt, parents)
                if parent_clause == none {
                    stmt.damaged = yes
                    if msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Invalid anonymous throw, "
                            "not inside any rescue clause.",
                            source_file=project_file,
                            line=stmt.line,
                            col=stmt.col
                        ))
                    }
                }

                for label in parent_clause.error_labels {
                    if label != none {
                        has_named_label = yes
                        break
                    }
                }
                if has_named_label {
                    stmt.damaged = yes
                    parent_clause.damaged = yes
                    if msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Invalid anonymous throw, "
                            "not allowed here because surrounding "
                            "rescue clause at line " +
                            parent_clause.line.as_str() +
                            ", column " + parent_clause.col.as_str() +
                            " has one or more named errors.",
                            source_file=project_file,
                            line=stmt.line,
                            col=stmt.col
                        ))
                    }
                } else {
                    var inner_scope = stmt.scope
                    for block in parent_clause.subblocks {
                        if block.len > 0 {
                            inner_scope = block[1].scope
                            break
                        }
                    }
                    var new_name = "autothrowlabel" + random.gen_id()
                    while not inner_scope.name_is_free(new_name,
                            project_file.global_scope) {
                        new_name = "autothrowlabel" + random.gen_id()
                    }
                    var new_sinfo = inner_scope.add_symbol(
                        new_name, project_file, parent_clause.line,
                        parent_clause.col)[2]
                    if new_sinfo == none {
                        throw new RuntimeError("Internal error.")
                    }
                    assert(parent_clause.error_labels.len > 0)
                    assert(parent_clause.symbol_info.len ==
                        parent_clause.error_labels.len)
                    var pos = 1
                    while pos <= parent_clause.error_labels.len {
                        assert(parent_clause.error_labels[pos] == none)
                        parent_clause.error_labels[pos] = new_name
                        parent_clause.symbol_info[pos] = new_sinfo.copy()
                        pos += 1
                    }
                    func assign_label_to_all_empty_throws(stmts) {
                        for stmt in stmts {
                            if stmt.kind == ast.N_STMT_THROW and
                                    stmt.subexprs.len == 0 {
                                var node = new ast_expr.IdRefExpr()
                                node.scope = inner_scope
                                node.line = stmt.line
                                node.col = stmt.col
                                node.label = new_name
                                node.ref = new st_ref.StorageRef(
                                    st_ref.ST_LOCAL, new_sinfo.storage_id
                                )
                                stmt.subexprs.add(node)
                            } elseif stmt.kind == ast.N_STMT_DO or
                                    stmt.kind == ast.N_STMT_IF {
                                for clause in stmt.subexprs {
                                    if clause.kind ==
                                            ast.N_EXPR_RESCUECLAUSE {
                                        # Don't cross into rescue clauses.
                                        continue
                                    }
                                    for block in clause.subblocks {
                                        assign_label_to_all_empty_throws(
                                            block)
                                    }
                                }
                            } elseif stmt.kind == ast.N_STMT_FUNC {
                                # Don't cross function boundaries.
                                continue
                            } elseif stmt.subblocks.len > 0 {
                                for block in stmt.subblocks {
                                    assign_label_to_all_empty_throws(
                                        block)
                                }
                            }
                        }
                    }
                    for block in parent_clause.subblocks {
                        assign_label_to_all_empty_throws(block)
                    }
                }
            }

            # Blocks:
            if stmt.subblocks.len > 0 {
                for block in stmt.subblocks {
                    if not check_and_analyze_recurse(
                            block, [stmt] + parents, msgs) {
                        return no
                    }
                }
            }
            if stmt.kind == ast.N_STMT_IF or
                    stmt.kind == ast.N_STMT_DO {
                for clause in stmt.subexprs {
                    for block in clause.subblocks {
                        if not check_and_analyze_recurse(
                                block, [stmt, clause] + parents, msgs) {
                            return no
                        }
                    }
                }
            }
        }
        return yes
    }
    return check_and_analyze_recurse(
        stmts, parents, msgs
    )
}

func advanced_phase1_globalrefs(
        stmts, is_moose64=no, msgs=none, project_file=none
        ) {
    func check_and_analyze_recurse(
            stmts, msgs) {
        for stmt in stmts {
            # FIXME
            # IMPORTANT: we also want to auto-const all vars here already.
            # (Then the next state, the iteration stage, can do better
            # guesses, especially inside functions.)

            # Blocks:
            if stmt.subblocks.len > 0 {
                for block in stmt.subblocks {
                    if not check_and_analyze_recurse(block, msgs) {
                        return no
                    }
                }
            }
            if stmt.kind == ast.N_STMT_IF or
                    stmt.kind == ast.N_STMT_DO {
                for clause in stmt.subexprs {
                    for block in clause.subblocks {
                        if not check_and_analyze_recurse(block, msgs) {
                            return no
                        }
                    }
                }
            }
        }
        return yes
    }
    return check_and_analyze_recurse(
        stmts, msgs
    )
}

func basic_phase_nestingdepth_and_misc(
        stmts, is_moose64=no, msgs=none, project_file=none
        ) {
    func check_and_analyze_recurse(
            stmts, msgs, max_block_nesting_left, is_moose64
            ) {
        if max_block_nesting_left < 0 and stmts.len > 0 {
            if msgs != none {
                msgs.add(new msg.FileMsg(
                    "Nesting of statements too deep here, "
                    "exceeds maximum supported depth.",
                    source_file=project_file,
                    line=stmts[1].line, col=stmts[1].col
                ))
            }
            return no
        }
        for stmt in stmts {
            if stmt.subblocks.len > 0 {
                for block in stmt.subblocks {
                    if not check_and_analyze_recurse(
                            block, msgs,
                            max_block_nesting_left - 1,
                            is_moose64) {
                        return no
                    }
                }
            }
            if stmt.kind == ast.N_STMT_IF or
                    stmt.kind == ast.N_STMT_DO {
                for clause in stmt.subexprs {
                    for block in clause.subblocks {
                        if not check_and_analyze_recurse(
                                block, msgs,
                                max_block_nesting_left - 1,
                                is_moose64) {
                            return no
                        }
                    }
                }
            }
        }
        return yes
    }
    return check_and_analyze_recurse(
        stmts, msgs, compiler_limit.max_statement_nesting,
        is_moose64
    )
}

func ensure_analysis_has_needed_error(analysis_result, msgs) {
    if not analysis_result and msgs != none {
        var had_error = no
        for m in msgs {
            if m.kind == msg.M_ERROR {
                had_error = yes
                break
            }
        }
        if not had_error {
            msgs.add(new msg.FileMsg(
                "Internal error occured, we failed "
                "analysis without a proper error message. "
                "Please report this bug to the compiler makers."
            ))
        }
    }
}

func do_advanced_check_and_analysis(project, msgs) {
    var is_moose64 = no
    if project.build_options != none and
            project.build_options.is_moose64 {
        is_moose64 = yes
    }

    func process_file(pfile) {
        pfile.ensure_ast() later:

        if not advanced_phase1_globalrefs(
                pfile.ast.stmts, is_moose64=is_moose64, msgs=msgs,
                project_file=pfile) {
            return later no
        }
        while yes {
            var result = advanced_phase2_evaluate_global_scope(
                pfile, is_moose64=is_moose64, msgs=msgs
            )
            if result != "changed" {
                if not result {
                    return later no
                }
                assert(result == yes)
                break
            }
        }
        if not is_moose64 and
                not advanced_phase3_h64_later_and_computevals(
                pfile.ast.stmts, msgs,
                project_file=pfile) {
            return later no
        }
        return later yes
    }
    var check_went_ok = project.do_for_all_files(process_file)
    later:

    await check_went_ok
    assert(check_went_ok == yes or check_went_ok == no)
    for m in msgs {
        if m.kind == msg.M_ERROR {
            check_went_ok = no
        }
    }

    ensure_analysis_has_needed_error(check_went_ok, msgs)
    return later check_went_ok
}

func do_basic_check_and_analysis(project, msgs, is_moose64=no) {
    func do_unsafe {
        func process_file(pfile) {
            pfile.ensure_ast() later:

            if not basic_phase_nestingdepth_and_misc(
                    pfile.ast.stmts, is_moose64=is_moose64,
                    msgs=msgs, project_file=pfile) {
                return later no
            }
            return later yes
        }
        var check_went_ok = project.do_for_all_files(process_file)
        later:

        await check_went_ok
        for m in msgs {
            if m.kind == msg.M_ERROR {
                check_went_ok = no
            }
        }

        return later check_went_ok
    }
    var result = do_unsafe() later:

    await result

    ensure_analysis_has_needed_error(result, msgs)
    return later result
}

func is_func_call_node_for_sure_a_self_call(
        project_file, call_node, symbol_info=none,
        called_node_ref=none,
        is_moose64=no, debug=no
        ) {
    if call_node.kind != ast.N_EXPR_BINOP or
            call_node.optoken.str != "(" {
        throw new ValueError("The parameter call_node "
            "must be a call expression.")
    }
    var called_node = call_node.subexprs[1]
    var called_node_parent = call_node
    var potential_self_ref = none
    if called_node.kind == ast.N_EXPR_IDREF {
        if called_node_ref == none {
            called_node_ref = called_node.ref
        }
    } elseif called_node.kind == ast.N_EXPR_BINOP and
            called_node.optoken.str == "." and
            called_node.subexprs.len >= 2 and
            called_node.subexprs[2].kind == ast.N_EXPR_IDREF {
        if called_node_ref == none {
            called_node_ref =
                called_node.subexprs[2].ref
        }
        if called_node.subexprs[1].kind == ast.N_EXPR_IDREF {
            potential_self_ref = called_node.subexprs[1].ref
        } elseif called_node.subexprs[1].kind ==
                ast.N_EXPR_BINOP and
                called_node.subexprs[1].optoken.str == "." and
                called_node.subexprs[1].
                    subexprs[2].kind == ast.N_EXPR_IDREF {
            potential_self_ref = called_node.subexprs[1].
                subexprs[2]
        }
    }

    if not is_moose64 {
        # Horse64 doesn't allow passing funcs around in a way
        # where you can call the self parameter passed in
        # explicitly (as non-implicit self call).
        # Therefore, this only depends on whether the
        # target func is clearly a func attr.
        if called_node_ref != none and
                called_node_ref == st_ref.ST_GLOBAL {
            var entry = st_scope.global_id_to_item(
                project_file.project,
                called_node_ref.id)
            return entry.kind == ast.N_STMT_FUNC and
                entry.type_path != none and
                entry.type_path.len > 0
        }
        return called_node_ref != none and
            called_node_ref == st_ref.ST_GLOBALATTR
    }
    assert(is_moose64)

    var is_possibly_self_obj_call =
        (called_node.kind == ast.N_EXPR_BINOP and
            called_node.optoken.str == "." and
            potential_self_ref != none and
            not st_ref.ref_is_global_func_def(
                project_file, potential_self_ref
            ))
    if not is_possibly_self_obj_call {
        if debug {
            print(if is_moose64 ("moosec: ") else ("horsec: ") +
                "debug: is_func_call_node_for_sure_a_self_call(): "
                "Found a node that can't be a self call: "
                "called_node=" + called_node.as_str() + " "
                "called_node_ref=" +
                    called_node_ref.as_str() + " "
                "potential_self_ref=" +
                    potential_self_ref.as_str() + " "
                "called_node_parent=" + called_node_parent.as_str())
        }
        return no
    }
    assert(potential_self_ref != none)

    if called_node_ref == none {
        return no
    }
    if symbol_info == none {
        symbol_info = st_ref.ref_to_symbol_info(
            called_node.subexprs[2].ref,
            node=called_node, project=project_file.project,
            is_moose64=is_moose64,
        )
    }
    if symbol_info == none or symbol_info.typeref_expr == none or
            not symbol_info.typeref_expr.is_func_ref {
        return no
    }
    return symbol_info.typeref_expr.is_func_attr
}

