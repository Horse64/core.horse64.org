## @module compiler.ast.analyze
# Copyright (c) 2023-2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import random from core.horse64.org

import compiler.ast as ast
import compiler.ast.analyze as ast_analyze
import compiler.ast.analyze.eval as ast_eval
import compiler.ast.expr as ast_expr
import compiler.ast.func_stmt as func_stmt
import compiler.ast.transform as ast_transform
import compiler.limit as compiler_limit
import compiler.moose64.ast.analyze as m64_ast_analyze
import compiler.msg as msg
import compiler.storage.ref as st_ref
import compiler.typeinfo as typeinfo
import compiler.typeinfo.ast_typeref as ast_typeref

extend type func_stmt.FuncStmt {
    var is_later_func
}

func stmt_list_contains_later_call(
        stmts, check_recursive=yes,
        include_later_ignore=no,
        recurse_into_funcs=no) {
    for stmt in stmts {
        if {ast.N_STMT_VAR, ast.N_STMT_ASSIGN,
                ast.N_STMT_CALL}.has(stmt.kind) and
                stmt.has_later and
                (include_later_ignore or
                 not stmt.has_later_ignore) {
            return yes
        } elseif stmt.kind == ast.N_STMT_RETURN and
                stmt.has_later {
            return yes
        } elseif check_recursive {
            if stmt.kind == ast.N_STMT_IF or
                    stmt.kind == ast.N_STMT_DO {
                for clause in stmt.subexprs {
                    for block in clause.subblocks {
                        if stmt_list_contains_later_call(block,
                                check_recursive=yes,
                                include_later_ignore=include_later_ignore) {
                            return yes
                        }
                    }
                }
            }
            if (recurse_into_funcs or
                    stmt.kind != ast.N_STMT_FUNC) and
                    stmt.subblocks.len > 0 {
                for block in stmt.subblocks {
                    if stmt_list_contains_later_call(block,
                            check_recursive=yes,
                            include_later_ignore=include_later_ignore) {
                        return yes
                    }
                }
            }
        }
    }
    return no
}

func ast_node_is_allowed_to_cause_type_error(
        node, parents, allow_typename_guard=yes,
        allow_attributeerror=no,
        ) {
    func check_expr_for_has_attr(origexpr) {
        func check_expr(expr) {
            if expr.kind == ast.N_EXPR_BINOP and
                    expr.optoken.str == "(" and
                    expr.subexprs.len >= 2 and
                    expr.subexprs[1].kind == ast.N_EXPR_IDREF and
                    expr.subexprs[1].label == "has_attr" and
                    (expr.subexprs[1].type_path == none or
                     expr.subexprs[1].type_path.len == 0) {
                return yes
            }
            for child in expr.subexprs {
                return check_expr(child)
            }
        }
        if origexpr.kind == ast.N_EXPR_IFELSECLAUSE {
            if check_expr(origexpr) {
                return yes
            }
        }
        for expr in origexpr.subexprs {
            if check_expr(expr) {
                return yes
            }
        }
        return no
    }
    func check_expr_for_typename(origexpr) {
        func check_expr(expr) {
            if expr.kind == ast.N_EXPR_BINOP and
                    expr.optoken.str == "(" and
                    expr.subexprs.len >= 2 and
                    expr.subexprs[1].kind == ast.N_EXPR_IDREF and
                    expr.subexprs[1].label == "typename" and
                    (expr.subexprs[1].type_path == none or
                     expr.subexprs[1].type_path.len == 0) {
                return yes
            }
            for child in expr.subexprs {
                return check_expr(child)
            }
        }
        if origexpr.kind == ast.N_EXPR_IFELSECLAUSE {
            if check_expr(origexpr) {
                return yes
            }
        }
        for expr in origexpr.subexprs {
            if check_expr(expr) {
                return yes
            }
        }
        return no
    }
    var i = parents.len
    while i >= 1 {
        if parents[i].kind == ast.N_STMT_IF {
            for clause in parents[i].subexprs {
                if clause.kind != ast.N_EXPR_IFELSECLAUSE or
                        clause.subblocks.len < 1 or
                        not clause.subblocks[1].find(node) {
                    continue
                }
                if check_expr_for_has_attr(clause) or (
                        allow_typename_guard and
                        check_expr_for_typename(clause)) {
                    return yes
                }
            }
        } elseif parents[i].kind == ast.N_STMT_DO {
            for clause in parents[i].subexprs {
                if not {ast.N_EXPR_RESCUECLAUSE,
                        N_EXPR_FINALLYCLAUSE}.has(
                            clause.kind
                        ) or
                        clause.subblocks.len < 1 or
                        not clause.subblocks[1].find(node) {
                    continue
                }
                var idx = 1
                while idx <= self.error_labels.len {
                    if self.subexprs[idx] != none and
                            self.subexprs[idx].kind ==
                                ast.N_EXPR_IDREF and
                            (self.subexprs[idx].str == "TypeError" or
                             (allow_attributeerror and
                              self.subexprs[idx].str ==
                                  "AttributeError")) and
                            (self.subexprs[idx].type_path == none or
                             self.subexprs[idx].type_path.len == 0) {
                        return yes
                    }
                    i += 1
                }
            }
        }
        i -= 1
    }
    return no
}

type CalledFuncTypesResult {
    var called_func_is_attr = no

    var func_var_type_expr
    var func_var_typeinfo
    var func_var_name
    var func_was_overridden
    var func_ref
    var arg_var_type_exprs = []
    var arg_var_typeinfos = []
    var self_var_type_expr = no
    var self_var_typeinfo = no
}

func CalledFuncTypesResult.as_str {
    var map = {
        "func_var_type_expr" -> self.func_var_type_expr,
        "func_var_typeinfo" -> self.func_var_typeinfo,
        "func_var_name" -> self.func_var_name,
        "func_was_overridden" -> self.func_was_overriden,
        "func_ref" -> self.func_ref,
        "arg_var_type_exprs" -> self.arg_var_type_exprs,
        "arg_var_typeinfos" -> self.arg_var_typeinfos,
        "self_var_type_expr" -> self.self_var_type_expr,
        "self_var_typeinfo" -> self.self_var_typeinfo,
    }
    return "CalledFuncTypesResult" + map.as_str()
}

func get_called_or_assigned_func_types(
        project_file, called_node, called_node_parents,
        allow_matching_func_override=no,
        allow_noncall_ref=no,
        ignore_arg_mismatch=no,
        msgs=none, is_moose64=no, debug=no
        ) {
    var dbg_prefix = if is_moose64 ("moosec: debug:")
        else ("horsec: debug:")
    if debug {
        print(dbg_prefix + " get_called_or_assigned_func_types(): "
            "launched on called_node=" + called_node.as_str())
    }
    if allow_noncall_ref {
        throw new RuntimeError("Option allow_noncall_ref=yes "
            "isn't implemented yet.")
    }
    if not is_moose64 {
        return later none
    }
    assert(typename(called_node_parents) == "list")
    var called_node_parent = if called_node_parents.len > 0
        (called_node_parents[called_node_parents.len]) else (none)
    if called_node.damaged or called_node_parent.damaged {
        return later none
    }
    var is_call = no
    if called_node_parent.kind != ast.N_EXPR_BINOP or
            called_node_parent.optoken.str != '(' or
            called_node_parent.subexprs.len != 2 or
            called_node_parent.subexprs[2].kind !=
                ast.N_EXPR_CALLARGS or
            called_node_parent.subexprs[1] != called_node {
        throw new RuntimeError("Internal error, "
            "get_called_or_assigned_func_types() called with "
            "called_node_parent not set to valid call "
            "expression.")
    }
    var call_args_expr = called_node_parent.subexprs[2]
    var func_typeinfo = m64_ast_analyze.get_c_or_m64_type_of_node(
        project_file, called_node, called_node_parents,
        store_self_value_ref_for_funcs=yes,
        msgs=msgs, debug=debug
    ) later:

    await func_typeinfo
    if debug {
        print(dbg_prefix + " get_called_or_assigned_func_types(): "
            "got type of node result func_typeinfo=" +
            func_typeinfo.as_str())
    }
    if func_typeinfo == none {
        if msgs == none {
            throw new RuntimeError("Failed to determine node type, "
                "internal error.")
        }
        msgs.add(new msg.FileMsg(
            "Unexpectedly failed to determine C type of "
            "called function. Did you use cyclic references?",
            kind=msg.M_ERROR, source_file=project_file,
            line=called_node_parent.line,
            col=called_node_parent.col,
        ))
        called_node.damaged = yes
        return later none
    }
    if func_typeinfo.kind != typeinfo.TI_FUNCREF {
        if msgs == none {
            throw new RuntimeError("The called node isn't a function.")
        }
        msgs.add(new msg.FileMsg(
            "Unexpected call to non-func item, "
            "this isn't allowed.",
            kind=msg.M_ERROR, source_file=project_file,
            line=called_node_parent.line,
            col=called_node_parent.col,
        ))
        called_node.damaged = yes
        return later none
    }
    var m64_type_ref = none
    func recompute_user_type {
        if func_typeinfo.func_typeexpr == none {
            return
        }
        # Try to trace back the actual func we're calling:
        assert(func_typeinfo.func_typeexpr.is_func_ref)
        m64_type_ref = func_typeinfo.func_typeexpr.
            try_resolve_to_user_type(
                project_file, recursive=yes,
                force_recompute=yes,
                is_moose64=is_moose64
            ) later:

        await m64_type_ref
    }
    recompute_user_type()
    later:

    var func_changed_to_override = no
    var func_actual_name = none
    if m64_type_ref != none {
        # Not a func pointer, we know the name of
        # what exactly we're calling.
        func_actual_name = st_ref.ref_to_item_name(
            project_file, m64_type_ref)
    }

    # Return assembled result:
    var self_value_ref = if func_typeinfo.func_self_ref != none
        (func_typeinfo.func_self_ref.copy()) else (none)
    var self_type_typeinfo = none
    var self_type_expr = none
    func handle_extra_for_self_type {
        if (self_value_ref == none and
                not func_typeinfo.func_typeexpr.is_func_attr) or
                called_node.kind != ast.N_EXPR_BINOP {
            return later
        }
        var result = ast_typeref.resolve_st_ref_to_type_ref_and_expr(
            project_file, self_value_ref,
            node=called_node.subexprs[1],
            node_parents=called_node_parents + [called_node],
            is_moose64=is_moose64,
        ) later:

        await result
        self_type_expr = result[2]
        if self_type_expr == none {
            if msgs == none {
                throw new RuntimeError("Failed to trace back to self type.")
            }
            msgs.add(new msg.FileMsg(
                "This call is unexpectedly done on an attribute "
                "on an item with a broken type. "
                "Was the item declared with a forbidden cyclic type?",
                kind=msg.M_ERROR, source_file=project_file,
                line=child_node.line,
                col=child_node.col,
            ))
            called_node.damaged = yes
            return later none
        }
    }
    handle_extra_for_self_type() later:

    if called_node.damaged {
        return later none
    }

    var func_var_typeref = func_typeinfo.func_typeexpr
    var func_var_typeinfo = func_typeinfo
    var arg_var_types = []
    var arg_var_type_exprs = []

    # Now, collect info about expected vs actually given call signature:
    var expected_args =
        func_typeinfo.func_typeexpr.arg_typeref_exprs.len +
        if func_typeinfo.func_typeexpr.is_func_attr (-1) else (0) +
        if func_typeinfo.func_typeexpr.is_failable (-1) else (0)
    assert(expected_args >= 0)
    var called_args = call_args_expr.subexprs.len
    var is_self_call = ast_analyze.
        is_func_call_node_for_sure_a_self_call(
            project_file, called_node_parent,
            is_moose64=is_moose64
        )
    if self_value_ref == none and no {
        is_self_call = no
    }
    var effective_called_args =
        called_args + if is_self_call (1) else (0)
    var last_param_m64_type = none
    func determine_last_param_type_if_needed {
        if call_args_expr.subexprs.len <= 0 {
            return later
        }
        last_param_m64_type =
            m64_ast_analyze.get_c_or_m64_type_of_node(
                project_file, call_args_expr.subexprs[
                    call_args_expr.subexprs.len
                ], called_node_parents + [call_args_expr],
                store_self_value_ref_for_funcs=no,
                msgs=none, debug=no
            ) later:

        await last_param_m64_type
        if last_param_m64_type == none {
            print(if is_moose64 ("hoosec")
                else ("moosec") + ": "
                "error: Internal error, failed to determine "
                "type of this node: "
                "arg_expr=" +
                call_args_expr.subexprs[
                    call_args_expr.subexprs.len
                ].as_str())
            throw new RuntimeError(
                "Internal error: Failed to determine "
                "type of last call parameter. Please "
                "report this error to the compiler makers."
            )
        }
    }
    determine_last_param_type_if_needed() later:
    var is_failable_call =
        last_param_m64_type != none and
        last_param_m64_type.kind == typeinfo.TI_USERTYPE and
        last_param_m64_type.user_type_ref.name ==
            "moose64_failed_result_t" and
        last_param_m64_type.modifiers.len == 1 and
        last_param_m64_type.modifiers[1].name == "ref"
    var expected_with_self_str =
        if func_typeinfo.func_typeexpr.is_func_attr ("with self ref")
        else ("without self ref")
    var called_with_self_str =
        if is_self_call ("with self ref")
        else ("without self ref")

    var called_name = "func"
    if called_node.kind == ast.N_EXPR_BINOP and
            called_node.optoken.str == "." and
            called_node.subexprs.len == 2 and
            called_node.subexprs[2].kind == ast.N_EXPR_IDREF {
        called_name = "'" + called_node.subexprs[2].label + "' "
            "func attr"
    }

    var signature_mismatch = no
    if effective_called_args != expected_args +
            if func_typeinfo.func_typeexpr.is_func_attr (1) else (0) +
            if func_typeinfo.func_typeexpr.is_failable (1) else (0) {
        signature_mismatch = yes
    }

    if signature_mismatch {
        # Try to find override...
        # FIXME: implement this

        # If we didn't find an override, error:
        if not ignore_arg_mismatch {
            if msgs == none {
                print(if is_moose64 ("hoosec")
                        else ("moosec") + ": "
                    "error: Internal error, "
                    "args mismatch in unexpected context, "
                    "effective_called_args=" +
                        effective_called_args.as_str() + " "
                    "expected_args=" +
                        expected_args.as_str() + " "
                    "is_failable_call=" +
                        is_failable_call.as_str() + " "
                    "is_self_call=" +
                        is_self_call.as_str() + " "
                    "is_func_attr=" +
                        func_typeinfo.func_typeexpr.
                        is_func_attr.as_str())
                throw new RuntimeError("Call has wrong number of "
                    "arguments.")
            }
            var expected_s =
                if expected_args != 1 ("s") else ("")
            var called_s =
                if called_args != 1 ("s") else ("")
            if not called_node.damaged {
                msgs.add(new msg.FileMsg(
                    "Unexpected number of args, " +
                    called_name + " expects " +
                        expected_args.as_str() + " "
                    "arg" + expected_s + " " +
                        expected_with_self_str + " "
                    "but this call provides " +
                    called_args.as_str() + " arg" + called_s + " " +
                    called_with_self_str + ".",
                    kind=msg.M_ERROR, source_file=project_file,
                    line=called_node.line,
                    col=called_node.col,
                ))
            }
            called_node.damaged = yes
            return later none
        }
    }

    arg_var_type_exprs = func_typeinfo.func_typeexpr.
        arg_typeref_exprs.copy()
    if self_value_ref != none and arg_var_type_exprs.len > 0 {
        arg_var_type_exprs = arg_var_type_exprs.sub(2)
    }
    func handle_args {
        var idx = 0
        func handle_arg(arg) {
            idx += 1
            var scope = called_node.scope
            var tinfo = m64_ast_analyze.get_c_or_m64_type_of_typeref(
                project_file, arg,
                store_self_value_ref_for_funcs=no,
                msgs=msgs
            ) later:

            await tinfo
            if tinfo == none {
                called_node.damaged = yes
            }
            arg_var_types.add(tinfo)
        }
        var queue = arg_var_type_exprs.copy()
        if queue.len == 0 {
            return later
        }
        var item = queue.pop()
        var _unused = handle_arg(item)
        later:

        await _unused

        if queue.len == 0 {
            return later
        }
        item = queue.pop()
        _unused = handle_arg(item) later repeat
    }
    handle_args() later:

    if called_node.damaged {
        return later none
    }

    var result = new CalledFuncTypesResult()
    result.called_func_is_attr =
        func_typeinfo.func_typeexpr.is_func_attr
    result.func_var_type_expr = func_var_typeref
    result.func_var_typeinfo = func_var_typeinfo
    result.func_var_name = func_actual_name
    result.func_ref = m64_type_ref
    result.func_was_overridden = func_changed_to_override
    result.arg_var_type_exprs = arg_var_type_exprs
    result.arg_var_typeinfos = arg_var_types
    result.self_var_type_expr = self_type_expr
    result.self_var_typeinfo = self_type_typeinfo
    return result
}

func get_global_storage_neighbor_closure(project) {
    func try_get_neighbor_node_value(node_ref) {
        if node_ref == none or node_ref.kind != st_ref.ST_GLOBAL {
            return [ast_eval.AR_UNKNOWN]
        }
        var st_id = node_ref.id
        var gscope_map =
            project.storage_id_to_global_scope_map
        if not gscope_map.has(st_id) {
            return [ast_eval.AR_UNKNOWN]
        }
        var st_id_map = gscope_map[st_id].storage_id_to_entry
        if not st_id_map.has(st_id) {
            return [ast_eval.AR_UNKNOWN]
        }
        var entry = st_id_map[st_id]
        if entry.kind != ast.N_STMT_VAR or
                not entry.initial_value_known {
            return [ast_eval.AR_UNKNOWN]
        }
        return [ast_eval.AR_VALUE, entry.initial_value]
    }
    return try_get_neighbor_node_value
}

func advanced_phase2_evaluate_global_scope(
        project_file, is_moose64=no, msgs=none
        ) {
    var globals_value_cb = get_global_storage_neighbor_closure(
        project_file.project)
    var had_error = no
    var had_change = no
    var stmt_map = project_file.global_scope.
        name_to_stmt_map
    for name in stmt_map {
        var stmt = stmt_map[name]
        if typename(stmt) == "list" or
                (has_attr(stmt, "is_enum_entry") and
                 stmt.is_enum_entry) or
                stmt.kind != ast.N_STMT_VAR or
                stmt.initial_value_known {
            continue
        }
        var v = ast_eval.try_eval_ast_node_value(
            stmt.subexprs[1], is_moose64=is_moose64,
            eval_by_storage_ref_callback=globals_value_cb)
        if v[1] == ast_eval.AR_VALUE {
            had_change = yes
            stmt.initial_value_known = yes
            stmt.initial_value = v[2]
            if stmt.subexprs[1].kind != ast.N_EXPR_LIT {
                var value_expr = new ast_expr.LiteralExpr()
                value_expr.line = stmt.subexprs[1].line
                value_expr.col = stmt.subexprs[1].col
                value_expr.value = v[2]
                stmt.subexprs[1] = value_expr
            }
        } elseif v[1] == ast_eval.AR_TYPEERROR {
            if msgs != none {
                msgs.add(new msg.FileMsg(
                    "Invalid assigned expression containing a "
                    "type mismatch for operands. "
                    "If intended, protect it with "
                    "a rescue block that catches TypeError.",
                    source_file=project_file,
                    line=stmt.subexprs[1].line,
                    col=stmt.subexprs[1].col
                ))
            }
            had_error = yes
        }
    }
    if had_change {
        return "changed"
    }
    return not had_error
}

func get_throw_statement_rescue_clause(stmt, parents) {
    var parent_clause = none
    var pos = 1
    while pos <= parents.len {
        if parents[pos].kind == ast.N_STMT_FUNC {
            return none
        } elseif parents[pos].kind == ast.N_EXPR_RESCUECLAUSE {
            return parents[pos]
        }
        pos += 1
    }
    return none
}

func is_idref_readonly_access(node, parent_chain) {
    if node.kind != ast.N_EXPR_IDREF and
            (node.kind != ast.N_EXPR_BINOP or
            node.optoken.str != "." or
            node.subexprs.len != 2 or
            node.subexprs[2].kind != ast.N_EXPR_IDREF) {
        throw new TypeError("Check only valid for identifiers.")
    }
    if parent_chain.len == 0 {
        return no
    }
    var child = node
    var parent_idx = 1
    var parent = parent_chain[parent_idx]
    while yes {
        if parent.kind == ast.N_STMT_VAR {
            return yes
        }
        if parent.kind == ast.N_STMT_ASSIGN {
            var pair_count = parent.subexprs.len / 2
            var pos = pair_count + 1
            assert(pair_count >= 1)
            while pos <= parent.subexprs.len {
                if parent.subexprs[pos] == child {
                    # It's an rvalue, that's a read-only access.
                    return yes
                }
                pos += 1
            }
            return no
        }
        parent_idx += 1
        if parent_idx > parent_chain.len {
            return no
        }
        child = parent
        parent = parent_chain[parent_idx]
    }
}

func analyze_and_configure_newly_added_func(
        node, msgs=none, project_file=none
        ) {
    var is_later_func = no
    for block in node.subblocks {
        if stmt_list_contains_later_call(
                block, check_recursive=yes,
                include_later_ignore=no,
                recurse_into_funcs=no) {
            is_later_func = yes
            break
        }
    }
    node.func_scope.is_later_func = is_later_func
}

func advanced_phase3_h64_later_and_computevals(
        stmts, msgs=none, project_file=none
        ) {
    var globals_value_cb = get_global_storage_neighbor_closure(
        project_file.project)
    var parents = []
    var project = project_file.project
    func check_and_analyze_recurse(
            stmts, parents, msgs
            ) {
        for stmt in stmts {
            if stmt.kind == ast.N_STMT_FUNC {
                analyze_and_configure_newly_added_func(
                    stmt, msgs=msgs, project_file=project_file
                )
            }

            func check_nested_constructors(expr, parents) {
                var parent = if parents.len >= 1 (parents[parents.len])
                    else (none)
                var grandparent = if parents.len >= 2 (parents[parents.len - 1])
                    else (none)
                var grandgrandparent = if parents.len >= 3
                    (parents[parents.len - 2]) else (none)
                if expr.damaged {
                    return expr
                }
                # Replace enum references with their values:
                if expr.kind == ast.N_EXPR_IDREF and
                        expr.ref != none and
                        expr.ref.kind == st_ref.ST_NUMLITERAL {
                    var value_expr = new ast_expr.LiteralExpr()
                    value_expr.scope = expr.scope
                    value_expr.line = expr.line
                    value_expr.col = expr.col
                    value_expr.value = expr.ref.id
                    return value_expr
                }

                # Make sure types can't be directly referenced:
                var is_type_constructor = no
                var is_any_type = expr.kind == ast.N_EXPR_IDREF and
                    expr.ref != none and
                    project.is_ref_a_type(expr.ref)
                var is_error_type = expr.kind == ast.N_EXPR_IDREF and
                    expr.ref != none and is_any_type and
                    project.is_ref_of_given_type_an_error(expr.ref)
                var is_regular_type = is_any_type and not is_error_type
                if expr.kind == ast.N_EXPR_IDREF and
                        expr.ref != none {
                    if parent != none and is_regular_type and
                            parent.kind == ast.N_EXPR_RESCUECLAUSE {
                        if not project.
                                is_ref_of_given_type_an_error(expr.ref) {
                            if msgs != none {
                                msgs.add(new msg.FileMsg(
                                    "Invalid type reference, must be an "
                                    "error type but it's a regular type.",
                                    source_file=project_file,
                                    line=expr.line,
                                    col=expr.col
                                ))
                            }
                            expr.damaged = yes
                        }
                    } elseif parent == none or
                            parent.kind != ast.N_EXPR_BINOP or
                            parent.optoken.str != "(" or
                            expr != parent.subexprs[1] or
                            grandparent == none or
                            grandparent.kind != ast.N_EXPR_UNOP or
                            grandparent.subexprs[1] != parent or
                            grandparent.optoken.str != "new" {
                        if (is_regular_type and (parent == none or
                                not {ast.N_STMT_TYPE,
                                ast.N_STMT_TYPEEXTEND,
                                ast.N_STMT_STRUCTEXTEND,
                                ast.N_STMT_ENUMEXTEND}.has(
                                    parent.kind
                                ))) or
                                (is_error_type
                                 and (parent == none or
                                      not {ast.N_STMT_TYPE,
                                      ast.N_EXPR_RESCUECLAUSE}.has(
                                          parent.kind
                                      ))) {
                            if msgs != none {
                                msgs.add(new msg.FileMsg(
                                    "Invalid type reference, must "
                                    "be part of a new constructor.",
                                    source_file=project_file,
                                    line=expr.line,
                                    col=expr.col
                                ))
                            }
                            expr.damaged = yes
                        }
                    } else {
                        is_type_constructor = yes
                    }
                }

                # Make sure errors are instantiated correctly:
                if is_type_constructor and is_error_type {
                    if grandgrandparent == none or
                            grandgrandparent.kind != ast.N_STMT_THROW {
                        if msgs != none {
                            msgs.add(new msg.FileMsg(
                                "Invalid error constructor call, "
                                "must be part of 'throw' statement.",
                                source_file=project_file,
                                line=callargs.line,
                                col=callargs.col
                            ))
                        }
                        expr.damaged = yes
                        return expr
                    }
                    var callargs = parent.subexprs[2]
                    if callargs.subexprs.len != 1 or
                            callargs.subexprs[1].kind ==
                            ast.N_EXPR_CALLKWARG {
                        if msgs != none {
                            msgs.add(new msg.FileMsg(
                                "Invalid error constructor call, "
                                "must have single positional "
                                "message string argument.",
                                source_file=project_file,
                                line=callargs.line,
                                col=callargs.col
                            ))
                        }
                        expr.damaged = yes
                        return expr
                    }
                }
                return expr
            }
            ast_transform.do_simply_on_all_exprs(
                stmt, check_nested_constructors)

            # Determine error message ahead of time for throws:
            if stmt.kind == ast.N_STMT_THROW and
                    not stmt.error_msg_failed_early_eval and
                    not stmt.has_damage() and
                    stmt.subexprs.len > 0 {
                var has_valid_error_arg = no
                var callargs, callobj
                assert(stmt.subexprs.len == 1)
                if stmt.subexprs[1].kind == ast.N_EXPR_UNOP and
                        stmt.subexprs[1].optoken.str == "new" and
                        stmt.subexprs[1].subexprs[1].kind ==
                            ast.N_EXPR_BINOP and
                        stmt.subexprs[1].subexprs[1].optoken.str == "(" and
                        stmt.subexprs[1].subexprs[1].subexprs[2].kind ==
                            ast.N_EXPR_CALLARGS {
                    callargs = stmt.subexprs[1].subexprs[1].
                        subexprs[2]
                    callobj = stmt.subexprs[1].subexprs[1].subexprs[1]
                    if callobj.kind != ast.N_EXPR_IDREF or
                            not project.is_ref_a_type(callobj.ref) or
                            not project.is_ref_of_given_type_an_error(
                                callobj.ref) {
                        has_valid_error_arg = no
                    } else {
                        has_valid_error_arg = yes
                    }
                } elseif stmt.subexprs[1].kind == ast.N_EXPR_IDREF {
                    has_valid_error_arg = yes
                }
                if not has_valid_error_arg {
                    if msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Invalid throw, must have a new "
                            "constructor as argument that "
                            "directly refers to an error type, "
                            "or a variable containing an "
                            "already thrown error.",
                            source_file=project_file,
                            line=stmt.subexprs[1].line,
                            col=stmt.subexprs[1].col
                        ))
                    }
                    stmt.damaged = yes
                    callargs.damaged = yes
                }
                if not stmt.damaged and callargs != none and (
                        callargs.subexprs.len != 1 or
                        callargs.subexprs[1].kind ==
                            ast.N_EXPR_CALLKWARG) {
                    if msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Invalid error constructor call, "
                            "must have single positional "
                            "message string argument.",
                            source_file=project_file,
                            line=stmt.subexprs[1].line,
                            col=stmt.subexprs[1].col
                        ))
                    }
                    stmt.damaged = yes
                    callargs.damaged = yes
                }
                if not stmt.damaged and callargs != none {
                    var v = ast_eval.try_eval_ast_node_value(
                        callargs.subexprs[1],
                        eval_by_storage_ref_callback=globals_value_cb)
                    if v[1] != ast_eval.AR_VALUE {
                        stmt.error_msg_failed_early_eval = yes
                    } elseif typename(v[2]) != "str" {
                        stmt.damaged = yes
                    } else {
                        stmt.error_msg_failed_early_eval = no
                        stmt.error_msg_aot_evaluated = v[2]
                    }
                    if stmt.damaged and msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Invalid error constructor call, "
                            "message argument must be str.",
                            source_file=project_file,
                            line=stmt.subexprs[1].line,
                            col=stmt.subexprs[1].col
                        ))
                    }
                }
            } elseif stmt.kind == ast.N_STMT_THROW and
                    not stmt.has_damage() and
                    stmt.subexprs.len == 0 {
                # This is an anonymous throw. Transform it to have
                # a named parameter!

                var has_named_label = no
                var parent_clause = get_throw_statement_rescue_clause(
                    stmt, parents)
                if parent_clause == none {
                    stmt.damaged = yes
                    if msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Invalid anonymous throw, "
                            "not inside any rescue clause.",
                            source_file=project_file,
                            line=stmt.line,
                            col=stmt.col
                        ))
                    }
                }

                for label in parent_clause.error_labels {
                    if label != none {
                        has_named_label = yes
                        break
                    }
                }
                if has_named_label {
                    stmt.damaged = yes
                    parent_clause.damaged = yes
                    if msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Invalid anonymous throw, "
                            "not allowed here because surrounding "
                            "rescue clause at line " +
                            parent_clause.line.as_str() +
                            ", column " + parent_clause.col.as_str() +
                            " has one or more named errors.",
                            source_file=project_file,
                            line=stmt.line,
                            col=stmt.col
                        ))
                    }
                } else {
                    var inner_scope = stmt.scope
                    for block in parent_clause.subblocks {
                        if block.len > 0 {
                            inner_scope = block[1].scope
                            break
                        }
                    }
                    var new_name = "autothrowlabel" + random.gen_id()
                    while not inner_scope.name_is_free(new_name,
                            project_file.global_scope) {
                        new_name = "autothrowlabel" + random.gen_id()
                    }
                    var new_sinfo = inner_scope.add_symbol(
                        new_name, project_file, parent_clause.line,
                        parent_clause.col)[2]
                    if new_sinfo == none {
                        throw new RuntimeError("Internal error.")
                    }
                    assert(parent_clause.error_labels.len > 0)
                    assert(parent_clause.symbol_info.len ==
                        parent_clause.error_labels.len)
                    var pos = 1
                    while pos <= parent_clause.error_labels.len {
                        assert(parent_clause.error_labels[pos] == none)
                        parent_clause.error_labels[pos] = new_name
                        parent_clause.symbol_info[pos] = new_sinfo.copy()
                        pos += 1
                    }
                    func assign_label_to_all_empty_throws(stmts) {
                        for stmt in stmts {
                            if stmt.kind == ast.N_STMT_THROW and
                                    stmt.subexprs.len == 0 {
                                var node = new ast_expr.IdRefExpr()
                                node.scope = inner_scope
                                node.line = stmt.line
                                node.col = stmt.col
                                node.label = new_name
                                node.ref = new st_ref.StorageRef(
                                    st_ref.ST_LOCAL, new_sinfo.storage_id
                                )
                                stmt.subexprs.add(node)
                            } elseif stmt.kind == ast.N_STMT_DO or
                                    stmt.kind == ast.N_STMT_IF {
                                for clause in stmt.subexprs {
                                    if clause.kind ==
                                            ast.N_EXPR_RESCUECLAUSE {
                                        # Don't cross into rescue clauses.
                                        continue
                                    }
                                    for block in clause.subblocks {
                                        assign_label_to_all_empty_throws(
                                            block)
                                    }
                                }
                            } elseif stmt.kind == ast.N_STMT_FUNC {
                                # Don't cross function boundaries.
                                continue
                            } elseif stmt.subblocks.len > 0 {
                                for block in stmt.subblocks {
                                    assign_label_to_all_empty_throws(
                                        block)
                                }
                            }
                        }
                    }
                    for block in parent_clause.subblocks {
                        assign_label_to_all_empty_throws(block)
                    }
                }
            }

            # Blocks:
            if stmt.subblocks.len > 0 {
                for block in stmt.subblocks {
                    if not check_and_analyze_recurse(
                            block, [stmt] + parents, msgs) {
                        return no
                    }
                }
            }
            if stmt.kind == ast.N_STMT_IF or
                    stmt.kind == ast.N_STMT_DO {
                for clause in stmt.subexprs {
                    for block in clause.subblocks {
                        if not check_and_analyze_recurse(
                                block, [stmt, clause] + parents, msgs) {
                            return no
                        }
                    }
                }
            }
        }
        return yes
    }
    return check_and_analyze_recurse(
        stmts, parents, msgs
    )
}

func advanced_phase1_globalrefs(
        stmts, is_moose64=no, msgs=none, project_file=none
        ) {
    func check_and_analyze_recurse(
            stmts, msgs) {
        for stmt in stmts {
            # FIXME
            # IMPORTANT: we also want to auto-const all vars here already.
            # (Then the next state, the iteration stage, can do better
            # guesses, especially inside functions.)

            # Blocks:
            if stmt.subblocks.len > 0 {
                for block in stmt.subblocks {
                    if not check_and_analyze_recurse(block, msgs) {
                        return no
                    }
                }
            }
            if stmt.kind == ast.N_STMT_IF or
                    stmt.kind == ast.N_STMT_DO {
                for clause in stmt.subexprs {
                    for block in clause.subblocks {
                        if not check_and_analyze_recurse(block, msgs) {
                            return no
                        }
                    }
                }
            }
        }
        return yes
    }
    return check_and_analyze_recurse(
        stmts, msgs
    )
}

func basic_phase_nestingdepth_and_misc(
        stmts, is_moose64=no, msgs=none, project_file=none
        ) {
    func check_and_analyze_recurse(
            stmts, msgs, max_block_nesting_left, is_moose64
            ) {
        if max_block_nesting_left < 0 and stmts.len > 0 {
            if msgs != none {
                msgs.add(new msg.FileMsg(
                    "Nesting of statements too deep here, "
                    "exceeds maximum supported depth.",
                    source_file=project_file,
                    line=stmts[1].line, col=stmts[1].col
                ))
            }
            return no
        }
        for stmt in stmts {
            if stmt.subblocks.len > 0 {
                for block in stmt.subblocks {
                    if not check_and_analyze_recurse(
                            block, msgs,
                            max_block_nesting_left - 1,
                            is_moose64) {
                        return no
                    }
                }
            }
            if stmt.kind == ast.N_STMT_IF or
                    stmt.kind == ast.N_STMT_DO {
                for clause in stmt.subexprs {
                    for block in clause.subblocks {
                        if not check_and_analyze_recurse(
                                block, msgs,
                                max_block_nesting_left - 1,
                                is_moose64) {
                            return no
                        }
                    }
                }
            }
        }
        return yes
    }
    return check_and_analyze_recurse(
        stmts, msgs, compiler_limit.max_statement_nesting,
        is_moose64
    )
}

func ensure_analysis_has_needed_error(analysis_result, msgs) {
    if not analysis_result and msgs != none {
        var had_error = no
        for m in msgs {
            if m.kind == msg.M_ERROR {
                had_error = yes
                break
            }
        }
        if not had_error {
            msgs.add(new msg.FileMsg(
                "Internal error occured, we failed "
                "analysis without a proper error message. "
                "Please report this bug to the compiler makers."
            ))
        }
    }
}

func do_advanced_check_and_analysis(project, msgs) {
    var is_moose64 = no
    if project.build_options != none and
            project.build_options.is_moose64 {
        is_moose64 = yes
    }

    func process_file(pfile) {
        pfile.ensure_ast() later:

        if not advanced_phase1_globalrefs(
                pfile.ast.stmts, is_moose64=is_moose64, msgs=msgs,
                project_file=pfile) {
            return later no
        }
        while yes {
            var result = advanced_phase2_evaluate_global_scope(
                pfile, is_moose64=is_moose64, msgs=msgs
            )
            if result != "changed" {
                if not result {
                    return later no
                }
                assert(result == yes)
                break
            }
        }
        if not is_moose64 and
                not advanced_phase3_h64_later_and_computevals(
                pfile.ast.stmts, msgs,
                project_file=pfile) {
            return later no
        }
        return later yes
    }
    var check_went_ok = project.do_for_all_files(process_file)
    later:

    await check_went_ok
    assert(check_went_ok == yes or check_went_ok == no)
    for m in msgs {
        if m.kind == msg.M_ERROR {
            check_went_ok = no
        }
    }

    ensure_analysis_has_needed_error(check_went_ok, msgs)
    return later check_went_ok
}

func do_basic_check_and_analysis(project, msgs, is_moose64=no) {
    func do_unsafe {
        func process_file(pfile) {
            pfile.ensure_ast() later:

            if not basic_phase_nestingdepth_and_misc(
                    pfile.ast.stmts, is_moose64=is_moose64,
                    msgs=msgs, project_file=pfile) {
                return later no
            }
            return later yes
        }
        var check_went_ok = project.do_for_all_files(process_file)
        later:

        await check_went_ok
        for m in msgs {
            if m.kind == msg.M_ERROR {
                check_went_ok = no
            }
        }

        return later check_went_ok
    }
    var result = do_unsafe() later:

    await result

    ensure_analysis_has_needed_error(result, msgs)
    return later result
}

func is_func_call_node_for_sure_a_self_call(
        project_file, call_node, symbol_info=none, is_moose64=no
        ) {
    if call_node.kind != ast.N_EXPR_BINOP or
            call_node.optoken.str != "(" {
        throw new ValueError("The parameter call_node "
            "must be a call expression.")
    }
    var called_node = call_node.subexprs[1]
    var is_possibly_self_obj_call =
        (called_node.kind == ast.N_EXPR_BINOP and
            called_node.optoken.str == "." and
            called_node.subexprs[1].kind == ast.N_EXPR_IDREF and
            called_node.subexprs[1].ref != none and
            not st_ref.ref_is_global_func_def(
                project_file, called_node.subexprs[1].ref
            ))
    if not is_possibly_self_obj_call {
        return no
    }
    assert(called_node.subexprs[1].ref != none)
    if not is_moose64 {
        # Horse64 doesn't allow passing funcs around in a way
        # where you can call the self parameter passed in
        # explicitly (as non-implicit self call).
        # Therefore, this only depends on whether the
        # target func is clearly a func attr.
        if called_node.subexprs[2].ref != none and
                called_node.subexprs[2].ref == st_ref.ST_GLOBAL {
            var entry = st_scope.global_id_to_item(
                project_file.project,
                called_node.ref.id)
            return entry.kind == ast.N_STMT_FUNC and
                entry.type_path != none and
                entry.type_path.len > 0
        }
        return called_node.subexpr[2].ref != none and
            called_node.subexprs[2].ref == st_ref.ST_GLOBALATTR
    }
    if called_node.subexprs[2].ref == none {
        return no
    }
    if symbol_info == none {
        symbol_info = st_ref.ref_to_symbol_info(
            project_file, called_node.subexprs[2].ref,
            node=called_node
        )
    }
    if symbol_info == none or symbol_info.typeref_expr == none or
            not symbol_info.typeref_expr.is_func_ref {
        return no
    }
    return symbol_info.typeref_expr.is_func_attr
}

