# @module compiler.ast.call_stmt
# Copyright (c) 2023, ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import compiler.ast as ast
import compiler.ast.expr as expr
import compiler.ast.invalid_stmt as invalid_stmt
import compiler.ast.later_parse as later_parse
import compiler.ast.block as block
import compiler.msg as msg
import compiler.token as token

type CallStmt base ast.StmtNode {
    var has_later = no
    var has_later_ignore = no
    var has_later_repeat = no
}

func CallStmt.init {
    base.init()
    self.kind = ast.N_STMT_CALL
}

func CallStmt.as_json_obj {
    var output = base.as_json_obj()
    if self.has_later {
        output["has_later"] = yes
    }
    if self.has_later_ignore {
        output["has_later_ignore"] = yes
    }
    if self.has_later_repeat {
        output["has_later_repeat"] = yes
    }
    return output
}

func CallStmt.as_code(indent=0) {
    return " ".rep(indent) + self.subexprs[1].as_code(indent=indent)
}

type AssignStmt base ast.StmtNode {
    var has_later = no
    var has_later_ignore = no
    var has_later_repeat = no
}

func AssignStmt.init {
    base.init()
    self.kind = ast.N_STMT_ASSIGN
}

func AssignStmt.as_json_obj {
    var output = base.as_json_obj()
    if self.has_later {
        output["has_later"] = yes
    }
    if self.has_later_ignore {
        output["has_later_ignore"] = yes
    }
    if self.has_later_repeat {
        output["has_later_repeat"] = yes
    }
    return output
}

func AssignStmt.as_code(indent=0) {
    return " ".rep(indent) +
        self.subexprs[1].as_code(indent=indent) + " = " +
        self.subexprs[2].as_code(indent=indent)
}

func check_call_or_assign_and_get_idx(
        tokens, pos, tokens_len, only_assigns=no, debug=no) {
    if pos > tokens_len or (
            not {token.T_NUM, token.T_STR, token.T_BYTES,
             token.T_IDENT}.has(tokens[pos].kind) and
            (tokens[pos].kind != token.T_KEYWORD or
             tokens[pos].str != "base")) {
        return -1
    }

    # To check this is a call or assign, find the '(' or '=':
    var is_call = yes
    var assign_or_call_idx = -1
    var i = pos + 1
    while yes {
        if i > tokens_len {
            break
        } elseif tokens[i].kind == token.T_DOT {
            if i + 1 > tokens_len or
                    tokens[i + 1].kind != token.T_IDENT {
                break
            }
            i += 2
            continue
        } elseif tokens[i].kind == token.T_ENCLOSE and
                (tokens[i].str == "[" or tokens[i].str == "(") {
            var bracket_pos = i
            var bracket_depth = 1
            i += 1
            while yes {
                if i > tokens_len {
                    break
                }
                if tokens[i].kind == token.T_ENCLOSE {
                    if {"(", "[", "{"}.has(tokens[i].str) {
                        bracket_depth += 1
                    } else {
                        assert({")", "]", "}"}.has(tokens[i].str))
                        bracket_depth -= 1
                        if bracket_depth <= 0 {
                            break
                        }
                    }
                }
                i += 1
            }
            i += 1
            if i > tokens_len or (
                    tokens[i].kind != token.T_DOT and
                    (tokens[i].kind != token.T_ENCLOSE or
                     not {"(", "["}.has(tokens[i].str)) and
                    tokens[i].kind != token.T_MATHASSIGN and
                    tokens[i].kind != token.T_ASSIGN) {
                if not only_assigns and tokens[bracket_pos].str == "(" {
                    return bracket_pos
                }
                return -1
            }
            continue
        } elseif tokens[i].kind == token.T_ENCLOSE and
                tokens[i].str == "(" {
            if only_assigns {
                return -1
            }
            return i
        } elseif tokens[i].kind == token.T_MATHASSIGN or
                tokens[i].kind == token.T_ASSIGN {
            return i
        } else {
            break
        }
    }
    return -1
}

func parse(tokens, pos, msgs, project_file=none, debug=no) {
    var tokens_len = tokens.len
    var startpos = pos

    var assign_or_call_idx = check_call_or_assign_and_get_idx(
        tokens, pos, tokens_len, debug=debug
    )
    if assign_or_call_idx < 0 {
        return later none
    }
    var is_call =
        tokens[assign_or_call_idx].kind == token.T_ENCLOSE

    # Parse the call or lvalue expression:
    var v1 = expr.parse_expression(
        tokens, pos,
        msgs, max_len=(if is_call (tokens_len) else
            (assign_or_call_idx)),
        project_file=project_file, debug=debug
    ) later:
    await v1

    if is_call {
        # Check if we actually got a call expression:
        var stmt = new CallStmt()
        stmt.line = token.get_line(tokens, startpos)
        stmt.col = token.get_col(tokens, startpos)
        if v1 == none or v1.kind != ast.N_EXPR_BINOP {
            msgs.add(new msg.FileMsg(
                "Unexpected expression " +
                (if v1 != none ("of kind " +
                 ast.NodeKind.num_label(v1.kind)) else
                 ("starting with token " +
                  token.describe_token(tokens[pos]))) +
                ", expected valid call expression.",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
        } elseif v1.optoken.str != "(" {
            msgs.add(new msg.FileMsg(
                "Unexpected binary operator expression " +
                token.describe_token(v1.optoken) +
                ", expected call statement with no surrounding " +
                "operator expressions, for statement starting in " +
                "line " + token.get_line(tokens, pos).as_str() +
                ", column " + token.get_col(tokens, pos).as_str() +
                ".",
                source_file=project_file,
                line=v1.optoken.line,
                col=v1.optoken.col,
            ))
        }
        if v1 == none {
            var skiplen = token.get_naive_stmt_or_expr_len(
                tokens, pos, for_expr=no
            )
            v1 = new expr.InvalidExpr(skiplen)
        }
        pos += v1.token_len
        stmt.subexprs.add(v1)

        pos = later_parse.
            parse_later_postfix(tokens, pos, stmt, msgs,
                project_file=project_file, debug=debug)
        stmt.token_len = (pos - startpos)

        return later stmt
    }
    assert(not is_call)

    var stmt = new AssignStmt()
    stmt.line = token.get_line(tokens, startpos)
    stmt.col = token.get_col(tokens, startpos)
    if v1 == none {
        msgs.add(new msg.FileMsg(
            "Unexpected token " +
            token.describe_token_at(tokens,
                assign_or_call_idx + 1) +
            ", expected valid lvalue expression for " +
            "assign operator at line " +
            token.get_line(tokens, assign_or_call_idx).as_str() +
            ", column " +
            token.get_col(tokens, assign_or_call_idx).as_str() + ".",
            source_file=project_file,
            line=token.get_line(tokens, pos),
            col=token.get_col(tokens, pos),
        ))
        var skiplen = token.get_naive_stmt_or_expr_len(
            tokens, pos, for_expr=no
        )
        if skiplen < 1 {
            skiplen = 1
        }
        v1 = new expr.InvalidExpr(skiplen)
    }

    var v2 = expr.parse_expression(
        tokens, assign_or_call_idx + 1,
        msgs,
        project_file=project_file, debug=debug
    ) later:
    await v2

    if v2 == none {
        msgs.add(new msg.FileMsg(
            "Unexpected token " +
            token.describe_token_at(tokens,
                assign_or_call_idx + 1) +
            ", expected valid assigned expression for " +
            "assign operator at line " +
            token.get_line(tokens, assign_or_call_idx).as_str() +
            ", column " +
            token.get_col(tokens, assign_or_call_idx).as_str() + ".",
            source_file=project_file,
            line=token.get_line(tokens, assign_or_call_idx + 1),
            col=token.get_col(tokens, assign_or_call_idx + 1),
        ))
        var skiplen = token.get_naive_stmt_or_expr_len(
            tokens, assign_or_call_idx, for_expr=no
        ) - 1
        if skiplen < 1 {
            skiplen = 1
        }
        v2 = new expr.InvalidExpr(skiplen)
    }
    pos = assign_or_call_idx + v2.token_len + 1
    stmt.token_len = (pos - startpos)
    stmt.subexprs.add(v1)
    stmt.subexprs.add(v2)

    var newpos =
        later_parse.parse_later_postfix(tokens, pos, stmt, msgs,
            project_file=project_file, debug=debug)

    if newpos > pos and not stmt.has_damage() {
        if v2.kind != ast.N_EXPR_BINOP or
                v2.optoken.str != "(" {
            msgs.add(new msg.FileMsg(
                "Unexpected use of 'later' for assigned "
                "expression " +
                ast.NodeKind.num_label(v2.kind) +
                if v2.kind == ast.N_EXPR_BINOP
                    (" (of type '" + v2.optoken.str + "')")
                    else ("") + ", "
                "can only use 'later' after call expression.",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            stmt.damaged = yes
        }
        if v1.kind != ast.N_EXPR_IDREF {
            msgs.add(new msg.FileMsg(
                "Unexpected use of 'later' for lvalue "
                "of type " +
                ast.NodeKind.num_label(v1.kind) + ", "
                "can only use when directly assigning a "
                "local variable name.",
                source_file=project_file,
                line=token.get_line(tokens, pos),
                col=token.get_col(tokens, pos),
            ))
            stmt.damaged = yes
        }
    }
    pos = newpos
    stmt.token_len = (pos - startpos)
    return stmt
}

