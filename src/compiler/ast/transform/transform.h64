## @module compiler.ast.transform
# Copyright (c) 2023-2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import debugger from core.horse64.org
import random from core.horse64.org
import textfmt from core.horse64.org
import time from core.horse64.org

import compiler.ast as ast
import compiler.ast.analyze as ast_analyze
import compiler.ast.call_or_assign_stmt as call_or_assign_stmt
import compiler.ast.expr as ast_expr
import compiler.ast.if_stmt as if_stmt
import compiler.ast.transform.later_transform as later_transform
import compiler.ast.var_stmt as var_stmt
import compiler.globals_order
import compiler.moose64.ast.transform as m64_ast_transform
import compiler.msg as msg
import compiler.project as project
import compiler.storage.ref as st_ref
import compiler.storage.scope as st_scope
import compiler.token as token
import compiler.typeinfo.ast_typeref as ast_typeref

type VisitQueueEntry {
    var node
    var parent
}

func VisitQueueEntry.init(node, parent) {
    self.node = node
    self.parent = parent
}

func split_if_to_single_clauses(project_file, node, parent) {
    assert(node.kind == ast.N_STMT_IF)
    if node.subexprs.len == 1 {
        return [node]
    }
    var inner_scope = node.scope
    assert(inner_scope != none)
    var result = []
    while node.subexprs.len > 1 {
        var want_split_var_node = yes
        var conditional_node = none
        var refer_to_condition_label = none
        var refer_to_storage_id = none
        var clause = node.subexprs[1]
        assert(not clause.is_else)
        assert(clause.subexprs.len == 1)
        conditional_node = clause.subexprs[1]

        if {ast.N_EXPR_IDREF,
                ast.N_EXPR_LIT}.has(conditional_node.kind) {
            want_split_var_node = no
        }

        if want_split_var_node {
            var vardef_node = new var_stmt.VarStmt()
            var new_name = "splitifcond" + random.gen_id()
            while not inner_scope.name_is_free(new_name,
                    project_file.global_scope) {
                new_name = "splitifcond" + random.gen_id()
            }
            var new_sinfo = inner_scope.add_symbol(
                new_name, project_file, node.line,
                node.col)[2]
            if new_sinfo == none {
                throw new RuntimeError("Internal error.")
            }
            refer_to_condition_label = new_name
            refer_to_storage_id = new_sinfo.storage_id

            vardef_node.var_labels.add(new_name)
            vardef_node.subexprs.add(conditional_node)
            vardef_node.line = conditional_node.line
            vardef_node.col = conditional_node.col
            vardef_node.scope = inner_scope
            result.add(vardef_node)

            var idref = new ast_expr.IdRefExpr()
            idref.scope = inner_scope
            idref.label = new_name
            idref.line = conditional_node.line
            idref.col = conditional_node.col
            idref.ref = new st_ref.StorageRef(
                st_ref.ST_LOCAL, new_sinfo.storage_id
            )
            clause.subexprs[1] = idref
        }

        result.add(node)
        var new_conditional = new if_stmt.IfStmt()
        new_conditional.scope = inner_scope
        new_conditional.subexprs = node.subexprs.sub(2)
        assert(new_conditional.subexprs.len >= 1)
        node.subexprs = node.subexprs.sub(1, 1)
        var first_clause = new_conditional.subexprs[1]
        new_conditional.line = first_clause.line
        new_conditional.col = first_clause.col

        var idref = new ast_expr.IdRefExpr()
        idref.scope = inner_scope
        idref.label = refer_to_condition_label
        idref.line = new_conditional.line
        idref.col = new_conditional.col
        idref.ref = new st_ref.StorageRef(
            st_ref.ST_LOCAL, refer_to_storage_id
        )
        var t = new token.Token("not",
            token.T_KEYWORD, idref.line, idref.col)
        var negated = new ast_expr.UnopExpr(t)
        negated.scope = inner_scope
        negated.subexprs.add(idref)
        negated.col = idref.col
        negated.line = idref.line

        var pos = 1
        while pos <= new_conditional.subexprs.len {
            var clause = new_conditional.subexprs[pos]
            if clause.subexprs.len == 0 {
                assert(clause.is_else)
                assert(pos == new_conditional.subexprs.len)
                clause.is_else = no
                clause.subexprs.add(negated)
            } else {
                assert(clause.subexprs.len == 1)
                var t = new token.Token("and",
                    token.T_KEYWORD, clause.subexprs[1].line,
                    clause.subexprs[1].col)
                var binop = new ast_expr.BinopExpr(t)
                binop.scope = inner_scope
                binop.line = t.line
                binop.col = t.col
                binop.subexprs.add(negated)
                binop.subexprs.add(clause.subexprs[1])
                clause.subexprs[1] = binop
            }
            pos += 1
        }
        node = new_conditional
    }
    assert(node.subexprs.len == 1)
    result.add(node)
    return result
}

func reparent_stmts_into_closure(
        func_node, stmts, outer_inner_scope,
        clone_all_stmts=yes,
        args_replacing_closure_refs_allowed=no,
        special_storage_remaps=[]
        ) {
    assert(func_node.kind == ast.N_STMT_FUNC)
    var closure_func_scope = func_node.func_scope
    assert(closure_func_scope != none)
    var outer_func_scope = outer_inner_scope.func_scope
    assert(outer_func_scope != closure_func_scope)

    var replaced_inner_scopes_map = {->}

    var vars_in_replaced_scope_st_ids = {->}

    if clone_all_stmts {
        var new_stmts = []
        for stmt in stmts {
            new_stmts.add(stmt.copy())
        }
        stmts = new_stmts
    }

    func replace_scopes(stmts) {
        func replace_scope_visitor(node, parents) {
            var is_in_outer_stmts_list = (
                stmts.has(node)
            )

            assert(node.scope != none)
            assert(node.scope.func_scope != none)
            if node.scope.func_scope != outer_func_scope {
                return later node
            }
            if replaced_inner_scopes_map.has(node.scope) {
                # We already have a replacement scope, return it:
                node.scope = replaced_inner_scopes_map[node.scope]
                assert(node.scope.func_scope == closure_func_scope)
                return later node
            } elseif node.scope.func_scope == outer_func_scope and
                    is_in_outer_stmts_list {
                # Since this is on the most outer level,
                # use the inner scope that our new func node
                # already created.
                replaced_inner_scopes_map[node.scope] =
                    func_node.func_scope.inner_scope
                node.scope = func_node.func_scope.inner_scope
                assert(node.scope.func_scope == closure_func_scope)
                return later node
            }
            var new_inner_scope = new st_scope.LocalScope()
            if node.scope.parent != none {
                if node.scope.parent == outer_inner_scope {
                    new_inner_scope.parent = outer_inner_scope
                } else {
                    if not replaced_inner_scopes_map.
                            has(node.scope.parent) {
                        replaced_inner_scopes_map[node.scope.parent] =
                            new st_scope.LocalScope()
                        replaced_inner_scopes_map[node.scope.parent].
                            func_scope = closure_func_scope
                    }
                    new_inner_scope.parent =
                        replaced_inner_scopes_map[node.scope.parent]
                }
            }
            new_inner_scope.func_scope = closure_func_scope
            replaced_inner_scopes_map[node.scope] = new_inner_scope
            for name in node.scope.name_to_symbol_map {
                if is_in_outer_stmts_list {
                    var defined_in_copied_range = no
                    for stmt in stmts {
                        if stmt.kind == ast.N_STMT_VAR and
                                stmt.var_labels.has(name) {
                            defined_in_copied_range = yes
                            break
                        } elseif stmt.kind == ast.N_STMT_FUNC and
                                stmt.label == name {
                            defined_in_copied_range = yes
                            break
                        }
                    }
                    if not defined_in_copied_range {
                        continue
                    }
                }
                var sinfo = node.scope.name_to_symbol_map[name]
                closure_func_scope.last_inner_storage_id += 1
                var st_id = closure_func_scope.last_inner_storage_id
                vars_in_replaced_scope_st_ids[sinfo.storage_id] = st_id
                var new_sinfo = sinfo.copy()
                new_sinfo.storage_id = sinfo.storage_id
                new_inner_scope.name_to_symbol_map[
                    new_sinfo.name] = new_sinfo
                new_inner_scope.storage_id_to_symbol_map[
                    st_id] = new_sinfo
            }
            node.scope = new_inner_scope
            assert(node.scope.func_scope == closure_func_scope)
            return later node
        }
        var queue = stmts.copy()
        if queue.len == 0 {
            return later
        }
        var next_node = queue.pop_at(1)
        var result = visit_ast_tree(next_node, replace_scope_visitor,
            pass_func_boundaries=yes, parent_chain=yes, backward=no)
        later:

        await result
        assert(result == yes)
        if queue.len == 0 {
            return later
        }
        next_node = queue.pop_at(1)
        result = visit_ast_tree(next_node, replace_scope_visitor,
            pass_func_boundaries=yes, parent_chain=yes, backward=no)
        later repeat
    }
    replace_scopes(stmts) later:

    if debugger.is_debug_build {
        for stmt in stmts {
            assert(stmt.scope.func_scope == closure_func_scope)
        }
    }
    func adjust_storage {
        func fix_storage_visitor(node, parents) {
            assert(node.scope != none)
            if node.scope.func_scope != closure_func_scope {
                return later node
            }
            if node.kind != ast.N_EXPR_IDREF or node.ref == none {
                return later node
            }
            for remap in special_storage_remaps {
                if remap[1].alike(node.ref) {
                    node.ref = remap[2].copy()
                    return later node
                }
            }
            if node.ref.kind != st_ref.ST_LOCAL {
                return later node
            }
            if vars_in_replaced_scope_st_ids.has(node.ref.id) {
                node.ref.id = vars_in_replaced_scope_st_ids[node.ref.id]
            } else {
                # This crosses closure boundaries now.
                var result_pair = node.scope.lookup(node.label,
                    is_write_access=no, cross_func_scopes=yes,
                    auto_add_ccapture=yes)

                assert(result_pair != none and
                    (result_pair[1].kind == st_ref.ST_CCAPTURE or
                    (args_replacing_closure_refs_allowed and
                    result_pair[1].kind == st_ref.ST_ARG)))
                node.ref = result_pair[1]
            }
            return later node
        }
        var queue = stmts.copy()
        if queue.len == 0 {
            return later
        }
        var next_node = queue.pop_at(1)
        var result = visit_ast_tree(next_node, fix_storage_visitor,
            pass_func_boundaries=yes, parent_chain=yes, backward=no)
        later:

        await result
        if queue.len == 0 {
            return later
        }
        next_node = queue.pop_at(1)
        result = visit_ast_tree(next_node, fix_storage_visitor,
            pass_func_boundaries=yes, parent_chain=yes, backward=no)
        later repeat
    }
    adjust_storage() later:

    func_node.subblocks = [stmts]
    return later
}

func visit_ast_tree(node, visit_cb, pass_func_boundaries=yes,
        parent_chain=no, backward=no, subtree_parent=none,
        return_new_root=no) {
    if subtree_parent != none {
        if parent_chain and typename(subtree_parent) != "list" {
            throw new TypeError("For parent_chain=yes, "
                "subtree_parent must also be set to a parent list if "
                "not none.")
        } elseif not parent_chain and
                typename(subtree_parent) == "list" {
            throw new TypeError("For parent_chain=no, "
                "subtree_parent shouldn't be set to a list if "
                "not none.")
        }
    }
    var root_to_return = none
    if return_new_root {
        root_to_return = node
    }
    var default_parent = if parent_chain ([]) else (none)
    if subtree_parent != none {
        default_parent = subtree_parent
    }
    var visit_queue = [
        new VisitQueueEntry(node, default_parent)
    ]
    var aborted = no
    var is_first = yes

    func queue_children_of_item(item, prev_parent) {
        if typename(item) == "list" {
            for node in item {
                if node == none {
                    continue
                }
                const supply_parent =
                    (if parent_chain (prev_parent + [node]) else (node))
                for expr in node.subexprs {
                    if expr == none {
                        continue
                    }
                    visit_queue.add(new VisitQueueEntry(
                        expr, supply_parent
                    ))
                }
                for block in node.subblocks {
                    for expr in block {
                        if expr == none {
                            continue
                        }
                        visit_queue.add(new VisitQueueEntry(
                            expr, supply_parent
                        ))
                    }
                }
            }
            return
        }
        const supply_parent =
            if parent_chain (prev_parent + [item]) else (item)
        if has_attr(item, "subexprs") {
            for expr in item.subexprs {
                if expr == none {
                    continue
                }
                visit_queue.add(new VisitQueueEntry(
                    expr, supply_parent
                ))
            }
        }
        if has_attr(item, "subblocks") {
            for block in item.subblocks {
                for st in block {
                    visit_queue.add(new VisitQueueEntry(
                        st, supply_parent
                    ))
                }
            }
        }
    }

    func process_next_node {
        if visit_queue.len == 0 {
            return later no
        }
        var next = visit_queue.pop_at(1)
        if not has_attr(next.node, "kind") and
                has_attr(next.node, "stmts") {
            # Must be a root ASTResult item. Skip, but queue children:
            if next.node != none and has_attr(next.node, "stmts") {
                const supply_parent = if parent_chain ([]) else (none)
                for st in next.node.stmts {
                    visit_queue.add(new VisitQueueEntry(
                        st, supply_parent
                    ))
                }
            }
            return later yes
        }
        if is_first {
            is_first = no
        } elseif not pass_func_boundaries and
                next.node.kind == ast.N_STMT_FUNC {
            return later yes
        }
        var new_node = visit_cb(next.node, next.parent)
        later:

        await new_node
        if new_node == no {
            aborted = yes
            return later no
        }
        if new_node != next.node {
            assert(typename(parent_chain) == "bool")
            var parent = if parent_chain
                (next.parent[next.parent.len]) else (next.parent)
            if has_attr(parent, "subexprs") {
                var pos = 1
                while pos <= parent.subexprs.len {
                    if parent.subexprs[pos] != next.node {
                        pos += 1
                        continue
                    }
                    if new_node == none {
                        parent.subexprs.pop_at(pos)
                        break
                    }
                    if typename(new_node) != "list" {
                        parent.subexprs[pos] = new_node
                        break
                    }
                    parent.stmts =
                        parent.subexprs.sub(1, pos - 1) +
                        new_node + parent.subexprs.sub(pos + 1)
                    break
                }
            }
            if has_attr(parent, "stmts") {
                var pos = 1
                while pos <= parent.stmts.len {
                    if parent.stmts[pos] != next.node {
                        pos += 1
                        continue
                    }
                    if new_node == none {
                        parent.stmts.pop_at(pos)
                        break
                    }
                    if typename(new_node) != "list" {
                        parent.stmts[pos] = new_node
                        break
                    }
                    parent.stmts =
                        parent.stmts.sub(1, pos - 1) +
                        new_node + parent.stmts.sub(pos + 1)
                    break
                }
            }
            if has_attr(parent, "subblocks") {
                var blockpos = 1
                while blockpos <= parent.subblocks.len {
                    var block = parent.subblocks[blockpos]
                    var pos = 1
                    while pos <= block.len {
                        if block[pos] != next.node {
                            pos += 1
                            continue
                        }
                        if new_node == none {
                            block.pop_at(pos)
                            break
                        }
                        if typename(new_node) != "list" {
                            block[pos] = new_node
                            break
                        }
                        var new_block = block.sub(1, pos - 1) +
                            new_node + block.sub(pos + 1)
                        parent.subblocks[blockpos] = new_block
                        break
                    }
                    blockpos += 1
                }
            }
            if next.node == root_to_return {
                root_to_return = new_node
            }
        }
        if new_node == none {
            return later yes
        }
        # Handle queueing up the newly inserted node(s) children:
        if not backward {
            queue_children_of_item(new_node, next.parent)
        }
        return later yes
    }
    var resume_queue = process_next_node() later:

    await resume_queue
    if not resume_queue {
        if aborted {
            return later no
        }
        if return_new_root {
            return root_to_return
        }
        return later yes
    }
    resume_queue = process_next_node() later repeat
}

func do_simply_on_all_exprs(stmt, callback) {
    var queue = []
    for expr in stmt.subexprs {
        queue.add([[stmt], expr])
    }
    while queue.len > 0 {
        var entry = queue.pop()
        var parents = entry[1]
        var parent = parents[1]
        var expr = entry[2]
        var result_expr = none
        if expr != none {
            result_expr = callback(expr, parents)
        }
        if result_expr != expr {
            var i = 1
            while i <= parent.subexprs.len {
                if parent.subexprs[i] == expr {
                    if result_expr == none {
                        parent.subexprs.pop(i)
                    } else {
                        parent.subexprs[i] = result_expr
                    }
                    break
                }
                i += 1
            }
        }
        if result_expr != none and
                result_expr.subexprs.len > 0 {
            var new_parents = parents + [result_expr]
            for subexpr in result_expr.subexprs {
                queue.add([new_parents, subexpr])
            }
        }
    }
}

func do_all_pre_nameres_transformations(
        project, msgs, build_options=none
        ) {
    if build_options != none and build_options.print_stages {
        print(build_options.build_program_name +
            ": info: stage checked-ast: "
            "Doing required pre name resolution transforms... "
            "[t=" + time.ticks().as_str() + "]")
    }
    if msgs != none and
            msg.msgs_contain_error(msgs) {
        return later no
    }

    func do_m64_transforms_if_needed {
        if build_options == none or
                not build_options.is_moose64 {
            return later yes
        }

        func process_file(pfile) {
            var result = m64_ast_transform.
                do_moose64_transforms_pre_nameresolution(
                    pfile, msgs)
            later:

            await result
            return later result
        }
        var result = project.do_for_all_files(process_file)
        later:

        await result
        assert(result == yes or result == no)
        return result
    }

    var success = do_m64_transforms_if_needed()
    later:

    await success
    if not success or (msgs != none and
            msg.msgs_contain_error(msgs)) {
        return later no
    }

    if build_options != none and build_options.print_stages {
        print(build_options.build_program_name +
            ": info: stage checked-ast: "
            "Finished pre name resolution transforms."
            "[t=" + time.ticks().as_str() + "]")
    }
    return later success
}

### This transformation will do some basic
### verification that the amount of arguments matches the
### ones of the target function signatures where known, and if
### applicable transform calls to the necessary func overrides.
func transform_func_overrides_and_check_func_arg_sig_match(
        project_file, project_ast, msgs,
        is_moose64=no, debug=no
        ) {
    var dbg_prefix =
        if is_moose64 ("moosec: debug: ") else ("horsec: debug: ") +
        "transform_func_overrides_and_check_func_arg_sig_match():"
    if debug {
        print(dbg_prefix + " Looking at file: " +
            project_file.as_str())
    }

    var had_error = no
    func do_transform_step(node, parents) {
        var parent = if parents.len > 0
            (parents[parents.len]) else (none)
        if node.damaged {
            return node
        }
        if node.kind != ast.N_EXPR_BINOP or
                node.optoken.str != "(" or
                node.subexprs.len < 2 or
                not {ast.N_EXPR_BINOP, ast.N_EXPR_IDREF}.has(
                    node.subexprs[1].kind
                ) or
                (node.subexprs[1].kind == ast.N_EXPR_BINOP and
                 (node.subexprs[1].optoken.str != "." or
                  node.subexprs[1].subexprs.len < 2 or
                  node.subexprs[1].subexprs[2].kind !=
                      ast.N_EXPR_IDREF
                 )) {
             return later node
        }
        var called_ref = none
        var called_node = none
        var called_node_parents = none
        var called_args_node = none
        var called_lbl_name = none
        var is_func_attr_call = no
        if node.subexprs[1].kind == ast.N_EXPR_IDREF {
            called_ref = node.subexprs[1].ref
            called_lbl_name = node.subexprs[1].label
            called_node = node.subexprs[1]
            called_args_node = node.subexprs[2]
            called_node_parents = parents + [node]
            assert(typename(called_ref) != "list")
        } else {
            assert(node.subexprs[1].kind == ast.N_EXPR_BINOP and
                node.subexprs[1].optoken.str == "." and
                node.subexprs[1].subexprs[2].
                    kind == ast.N_EXPR_IDREF)
            called_ref = node.subexprs[1].subexprs[2].ref
            called_lbl_name = node.subexprs[1].subexprs[2].label
            called_node = node.subexprs[1]
            called_args_node = node.subexprs[2]
            called_node_parents = parents + [node]
            assert(typename(called_ref) != "list")
        }

        assert(called_args_node.kind == ast.N_EXPR_CALLARGS)
        if not is_moose64 and (called_ref == none or
                {st_ref.ST_LOCAL, st_ref.ST_ARG}.has(
                    called_ref.kind
                )) {
            # We're likely calling some dynamic variable with
            # completely unknown type, which is possible in Horse64.
            # It's not worth trying to figure out what we're calling.
            return later node
        }
        if debug {
            print(dbg_prefix + " Looking at call for potential "
                "func overrides: "
                "called_lbl_name=" + textfmt.
                    as_escaped_code_string(called_lbl_name) + " "
                "node=" + node.as_str() + " "
                "called_node=" + called_node.as_str() + " "
                "called_ref=" + called_ref.as_str() + " "
                "is_func_attr_call=" + is_func_attr_call.as_str())
        }

        if called_ref == none or
                {st_ref.ST_CCAPTURE}.has(called_ref.kind) {
            print(if is_moose64 ("moosec") else ("horsec") + ": "
                "error: Internal error, failed to resolve a "
                "call or found it to be to an impossible "
                "value type. Please report this error to "
                "the compiler makers. Details: "
                "called_ref=" + called_ref.as_str() + " "
                "node=" + node.as_str())
            throw new RuntimeError("Internal error, "
                "failed to resolve call in valid manner.")
        }

        var func_is_external = no
        var func_type_expr = none
        var detected_called_func_ref = none
        var detected_called_func_name = none
        var detected_called_func_type_name = none
        var detected_called_func_module_import_name = none
        var could_be_override = no
        func resolve_func_type_expr_if_needed {
            if not is_moose64 {
                # for now, don't even try for Horse64.
                return later
            }
            if debug {
                print(dbg_prefix + " "
                    "resolve_func_type_expr_if_needed(): "
                    "Resolving to func expr...")
            }
            # XXX: This call here does the actual override:
            var func_type_expr_result = ast_typeref.
                resolve_st_ref_to_type_ref_and_expr(
                    project_file, called_ref, node=called_node,
                    node_parents=called_node_parents,
                    apply_func_override_for_args_node=
                        called_args_node,
                    msgs=msgs,
                    is_moose64=is_moose64,
                    debug=debug,
                ) later:

            await func_type_expr_result
            func_is_external =
                func_type_expr_result.storage_ref != none and
                {st_ref.ST_MCREF, st_ref.ST_CEXT}.has(
                    func_type_expr_result.storage_ref.kind
                )
            func_type_expr = func_type_expr_result.type_expr
            if func_type_expr_result.storage_ref != none {
                detected_called_func_name =
                    st_ref.ref_to_item_name(
                        project_file,
                        func_type_expr_result.storage_ref
                    )
                if func_type_expr_result.storage_ref.kind ==
                        st_ref.ST_GLOBALATTR {
                    var entry = st_scope.global_id_to_item(
                        project_file.project,
                        func_type_expr_result.storage_ref.id[1]
                        )
                    assert(entry != none)
                    var anscope = entry.attr_names_scope
                    detected_called_func_type_name =
                        anscope.label
                }
                var import_stmt = none
                if func_type_expr_result.storage_ref.kind !=
                        st_ref.ST_MCREF {
                    import_stmt = st_ref.
                        ref_to_corresponding_import_stmt_node(
                            project_file,
                            func_type_expr_result.storage_ref
                        )
                }
                if import_stmt != none {
                    if import_stmt.renamed_as != none {
                        detected_called_func_module_import_name =
                            import_stmt.renamed_as
                    } elseif import_stmt.kind == ast.N_STMT_IMPORT {
                        detected_called_func_module_import_name =
                            import_stmt.module_path.join(".")
                    }
                }
            }
            if func_type_expr_result.resolved_func_is_override {
                node.clear_precomputed_typeref()
                if detected_called_func_type_name != none and
                        func_type_expr_result.has_self_expr {
                    # This is a func attr, called on a self expr.
                    assert({st_ref.ST_GLOBALATTR}.has(
                        func_type_expr_result.storage_ref.kind
                    ))
                    assert(node.subexprs[1].kind == ast.N_EXPR_BINOP)
                    var name_access = node.subexprs[1].subexprs[2]
                    assert(name_access.kind == ast.N_EXPR_IDREF and
                        name_access.label == called_lbl_name)
                    name_access.ref =
                        func_type_expr_result.storage_ref.copy()
                    name_access.label = detected_called_func_name
                } else {
                    var new_idref = new ast_expr.IdRefExpr()
                    node.subexprs[1] = new_idref
                    new_idref.scope = node.scope
                    new_idref.line = node.line
                    new_idref.col = node.col
                    new_idref.ref = func_type_expr_result.storage_ref.copy()
                    new_idref.label = detected_called_func_name
                    if detected_called_func_module_import_name != none and
                            detected_called_func_module_import_name != "" {
                        new_idref.type_path =
                            detected_called_func_module_import_name.split(".")
                    }
                    if detected_called_func_type_name != none {
                        if new_idref.type_path == none {
                            new_idref.type_path = []
                        }
                        new_idref.type_path.add(
                            detected_called_func_type_name
                        )
                    }
                }
            }

            if debug {
                print(dbg_prefix + " " +
                    "resolve_func_type_expr_if_needed(): "
                    "Result: func_is_external=" +
                        func_is_external.as_str() + " "
                    "func_type_expr_result=" +
                        func_type_expr_result.as_str() + " "
                    "called_node=" + called_node.as_str() + " "
                    "called_ref=" + called_ref.as_str() + " "
                    "detected_called_func_module_import_name=" +
                        detected_called_func_module_import_name.as_str() + " "
                    "detected_called_func_type_name=" +
                        detected_called_func_type_name.as_str() + " "
                    "detected_called_func_name=" +
                        detected_called_func_name.as_str()
                )
            }
        }
        resolve_func_type_expr_if_needed()
        later:

        if func_is_external and (not is_moose64 or
                yes) {  # FIXME, Change once we can resolve this.
            return later node
        }
        # For Moose64, we require that non-external funcs fully resolve:
        if is_moose64 and
                func_type_expr == none and
                not func_is_external {
            var user_was_informed_of_broken_node = no
            if msgs != none and (node.damaged or
                    called_node.damaged) {
                for m in msgs {
                    if m.kind == msg.M_ERROR {
                        user_was_informed_of_broken_node = yes
                        break
                    }
                }
            }
            if user_was_informed_of_broken_node {
                called_node.damaged = yes
                node.damaged = yes
                if debug {
                    print(dbg_prefix + " The call appears to be "
                        "faulty, node.damaged is set. Bail out.")
                }
                had_error = yes
                return later node
            }
            # If we arrive here, this isn't a properly handled
            # error situation and something went very wrong:
            print(if is_moose64 ("moosec") else ("horsec") + ": "
                "error: Internal error, failed to obtain a "
                "func type expr when we expected to get one. "
                "Please report this error to "
                "the compiler makers. Details: "
                "called_ref=" + called_ref.as_str() + " "
                "called_node=" + called_node.as_str() + " "
                "node=" + node.as_str() + " "
                "node.damaged=" + node.damaged.as_str() + " "
                "msgs=" + if msgs != none(msgs.as_str())
                    else ("none") + ")")
            throw new RuntimeError("Internal error, "
                "failed to obtain a valid func type expr.")
        }
        if debug {
            print(dbg_prefix + " func_type_expr=" +
                func_type_expr.as_str())
            print(dbg_prefix + " called_ref=" +
                called_ref.as_str())
        }

        return later node
    }
    var result = visit_ast_tree(
        project_ast, do_transform_step,
        pass_func_boundaries=yes,
        parent_chain=yes, backward=no
    ) later:

    await result
    if not result or had_error {
        return later no
    }
    return later yes
}

func do_all_post_nameres_transformations(
        project, msgs, build_options=none) {
    if build_options != none and build_options.print_stages {
        print(build_options.build_program_name +
            ": info: stage transformed-code: "
            "Entering checks and analysis... "
            "[t=" + time.ticks().as_str() + "]")
    }
    if msgs != none and
            msg.msgs_contain_error(msgs) {
        return later no
    }

    var is_moose64 = (build_options != none and
        build_options.is_moose64)
    var success = ast_analyze.do_advanced_check_and_analysis(
        project, msgs) later:

    await success
    if not success or (msgs != none and
            msg.msgs_contain_error(msgs)) {
        return later no
    }
    func do_m64_transforms_if_needed {
        if not is_moose64 {
            return later yes
        }
        if build_options != none and
                build_options.print_stages {
            print(build_options.build_program_name +
                ": info: stage transformed-code: "
                "Entering moose64-specific transform... "
                "[t=" + time.ticks().as_str() + "]")
        }

        func process_file(pfile) {
            var result = m64_ast_transform.
                do_moose64_transforms_post_nameresolution(
                    pfile, msgs)
            later:

            await result
            return later result
        }
        var result = project.do_for_all_files(process_file)
        later:

        await result
        assert(result == yes or result == no)
        return result
    }
    success = do_m64_transforms_if_needed()
    later:

    await success
    if not success or (msgs != none and
            msg.msgs_contain_error(msgs)) {
        return later no
    }
    var had_error = no
    func do_func_call_check_and_overrides {
        func process_file(pfile) {
            var result =
                transform_func_overrides_and_check_func_arg_sig_match(
                    pfile, pfile.ast, msgs, is_moose64=is_moose64)
            later:

            await result
            if not result {
                had_error = yes
            }
            # Even if we had an error, process all files:
            return later yes
        }
        var result = project.do_for_all_files(process_file)
        later:

        await result
        assert(result == yes or result == no)
        return (result and not had_error)
    }
    success = do_func_call_check_and_overrides()
    later:

    await success
    if not success or (msgs != none and
            msg.msgs_contain_error(msgs)) {
        return later no
    }
    func do_later_transform_if_needed {
        if is_moose64 {
            return later yes
        }
        if build_options != none and build_options.print_stages {
            print(build_options.build_program_name +
                ": info: stage transformed-code: "
                "Entering later transform... "
                "[t=" + time.ticks().as_str() + "]")
        }
        success = later_transform.first_pass_later_transform(
            project, msgs, build_options=build_options
        )
        later:

        await success

        return success
    }
    success = do_later_transform_if_needed()
    later:

    await success
    if not success or (msgs != none and
            msg.msgs_contain_error(msgs)) {
        return later no
    }

    success = compiler.globals_order.
        register_globals_for_project(
            project, msgs=msgs, is_moose64=is_moose64
        ) later:

    await success
    if not success or (msgs != none and
            msg.msgs_contain_error(msgs)) {
        return later no
    }
    if build_options != none and build_options.print_stages {
        print(build_options.build_program_name +
            ": info: stage transformed-code: "
            "All analysis and transformations done."
            "[t=" + time.ticks().as_str() + "]")
    }
    return later success
}

func transform_typeref_inline_constructor(
        project_file, project_ast, msgs,
        call_expr_to_failed_check_map=none,
        failed_check_to_call_expr_map=none,
        parent_stmt_to_call_exprs_map=none,
        is_moose64=no
        ) {
    func do_transform_step(node, parent) {
        if node.kind != ast.N_STMT_VAR or
                not node.has_type_expr {
            return later node
        }
        assert(node.scope == none)
        assert(node.symbol_info == none or
            node.symbol_info.len == 0)
        assert(node.subexprs.len >= 1)
        var type_expr = node.subexprs[node.subexprs.len]
        if not node.is_empty or not type_expr.has_init_expr {
            return later node
        }
        var init_expr = type_expr.subexprs[1]
        var parent_block = ast.get_node_parent_block(
            node, parent
        )
        if parent_block == none {
            throw new RuntimeError("Internal error, failed to "
                "obtain parent block of node. Please report "
                "this error to the compiler makers.")
        }

        var result = []
        for lbl in node.var_labels {
            var call_stmt = new call_or_assign_stmt.CallStmt()
            var idref_expr = new ast_expr.IdRefExpr()
            idref_expr.label = lbl
            idref_expr.line = node.line
            idref_expr.col = node.col
            var idref_expr2 = new ast_expr.IdRefExpr()
            idref_expr2.label = "init"
            idref_expr2.line = node.line
            idref_expr2.col = node.col
            var optoken1 = new token.Token(
                ".", token.T_DOT, node.line, node.col
            )
            var attr_op = new ast_expr.BinopExpr(optoken1)
            attr_op.line = node.line
            attr_op.col = node.col
            attr_op.subexprs = [idref_expr, idref_expr2]
            assert(init_expr.kind == ast.N_EXPR_CALLARGS)
            var optoken2 = new token.Token(
                '(', token.T_ENCLOSE, node.line, node.col
            )
            var call_expr = new ast_expr.BinopExpr(optoken2)
            call_expr.line = node.line
            call_expr.col = node.col
            call_expr.subexprs = [attr_op, init_expr.copy()]
            call_stmt.subexprs = [call_expr]
            result.add(call_stmt)
            if call_expr_to_failed_check_map != none and
                    call_expr_to_failed_check_map.has(node) {
                var check = call_expr_to_failed_check_map[node]
                call_expr_to_failed_check_map.del(node)
                assert(failed_check_to_call_expr_map.has(check))
                assert(parent_stmt_to_call_exprs_map.has(node))
                parent_stmt_to_call_exprs_map.del(node)
                failed_check_to_call_expr_map[check] = (
                    call_expr
                )
                parent_stmt_to_call_exprs_map[call_stmt] = [
                    call_expr
                ]
                check.check_expr = attr_op.copy()
            }
        }
        type_expr.subexprs = []
        type_expr.has_init_expr = no
        return later [node] + result
    }
    var result = visit_ast_tree(
        project_ast, do_transform_step, pass_func_boundaries=yes,
        parent_chain=no, backward=no, subtree_parent=none,
        return_new_root=no
    ) later:

    await result
    return result
}

