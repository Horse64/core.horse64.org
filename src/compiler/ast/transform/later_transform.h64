## @module compiler.ast.transform.later_transform
# Copyright (c) 2023-2025, ellie/@ell1e & Horse64's contributors
# (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import debugger from core.horse64.org
import random from core.horse64.org
import time from core.horse64.org

import compiler.ast as ast
import compiler.ast.analyze as ast_analyze
import compiler.ast.await_stmt as await_stmt
import compiler.ast.builder as ast_builder
import compiler.ast.call_or_assign_stmt as call_or_assign_stmt
import compiler.ast.do_stmt as do_stmt
import compiler.ast.expr as ast_expr
import compiler.ast.func_stmt as func_stmt
import compiler.ast.return_stmt as return_stmt
import compiler.ast.throw_stmt as throw_stmt
import compiler.ast.transform as ast_transform
import compiler.ast.type_stmt as type_stmt
import compiler.ast.var_stmt as var_stmt
import compiler.cext as cext
import compiler.msg as msg
import compiler.storage.ref as st_ref
import compiler.storage.scope as st_scope
import compiler.token as token

extend type await_stmt.AwaitStmt {
    var _owning_later_call_closure_name
    var _owning_later_call_param_indexes
}

extend type do_stmt.DoStmt {
    var _is_later_processed_do = no
}

type LaterExitInfo {
    var exit_cb_label
    var exit_cb_storage_ref
}

extend type st_scope.FuncScope {
    var later_transform_info
}

func st_scope.FuncScope.get_later_transform_info {
    return self.later_transform_info
}

type LaterTransformInfo {
    var _exit_info
    var owning_local_scope
}

func LaterTransformInfo.exit_info {
    var limit_to_fscope = none
    if self.owning_local_scope != none {
        limit_to_fscope = self.owning_local_scope.func_scope
    }
    var check_info = self
    while check_info._exit_info == none and
            check_info.owning_local_scope != none {
        assert(limit_to_fscope != none)
        var scope = check_info.owning_local_scope
        while scope.parent != none {
            scope = scope.parent
            if scope == none or scope.func_scope !=
                    limit_to_fscope {
                if limit_to_fscope.later_transform_info != none {
                    return limit_to_fscope.later_transform_info._exit_info
                }
                return none
            }
            if scope.later_transform_info != none and
                    scope.later_transform_info._exit_info != none {
                return scope.later_transform_info._exit_info
            }
        }
        if limit_to_fscope.later_transform_info != none {
            return limit_to_fscope.later_transform_info._exit_info
        }
        return none
    }
    return check_info._exit_info
}

extend type st_scope.LocalScope {
    var later_transform_info
}

func st_scope.LocalScope.get_later_transform_info {
    if self.later_transform_info == none {
        self.later_transform_info =
            new LaterTransformInfo()
        self.later_transform_info.owning_local_scope = self
    }
    return self.later_transform_info
}

func get_later_assigned_value_info(stmt) {
    var async_return_value_storage_refs = []
    var async_return_value_labels = []
    if stmt.kind == ast.N_STMT_VAR {
        if (typename(stmt.symbol_info) != "list") {
            print("horsec: error: CRITICAL ERROR IN "
                "src/compiler/ast/transform/"
                "later_transform.h64: "
                "Encountered var statement without "
                "symbol info, which shouldn't be possible "
                "at this stage: " +
                stmt.as_str())
            throw new RuntimeError(
                "Internal error: Encountered N_STMT_VAR "
                "with incomplete symbol info, this is invalid. "
                "Please report this bug to the compiler "
                "team."
            )
        }
        var index = 0
        for sinfo in stmt.symbol_info {
            index += 1
            async_return_value_storage_refs.add(
                new st_ref.StorageRef(
                    st_ref.ST_LOCAL, sinfo.storage_id
                )
            )
            assert(index >= 1 and index <= stmt.var_labels.len)
            async_return_value_labels.add(
                stmt.var_labels[index]
            )
        }
    } else {
        assert(stmt.kind == ast.N_STMT_ASSIGN)
        var pairs_count = stmt.subexprs.len / 2
        assert(pairs_count >= 1)
        var i = 1
        while i <= pairs_count {
            if stmt.subexprs[i].ref == none {
                print("horsec: error: CRITICAL ERROR IN "
                    "src/compiler/ast/transform/"
                    "later_transform.h64: "
                    "Encountered assignment target without "
                    "ref info, which shouldn't be possible "
                    "at this stage: " +
                    [stmt, stmt.subexprs[i]].as_str())
                throw new RuntimeError(
                    "Internal error: Encountered N_STMT_ASSIGN "
                    "with incomplete storage ref, this is invalid. "
                    "Please report this bug to the compiler "
                    "team."
                )
            }
            async_return_value_storage_refs.add(
                stmt.subexprs[i].ref
            )
            async_return_value_labels.add(
                stmt.subexprs[i].label
            )
            i += 1
        }
    }
    return [
        async_return_value_labels,
        async_return_value_storage_refs
    ]
}

func find_repeat_for_later_call_stmt(
        call_stmt, parents, msgs=none,
        project_file=none
        ) {
    assert({ast.N_STMT_ASSIGN,
        ast.N_STMT_VAR}.has(call_stmt.kind))
    var debug = no
    if debug {
        print("find_repeat_for_later_call_stmt(): Finding " +
            "later repeat for: " + call_stmt.as_str())
    }
    var _result = get_later_assigned_value_info(call_stmt)
    var async_return_value_storage_refs = _result[2]
    var async_return_value_labels = _result[1]

    var block = none
    if parents.len > 0 {
        block = ast.get_node_parent_block(
            call_stmt, parents[parents.len]
        )
    }
    if block == none {
        throw new RuntimeError("Internal error: "
            "Can't find parent block of later call, "
            "unexpectedly malformed AST?!")
    }
    var idx = block.find(call_stmt)
    assert(idx != none)
    idx += 1
    func find_matching_repeat_in_subblock(
            call_stmt, block, start_idx=1,
            msgs=none,
            project_file=none,
            is_invalid_if_found=no,
            is_invalid_block_name="<unspecified>",
            debug=no
            ) {
        if debug {
            var block_str = block.as_str()
            if block_str.len > 300 {
                block_str = block_str.sub(1, 150) + "..." +
                    block_str.sub(block_str.len - 150)
            }
            print("find_repeat_for_later_call_stmt(): " +
                "Searching in block: " + block_str)
        }
        var idx = start_idx
        while idx <= block.len {
            var node = block[idx]
            if debug {
                print("find_repeat_for_later_call_stmt(): " +
                    "Examining block[" + idx.as_str() +
                    "]: " + node.as_str())
            }
            if node.kind == ast.N_STMT_FUNC {
                idx += 1
                continue
            }
            if node.kind == ast.N_STMT_IF {
                for clause in node.subexprs {
                    for subblock in clause.subblocks {
                        var inner_repeats =
                            find_matching_repeat_in_subblock(
                                call_stmt, subblock, msgs=msgs,
                                project_file=project_file,
                                is_invalid_if_found=yes,
                                is_invalid_block_name="if",
                                debug=debug,
                            )
                        if inner_repeats == none {
                            return [none, no]
                        }
                        assert(inner_repeats[1] == none)
                    }
                }
                idx += 1
                continue
            }
            if {ast.N_STMT_VAR, ast.N_STMT_ASSIGN}.has(
                    node.kind) and
                    node.has_later and
                    not node.has_later_ignore and
                    node.has_later_repeat {
                var repeat_matches_us = no
                var _result = get_later_assigned_value_info(call_stmt)
                var repeat_assigned_refs = _result[2]
                var repeat_assigned_names = _result[1]
                assert(repeat_assigned_refs.len > 0)

                repeat_matches_us = yes
                var idx2 = 0
                for var_ref in repeat_assigned_refs {
                    idx2 += 1
                    if idx > async_return_value_storage_refs.len or
                            var_ref.alike(
                                async_return_value_storage_refs[idx2]
                            ) {
                        repeat_matches_us = no
                        break
                    }
                }
                if repeat_assigned_refs.len <
                        async_return_value_storage_refs.len {
                    repeat_matches_us = no
                }
                if not repeat_matches_us {
                    idx += 1
                    continue
                }
                if debug {
                    print("find_repeat_for_later_call_stmt(): " +
                        "Collected this repeat.")
                }
                if is_invalid_if_found {
                    if debug {
                        print(
                            "find_repeat_for_later_call_stmt(): " +
                            "Oops, but is_invalid_if_found=" +
                            is_invalid_if_found.as_str() + "!"
                        )
                    }
                    if msgs != none {
                        if not call_stmt.damaged {
                            msgs.add(new msg.FileMsg(
                                "Unexpected misplaced later repeat, "
                                "can't be nested inside a " +
                                is_invalid_block_name +
                                    if is_invalid_block_name.len > 0
                                        (" ") else ("") +
                                "code block when the corresponding "
                                "preceding later call "
                                "in line " + call_stmt.line.as_str() +
                                ", column " +
                                call_stmt.col.as_str() + " "
                                "isn't also part of this code block.",
                                source_file=project_file,
                                line=node.line,
                                col=node.col,
                            ))
                        }
                        call_stmt.damaged = yes
                    } else {
                        throw new ValueError(
                            "Repeat doesn't match previous later call."
                        )
                    }
                    return [none, no]
                }
                if debug {
                    print("find_repeat_for_later_call_stmt(): " +
                        "Collected this repeat=" + node.as_str())
                }
                return [node, yes]
            }
            for subblock in node.subblocks {
                var inner_result = find_matching_repeat_in_subblock(
                    call_stmt, subblock, msgs=msgs,
                    project_file=project_file,
                    is_invalid_if_found=yes,
                    debug=debug,
                )
                if not inner_result[2] {
                    return [none, no]
                }
                if inner_result[1] != none {
                    return [inner_result[1], yes]
                }
            }
            if node.kind == ast.N_STMT_DO {
                for clause in node.subexprs {
                    for subblock in clause.subblocks {
                        var inner_result =
                            find_matching_repeat_in_subblock(
                                call_stmt, subblock, msgs=msgs,
                                project_file=project_file,
                                is_invalid_if_found=yes,
                                is_invalid_block_name=
                                    if clause.kind ==
                                            ast.N_EXPR_RESCUECLAUSE
                                        ("rescue") else ("finally"),
                                debug=debug,
                            )
                        if inner_result == none {
                            return [none, no]
                        }
                        assert(inner_result[1] == none)
                    }
                }
            }
            idx += 1
        }
        if debug {
            var block_str = block.as_str()
            if block_str.len > 300 {
                block_str = block_str.sub(1, 150) + "..." +
                    block_str.sub(block_str.len - 150)
            }
            print("find_repeat_for_later_call_stmt(): " +
                "Done searching in block with no match: " +
                block_str)
        }
        return [none, yes]
    }
    var repeat_result = find_matching_repeat_in_subblock(
        call_stmt, block, start_idx=idx,
        msgs=msgs,
        project_file=project_file,
        debug=debug,
    )
    if repeat_result == none {
        return none
    }
    return repeat_result[1]
}

func find_await_after_later_call_stmt(
        call_stmt, parents, msgs=none,
        project_file=none
        ) {
    assert({ast.N_STMT_ASSIGN,
        ast.N_STMT_VAR}.has(call_stmt.kind))
    var debug = no
    if debug {
        print("find_await_after_later_call_stmt(): Finding " +
            "await for: " + call_stmt.as_str())
    }
    var _result = get_later_assigned_value_info(call_stmt)
    var async_return_value_storage_refs = _result[2]
    var async_return_value_labels = _result[1]

    var block = none
    if parents.len > 0 {
        block = ast.get_node_parent_block(
            call_stmt, parents[parents.len]
        )
    }
    if block == none {
        throw new RuntimeError("Internal error: "
            "Can't find parent block of later call, "
            "unexpectedly malformed AST?!")
    }
    var idx = block.find(call_stmt)
    assert(idx != none)
    idx += 1
    func find_awaits_in_subblock(
            call_stmt, block, start_idx=1,
            msgs=none,
            had_previous_awaits=no,
            project_file=none,
            is_invalid_if_found=no,
            is_invalid_block_name="<unspecified>",
            debug=no
            ) {
        if debug {
            print("find_await_after_later_call_stmt(): " +
                "Searching in block: " + block.as_str())
        }
        var awaits = []
        var idx = start_idx
        while idx <= block.len {
            var node = block[idx]
            if debug {
                print("find_await_after_later_call_stmt(): " +
                    "Examining block[" + idx.as_str() +
                    "]: " + node.as_str())
            }
            if node.kind == ast.N_STMT_FUNC {
                idx += 1
                continue
            }
            if {ast.N_STMT_CALL, ast.N_STMT_ASSIGN,
                    ast.N_STMT_VAR}.has(node.kind) and
                    node.has_later and
                    not node.has_later_ignore {
                if awaits.len > 0 or
                        had_previous_awaits {
                    # Bail here, further valid awaits can't be past
                    # another later call like this.
                    return [awaits, no]
                }
                if msgs != none {
                    if not call_stmt.damaged {
                        msgs.add(new msg.FileMsg(
                            "Unexpected later call, expected "
                            "await statement here for previous "
                            "later call "
                            "in line " + call_stmt.line.as_str() +
                            ", column " + call_stmt.col.as_str() +
                            ".",
                            source_file=project_file,
                            line=node.line,
                            col=node.col,
                        ))
                    }
                    call_stmt.damaged = yes
                } else {
                    throw new ValueError(
                        "Later call after other "
                        "later call before await."
                    )
                }
                return none
            }
            if node.kind == ast.N_STMT_IF {
                for clause in node.subexprs {
                    for subblock in clause.subblocks {
                        var inner_awaits = find_awaits_in_subblock(
                            call_stmt, subblock, msgs=msgs,
                            project_file=project_file,
                            had_previous_awaits=had_previous_awaits,
                            is_invalid_if_found=yes,
                            is_invalid_block_name="if",
                            debug=debug,
                        )
                        if inner_awaits == none {
                            return none
                        }
                        assert(inner_awaits[1].len == 0)
                    }
                }
                idx += 1
                continue
            }
            if node.kind == ast.N_STMT_FOR or
                    node.kind == ast.N_STMT_WHILE {
                for subblock in node.subblocks {
                    var inner_awaits = find_awaits_in_subblock(
                        call_stmt, subblock, msgs=msgs,
                        project_file=project_file,
                        had_previous_awaits=had_previous_awaits,
                        is_invalid_if_found=yes,
                        is_invalid_block_name=
                            if node.kind == ast.N_STMT_FOR
                                ("for") else ("while"),
                        debug=debug,
                    )
                    if inner_awaits == none {
                        return none
                    }
                    assert(inner_awaits[1].len == 0)
                }
                idx += 1
                continue
            }
            if node.kind == ast.N_STMT_AWAIT {
                var match_indexes = []
                var await_matches_us = no
                var index = 0
                for subexpr in node.subexprs {
                    assert(subexpr.kind == ast.N_EXPR_IDREF)
                    if subexpr.ref == none {
                        continue
                    }
                    index = 0
                    for known_ref in
                            async_return_value_storage_refs {
                        index += 1
                        if known_ref.alike(subexpr.ref) {
                            await_matches_us = yes
                            match_indexes.add(index)
                        }
                    }
                }
                if not await_matches_us {
                    if msgs != none {
                        if not call_stmt.damaged {
                            msgs.add(new msg.FileMsg(
                                "Unexpected mismatched await, the "
                                "arguments don't match any of the "
                                "assigned values of the corresponding "
                                "preceding "
                                "later call "
                                "in line " + call_stmt.line.as_str() +
                                ", column " + call_stmt.col.as_str() +
                                ".",
                                source_file=project_file,
                                line=node.line,
                                col=node.col,
                            ))
                        }
                        call_stmt.damaged = yes
                    } else {
                        throw new ValueError(
                            "Await doesn't match previous later call."
                        )
                    }
                    return none
                }
                if not is_invalid_if_found and
                        match_indexes.len < node.subexprs.len {
                    if msgs != none {
                        if not call_stmt.damaged {
                            msgs.add(new msg.FileMsg(
                                "Unexpected await arguments, some "
                                "don't map to arguments of the "
                                "corresponding preceding later call "
                                "in line " + call_stmt.line.as_str() +
                                ", column " +
                                call_stmt.col.as_str() + ".",
                                source_file=project_file,
                                line=node.line,
                                col=node.col,
                            ))
                        }
                        call_stmt.damaged = yes
                    } else {
                        throw new ValueError(
                            "Await arguments don't match "
                            "previous later call."
                        )
                    }
                }
                if debug {
                    print("find_await_after_later_call_stmt(): " +
                        "Collected this await.")
                }
                if is_invalid_if_found {
                    if debug {
                        print(
                            "find_await_after_later_call_stmt(): " +
                            "Oops, but is_invalid_if_found=" +
                            is_invalid_if_found.as_str() + "!"
                        )
                    }
                    if msgs != none {
                        if not call_stmt.damaged {
                            msgs.add(new msg.FileMsg(
                                "Unexpected misplaced await, can't "
                                "be nested inside " +
                                is_invalid_block_name + " "
                                "code block when the corresponding "
                                "preceding later call "
                                "in line " + call_stmt.line.as_str() +
                                ", column " +
                                call_stmt.col.as_str() + " "
                                "isn't also part of this code block.",
                                source_file=project_file,
                                line=node.line,
                                col=node.col,
                            ))
                        }
                        call_stmt.damaged = yes
                    } else {
                        throw new ValueError(
                            "Await doesn't match previous later call."
                        )
                    }
                    return none
                }
                had_previous_awaits = yes
                node._owning_later_call_param_indexes = (
                    match_indexes
                )
                awaits.add(node)
                if debug {
                    print("find_await_after_later_call_stmt(): " +
                        "Collected these results so far: awaits=" +
                        awaits.as_str())
                }
                idx += 1
                continue
            }
            for subblock in node.subblocks {
                var inner_result = find_awaits_in_subblock(
                    call_stmt, subblock, msgs=msgs,
                    project_file=project_file,
                    had_previous_awaits=had_previous_awaits,
                    debug=debug,
                )
                if inner_result == none {
                    return none
                }
                awaits += inner_result[1]
                if awaits.len > 0 {
                    had_previous_awaits = yes
                }
                if not inner_result[2] {
                    # We encountered a later call,
                    # hence have to bail out of scanning.
                    return [awaits, no]
                }
            }
            if node.kind == ast.N_STMT_DO {
                for clause in node.subexprs {
                    for subblock in clause.subblocks {
                        var inner_result = find_awaits_in_subblock(
                            call_stmt, subblock, msgs=msgs,
                            project_file=project_file,
                            had_previous_awaits=had_previous_awaits,
                            is_invalid_if_found=yes,
                            is_invalid_block_name=
                                if clause.kind ==
                                        ast.N_EXPR_RESCUECLAUSE
                                    ("rescue") else ("finally"),
                            debug=debug,
                        )
                        if inner_result == none {
                            return none
                        }
                        assert(inner_result[1].len == 0)
                    }
                }
            }
            idx += 1
        }
        return [awaits, yes]
    }
    var awaits_result = find_awaits_in_subblock(
        call_stmt, block, start_idx=idx,
        msgs=msgs,
        project_file=project_file,
        debug=debug,
    )
    var missing_ref_names = []
    var have_missing_ref = no
    if awaits_result != none {
        var ref_idx = 0
        for needed_ref in async_return_value_storage_refs {
            ref_idx += 1
            var found_in_awaits = no
            for await_stmt in awaits_result[1] {
                for subexpr in await_stmt.subexprs {
                    if needed_ref.alike(subexpr.ref) {
                        found_in_awaits = yes
                        break
                    }
                }
            }
            if not found_in_awaits {
                have_missing_ref = yes
                missing_ref_names.add(
                    async_return_value_labels[ref_idx]
                )
            }
        }
    }
    if awaits_result != none and have_missing_ref {
        assert(missing_ref_names.len > 0)
        var end_of_block_line = none
        var end_of_block_col = none
        if block.len > 0 {
            end_of_block_line = block[block.len].line
            end_of_block_col = block[block.len].col
        }
        if msgs != none {
            if not call_stmt.damaged {
                msgs.add(new msg.FileMsg(
                    "Unexpected end of block, "
                    "expected await on variable named "
                    "'" + missing_ref_names[1] +
                    "' before end of this "
                    "block, for preceding later call "
                    "in line " + call_stmt.line.as_str() +
                    ", column " +
                    call_stmt.col.as_str() + " "
                    ".",
                    source_file=project_file,
                    line=end_of_block_line,
                    col=end_of_block_col,
                ))
            }
            call_stmt.damaged = yes
        } else {
            throw new RuntimeError("Missing await after "
                "later call.")
        }
        return none
    }
    if awaits_result == none {
        return none
    }
    return awaits_result[1]
}

func first_pass_later_transform(
        project, msgs, build_options=none
        ) {
    func does_return_need_callback(
            return_stmt_node, parents
            ) {
        assert(parents != none and typename(parents) == "list")
        var parent = parents[parents.len]
        var block = ast.get_node_parent_block(
            return_stmt_node, parent
        )
        var idx = none
        if block != none {
            idx = block.find(return_stmt_node)
        }
        if block == none or idx == none {
            throw new RuntimeError("Internal error: "
                "Failed to find "
                "position of return statement in parent, "
                "malformed AST tree?")
        }
        assert(idx >= 1)
        var stmt_before = none
        if idx > 1 {
            stmt_before = block[idx - 1]
        }

        if stmt_before != none and
                stmt_before.kind == ast.N_STMT_CALL and
                stmt_before.subexprs.len >= 1 and
                stmt_before.subexprs[1].kind == ast.N_EXPR_BINOP and
                stmt_before.subexprs[1].optoken.str == "(" and
                stmt_before.subexprs[1].subexprs.len >= 2 {
            var call_subexprs = stmt_before.subexprs[1].subexprs
            if call_subexprs[1].kind == ast.N_EXPR_IDREF and
                    call_subexprs[1].label ==
                        "$schedule_later" and
                    call_subexprs[2].kind == ast.N_EXPR_CALLARGS and
                    call_subexprs[2].subexprs.len >= 1 and
                    call_subexprs[2].subexprs[1].kind ==
                        ast.N_EXPR_IDREF and
                    call_subexprs[2].subexprs[1].
                        label.starts("$laterreturncb") {
                return no
            }
        }
        return yes
    }
    func func_was_obviously_not_later_transformed(
            func_node
            ) {
        for arg in func_node.arg_labels {
            if arg.starts("$latererr") or
                    arg.starts("$laterreturn") {
                return no
            }
        }
        return yes
    }
    func make_later_return_cb_call(exit_info, return_expr,
            inner_scope, line, col, as_error=no,
            transformed_nodes_set=none, call_delayed=yes) {
        assert(exit_info != none)
        assert(inner_scope != none)
        var callback_call = new call_or_assign_stmt.CallStmt()
        callback_call.scope = inner_scope
        callback_call.line = line
        callback_call.col = col
        var t = new token.Token(
            "(", token.T_ENCLOSE, line, col)
        var call_expr = new ast_expr.BinopExpr(t)
        call_expr.scope = inner_scope
        call_expr.line = line
        call_expr.col = col
        callback_call.subexprs.add(call_expr)
        if return_expr == none {
            return_expr = new ast_expr.LiteralExpr()
            return_expr.scope = inner_scope
            return_expr.line = line
            return_expr.col = col
        }
        var idexpr = none
        if call_delayed {
            idexpr = new ast_expr.IdRefExpr()
            idexpr.scope = inner_scope
            idexpr.label = "$schedule_later"
            idexpr.line = line
            idexpr.col = col
        }
        var noneexpr = new ast_expr.LiteralExpr()
        noneexpr.scope = inner_scope
        noneexpr.line = line
        noneexpr.col = col
        var idexpr2 = new ast_expr.IdRefExpr()
        idexpr2.scope = inner_scope
        idexpr2.label = exit_info.exit_cb_label
        idexpr2.line = line
        idexpr2.col = col
        idexpr2.ref = exit_info.exit_cb_storage_ref
        var callargs = new ast_expr.CallArgsExpr()
        callargs.scope = inner_scope
        callargs.line = line
        callargs.col = col
        if call_delayed {
            if not as_error {
                callargs.subexprs = [idexpr2, noneexpr, return_expr]
            } else {
                callargs.subexprs = [idexpr2, return_expr, noneexpr]
            }
            call_expr.subexprs = [idexpr, callargs]
        } else {
            if not as_error {
                callargs.subexprs = [noneexpr, return_expr]
            } else {
                callargs.subexprs = [return_expr, noneexpr]
            }
            call_expr.subexprs = [idexpr2, callargs]
        }
        var rt_stmt = new return_stmt.ReturnStmt()
        rt_stmt.scope = inner_scope
        rt_stmt.line = line
        rt_stmt.col = col
        if transformed_nodes_set != none {
            transformed_nodes_set.add(rt_stmt)
        }
        return [callback_call, rt_stmt]
    }
    func wrap_func_in_later_do_rescue(
            pfile, node, transformed_nodes_set=none
            ) {
        assert(node.kind == ast.N_STMT_FUNC)
        var inner_scope = node.func_scope.inner_scope

        # Move it into do rescue to propagate error:
        var doresc = new do_stmt.DoStmt()
        doresc.scope = node.func_scope.inner_scope
        doresc._is_later_processed_do = yes
        doresc.line = node.line
        doresc.col = node.col
        var rescclause = new do_stmt.RescueClause()
        rescclause.scope = doresc.scope
        rescclause.line = doresc.line
        rescclause.col = doresc.col
        doresc.subexprs += [rescclause]
        doresc.subblocks.add(node.subblocks[1])
        node.subblocks = [[doresc]]
        var err_name = "$_latererr" + random.gen_id()
        while not inner_scope.name_is_free(err_name,
                pfile.global_scope) {
            err_name = "$_latererr" + random.gen_id()
        }
        var err_ref = inner_scope.add_symbol(
            err_name, pfile, rescclause.line, rescclause.col
        )
        rescclause.error_labels.add(err_name)
        rescclause.subexprs.add(none)  # ='any'

        # Inside rescue clause, return error to callback:
        var error_idref = new ast_expr.IdRefExpr()
        error_idref.scope = inner_scope
        error_idref.line = doresc.line
        error_idref.col = doresc.col
        error_idref.label = err_name
        error_idref.ref = err_ref
        assert(
            node.func_scope.
                get_later_transform_info()._exit_info != none
        )
        assert(
            node.func_scope.get_later_transform_info().
                exit_info() != none
        )
        var nodes = make_later_return_cb_call(
            node.func_scope.get_later_transform_info().exit_info(),
            error_idref,
            inner_scope, node.line, node.col, as_error=yes,
            call_delayed=yes,
            transformed_nodes_set=transformed_nodes_set)
        rescclause.subblocks = [nodes]
        if transformed_nodes_set != none {
            transformed_nodes_set.add(node)
        }

        return node
    }
    func transform_file(pfile) {
        var debug = no
        #debug = (
        #    pfile.source_uri != none and
        #    pfile.source_uri.has("somefile.h64")
        #)
        if build_options != none and build_options.print_stages {
            var print_name = "<unknown>"
            if pfile.source_uri != none {
                print_name = pfile.source_uri
            }
            if print_name.len > 30 {
                print_name = "..." +
                    print_name.sub(print_name.len - 30)
            }
            print(build_options.build_program_name +
                ": info: stage transformed-code: "
                "Later transforming file " + print_name + "... "
                "[t=" + time.ticks().as_str() + "]")
        }

        var later_call_labels_used = {}
        var transformed_nodes = {}
        var to_be_deleted_nodes = {}
        func transform_awaits_for_call(
                func_node, parents, call_unique_label
                ) {
            var builder = new ast_builder.ASTBuilder(pfile)
            func await_transform_nodes(node, parents) {
                if node.kind != ast.N_STMT_AWAIT or
                        node._owning_later_call_closure_name !=
                        call_unique_label {
                    return later node
                }
                var indexes = node._owning_later_call_param_indexes
                if indexes.len <= 1 {
                    assert(indexes.len == 1)
                    var arg_labels = func_node.arg_labels
                    if indexes[1] < 1 or
                            indexes[1] > arg_labels.len {
                        print("horsec: error: in file " +
                            pfile.source_uri.as_str() +
                            ": Encountered invalid "
                            "node with node."
                            "_owning_later_call_param_indexes "
                            "being invalid, indexes=" +
                            indexes.as_str() + ", arg_labels=" +
                            arg_labels.as_str() + ", "
                            "func_node.label=" +
                            func_node.label.as_str() + ", "
                            "func_node=" +
                            func_node.as_str().sub(1, 300) + "...")
                        throw new RuntimeError("Internal error, "
                            "node._owning_later_call_param_indexes "
                            "are invalid.")
                    }
                    var container_name = arg_labels[
                        indexes[1]
                    ]
                    var container_ref = new st_ref.StorageRef(
                        st_ref.ST_ARG, indexes[1]
                    )
                    var if_node = builder.make_if_neq_none_node(
                        node.scope,
                        container_name, container_ref,
                        line=node.line, col=node.col
                    )
                    var throw_node = new throw_stmt.ThrowStmt()
                    throw_node.scope = new st_scope.LocalScope()
                    throw_node.scope.parent = node.scope
                    throw_node.scope.func_scope =
                        throw_node.scope.parent.func_scope
                    throw_node.line = node.line
                    throw_node.col = node.col
                    var error_ref_expr = new ast_expr.IdRefExpr()
                    error_ref_expr.scope = throw_node.scope
                    error_ref_expr.line = node.line
                    error_ref_expr.col = node.col
                    error_ref_expr.label = container_name
                    error_ref_expr.ref = container_ref.copy()
                    throw_node.subexprs.add(error_ref_expr)
                    if_node.subexprs[1].subblocks[1].add(
                        throw_node
                    )

                    return later if_node
                }

                var container_expr = new ast_expr.ContainerExpr()
                container_expr.scope = node.scope
                container_expr.container_kind = ast_expr.C_LIST
                container_expr.line = node.line
                container_expr.col = node.col
                var err_array_node = builder.make_var_node(
                    node.scope, "$errarray", expr=container_expr,
                    line=node.line, col=node.col,
                    add_unique_suffix=yes
                )
                var err_array_label = err_array_node.var_labels[1]
                var err_array_ref = new st_ref.StorageRef(
                    st_ref.ST_LOCAL,
                    err_array_node.symbol_info[1].storage_id
                )
                var add_new_nodes = [err_array_node]
                for idx in indexes {
                    var err_name = func_node.arg_labels[idx]
                    var err_ref = new st_ref.StorageRef(
                        st_ref.ST_ARG, idx
                    )
                    var if_node = builder.make_if_neq_none_node(
                        node.scope, err_name, err_ref,
                        line=node.line, col=node.col
                    )
                    var err_ref_expr = new ast_expr.IdRefExpr()
                    err_ref_expr.scope = new st_scope.LocalScope()
                    err_ref_expr.scope.parent = node.scope
                    err_ref_expr.scope.func_scope =
                        err_ref_expr.scope.parent.func_scope
                    err_ref_expr.line = node.line
                    err_ref_expr.col = node.col
                    err_ref_expr.label = err_name
                    err_ref_expr.ref = err_ref
                    var add_node =
                        builder.make_add_to_named_list_node(
                            node.scope, err_array_label,
                            err_array_ref, expr=err_ref_expr,
                            line=node.line, col=node.col
                        )
                    if_node.subexprs[1].subblocks[1].add(add_node)
                    add_new_nodes.add(if_node)
                }
                var if_node = builder.make_length_cmp_node(
                    node.scope,
                    err_array_label, err_array_ref,
                    comp_type=">",
                    length_expr=0,
                    line=node.line, col=node.col
                )
                var throw_node = new throw_stmt.ThrowStmt()
                throw_node.scope = new st_scope.LocalScope()
                throw_node.scope.parent = node.scope
                throw_node.scope.func_scope =
                    throw_node.scope.parent.func_scope
                throw_node.line = node.line
                throw_node.col = node.col
                var error_ref_expr = new ast_expr.IdRefExpr()
                error_ref_expr.scope = throw_node.scope
                error_ref_expr.line = node.line
                error_ref_expr.col = node.col
                error_ref_expr.label = err_array_label
                error_ref_expr.ref = err_array_ref.copy()
                throw_node.subexprs.add(error_ref_expr)
                if_node.subexprs[1].subblocks[1].add(
                    throw_node
                )
                add_new_nodes.add(if_node)
                return later add_new_nodes
            }
            var result = ast_transform.visit_ast_tree(
                func_node, await_transform_nodes, parent_chain=yes,
                subtree_parent=parents, return_new_root=yes
            ) later:

            await result
            if result == no or result != func_node {
                throw new RuntimeError("Unexpected "
                    "internal error, await_transform_nodes() "
                    "shouldn't swap function itself.")
            }
            return later yes
        }
        func later_transform_node(node, parents) {
            if debug {
                print("later_transform.h64: debug: "
                    "Visiting node: " + node.as_str())
            }
            if to_be_deleted_nodes.has(node) {
                return later none
            }
            if node.kind != ast.N_STMT_FUNC and (
                    node.scope == none or node.scope.func_scope == none or
                    not node.scope.func_scope.is_later_func) {
                return later node
            }
            if node.kind == ast.N_STMT_FUNC and
                    node.func_scope.later_transform_info == none {
                node.func_scope.later_transform_info =
                    new LaterTransformInfo()
            }
            var inner_scope = node.scope
            if node.kind == ast.N_STMT_FUNC and
                    not transformed_nodes.has(node) and
                    node.func_scope.is_later_func and
                    (node.func_scope.
                        later_transform_info._exit_info == none or
                    func_was_obviously_not_later_transformed(node)) {
                transformed_nodes.add(node)
                assert(node.kind == ast.N_STMT_FUNC)
                var is_generated_latercb = (
                    node.label.starts("$laterfunc")
                )
                inner_scope = node.func_scope.inner_scope
                assert(
                    not is_generated_latercb or (
                    node.func_scope.
                        later_transform_info != none and
                    node.func_scope.
                        later_transform_info._exit_info != none)
                )
                var new_name = "$laterreturncb" + random.gen_id()
                while not inner_scope.name_is_free(new_name,
                        pfile.global_scope) {
                    new_name = "$laterreturncb" + random.gen_id()
                }
                var exinfo = none
                if not is_generated_latercb {
                    exinfo = new LaterExitInfo()
                    exinfo.exit_cb_label = new_name
                    if node.func_scope.later_transform_info == none {
                        node.func_scope.later_transform_info =
                            new LaterTransformInfo()
                        # Note/XXX:
                        # Don't set .owning_local_scope whenever
                        # LaterTransformInfo() belongs to func scope.
                    }
                    node.func_scope.later_transform_info._exit_info = (
                        exinfo
                    )
                    exinfo.exit_cb_storage_ref =
                        inner_scope.add_symbol(new_name, pfile,
                            node.line, node.col)
                } else {
                    exinfo = node.func_scope.
                        later_transform_info._exit_info
                }

                var pos_arg_count =
                    node.arg_labels.len - node.kw_arg_count
                node.arg_labels = node.arg_labels.sub(1, pos_arg_count) +
                    [new_name] + node.arg_labels.sub(pos_arg_count + 1)

                # Add return at the end if not present:
                if node.subblocks[1].len == 0 or
                        node.subblocks[1][node.subblocks[1].len].kind !=
                        ast.N_STMT_RETURN {
                    var line = node.line
                    var col = node.col
                    if node.subblocks[1].len > 0 {
                        line = node.subblocks[1]
                            [node.subblocks[1].len].line
                        col = node.subblocks[1]
                            [node.subblocks[1].len].col
                    }
                    var nodes = make_later_return_cb_call(
                        exinfo, none, inner_scope, line, col,
                        call_delayed=yes
                    )
                    for inner_node in nodes {
                        transformed_nodes.add(inner_node)
                    }
                    node.subblocks[1] += nodes
                    assert(node.subblocks[1][node.subblocks[1].len].
                        kind == ast.N_STMT_RETURN)
                    assert(not does_return_need_callback(
                        node.subblocks[1][node.subblocks[1].len],
                        parents + [node]
                    ))
                }

                node = wrap_func_in_later_do_rescue(
                    pfile, node,
                    transformed_nodes_set=transformed_nodes)
                assert(transformed_nodes.has(node))
                return node
            }
            if node.kind == ast.N_STMT_DO and
                    not transformed_nodes.has(node) and
                    not node._is_later_processed_do and
                    node.subexprs.len > 0 and
                    node.scope != none and
                    parents.len > 0 and
                    ast_analyze.stmt_list_contains_later_call(
                        node.subblocks[1],
                        check_recursive=yes,
                        include_later_ignore=no,
                        recurse_into_funcs=no) {
                transformed_nodes.add(node)
                assert(node.subblocks[1].len > 0)
                node._is_later_processed_do = yes
                var inner_scope = node.subblocks[1][1].scope
                if debugger.is_debug_build {
                    for stmt in node.subblocks[1] {
                        assert(stmt.scope == inner_scope)
                    }
                }
                var tinfo = inner_scope.get_later_transform_info()
                assert(tinfo._exit_info == none)

                var einfo = new LaterExitInfo()
                tinfo._exit_info = einfo
                var parent_block = ast.get_node_parent_block(
                    node, parents[parents.len]
                )
                assert(parent_block != none)
                var idx = parent_block.find(node)
                assert(idx != none and idx >= 1 and
                    idx <= parent_block.len)

                var rescue_clauses = []
                var finally_clause = none
                for clause in node.subexprs {
                    if clause.kind == ast.N_EXPR_RESCUECLAUSE {
                        rescue_clauses.add(clause)
                    } elseif clause.kind ==
                            ast.N_EXPR_FINALLYCLAUSE {
                        assert(finally_clause == none)
                        finally_clause = clause
                    }
                }
                assert(finally_clause != none or
                    rescue_clauses.len > 0)

                var builder = new ast_builder.ASTBuilder(pfile)
                var insert_before_do_stmt = []
                var finallyvarnode = none
                var finallyfuncnode = none
                var errordispatchfuncnode = none
                var rescuefuncnodes = []
                var past_do_func_node = none
                var _funcnamesused = {}
                if finally_clause != none {
                    var val = new ast_expr.LiteralExpr()
                    val.scope = node.scope
                    val.line = node.line
                    val.col = node.col
                    val.value = no
                    finallyvarnode = builder.make_var_node(
                        node.scope, "$finallywascalled",
                        expr=val,
                        line=node.line, col=node.col,
                        add_unique_suffix=yes
                    )
                    insert_before_do_stmt.add(finallyvarnode)
                }
                for rescue_clause in rescue_clauses {
                    var func_node = builder.make_func_node(
                        node.scope,
                        "$rescuefunc",
                        avoid_names=_funcnamesused,
                        line=node.line, col=node.col
                    )
                    rescuefuncnodes.add(func_node)
                    insert_before_do_stmt.add(func_node)
                    _funcnamesused.add(func_node.label)
                    func_node.arg_labels = []
                    func_node.kw_arg_count = 0
                    func_node.func_scope.arg_symbol_info = []
                    idx = 0
                    for error_label in rescue_clause.error_labels {
                        idx += 1
                        func_node.func_scope.add_arg(
                            error_label, ast_node=node,
                            project_file=pfile
                        )
                    }
                }
                if rescue_clauses.len > 0 {
                    errordispatchfuncnode = builder.make_func_node(
                        node.scope,
                        "$errordispatchfunc",
                        avoid_names=_funcnamesused,
                        line=node.line, col=node.col
                    )
                    var inner_scope = errordispatchfuncnode.
                        func_scope.inner_scope
                    assert(inner_scope != none)
                    errordispatchfuncnode.arg_labels = []
                    errordispatchfuncnode.kw_arg_count = 0
                    errordispatchfuncnode.func_scope.add_arg("eobj")

                    var do_stmt_node = new do_stmt.DoStmt()
                    do_stmt_node.scope = inner_scope
                    do_stmt_node.line = node.line
                    do_stmt_node.col = node.col
                    errordispatchfuncnode.subblocks = [[do_stmt_node]]
                    var do_block_scope = new st_scope.LocalScope()
                    do_block_scope.parent = inner_scope
                    do_block_scope.func_scope = inner_scope.func_scope
                    var throw_idref = new ast_expr.IdRefExpr()
                    throw_idref.scope = do_block_scope
                    throw_idref.line = node.line
                    throw_idref.col = node.col
                    throw_idref.label = "eobj"
                    throw_idref.ref = new st_ref.StorageRef(
                        st_ref.ST_ARG, 1
                    )
                    var throw_node = new throw_stmt.ThrowStmt()
                    throw_node.scope = do_block_scope
                    throw_node.line = node.line
                    throw_node.col = node.col
                    throw_node.subexprs = [
                        throw_idref
                    ]
                    do_stmt_node.subblocks = [[throw_node]]
                    do_stmt_node.subexprs = []
                    var clauseidx = 0
                    for rclause in rescue_clauses {
                        clauseidx += 1
                        var clause_node =
                            new do_stmt.RescueClause()
                        clause_node.scope = inner_scope
                        clause_node.line = node.line
                        clause_node.col = node.col
                        clause_node.subblocks = [[]]
                        clause_node.subexprs = []
                        clause_node.error_labels = []
                        do_stmt_node.subexprs.add(clause_node)
                        var in_clause_scope = new st_scope.LocalScope()
                        in_clause_scope.parent = inner_scope
                        in_clause_scope.func_scope =
                            inner_scope.func_scope
                        var errlabel_to_sinfo = {->}
                        clause_node.symbol_info = []
                        var idx = 0
                        for error_label in rclause.error_labels {
                            idx += 1
                            var error_type_expr = none
                            if rclause.subexprs[idx] != none {
                                error_type_expr =
                                    rclause.subexprs[idx].copy()
                            }
                            clause_node.error_labels.add(error_label)
                            clause_node.subexprs.add(error_type_expr)
                            if not errlabel_to_sinfo.has(error_label) {
                                in_clause_scope.add_symbol(
                                    error_label, pfile,
                                    node.line, node.col
                                )
                            }
                            assert(in_clause_scope.
                                name_to_symbol_map.has(error_label))
                            if not errlabel_to_sinfo.has(error_label) {
                                errlabel_to_sinfo[error_label] =
                                    in_clause_scope.
                                        name_to_symbol_map[error_label]
                            }
                            clause_node.symbol_info.add(
                                errlabel_to_sinfo[error_label]
                            )
                        }
                        var call_func_name =
                            rescuefuncnodes[clauseidx].label
                        var call_func_ref =
                            in_clause_scope.lookup(call_func_name)[1]
                        assert(call_func_ref != none)
                        assert(call_func_ref.kind ==
                            st_ref.ST_CCAPTURE)
                        var call_idref = new ast_expr.IdRefExpr()
                        call_idref.scope = in_clause_scope
                        call_idref.line = node.line
                        call_idref.col = node.col
                        call_idref.label = call_func_name
                        call_idref.ref = call_func_ref
                        var optoken = new token.Token(
                            "(", token.T_ENCLOSE,
                            node.line, node.col
                        )
                        var call_op = new ast_expr.BinopExpr(optoken)
                        call_op.scope = in_clause_scope
                        call_op.line = node.line
                        call_op.col = node.col
                        var call_args = new ast_expr.CallArgsExpr()
                        call_args.scope = in_clause_scope
                        call_args.line = node.line
                        call_args.col = node.col
                        call_args.subexprs = []
                        call_op.subexprs = [call_idref, call_args]
                        var call_stmt =
                            new call_or_assign_stmt.CallStmt()
                        call_stmt.scope = in_clause_scope
                        call_stmt.line = node.line
                        call_stmt.col = node.col
                        call_stmt.subexprs = [call_op]
                        clause_node.subblocks[1].add(call_stmt)
                        for error_label in rclause.error_labels {
                            var call_errarg_idref =
                                new ast_expr.IdRefExpr()
                            call_errarg_idref.scope = in_clause_scope
                            call_errarg_idref.line = node.line
                            call_errarg_idref.col = node.col
                            call_errarg_idref.label = error_label
                            call_errarg_idref.ref =
                                errlabel_to_sinfo[error_label].copy()
                            call_args.subexprs.add(
                                call_errarg_idref
                            )
                        }
                    }
                    insert_before_do_stmt.add(errordispatchfuncnode)
                }

                func get_rescue_error_ref_remaps(rclause) {
                    if rclause.symbol_info == none or
                            rclause.symbol_info.len !=
                            rclause.error_labels.len {
                        print("horsec: error: in later_transform.h64: "
                            "rescue clause has wrong or missing "
                            "symbol info: symbol_info=" +
                            rclause.symbol_info.as_str() +
                            ", rclause=" +
                            rclause.as_str())
                        throw new RuntimeError("Rescue clause with "
                            "wrong symbol info, this shouldn't "
                            "ever happen. Please report this error "
                            "to the compiler makers.")
                    }
                    var storage_remaps = []
                    var idx = 0
                    for st_info_entry in rclause.symbol_info {
                        if st_info_entry == none {
                            # This means this error entry has no label,
                            # hence can be ignored.
                            continue
                        }
                        idx += 1
                        storage_remaps.add([
                            new st_ref.StorageRef(
                                st_ref.ST_ARG,
                                st_info_entry.storage_id
                            ),
                            new st_ref.StorageRef(
                                st_ref.ST_ARG, idx
                            )
                        ])
                    }
                    return storage_remaps
                }

                func move_stmts_into_rescue_closures {
                    var index = 1
                    var queue = rescue_clauses.copy()
                    if queue.len == 0 {
                        return later
                    }
                    var rescue_clause = queue.pop()
                    var func_node = rescuefuncnodes[index]
                    var result =
                        ast_transform.reparent_stmts_into_closure(
                            func_node, rescue_clause.subblocks[1],
                            node.scope, clone_all_stmts=yes,
                            args_replacing_closure_refs_allowed=no,
                            special_storage_remaps=
                                get_rescue_error_ref_remaps(
                                    rescue_clause
                                )
                        ) later:

                    await result
                    if queue.len == 0 {
                        return later
                    }
                    index += 1
                    rescue_clause = queue.pop()
                    func_node = rescuefuncnodes[index]
                    result =
                        ast_transform.reparent_stmts_into_closure(
                            func_node, rescue_clause.subblocks[1],
                            node.scope, clone_all_stmts=yes,
                            args_replacing_closure_refs_allowed=no,
                            special_storage_remaps=
                                get_rescue_error_ref_remaps(
                                    rescue_clause
                                )
                        ) later repeat
                }
                move_stmts_into_rescue_closures() later:

                func handle_finally_node {
                    if finally_clause == none {
                        return later
                    }
                    finallyfuncnode = builder.make_func_node(
                        node.scope,
                        "$finallyfunc",
                        avoid_names=_funcnamesused,
                        line=node.line, col=node.col
                    )
                    insert_before_do_stmt.add(finallyfuncnode)
                    _funcnamesused.add(finallyfuncnode.label)
                    ast_transform.reparent_stmts_into_closure(
                        finallyfuncnode,
                        finally_clause.subblocks[1],
                        node.scope, clone_all_stmts=yes,
                        args_replacing_closure_refs_allowed=no
                    ) later:
                }
                handle_finally_node() later:

                assert((finally_clause != none and
                    finallyfuncnode != none) or
                    (finally_clause == none and
                    finallyfuncnode == none))
                past_do_func_node = none
                var can_exit_past_do = no
                func build_past_do_func {
                    if not can_exit_past_do {
                        return later
                    }

                    var stmts_after = []
                    var scan_node = node
                    var parents_idx = parents.len + 1
                    while yes {
                        stmts_after += ast.get_neighbor_statements_after(
                            scan_node, if parents_idx > 1
                                (parents[parents_idx - 1]) else (none),
                            stop_at_return=yes)
                        parents_idx -= 1
                        if parents_idx < 1 or (stmts_after.len > 0 and
                                (stmts_after[stmts_after.len].kind ==
                                    ast.N_STMT_RETURN or
                                stmts_after[stmts_after.len].kind ==
                                    ast.N_STMT_THROW)) {
                            break
                        }
                        scan_node = parents[parents_idx]
                        if scan_node.kind == ast.N_STMT_FUNC or
                                scan_node.scope == none or
                                scan_node.scope.func_scope !=
                                    node.scope.func_scope {
                            break
                        }
                    }
                    if stmts_after.len == 0 {
                        return later
                    }
                    past_do_func_node = builder.make_func_node(
                        node.scope,
                        "$pastdostmt",
                        avoid_names=_funcnamesused,
                        line=node.line, col=node.col
                    )
                    past_do_func_node.subblocks = [[]]
                    insert_before_do_stmt = [past_do_func_node] +
                        insert_before_do_stmt

                    ast_transform.reparent_stmts_into_closure(
                        past_do_func_node,
                        stmts_after,
                        node.scope, clone_all_stmts=yes,
                        args_replacing_closure_refs_allowed=no
                    ) later:
                }
                if node.subblocks[1].len == 0 or
                        not {ast.N_STMT_RETURN,
                        ast.N_STMT_THROW}.has(
                            node.subblocks[1][
                                node.subblocks[1].len].kind
                        ) {
                    can_exit_past_do = yes
                } else {
                    for func_node in rescuefuncnodes {
                        assert(func_node != none)
                        if func_node.subblocks[1].len == 0 or
                                not {ast.N_STMT_RETURN,
                                ast.N_STMT_THROW}.has(
                                    func_node.subblocks[1][
                                        func_node.subblocks[1].len].kind
                                ) {
                            can_exit_past_do = yes
                            break
                        }
                    }
                }
                build_past_do_func() later:

                assert(insert_before_do_stmt.len > 0)
                return later insert_before_do_stmt + [node]
            }
            if {ast.N_STMT_VAR, ast.N_STMT_CALL,
                    ast.N_STMT_ASSIGN}.has(node.kind) and
                    not transformed_nodes.has(node) and
                    node.has_later and not node.has_later_ignore and
                    not node.has_later_repeat and
                    node.scope != none and
                    node.scope.func_scope.is_later_func {
                transformed_nodes.add(node)
                var builder = new ast_builder.ASTBuilder(pfile)
                var assigned_or_declared_names = []
                var call_idx = 1
                if node.kind == ast.N_STMT_ASSIGN {
                    assert(node.subexprs.len >= 2)
                    call_idx = node.subexprs.len / 2 + 1
                }
                var call_exprs = [node.subexprs[call_idx]]
                assert(call_exprs[1].kind == ast.N_EXPR_BINOP and
                    call_exprs[1].subexprs.len == 2 and
                    call_exprs[1].subexprs[2].kind ==
                        ast.N_EXPR_CALLARGS)
                if node.kind == ast.N_STMT_VAR {
                    assigned_or_declared_names += node.var_labels
                    for expr in node.subexprs.sub(2) {
                        assert(expr.kind == ast.N_EXPR_BINOP)
                        call_exprs.add(expr)
                    }
                } elseif node.kind == ast.N_STMT_ASSIGN {
                    for expr in node.subexprs.sub(
                            1, node.subexprs.len / 2) {
                        assert(expr.kind == ast.N_EXPR_IDREF)
                        assigned_or_declared_names.add(expr.label)
                    }
                    for expr in node.subexprs.sub(
                            node.subexprs.len / 2 + 2) {
                        assert(expr.kind == ast.N_EXPR_BINOP)
                        call_exprs.add(expr)
                    }
                }
                var stmts_after = []
                var scan_node = node
                var einfo = node.scope.
                    get_later_transform_info().exit_info()
                assert(einfo != none)

                # Find where the awaits are:
                var awaits = []
                var repeat_stmt = none
                if node.kind != ast.N_STMT_CALL {
                    awaits = find_await_after_later_call_stmt(
                        node, parents, msgs=msgs,
                        project_file=pfile
                    )
                    repeat_stmt = find_repeat_for_later_call_stmt(
                        node, parents, msgs=msgs,
                        project_file=pfile
                    )
                }
                if awaits == none or node.damaged {
                    return later node
                }

                # Prepare new closure to be filled later:
                var func_node = builder.make_func_node(
                    inner_scope, "$laterfunc",
                    avoid_names=later_call_labels_used,
                    line=node.line, col=node.line)
                for await_entry in awaits {
                    await_entry._owning_later_call_closure_name =
                        func_node.label
                }
                later_call_labels_used.add(func_node.label)

                # Collect contents for new, made-up closure:
                var parents_idx = parents.len + 1
                while yes {
                    stmts_after += ast.get_neighbor_statements_after(
                        scan_node, if parents_idx > 1
                            (parents[parents_idx - 1]) else (none),
                        stop_at_return=yes)
                    parents_idx -= 1
                    if parents_idx < 1 or (stmts_after.len > 0 and
                            (stmts_after[stmts_after.len].kind ==
                                ast.N_STMT_RETURN or
                            stmts_after[stmts_after.len].kind ==
                                ast.N_STMT_THROW)) {
                        break
                    }
                    scan_node = parents[parents_idx]
                    if scan_node.kind == ast.N_STMT_FUNC or
                            scan_node.scope == none or
                            scan_node.scope.func_scope !=
                                node.scope.func_scope {
                        break
                    }
                }
                var err_param_names = ["$latererr" + random.gen_id()]
                var param_name_return = none
                var array_lock_node = none
                var array_lock_ref = none
                var array_lock_name = none
                var array_name = none
                var result_array_node = none
                var result_count_name = none
                var result_count_node = none
                if assigned_or_declared_names.len == 1 {
                    param_name_return = assigned_or_declared_names[1]
                } elseif assigned_or_declared_names.len > 1 {
                    var i = 2
                    while i <= assigned_or_declared_names.len {
                        var err_name = "$latererr" + random.gen_id()
                        while err_param_names.has(err_name) {
                            err_name = "$latererr" + random.gen_id()
                        }
                        err_param_names.add(err_name)
                        i += 1
                    }
                    var listexpr = new ast_expr.ContainerExpr()
                    listexpr.scope = inner_scope
                    listexpr.line = node.line
                    listexpr.col = node.col
                    listexpr.container_kind = ast_expr.C_LIST
                    i = 1
                    while i <= assigned_or_declared_names.len * 2 {
                        var none_expr = new ast_expr.LiteralExpr()
                        none_expr.scope = inner_scope
                        none_expr.line = node.line
                        none_expr.col = node.col
                        listexpr.subexprs.add(none_expr)
                        i += 1
                    }
                    result_array_node =
                        builder.make_var_node(
                            inner_scope, "$latervaluearray",
                            expr=listexpr, add_unique_suffix=yes,
                            line=node.line, col=node.col
                        )
                    array_name = result_array_node.var_labels[1]
                    param_name_return = none
                    array_lock_node =
                        builder.make_create_lock_node(
                            inner_scope, "$laterarraylock",
                            add_unique_suffix=yes,
                            line=node.line, col=node.col
                        )
                    array_lock_name = array_lock_node.var_labels[1]
                    array_lock_ref = new st_ref.StorageRef(
                        st_ref.ST_LOCAL,
                        array_lock_node.symbol_info[1].storage_id
                    )
                    var zero_expr = new ast_expr.LiteralExpr()
                    zero_expr.scope = inner_scope
                    zero_expr.line = node.line
                    zero_expr.col = node.col
                    zero_expr.value = 0
                    result_count_node =
                        builder.make_var_node(
                            inner_scope, "$completedvaluecount",
                            expr=zero_expr, add_unique_suffix=yes,
                            line=node.line, col=node.col
                        )
                    result_count_name =
                        result_count_node.var_labels[1]
                }

                # If we have multiple things to call, we need in-between
                # closures to gradually collect all the results:
                var partial_result_func_nodes = []
                var partial_result_func_names = []
                if call_exprs.len > 1 {
                    var i = 1
                    while i <= call_exprs.len {
                        var partial_result_func_node =
                            builder.make_func_node(
                                inner_scope, "$laterfunc",
                                line=node.line, col=node.col
                            )
                        partial_result_func_names.add(
                            partial_result_func_node.label
                        )
                        partial_result_func_node.scope = inner_scope
                        var block = []
                        partial_result_func_node.subblocks = [block]
                        partial_result_func_node.add_arg(
                            err_param_names[i],
                            ast_node=node, project_file=pfile
                        )
                        partial_result_func_node.add_arg(
                            "$partialresult",
                            ast_node=node, project_file=pfile
                        )
                        partial_result_func_node.kw_arg_count = 0
                        partial_result_func_nodes.add(
                            partial_result_func_node
                        )
                        var func_inner_scope =
                            partial_result_func_node.func_scope.inner_scope
                        var array_lock_inner_ref =
                            func_inner_scope.lookup(
                                array_lock_name
                            )[1]
                        var array_inner_ref = func_inner_scope.lookup(
                            array_name
                        )[1]
                        var result_count_inner_ref =
                            func_inner_scope.lookup(
                                result_count_name
                            )[1]

                        var literal_expr = new ast_expr.LiteralExpr()
                        literal_expr.value = no
                        literal_expr.scope = func_inner_scope
                        literal_expr.line = node.line
                        literal_expr.col = node.col
                        block.add(
                            builder.make_var_node(
                                func_inner_scope, "$justcompleted",
                                expr=literal_expr,
                                add_unique_suffix=yes,
                                line=node.line, col=node.col
                            )
                        )
                        var completed_name =
                            block[block.len].var_labels[1]
                        var completed_ref = new st_ref.StorageRef(
                            st_ref.ST_LOCAL,
                            block[block.len].symbol_info[1].storage_id
                        )

                        block.add(
                            builder.make_lock_hvm_lock_node(
                                func_inner_scope, array_lock_name,
                                array_lock_inner_ref,
                                line=node.line, col=node.col
                            )
                        )

                        var do_block = []
                        var finally_block = []
                        var do_rescue = new do_stmt.DoStmt()
                        do_rescue.scope = func_inner_scope
                        do_rescue.line = node.line
                        do_rescue.col = node.col
                        var finally_clause = new do_stmt.FinallyClause()
                        var do_inner_scope = new st_scope.LocalScope()
                        do_inner_scope.parent = func_inner_scope
                        do_inner_scope.func_scope =
                            func_inner_scope.func_scope
                        var finally_inner_scope =
                            new st_scope.LocalScope()
                        finally_inner_scope.parent = func_inner_scope
                        finally_inner_scope.func_scope =
                            func_inner_scope.func_scope
                        finally_clause.scope = func_inner_scope
                        finally_clause.line = node.line
                        finally_clause.col = node.col
                        finally_clause.subblocks = [finally_block]
                        do_rescue.subexprs = [finally_clause]
                        do_rescue.subblocks = [do_block]
                        block.add(do_rescue)

                        var arg_1_ref = new st_ref.StorageRef(
                            st_ref.ST_ARG, 1
                        )
                        var arg_1_expr = new ast_expr.IdRefExpr()
                        arg_1_expr.scope = do_inner_scope
                        arg_1_expr.line = node.line
                        arg_1_expr.col = node.col
                        arg_1_expr.label = err_param_names[i]
                        arg_1_expr.ref = arg_1_ref
                        var arg_2_ref = new st_ref.StorageRef(
                            st_ref.ST_ARG, 2
                        )
                        var arg_2_expr = new ast_expr.IdRefExpr()
                        arg_2_expr.scope = do_inner_scope
                        arg_2_expr.line = node.line
                        arg_2_expr.col = node.col
                        arg_2_expr.label = "$partialresult"
                        arg_2_expr.ref = arg_2_ref
                        do_block.add(
                            builder.make_set_to_named_list_node(
                                do_inner_scope, array_name,
                                number_expr=((i - 1) * 2) + 1,
                                assigned_expr=arg_1_expr,
                                array_inner_ref,
                                line=node.line, col=node.col
                            )
                        )
                        do_block.add(
                            builder.make_set_to_named_list_node(
                                do_inner_scope, array_name,
                                number_expr=((i - 1) * 2) + 2,
                                assigned_expr=arg_2_expr,
                                array_inner_ref,
                                line=node.line, col=node.col
                            )
                        )
                        do_block.add(
                            builder.make_increment_var_node(
                                do_inner_scope, result_count_name,
                                result_count_inner_ref,
                                number_expr=2,
                                line=node.line, col=node.col
                            )
                        )
                        do_block.add(
                            builder.make_var_cmp_node(
                                do_inner_scope,
                                result_count_name,
                                result_count_inner_ref,
                                comp_type=">=",
                                length_expr=(call_exprs.len * 2),
                                line=node.line, col=node.col
                            )
                        )
                        var if_stmt = do_block[do_block.len]
                        var inside_if_scope = new st_scope.LocalScope()
                        inside_if_scope.parent = do_inner_scope
                        inside_if_scope.func_scope =
                            func_inner_scope.func_scope
                        var yes_expr = new ast_expr.LiteralExpr()
                        yes_expr.scope = inside_if_scope
                        yes_expr.value = yes
                        yes_expr.line = node.line
                        yes_expr.col = node.col
                        if_stmt.subexprs[1].subblocks[1].add(
                            builder.make_assign_node(
                                inside_if_scope, completed_name,
                                completed_ref, expr=yes_expr,
                                line=node.line, col=node.col
                            )
                        )
                        finally_block.add(
                            builder.make_unlock_hvm_lock_node(
                                finally_inner_scope, array_lock_name,
                                array_lock_inner_ref,
                                line=node.line, col=node.col
                            )
                        )

                        var not_optoken = new token.Token(
                            "not", token.T_KEYWORD,
                            node.line, node.col
                        )
                        var not_expr = new ast_expr.UnopExpr(
                            not_optoken
                        )
                        not_expr.scope = func_inner_scope
                        not_expr.line = node.line
                        not_expr.col = node.col
                        var not_completed_idexpr =
                            new ast_expr.IdRefExpr()
                        not_completed_idexpr.label = completed_name
                        not_completed_idexpr.ref =
                            completed_ref.copy()
                        not_expr.subexprs = [not_completed_idexpr]
                        block.add(
                            builder.make_if_node(
                                func_inner_scope,
                                expr=not_expr,
                                line=node.line, col=node.col
                            )
                        )
                        var not_completed_return =
                            new return_stmt.ReturnStmt()
                        not_completed_return.scope =
                            func_inner_scope
                        not_completed_return.line = node.line
                        not_completed_return.col = node.col
                        block[block.len].subexprs[1].
                            subblocks[1].add(
                                not_completed_return
                            )
                        i += 1
                    }
                }

                # Actually fill in details for made-up closure:
                assert(func_node.func_scope != none)
                assert(func_node.func_scope.inner_scope != none)
                assert(inner_scope != none)
                func_node.scope = inner_scope
                func_node.subblocks = [stmts_after]
                func_node.arg_labels = []
                for err_param in err_param_names {
                    func_node.func_scope.add_arg(
                        err_param, ast_node=node,
                        project_file=pfile
                    )
                }
                if assigned_or_declared_names.len > 0 {
                    for name in assigned_or_declared_names {
                        func_node.func_scope.add_arg(
                            name, ast_node=node,
                            project_file=pfile
                        )
                    }
                } else {
                    func_node.func_scope.add_arg(
                        "$unused" + random.gen_id(),
                        ast_node=node, project_file=pfile
                    )
                }
                func_node.kw_arg_count = 0
                if func_node.func_scope.later_transform_info == none {
                    func_node.func_scope.later_transform_info =
                        new LaterTransformInfo()
                    # Note/XXX:
                    # Don't set .owning_local_scope whenever
                    # LaterTransformInfo() belongs to func scope.
                }
                func_node.func_scope.
                        later_transform_info._exit_info =
                    node.scope.func_scope.
                        later_transform_info._exit_info
                node.is_later = no

                # If we got partial result closures, call back into
                # the final closure from there:
                if call_exprs.len > 1 {
                    var i = 1
                    while i <= call_exprs.len {
                        # Construct call with its arguments:
                        var partial_closure_inner_scope =
                            partial_result_func_nodes[i].
                            func_scope.inner_scope
                        var func_node_ref = new st_ref.StorageRef(
                            st_ref.ST_LOCAL,
                            func_node.symbol_info.storage_id
                        )
                        var final_called_expr = new ast_expr.IdRefExpr()
                        final_called_expr.scope =
                            partial_closure_inner_scope
                        final_called_expr.label = func_node.label
                        final_called_expr.ref = func_node_ref
                        final_called_expr.line = node.line
                        final_called_expr.col = node.col
                        var final_call_stmt =
                            new call_or_assign_stmt.CallStmt()
                        final_call_stmt.scope =
                            partial_closure_inner_scope
                        final_call_stmt.line = node.line
                        final_call_stmt.col = node.col
                        var final_call_args = new ast_expr.CallArgsExpr()
                        final_call_args.scope =
                            partial_closure_inner_scope
                        final_call_args.line = node.line
                        final_call_args.col = node.col
                        final_call_args.subexprs = []
                        var optoken = new token.Token(
                            '(', token.T_ENCLOSE, node.line, node.col
                        )
                        var final_call_expr = new ast_expr.BinopExpr(
                            optoken
                        )
                        final_call_expr.scope =
                            partial_closure_inner_scope
                        final_call_expr.line = node.line
                        final_call_expr.col = node.col
                        final_call_expr.subexprs = [
                            final_called_expr, final_call_args
                        ]
                        final_call_stmt.subexprs = [
                            final_call_expr
                        ]
                        # We need to unify the results from all
                        # partial closures:
                        var unified_err_exprs = []
                        var unified_arg_exprs = []
                        var i2 = 1
                        while i2 <= call_exprs.len {
                            var array_inner_ref =
                                partial_closure_inner_scope.lookup(
                                    array_name
                                )[1]
                            var array_ref_expr_1 =
                                new ast_expr.IdRefExpr()
                            array_ref_expr_1.scope =
                                partial_closure_inner_scope
                            array_ref_expr_1.line = node.line
                            array_ref_expr_1.col = node.col
                            array_ref_expr_1.label = array_name
                            array_ref_expr_1.ref =
                                array_inner_ref.copy()
                            var num_expr_1 = new ast_expr.LiteralExpr()
                            num_expr_1.scope =
                                partial_closure_inner_scope
                            num_expr_1.line = node.line
                            num_expr_1.col = node.col
                            num_expr_1.value = (i2 - 1) * 2 + 1
                            var optoken_1 = new token.Token(
                                '[', token.T_ENCLOSE,
                                node.line, node.col
                            )
                            var array_index_expr_1 =
                                new ast_expr.BinopExpr(optoken_1)
                            array_index_expr_1.scope =
                                partial_closure_inner_scope
                            array_index_expr_1.line = node.line
                            array_index_expr_1.col = node.col
                            array_index_expr_1.subexprs = [
                                array_ref_expr_1, num_expr_1
                            ]
                            var array_ref_expr_2 =
                                new ast_expr.IdRefExpr()
                            array_ref_expr_2.scope =
                                partial_closure_inner_scope
                            array_ref_expr_2.line = node.line
                            array_ref_expr_2.col = node.col
                            array_ref_expr_2.label = array_name
                            array_ref_expr_2.ref =
                                array_inner_ref.copy()
                            var num_expr_2 = new ast_expr.LiteralExpr()
                            num_expr_2.scope =
                                partial_closure_inner_scope
                            num_expr_2.line = node.line
                            num_expr_2.col = node.col
                            num_expr_2.value = (i2 - 1) * 2 + 2
                            var optoken_2 = new token.Token(
                                '[', token.T_ENCLOSE,
                                node.line, node.col
                            )
                            var array_index_expr_2 =
                                new ast_expr.BinopExpr(optoken_2)
                            array_index_expr_2.scope =
                                partial_closure_inner_scope
                            array_index_expr_2.line = node.line
                            array_index_expr_2.col = node.col
                            array_index_expr_2.subexprs = [
                                array_ref_expr_2, num_expr_2
                            ]
                            unified_err_exprs.add(
                                array_index_expr_1
                            )
                            unified_arg_exprs.add(
                                array_index_expr_2
                            )
                            i2 += 1
                        }
                        final_call_args.subexprs =
                            unified_err_exprs +
                            unified_arg_exprs
                        partial_result_func_nodes[i].
                            subblocks[1].add(
                                final_call_stmt
                            )
                        i += 1
                    }
                }

                # Construct call(s) that replace the original
                # later calls:
                var call_stmt_main_node
                var call_stmt_nodes = []
                var i = 1
                while i <= call_exprs.len {
                    var continuation_idref = new ast_expr.IdRefExpr()
                    continuation_idref.scope = inner_scope
                    continuation_idref.line = node.line
                    continuation_idref.col = node.col
                    continuation_idref.label =
                        if partial_result_func_names.len > 0
                            (partial_result_func_names[i]) else
                            (func_node.label)
                    call_exprs[i].subexprs[2].
                        subexprs.add(continuation_idref)
                    call_stmt_main_node =
                        new call_or_assign_stmt.CallStmt()
                    call_stmt_main_node.scope = inner_scope
                    call_stmt_main_node.line = node.line
                    call_stmt_main_node.col = node.col
                    call_stmt_main_node.subexprs.add(call_exprs[i])
                    call_stmt_nodes.add(call_stmt_main_node)
                    i += 1
                }
                var return_stmt_node = new return_stmt.ReturnStmt()
                return_stmt_node.scope = inner_scope
                return_stmt_node.line = node.line
                return_stmt_node.col = node.col

                # Reparent follow-up code into our new later closure:
                ast_transform.reparent_stmts_into_closure(
                    func_node, stmts_after, func_node.scope,
                    clone_all_stmts=yes,
                    args_replacing_closure_refs_allowed=yes
                ) later:

                # Make sure to transform whatever reparented code
                # we have, in case it also has nested later calls:
                ast_analyze.analyze_and_configure_newly_added_func(
                    func_node, msgs=msgs, project_file=pfile
                )
                func_node.func_scope.is_later_func = yes
                assert(not transformed_nodes.has(func_node))
                assert(func_node.func_scope != none)
                if debugger.is_debug_build {
                    for stmt in func_node.subblocks[1] {
                        assert(stmt.scope != none)
                        if stmt.scope.func_scope !=
                                func_node.func_scope {
                            print("horsec: error: in later_transform.h64: "
                                "Statement has wrong func_scope: " +
                                stmt.as_str())
                            throw new RuntimeError("Internal error.")
                        }
                    }
                }
                var await_fix_result = transform_awaits_for_call(
                    func_node, parents, func_node.label
                ) later:
                await await_fix_result
                if not await_fix_result {
                    return later node
                }
                var new_root = ast_transform.visit_ast_tree(
                    func_node, later_transform_node, parent_chain=yes,
                    subtree_parent=parents, return_new_root=yes
                ) later:
                await new_root
                assert(new_root != no and new_root != none)
                if typename(new_root) != "list" {
                    new_root = [new_root]
                }
                func_node = new_root[1]
                assert(func_node.kind == ast.N_STMT_FUNC)

                # If the continuation isn't a later func, then
                # it won't be auto-wrapped into a catch-all do
                # statement to redirect any errors.
                # Do that manually in that case:
                var has_catchall_do_stmt = no
                for stmt in func_node.subblocks[1] {
                    if stmt.kind == ast.N_STMT_DO and
                            stmt._is_later_processed_do {
                        has_catchall_do_stmt = yes
                        break
                    }
                }
                if not has_catchall_do_stmt {
                    func_node = wrap_func_in_later_do_rescue(
                        pfile, func_node,
                        transformed_nodes_set=transformed_nodes
                    )
                }

                # Now put everything together and insert it,
                # instead of the original later call:
                var result = new_root
                result += call_stmt_nodes + [return_stmt_node]
                result = partial_result_func_nodes + result
                if result_array_node != none {
                    result = [result_array_node, result_count_node,
                        array_lock_node] + result
                }
                assert(
                    not func_node.func_scope.is_later_func or (
                    func_node.func_scope.
                        later_transform_info != none and
                    func_node.func_scope.later_transform_info.
                        _exit_info != none)
                )
                assert(func_node.scope == call_stmt_main_node.scope)
                assert(not func_node.subblocks[1].has(call_stmt_main_node))
                var parent = parents[parents.len]
                var block = ast.get_node_parent_block(
                    node, parent
                )
                assert(block != none)
                var idx = block.find(node)
                assert(idx >= 1)
                var stmt_before = none
                idx += 1
                while idx <= block.len {
                    to_be_deleted_nodes.add(block[idx])
                    idx += 1
                }
                return later result
            }
            if node.kind == ast.N_STMT_RETURN and
                    not transformed_nodes.has(node) and
                    node.scope != none and
                    node.scope.func_scope.is_later_func and
                    does_return_need_callback(
                        node, parents
                    ) {
                transformed_nodes.add(node)
                var line = node.line
                var col = node.col
                var einfo = node.scope.
                    get_later_transform_info().exit_info()
                assert(
                    node.scope.get_later_transform_info().
                        owning_local_scope == node.scope
                )
                assert(einfo != none)
                var nodes = make_later_return_cb_call(
                    einfo,
                    if node.subexprs.len > 0 (node.subexprs[1])
                        else (none), inner_scope, line, col,
                    call_delayed=yes
                )
                return later nodes
            }
            if node.kind == ast.N_STMT_IF and no {
                var has_later = no
                for clause in node.subexprs {
                    for block in clause.subblocks {
                        var clause_has_later = ast_analyze.
                            stmt_list_contains_later_call(block)
                        if clause_has_later {
                            has_later = yes
                        }
                    }
                }
                if has_later {
                    return later ast_transform.split_if_to_single_clauses(
                        pfile, node, parents[parents.len])
                }
            }
            return later node
        }
        pfile.ensure_ast() later:

        var success = ast_transform.visit_ast_tree(
            pfile.ast, later_transform_node, parent_chain=yes
        ) later:

        await success
        assert(success == yes)
        return later success
    }
    var success = project.do_for_all_files(transform_file)
    later:

    await success
}

