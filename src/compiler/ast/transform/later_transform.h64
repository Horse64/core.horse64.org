# @module compiler.ast.transform.later_transform
# Copyright (c) 2023, ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import random from core.horse64.org

import compiler.ast as cast
import compiler.ast.analyze as ast_analyze
import compiler.ast.call_or_assign_stmt as call_or_assign_stmt
import compiler.ast.expr as ast_expr
import compiler.ast.func_stmt as func_stmt
import compiler.ast.return_stmt as return_stmt
import compiler.ast.transform as ast_transform
import compiler.ast.type_stmt as type_stmt
import compiler.storage.scope as st_scope
import compiler.token as token

type LaterExitInfo {
    var is_func_return = yes
    var exit_cb_label
}

extend st_scope.FuncScope {
    var later_exit_info
}

extend st_scope.LocalScope {
    var later_exit_info
}

func st_scope.LocalScope.get_later_exit_info {
    var scope = self
    while scope != none {
        if scope.later_exit_info != none {
            return scope.later_exit_info
        }
        scope = scope.parent
    }
    if self.func_scope != none {
        return self.func_scope.later_exit_info
    }
}

func first_pass_later_transform(project, msgs) {
    var transformed_nodes = {}
    func make_later_return_cb_call(exit_info, return_expr,
            inner_scope, line, col) {
        var callback_call = new call_or_assign_stmt.CallStmt()
        callback_call.scope = inner_scope
        callback_call.line = line
        callback_call.col = col
        var t = new token.Token(
            "(", token.T_ENCLOSE, line, col)
        var call_expr = new ast_expr.BinopExpr(t)
        call_expr.scope = inner_scope
        call_expr.line = line
        call_expr.col = col
        callback_call.subexprs.add(call_expr)
        if return_expr == none {
            return_expr = new ast_expr.LiteralExpr()
            return_expr.scope = inner_scope
            return_expr.line = line
            return_expr.col = col
        }
        var idexpr = none
        if exit_info.is_func_return {
            idexpr = new ast_expr.IdRefExpr()
            idexpr.scope = inner_scope
            idexpr.label = "$schedule_later"
            idexpr.line = line
            idexpr.col = col
        }
        var idexpr2 = new ast_expr.IdRefExpr()
        idexpr2.scope = inner_scope
        idexpr2.label = exit_info.exit_cb_label
        idexpr2.line = line
        idexpr2.col = col
        var callargs = new ast_expr.CallOrDefArgsExpr()
        callargs.scope = inner_scope
        callargs.line = line
        callargs.col = col
        if exit_info.is_func_return {
            callargs.subexprs = [idexpr2, return_expr]
            call_expr.subexprs = [idexpr, callargs]
        } else {
            callargs.subexprs = [return_expr]
            call_expr.subexprs = [idexpr2, callargs]
        }
        var rt_stmt = new return_stmt.ReturnStmt()
        rt_stmt.scope = inner_scope
        rt_stmt.line = line
        rt_stmt.col = col
        return [callback_call, rt_stmt]
    }
    func transform_file(pfile) {
        func transform_node(node, parents) {
            if node.kind != cast.N_STMT_FUNC and (
                    node.scope == none or node.scope.func_scope == none or
                    not node.scope.func_scope.is_later_func) {
                return later node
            }
            var inner_scope = node.scope
            if node.kind == cast.N_STMT_FUNC and
                    not transformed_nodes.has(node) and
                    node.func_scope.is_later_func and
                    node.func_scope.later_exit_info == none {
                transformed_nodes.add(node)
                inner_scope = node.func_scope.inner_scope
                var new_name = "latercb" + random.gen_id()
                while not inner_scope.name_is_free(new_name,
                        pfile.global_scope) {
                    new_name = "latercb" + random.gen_id()
                }
                var einfo = new LaterExitInfo()
                einfo.exit_cb_label = new_name
                node.func_scope.later_exit_info = einfo

                var pos_arg_count =
                    node.arg_labels.len - node.kw_arg_count
                node.arg_labels = node.arg_labels.sub(1, pos_arg_count) +
                    [new_name] + node.arg_labels.sub(pos_arg_count + 1)

                # Add return at the end if not present:
                if node.subblocks[1].len == 0 or
                        node.subblocks[1][node.subblocks[1].len].kind !=
                        cast.N_STMT_RETURN {
                    var line = node.line
                    var col = node.col
                    if node.subblocks[1].len > 0 {
                        line = node.subblocks[1]
                            [node.subblocks[1].len].line
                        col = node.subblocks[1]
                            [node.subblocks[1].len].col
                    }
                    var nodes = make_later_return_cb_call(
                        einfo, none, inner_scope, line, col)
                    for inner_node in nodes {
                        transformed_nodes.add(inner_node)
                    }
                    node.subblocks[1] += nodes
                }
            }
            if {cast.N_STMT_VAR,
                    cast.N_STMT_ASSIGN}.has(node.kind) and
                    not transformed_nodes.has(node) and
                    node.has_later and not node.has_later_ignore and
                    node.scope.func_scope.is_later_func and
                    not node.has_later_repeat {
                transformed_nodes.add(node)
                var call_idx = 1
                if node.kind == cast.N_STMT_ASSIGN {
                    call_idx = node.subexprs.len / 2 + 1
                }
                var call_exprs = [node.subexprs[call_idx]]
                assert(call_exprs[1].kind == cast.N_EXPR_BINOP and
                        call_exprs[1].subexprs.len == 2 and
                        call_exprs[1].subexprs[2].kind ==
                            cast.N_EXPR_CALLORDEFARGS)
                if node.kind == cast.N_STMT_VAR {
                    for expr in node.subexprs.sub(2) {
                        assert(expr.kind == cast.N_EXPR_BINOP)
                        call_exprs.add(expr)
                    }
                } elseif node.kind == cast.N_STMT_ASSIGN {
                    for expr in node.subexprs.sub(
                            node.subexprs.len / 2 + 2) {
                        assert(expr.kind == cast.N_EXPR_BINOP)
                        call_exprs.add(expr)
                    }
                }
                var stmts_after = []
                var scan_node = node
                var einfo = node.scope.get_later_exit_info()
                assert(einfo != none)
                var parents_idx = parents.len + 1
                while yes {
                    stmts_after += cast.get_neighbor_statements_after(
                        scan_node, if parents_idx > 1
                            (parents[parents_idx - 1]) else (none))
                    parents_idx -= 1
                    if parents_idx < 1 {
                        break
                    }
                    scan_node = parents[parents_idx]
                    if scan_node.kind == cast.N_STMT_FUNC or
                            scan_node.scope.
                                get_later_exit_info() != einfo {
                        break
                    }
                }
                var func_node = pfile.make_new_made_up_func_node(
                    inner_scope, "laterfunc", line=node.line,
                    col=node.line)
                func_node.scope = inner_scope
                transformed_nodes.add(func_node)
                func_node.subblocks = [stmts_after]
                node.is_later = no
                var continuation_idref = new ast_expr.IdRefExpr()
                continuation_idref.scope = inner_scope
                continuation_idref.line = node.line
                continuation_idref.col = node.col
                continuation_idref.label = func_node.label
                call_exprs[1].subexprs[2].
                    subexprs.add(continuation_idref)
                var call_stmt_node = new call_or_assign_stmt.CallStmt()
                call_stmt_node.scope = inner_scope
                call_stmt_node.line = node.line
                call_stmt_node.col = node.col
                call_stmt_node.subexprs.add(call_exprs[1])

                ast_transform.reparent_nodes_into_closure(
                    func_node, stmts_after, func_node.scope) later:

                return later [func_node, call_stmt_node]
            }
            if node.kind == cast.N_STMT_RETURN and
                    not transformed_nodes.has(node) and
                    node.scope.func_scope.is_later_func {
                transformed_nodes.add(node)
                var line = node.line
                var col = node.col
                var einfo = node.scope.get_later_exit_info()
                assert(einfo != none)
                var nodes = make_later_return_cb_call(
                    einfo,
                    if node.subexprs.len > 0 (node.subexprs[1])
                        else (none), inner_scope, line, col)
                return later nodes
            }
            if node.kind == cast.N_STMT_IF and no {
                var has_later = no
                for clause in node.subexprs {
                    for block in clause.subblocks {
                        var clause_has_later = ast_analyze.
                            stmt_list_contains_later_call(block)
                        if clause_has_later {
                            has_later = yes
                        }
                    }
                }
                if has_later {
                    return later ast_transform.split_if_to_single_clauses(
                        pfile, node, parents[parents.len])
                }
            }
            return later node
        }
        pfile.ensure_ast() later:

        var success = ast_transform.visit_ast_tree(
            pfile.ast, transform_node, parent_chain=yes) later:

        await success
        assert(success == yes)
        return later success
    }
    var success = project.do_for_all_files(transform_file)
    later:

    await success
}

