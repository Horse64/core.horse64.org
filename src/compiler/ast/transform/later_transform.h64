## @module compiler.ast.transform.later_transform
# Copyright (c) 2023-2024, ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import debugger from core.horse64.org
import random from core.horse64.org
import time from core.horse64.org

import compiler.ast as ast
import compiler.ast.analyze as ast_analyze
import compiler.ast.call_or_assign_stmt as call_or_assign_stmt
import compiler.ast.do_stmt as do_stmt
import compiler.ast.expr as ast_expr
import compiler.ast.func_stmt as func_stmt
import compiler.ast.return_stmt as return_stmt
import compiler.ast.transform as ast_transform
import compiler.ast.type_stmt as type_stmt
import compiler.msg as msg
import compiler.storage.ref as storage_ref
import compiler.storage.scope as st_scope
import compiler.token as token

type LaterExitInfo {
    var exit_cb_label
    var exit_cb_storage_ref
}

extend type st_scope.FuncScope {
    var later_transform_info
}

func st_scope.FuncScope.get_later_transform_info {
    return self.later_transform_info
}

type LaterTransformInfo {
    var _exit_info
    var owning_local_scope
}

func LaterTransformInfo.exit_info {
    var limit_to_fscope = none
    if self.owning_local_scope != none {
        limit_to_fscope = self.owning_local_scope.func_scope
    }
    var check_info = self
    while check_info._exit_info == none and
            check_info.owning_local_scope != none {
        assert(limit_to_fscope != none)
        var scope = check_info.owning_local_scope
        while scope.parent != none {
            scope = scope.parent
            if scope == none or scope.func_scope !=
                    limit_to_fscope {
                if limit_to_fscope.later_transform_info != none {
                    return limit_to_fscope.later_transform_info._exit_info
                }
                return none
            }
            if scope.later_transform_info != none and
                    scope.later_transform_info._exit_info != none {
                return scope.later_transform_info._exit_info
            }
        }
        if limit_to_fscope.later_transform_info != none {
            return limit_to_fscope.later_transform_info._exit_info
        }
        return none
    }
    return check_info._exit_info
}

extend type st_scope.LocalScope {
    var later_transform_info
}

func st_scope.LocalScope.get_later_transform_info {
    if self.later_transform_info == none {
        self.later_transform_info =
            new LaterTransformInfo()
        self.later_transform_info.owning_local_scope = self
    }
    return self.later_transform_info
}

func get_later_assigned_value_info(stmt) {
    var async_return_value_storage_refs = []
    var async_return_value_labels = []
    if stmt.kind == ast.N_STMT_VAR {
        if (typename(stmt.symbol_info) != "list") {
            print("horsec: error: CRITICAL ERROR IN "
                "src/compiler/ast/transform/"
                "later_transform.h64: "
                "Encountered var statement without "
                "symbol info, which shouldn't be possible "
                "at this stage: " +
                stmt.as_str())
            throw new RuntimeError(
                "Internal error: Encountered N_STMT_VAR "
                "with incomplete symbol info, this is invalid. "
                "Please report this bug to the compiler "
                "team."
            )
        }
        var index = 0
        for sinfo in stmt.symbol_info {
            index += 1
            async_return_value_storage_refs.add(
                new storage_ref.StorageRef(
                    storage_ref.ST_LOCAL, sinfo.storage_id
                )
            )
            assert(index >= 1 and index <= stmt.var_labels.len)
            async_return_value_labels.add(
                stmt.var_labels[index]
            )
        }
    } else {
        assert(stmt.kind == ast.N_STMT_ASSIGN)
        var pairs_count = stmt.subexprs.len / 2
        assert(pairs_count >= 1)
        var i = 1
        while i <= pairs_count {
            if stmt.subexprs[i].ref == none {
                print("horsec: error: CRITICAL ERROR IN "
                    "src/compiler/ast/transform/"
                    "later_transform.h64: "
                    "Encountered assignment target without "
                    "ref info, which shouldn't be possible "
                    "at this stage: " +
                    [stmt, stmt.subexprs[i]].as_str())
                throw new RuntimeError(
                    "Internal error: Encountered N_STMT_ASSIGN "
                    "with incomplete storage ref, this is invalid. "
                    "Please report this bug to the compiler "
                    "team."
                )
            }
            async_return_value_storage_refs.add(
                stmt.subexprs[i].ref
            )
            async_return_value_labels.add(
                stmt.subexprs[i].label
            )
            i += 1
        }
    }
    return [
        async_return_value_labels,
        async_return_value_storage_refs
    ]
}

func find_repeat_for_later_call_stmt(
        call_stmt, parents, msgs=none,
        project_file=none
        ) {
    assert({ast.N_STMT_ASSIGN,
        ast.N_STMT_VAR}.has(call_stmt.kind))
    var debug = no
    if debug {
        print("find_repeat_for_later_call_stmt(): Finding " +
            "later repeat for: " + call_stmt.as_str())
    }
    var _result = get_later_assigned_value_info(call_stmt)
    var async_return_value_storage_refs = _result[2]
    var async_return_value_labels = _result[1]

    var block = none
    if parents.len > 0 {
        block = ast.get_node_parent_block(
            call_stmt, parents[parents.len]
        )
    }
    if block == none {
        throw new RuntimeError("Internal error: "
            "Can't find parent block of later call, "
            "unexpectedly malformed AST?!")
    }
    var idx = block.find(call_stmt)
    assert(idx != none)
    idx += 1
    func find_matching_repeat_in_subblock(
            call_stmt, block, start_idx=1,
            msgs=none,
            project_file=none,
            is_invalid_if_found=no,
            is_invalid_block_name="<unspecified>",
            debug=no
            ) {
        if debug {
            var block_str = block.as_str()
            if block_str.len > 300 {
                block_str = block_str.sub(1, 150) + "..." +
                    block_str.sub(block_str.len - 150)
            }
            print("find_repeat_for_later_call_stmt(): " +
                "Searching in block: " + block_str)
        }
        var idx = start_idx
        while idx <= block.len {
            var node = block[idx]
            if debug {
                print("find_repeat_for_later_call_stmt(): " +
                    "Examining block[" + idx.as_str() +
                    "]: " + node.as_str())
            }
            if node.kind == ast.N_STMT_FUNC {
                idx += 1
                continue
            }
            if node.kind == ast.N_STMT_IF {
                for clause in node.subexprs {
                    for subblock in clause.subblocks {
                        var inner_repeats =
                            find_matching_repeat_in_subblock(
                                call_stmt, subblock, msgs=msgs,
                                project_file=project_file,
                                is_invalid_if_found=yes,
                                is_invalid_block_name="if",
                                debug=debug,
                            )
                        if inner_repeats == none {
                            return [none, no]
                        }
                        assert(inner_repeats[1] == none)
                    }
                }
                idx += 1
                continue
            }
            if {ast.N_STMT_VAR, ast.N_STMT_ASSIGN}.has(
                    node.kind) and
                    node.has_later and
                    not node.has_later_ignore and
                    node.has_later_repeat {
                var repeat_matches_us = no
                var _result = get_later_assigned_value_info(call_stmt)
                var repeat_assigned_refs = _result[2]
                var repeat_assigned_names = _result[1]
                assert(repeat_assigned_refs.len > 0)

                repeat_matches_us = yes
                var idx2 = 0
                for var_ref in repeat_assigned_refs {
                    idx2 += 1
                    if idx > async_return_value_storage_refs.len or
                            var_ref.alike(
                                async_return_value_storage_refs[idx2]
                            ) {
                        repeat_matches_us = no
                        break
                    }
                }
                if repeat_assigned_refs.len <
                        async_return_value_storage_refs.len {
                    repeat_matches_us = no
                }
                if not repeat_matches_us {
                    idx += 1
                    continue
                }
                if debug {
                    print("find_repeat_for_later_call_stmt(): " +
                        "Collected this repeat.")
                }
                if is_invalid_if_found {
                    if debug {
                        print(
                            "find_repeat_for_later_call_stmt(): " +
                            "Oops, but is_invalid_if_found=" +
                            is_invalid_if_found.as_str() + "!"
                        )
                    }
                    if msgs != none {
                        if not call_stmt.damaged {
                            msgs.add(new msg.FileMsg(
                                "Unexpected misplaced later repeat, "
                                "can't be nested inside a " +
                                is_invalid_block_name +
                                    if is_invalid_block_name.len > 0
                                        (" ") else ("") +
                                "code block when the corresponding "
                                "preceding later call "
                                "in line " + call_stmt.line.as_str() +
                                ", column " +
                                call_stmt.col.as_str() + " "
                                "isn't also part of this code block.",
                                source_file=project_file,
                                line=node.line,
                                col=node.col,
                            ))
                        }
                        call_stmt.damaged = yes
                    } else {
                        throw new ValueError(
                            "Repeat doesn't match previous later call."
                        )
                    }
                    return [none, no]
                }
                if debug {
                    print("find_repeat_for_later_call_stmt(): " +
                        "Collected this repeat=" + node.as_str())
                }
                return [node, yes]
            }
            for subblock in node.subblocks {
                var inner_result = find_matching_repeat_in_subblock(
                    call_stmt, subblock, msgs=msgs,
                    project_file=project_file,
                    is_invalid_if_found=yes,
                    debug=debug,
                )
                if not inner_result[2] {
                    return [none, no]
                }
                if inner_result[1] != none {
                    return [inner_result[1], yes]
                }
            }
            if node.kind == ast.N_STMT_DO {
                for clause in node.subexprs {
                    for subblock in clause.subblocks {
                        var inner_result =
                            find_matching_repeat_in_subblock(
                                call_stmt, subblock, msgs=msgs,
                                project_file=project_file,
                                is_invalid_if_found=yes,
                                is_invalid_block_name=
                                    if clause.kind ==
                                            ast.N_EXPR_RESCUECLAUSE
                                        ("rescue") else ("finally"),
                                debug=debug,
                            )
                        if inner_result == none {
                            return [none, no]
                        }
                        assert(inner_result[1] == none)
                    }
                }
            }
            idx += 1
        }
        if debug {
            var block_str = block.as_str()
            if block_str.len > 300 {
                block_str = block_str.sub(1, 150) + "..." +
                    block_str.sub(block_str.len - 150)
            }
            print("find_repeat_for_later_call_stmt(): " +
                "Done searching in block with no match: " +
                block_str)
        }
        return [none, yes]
    }
    var repeat_result = find_matching_repeat_in_subblock(
        call_stmt, block, start_idx=idx,
        msgs=msgs,
        project_file=project_file,
        debug=debug,
    )
    if repeat_result == none {
        return none
    }
    return repeat_result[1]
}

func find_await_after_later_call_stmt(
        call_stmt, parents, msgs=none,
        project_file=none
        ) {
    assert({ast.N_STMT_ASSIGN,
        ast.N_STMT_VAR}.has(call_stmt.kind))
    var debug = no
    if debug {
        print("find_await_after_later_call_stmt(): Finding " +
            "await for: " + call_stmt.as_str())
    }
    var _result = get_later_assigned_value_info(call_stmt)
    var async_return_value_storage_refs = _result[2]
    var async_return_value_labels = _result[1]

    if call_stmt.kind == ast.N_STMT_VAR {
        if (typename(call_stmt.symbol_info) != "list") {
            print("horsec: error: CRITICAL ERROR IN "
                "src/compiler/ast/transform/"
                "later_transform.h64: "
                "Encountered var statement without "
                "symbol info, which shouldn't be possible "
                "at this stage: " +
                call_stmt.as_str())
            throw new RuntimeError(
                "Internal error: Encountered N_STMT_VAR "
                "with incomplete symbol info, this is invalid. "
                "Please report this bug to the compiler "
                "team."
            )
        }
        var index = 0
        for sinfo in call_stmt.symbol_info {
            index += 1
            async_return_value_storage_refs.add(
                new storage_ref.StorageRef(
                    storage_ref.ST_LOCAL, sinfo.storage_id
                )
            )
            assert(index >= 1 and index <= call_stmt.var_labels.len)
            async_return_value_labels.add(
                call_stmt.var_labels[index]
            )
        }
    } else {
        assert(call_stmt.kind == ast.N_STMT_ASSIGN)
        var pairs_count = call_stmt.subexprs.len / 2
        assert(pairs_count >= 1)
        var i = 1
        while i <= pairs_count {
            if call_stmt.subexprs[i].ref == none {
                print("horsec: error: CRITICAL ERROR IN "
                    "src/compiler/ast/transform/"
                    "later_transform.h64: "
                    "Encountered assignment target without "
                    "ref info, which shouldn't be possible "
                    "at this stage: " +
                    [call_stmt, call_stmt.subexprs[i]].as_str())
                throw new RuntimeError(
                    "Internal error: Encountered N_STMT_ASSIGN "
                    "with incomplete storage ref, this is invalid. "
                    "Please report this bug to the compiler "
                    "team."
                )
            }
            async_return_value_storage_refs.add(
                call_stmt.subexprs[i].ref
            )
            async_return_value_labels.add(
                call_stmt.subexprs[i].label
            )
            i += 1
        }
    }
    var block = none
    if parents.len > 0 {
        block = ast.get_node_parent_block(
            call_stmt, parents[parents.len]
        )
    }
    if block == none {
        throw new RuntimeError("Internal error: "
            "Can't find parent block of later call, "
            "unexpectedly malformed AST?!")
    }
    var idx = block.find(call_stmt)
    assert(idx != none)
    idx += 1
    func find_awaits_in_subblock(
            call_stmt, block, start_idx=1,
            msgs=none,
            had_previous_awaits=no,
            project_file=none,
            is_invalid_if_found=no,
            is_invalid_block_name="<unspecified>",
            debug=no
            ) {
        if debug {
            print("find_await_after_later_call_stmt(): " +
                "Searching in block: " + block.as_str())
        }
        var awaits = []
        var idx = start_idx
        while idx <= block.len {
            var node = block[idx]
            if debug {
                print("find_await_after_later_call_stmt(): " +
                    "Examining block[" + idx.as_str() +
                    "]: " + node.as_str())
            }
            if node.kind == ast.N_STMT_FUNC {
                idx += 1
                continue
            }
            if {ast.N_STMT_CALL, ast.N_STMT_ASSIGN,
                    ast.N_STMT_VAR}.has(node.kind) and
                    node.has_later and
                    not node.has_later_ignore {
                if awaits.len > 0 or
                        had_previous_awaits {
                    # Bail here, further valid awaits can't be past
                    # another later call like this.
                    return [awaits, no]
                }
                if msgs != none {
                    if not call_stmt.damaged {
                        msgs.add(new msg.FileMsg(
                            "Unexpected later call, expected "
                            "await statement here for previous "
                            "later call "
                            "in line " + call_stmt.line.as_str() +
                            ", column " + call_stmt.col.as_str() +
                            ".",
                            source_file=project_file,
                            line=node.line,
                            col=node.col,
                        ))
                    }
                    call_stmt.damaged = yes
                } else {
                    throw new ValueError(
                        "Later call after other "
                        "later call before await."
                    )
                }
                return none
            }
            if node.kind == ast.N_STMT_IF {
                for clause in node.subexprs {
                    for subblock in clause.subblocks {
                        var inner_awaits = find_awaits_in_subblock(
                            call_stmt, subblock, msgs=msgs,
                            project_file=project_file,
                            had_previous_awaits=had_previous_awaits,
                            is_invalid_if_found=yes,
                            is_invalid_block_name="if",
                            debug=debug,
                        )
                        if inner_awaits == none {
                            return none
                        }
                        assert(inner_awaits[1].len == 0)
                    }
                }
                idx += 1
                continue
            }
            if node.kind == ast.N_STMT_FOR or
                    node.kind == ast.N_STMT_WHILE {
                for subblock in node.subblocks {
                    var inner_awaits = find_awaits_in_subblock(
                        call_stmt, subblock, msgs=msgs,
                        project_file=project_file,
                        had_previous_awaits=had_previous_awaits,
                        is_invalid_if_found=yes,
                        is_invalid_block_name=
                            if node.kind == ast.N_STMT_FOR
                                ("for") else ("while"),
                        debug=debug,
                    )
                    if inner_awaits == none {
                        return none
                    }
                    assert(inner_awaits[1].len == 0)
                }
                idx += 1
                continue
            }
            if node.kind == ast.N_STMT_AWAIT {
                var await_matches_us = no
                for subexpr in node.subexprs {
                    assert(subexpr.kind == ast.N_EXPR_IDREF)
                    if subexpr.ref == none {
                        continue
                    }
                    for known_ref in
                            async_return_value_storage_refs {
                        if known_ref.alike(subexpr.ref) {
                            await_matches_us = yes
                        }
                    }
                }
                if not await_matches_us {
                    if msgs != none {
                        if not call_stmt.damaged {
                            msgs.add(new msg.FileMsg(
                                "Unexpected mismatched await, the "
                                "arguments don't match any of the "
                                "assigned values of the corresponding "
                                "preceding "
                                "later call "
                                "in line " + call_stmt.line.as_str() +
                                ", column " + call_stmt.col.as_str() +
                                ".",
                                source_file=project_file,
                                line=node.line,
                                col=node.col,
                            ))
                        }
                        call_stmt.damaged = yes
                    } else {
                        throw new ValueError(
                            "Await doesn't match previous later call."
                        )
                    }
                    return none
                }
                if debug {
                    print("find_await_after_later_call_stmt(): " +
                        "Collected this await.")
                }
                if is_invalid_if_found {
                    if debug {
                        print(
                            "find_await_after_later_call_stmt(): " +
                            "Oops, but is_invalid_if_found=" +
                            is_invalid_if_found.as_str() + "!"
                        )
                    }
                    if msgs != none {
                        if not call_stmt.damaged {
                            msgs.add(new msg.FileMsg(
                                "Unexpected misplaced await, can't "
                                "be nested inside " +
                                is_invalid_block_name + " "
                                "code block when the corresponding "
                                "preceding later call "
                                "in line " + call_stmt.line.as_str() +
                                ", column " +
                                call_stmt.col.as_str() + " "
                                "isn't also part of this code block.",
                                source_file=project_file,
                                line=node.line,
                                col=node.col,
                            ))
                        }
                        call_stmt.damaged = yes
                    } else {
                        throw new ValueError(
                            "Await doesn't match previous later call."
                        )
                    }
                    return none
                }
                had_previous_awaits = yes
                awaits.add(node)
                if debug {
                    print("find_await_after_later_call_stmt(): " +
                        "Collected these results so far: awaits=" +
                        awaits.as_str())
                }
                idx += 1
                continue
            }
            for subblock in node.subblocks {
                var inner_result = find_awaits_in_subblock(
                    call_stmt, subblock, msgs=msgs,
                    project_file=project_file,
                    had_previous_awaits=had_previous_awaits,
                    debug=debug,
                )
                if inner_result == none {
                    return none
                }
                awaits += inner_result[1]
                if awaits.len > 0 {
                    had_previous_awaits = yes
                }
                if not inner_result[2] {
                    # We encountered a later call,
                    # hence have to bail out of scanning.
                    return [awaits, no]
                }
            }
            if node.kind == ast.N_STMT_DO {
                for clause in node.subexprs {
                    for subblock in clause.subblocks {
                        var inner_result = find_awaits_in_subblock(
                            call_stmt, subblock, msgs=msgs,
                            project_file=project_file,
                            had_previous_awaits=had_previous_awaits,
                            is_invalid_if_found=yes,
                            is_invalid_block_name=
                                if clause.kind ==
                                        ast.N_EXPR_RESCUECLAUSE
                                    ("rescue") else ("finally"),
                            debug=debug,
                        )
                        if inner_result == none {
                            return none
                        }
                        assert(inner_result[1].len == 0)
                    }
                }
            }
            idx += 1
        }
        return [awaits, yes]
    }
    var awaits_result = find_awaits_in_subblock(
        call_stmt, block, start_idx=idx,
        msgs=msgs,
        project_file=project_file,
        debug=debug,
    )
    var missing_ref_names = []
    var have_missing_ref = no
    if awaits_result != none {
        var ref_idx = 0
        for needed_ref in async_return_value_storage_refs {
            ref_idx += 1
            var found_in_awaits = no
            for await_stmt in awaits_result[1] {
                for subexpr in await_stmt.subexprs {
                    if needed_ref.alike(subexpr.ref) {
                        found_in_awaits = yes
                        break
                    }
                }
            }
            if not found_in_awaits {
                have_missing_ref = yes
                missing_ref_names.add(
                    async_return_value_labels[ref_idx]
                )
            }
        }
    }
    if awaits_result != none and have_missing_ref {
        assert(missing_ref_names.len > 0)
        var end_of_block_line = none
        var end_of_block_col = none
        if block.len > 0 {
            end_of_block_line = block[block.len].line
            end_of_block_col = block[block.len].col
        }
        if msgs != none {
            if not call_stmt.damaged {
                msgs.add(new msg.FileMsg(
                    "Unexpected end of block, "
                    "expected await on variable named "
                    "'" + missing_ref_names[1] +
                    "' before end of this "
                    "block, for preceding later call "
                    "in line " + call_stmt.line.as_str() +
                    ", column " +
                    call_stmt.col.as_str() + " "
                    ".",
                    source_file=project_file,
                    line=end_of_block_line,
                    col=end_of_block_col,
                ))
            }
            call_stmt.damaged = yes
        } else {
            throw new RuntimeError("Missing await after "
                "later call.")
        }
        return none
    }
    if awaits_result == none {
        return none
    }
    return awaits_result[1]
}

func first_pass_later_transform(
        project, msgs, build_options=none
        ) {
    func does_return_need_callback(
            return_stmt_node, parents
            ) {
        assert(parents != none and typename(parents) == "list")
        var parent = parents[parents.len]
        var block = ast.get_node_parent_block(
            return_stmt_node, parent
        )
        var idx = none
        if block != none {
            idx = block.find(return_stmt_node)
        }
        if block == none or idx == none {
            throw new RuntimeError("Internal error: "
                "Failed to find "
                "position of return statement in parent, "
                "malformed AST tree?")
        }
        assert(idx >= 1)
        var stmt_before = none
        if idx > 1 {
            stmt_before = block[idx - 1]
        }

        if stmt_before != none and
                stmt_before.kind == ast.N_STMT_CALL and
                stmt_before.subexprs.len >= 1 and
                stmt_before.subexprs[1].kind == ast.N_EXPR_BINOP and
                stmt_before.subexprs[1].optoken.str == "(" and
                stmt_before.subexprs[1].subexprs.len >= 2 {
            var call_subexprs = stmt_before.subexprs[1].subexprs
            if call_subexprs[1].kind == ast.N_EXPR_IDREF and
                    call_subexprs[1].label ==
                        "$schedule_later" and
                    call_subexprs[2].kind == ast.N_EXPR_CALLARGS and
                    call_subexprs[2].subexprs.len >= 1 and
                    call_subexprs[2].subexprs[1].kind ==
                        ast.N_EXPR_IDREF and
                    call_subexprs[2].subexprs[1].
                        label.starts("$laterreturncb") {
                return no
            }
        }
        return yes
    }
    func func_was_obviously_not_later_transformed(
            func_node
            ) {
        for arg in func_node.arg_labels {
            if arg.starts("$latererr") or
                    arg.starts("$laterreturn") {
                return no
            }
        }
        return yes
    }
    func make_later_return_cb_call(exit_info, return_expr,
            inner_scope, line, col, as_error=no,
            transformed_nodes_set=none, call_delayed=yes) {
        assert(exit_info != none)
        assert(inner_scope != none)
        var callback_call = new call_or_assign_stmt.CallStmt()
        callback_call.scope = inner_scope
        callback_call.line = line
        callback_call.col = col
        var t = new token.Token(
            "(", token.T_ENCLOSE, line, col)
        var call_expr = new ast_expr.BinopExpr(t)
        call_expr.scope = inner_scope
        call_expr.line = line
        call_expr.col = col
        callback_call.subexprs.add(call_expr)
        if return_expr == none {
            return_expr = new ast_expr.LiteralExpr()
            return_expr.scope = inner_scope
            return_expr.line = line
            return_expr.col = col
        }
        var idexpr = none
        if call_delayed {
            idexpr = new ast_expr.IdRefExpr()
            idexpr.scope = inner_scope
            idexpr.label = "$schedule_later"
            idexpr.line = line
            idexpr.col = col
        }
        var noneexpr = new ast_expr.LiteralExpr()
        noneexpr.scope = inner_scope
        noneexpr.line = line
        noneexpr.col = col
        var idexpr2 = new ast_expr.IdRefExpr()
        idexpr2.scope = inner_scope
        idexpr2.label = exit_info.exit_cb_label
        idexpr2.line = line
        idexpr2.col = col
        idexpr2.ref = exit_info.exit_cb_storage_ref
        var callargs = new ast_expr.CallArgsExpr()
        callargs.scope = inner_scope
        callargs.line = line
        callargs.col = col
        if call_delayed {
            if not as_error {
                callargs.subexprs = [idexpr2, noneexpr, return_expr]
            } else {
                callargs.subexprs = [idexpr2, return_expr, noneexpr]
            }
            call_expr.subexprs = [idexpr, callargs]
        } else {
            if not as_error {
                callargs.subexprs = [noneexpr, return_expr]
            } else {
                callargs.subexprs = [return_expr, noneexpr]
            }
            call_expr.subexprs = [idexpr2, callargs]
        }
        var rt_stmt = new return_stmt.ReturnStmt()
        rt_stmt.scope = inner_scope
        rt_stmt.line = line
        rt_stmt.col = col
        if transformed_nodes_set != none {
            transformed_nodes_set.add(rt_stmt)
        }
        return [callback_call, rt_stmt]
    }
    func wrap_func_in_later_do_rescue(pfile, node, latercb_name,
            transformed_nodes_set=none) {
        assert(node.kind == ast.N_STMT_FUNC)
        var inner_scope = node.func_scope.inner_scope

        # Move it into do rescue to propagate error:
        var doresc = new do_stmt.DoStmt()
        doresc.scope = node.func_scope.inner_scope
        doresc.line = node.line
        doresc.col = node.col
        var rescclause = new do_stmt.RescueClause()
        rescclause.scope = doresc.scope
        rescclause.line = doresc.line
        rescclause.col = doresc.col
        doresc.subexprs += [rescclause]
        doresc.subblocks.add(node.subblocks[1])
        node.subblocks = [[doresc]]
        var err_name = "$_latererr" + random.gen_id()
        while not inner_scope.name_is_free(err_name,
                pfile.global_scope) {
            err_name = "$_latererr" + random.gen_id()
        }
        var err_ref = inner_scope.add_symbol(
            err_name, rescclause.line, rescclause.col)
        rescclause.error_labels.add(err_name)
        rescclause.subexprs.add(none)  # ='any'

        # Inside rescue clause, return error to callback:
        var error_idref = new ast_expr.IdRefExpr()
        error_idref.scope = inner_scope
        error_idref.line = doresc.line
        error_idref.col = doresc.col
        error_idref.label = err_name
        error_idref.ref = err_ref
        assert(
            node.func_scope.
                get_later_transform_info()._exit_info != none
        )
        assert(
            node.func_scope.get_later_transform_info().
                exit_info() != none
        )
        var nodes = make_later_return_cb_call(
            node.func_scope.get_later_transform_info().exit_info(),
            error_idref,
            inner_scope, node.line, node.col, as_error=yes,
            call_delayed=yes,
            transformed_nodes_set=transformed_nodes_set)
        rescclause.subblocks = [nodes]
        if transformed_nodes_set != none {
            transformed_nodes_set.add(node)
        }

        return node
    }
    func transform_file(pfile) {
        var debug = no
        #debug = (
        #    pfile.source_uri != none and
        #    pfile.source_uri.has("somefile.h64")
        #)
        if build_options != none and build_options.print_stages {
            var print_name = "<unknown>"
            if pfile.source_uri != none {
                print_name = pfile.source_uri
            }
            if print_name.len > 30 {
                print_name = "..." +
                    print_name.sub(print_name.len - 30)
            }
            print(build_options.build_program_name +
                ": info: stage transformed-code: "
                "Later transforming file " + print_name + "... "
                "[t=" + time.ticks().as_str() + "]")
        }
        var transformed_nodes = {}
        var to_be_deleted_nodes = {}
        func later_transform_node(node, parents) {
            if debug {
                print("later_transform.h64: debug: "
                    "Visiting node: " + node.as_str())
            }
            if to_be_deleted_nodes.has(node) {
                return later none
            }
            if node.kind != ast.N_STMT_FUNC and (
                    node.scope == none or node.scope.func_scope == none or
                    not node.scope.func_scope.is_later_func) {
                return later node
            }
            if node.kind == ast.N_STMT_FUNC and
                    node.func_scope.later_transform_info == none {
                node.func_scope.later_transform_info =
                    new LaterTransformInfo()
            }
            var inner_scope = node.scope
            if node.kind == ast.N_STMT_FUNC and
                    not transformed_nodes.has(node) and
                    node.func_scope.is_later_func and
                    (node.func_scope.
                        later_transform_info._exit_info == none or
                    func_was_obviously_not_later_transformed(node)) {
                transformed_nodes.add(node)
                assert(node.kind == ast.N_STMT_FUNC)
                var is_generated_latercb = (
                    node.label.starts("$laterfunc")
                )
                inner_scope = node.func_scope.inner_scope
                assert(
                    not is_generated_latercb or (
                    node.func_scope.
                        later_transform_info != none and
                    node.func_scope.
                        later_transform_info._exit_info != none)
                )
                var new_name = "$laterreturncb" + random.gen_id()
                while not inner_scope.name_is_free(new_name,
                        pfile.global_scope) {
                    new_name = "$laterreturncb" + random.gen_id()
                }
                var exinfo = none
                if not is_generated_latercb {
                    exinfo = new LaterExitInfo()
                    exinfo.exit_cb_label = new_name
                    if node.func_scope.later_transform_info == none {
                        node.func_scope.later_transform_info =
                            new LaterTransformInfo()
                        # Note/XXX:
                        # Don't set .owning_local_scope whenever
                        # LaterTransformInfo() belongs to func scope.
                    }
                    node.func_scope.later_transform_info._exit_info = (
                        exinfo
                    )
                    exinfo.exit_cb_storage_ref =
                        inner_scope.add_symbol(new_name, node.line,
                            node.col)
                } else {
                    exinfo = node.func_scope.
                        later_transform_info._exit_info
                }

                var pos_arg_count =
                    node.arg_labels.len - node.kw_arg_count
                node.arg_labels = node.arg_labels.sub(1, pos_arg_count) +
                    [new_name] + node.arg_labels.sub(pos_arg_count + 1)

                # Add return at the end if not present:
                if node.subblocks[1].len == 0 or
                        node.subblocks[1][node.subblocks[1].len].kind !=
                        ast.N_STMT_RETURN {
                    var line = node.line
                    var col = node.col
                    if node.subblocks[1].len > 0 {
                        line = node.subblocks[1]
                            [node.subblocks[1].len].line
                        col = node.subblocks[1]
                            [node.subblocks[1].len].col
                    }
                    var nodes = make_later_return_cb_call(
                        exinfo, none, inner_scope, line, col,
                        call_delayed=yes
                    )
                    for inner_node in nodes {
                        transformed_nodes.add(inner_node)
                    }
                    node.subblocks[1] += nodes
                    assert(node.subblocks[1][node.subblocks[1].len].
                        kind == ast.N_STMT_RETURN)
                    assert(not does_return_need_callback(
                        node.subblocks[1][node.subblocks[1].len],
                        parents + [node]
                    ))
                }

                node = wrap_func_in_later_do_rescue(
                    pfile, node, new_name,
                    transformed_nodes_set=transformed_nodes)
                assert(transformed_nodes.has(node))
                return node
            }
            if {ast.N_STMT_VAR, ast.N_STMT_CALL,
                    ast.N_STMT_ASSIGN}.has(node.kind) and
                    not transformed_nodes.has(node) and
                    node.has_later and not node.has_later_ignore and
                    not node.has_later_repeat and
                    node.scope != none and
                    node.scope.func_scope.is_later_func {
                transformed_nodes.add(node)
                var assigned_or_declared_names = []
                var call_idx = 1
                if node.kind == ast.N_STMT_ASSIGN {
                    assert(node.subexprs.len >= 2)
                    call_idx = node.subexprs.len / 2 + 1
                }
                var call_exprs = [node.subexprs[call_idx]]
                assert(call_exprs[1].kind == ast.N_EXPR_BINOP and
                    call_exprs[1].subexprs.len == 2 and
                    call_exprs[1].subexprs[2].kind ==
                        ast.N_EXPR_CALLARGS)
                if node.kind == ast.N_STMT_VAR {
                    assigned_or_declared_names += node.var_labels
                    for expr in node.subexprs.sub(2) {
                        assert(expr.kind == ast.N_EXPR_BINOP)
                        call_exprs.add(expr)
                    }
                } elseif node.kind == ast.N_STMT_ASSIGN {
                    for expr in node.subexprs.sub(
                            1, node.subexprs.len / 2) {
                        assert(expr.kind == ast.N_EXPR_IDREF)
                        assigned_or_declared_names.add(expr.label)
                    }
                    for expr in node.subexprs.sub(
                            node.subexprs.len / 2 + 2) {
                        assert(expr.kind == ast.N_EXPR_BINOP)
                        call_exprs.add(expr)
                    }
                }
                var stmts_after = []
                var scan_node = node
                if node.scope.later_transform_info == none {
                    node.scope.later_transform_info =
                        new LaterTransformInfo()
                    node.scope.later_transform_info.
                        owning_local_scope = node.scope
                }
                var einfo = node.scope.
                    get_later_transform_info().exit_info()
                assert(einfo != none)

                # Collect contents for new, made-up closure:
                var parents_idx = parents.len + 1
                while yes {
                    stmts_after += ast.get_neighbor_statements_after(
                        scan_node, if parents_idx > 1
                            (parents[parents_idx - 1]) else (none),
                        stop_at_return=yes)
                    parents_idx -= 1
                    if parents_idx < 1 or (stmts_after.len > 0 and
                            stmts_after[stmts_after.len].kind ==
                                ast.N_STMT_RETURN) {
                        break
                    }
                    scan_node = parents[parents_idx]
                    if scan_node.kind == ast.N_STMT_FUNC or
                            scan_node.scope == none or
                            scan_node.scope.func_scope.
                                get_later_transform_info().exit_info() !=
                                einfo {
                        break
                    }
                }
                var err_param_name = "$latererr" + random.gen_id()
                var param_name_return = none
                if assigned_or_declared_names.len == 1 {
                    param_name_return = assigned_or_declared_names[1]
                } elseif assigned_or_declared_names.len > 1 {
                    param_name_return = "$latervaluearray"
                } else {
                    param_name_return = "$unused" + random.gen_id()
                }

                # Find where the awaits are:
                var awaits = []
                var repeat_stmt = none
                if node.kind != ast.N_STMT_CALL {
                    awaits = find_await_after_later_call_stmt(
                        node, parents, msgs=msgs,
                        project_file=pfile
                    )
                    repeat_stmt = find_repeat_for_later_call_stmt(
                        node, parents, msgs=msgs,
                        project_file=pfile
                    )
                }
                if awaits == none or node.damaged {
                    return later node
                }

                # Actually construct made-up closure:
                var func_node = pfile.make_new_made_up_func_node(
                    inner_scope, "$laterfunc", line=node.line,
                    col=node.line)
                assert(func_node.func_scope != none)
                assert(func_node.func_scope.inner_scope != none)
                assert(inner_scope != none)
                func_node.scope = inner_scope
                func_node.subblocks = [stmts_after]
                func_node.arg_labels = [err_param_name,
                    param_name_return]
                func_node.kw_arg_count = 0
                if func_node.func_scope.later_transform_info == none {
                    func_node.func_scope.later_transform_info =
                        new LaterTransformInfo()
                    # Note/XXX:
                    # Don't set .owning_local_scope whenever
                    # LaterTransformInfo() belongs to func scope.
                }
                func_node.func_scope.later_transform_info._exit_info =
                    node.scope.func_scope.later_transform_info._exit_info
                node.is_later = no
                var continuation_idref = new ast_expr.IdRefExpr()
                continuation_idref.scope = inner_scope
                continuation_idref.line = node.line
                continuation_idref.col = node.col
                continuation_idref.label = func_node.label
                call_exprs[1].subexprs[2].
                    subexprs.add(continuation_idref)
                var call_stmt_node = new call_or_assign_stmt.CallStmt()
                call_stmt_node.scope = inner_scope
                call_stmt_node.line = node.line
                call_stmt_node.col = node.col
                call_stmt_node.subexprs.add(call_exprs[1])
                var return_stmt_node = new return_stmt.ReturnStmt()
                return_stmt_node.scope = inner_scope
                return_stmt_node.line = node.line
                return_stmt_node.col = node.col

                ast_transform.reparent_stmts_into_closure(
                    func_node, stmts_after, func_node.scope,
                    clone_all_stmts=yes) later:

                ast_analyze.analyze_and_configure_newly_added_func(
                    func_node, msgs=msgs, project_file=pfile
                )
                func_node.func_scope.is_later_func = yes
                assert(not transformed_nodes.has(func_node))
                assert(func_node.func_scope != none)
                if debugger.is_debug_build {
                    for stmt in func_node.subblocks[1] {
                        assert(stmt.scope != none)
                        if stmt.scope.func_scope !=
                                func_node.func_scope {
                            print("later_transform.h64: error: "
                                "Statement has wrong func_scope: " +
                                stmt.as_str())
                            throw new RuntimeError("Internal error.")
                        }
                    }
                }
                var new_root = ast_transform.visit_ast_tree(
                    func_node, later_transform_node, parent_chain=yes,
                    subtree_parent=parents, return_new_root=yes
                ) later:

                await new_root
                assert(new_root != no and new_root != none)
                if typename(new_root) != "list" {
                    new_root = [new_root]
                }
                func_node = new_root[1]
                var result = new_root
                result += [call_stmt_node, return_stmt_node]

                assert(
                    not func_node.func_scope.is_later_func or (
                    func_node.func_scope.
                        later_transform_info != none and
                    func_node.func_scope.later_transform_info.
                        _exit_info != none)
                )
                assert(func_node.scope == call_stmt_node.scope)
                assert(not func_node.subblocks[1].has(call_stmt_node))

                var parent = parents[parents.len]
                var block = ast.get_node_parent_block(
                    node, parent
                )
                assert(block != none)
                var idx = block.find(node)
                assert(idx >= 1)
                var stmt_before = none
                idx += 1
                while idx <= block.len {
                    to_be_deleted_nodes.add(block[idx])
                    idx += 1
                }
                return later result
            }
            if node.kind == ast.N_STMT_RETURN and
                    not transformed_nodes.has(node) and
                    node.scope != none and
                    node.scope.func_scope.is_later_func and
                    does_return_need_callback(
                        node, parents
                    ) {
                transformed_nodes.add(node)
                var line = node.line
                var col = node.col
                if node.scope.later_transform_info == none {
                    node.scope.later_transform_info =
                        new LaterTransformInfo()
                    node.scope.later_transform_info.
                        owning_local_scope = node.scope
                }
                var einfo = node.scope.
                    get_later_transform_info().exit_info()
                assert(
                    node.scope.get_later_transform_info().
                        owning_local_scope == node.scope
                )
                assert(einfo != none)
                var nodes = make_later_return_cb_call(
                    einfo,
                    if node.subexprs.len > 0 (node.subexprs[1])
                        else (none), inner_scope, line, col,
                    call_delayed=yes
                )
                return later nodes
            }
            if node.kind == ast.N_STMT_IF and no {
                var has_later = no
                for clause in node.subexprs {
                    for block in clause.subblocks {
                        var clause_has_later = ast_analyze.
                            stmt_list_contains_later_call(block)
                        if clause_has_later {
                            has_later = yes
                        }
                    }
                }
                if has_later {
                    return later ast_transform.split_if_to_single_clauses(
                        pfile, node, parents[parents.len])
                }
            }
            return later node
        }
        pfile.ensure_ast() later:

        var success = ast_transform.visit_ast_tree(
            pfile.ast, later_transform_node, parent_chain=yes
        ) later:

        await success
        assert(success == yes)
        return later success
    }
    var success = project.do_for_all_files(transform_file)
    later:

    await success
}

