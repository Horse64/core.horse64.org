# @module compiler.comment.command
# Copyright (c) 2023, ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import io from core.horse64.org
import text from core.horse64.org

func _starts_command_comment(s, pos, slen) {
    var code_a = text.code('a')
    var code_cap_a = text.code('A')
    var code_z = text.code('z')
    var code_cap_z = text.code('Z')
    if s[pos] == '@' and
            pos + 1 <= slen and
            ((text.code(s[pos + 1]) >= code_a and
                text.code(s[pos + 1]) <= code_z) or
             (text.code(s[pos + 1]) >= code_cap_a and
                text.code(s[pos + 1]) <= code_cap_z) or
             text.code(s[pos + 1]) > 127) {
        return yes
    }
    return no
}

func get_comments_from_str(
        s, stop_at_noncomment=no, only_doc_comments=yes,
        strip_noncommands=no
        ) {
    var code_a = text.code('a')
    var code_cap_a = text.code('A')
    var code_z = text.code('z')
    var code_cap_z = text.code('Z')

    var comment_lines = []
    var line_had_comment = no
    var i = 1
    while i <= s.len {
        if not line_had_comment and
                not {" ", "\n", "\r", "\t", "#"}.has(s[i]) {
            # This is a non-comment line.

            if stop_at_noncomment {
                break
            }
            while i <= s.len and s[i] != '\r' and
                    s[i] != '\n' and s[i] != '#' {
                i += 1
            }
            if i > s.len or s[i] != '#' {
                while i <= s.len and (
                        s[i] == '\r' or s[i] == '\n') {
                    i += 1
                }
                if comment_lines.len > 0 and
                        comment_lines[comment_lines.len].len > 0 {
                    comment_lines.add("")
                }
                continue
            }
        }
        if s[i] == '#' and not line_had_comment {
            # This is a comment line:

            line_had_comment = yes
            if only_doc_comments and (i + 1 > s.len or
                    s[i + 1] != '#') {
                while i <= s.len and s[i] != '\n' and
                        s[i] != '\r' {
                    i += 1
                }
                line_had_comment = no
                i += 1
                continue
            }
            comment_start = "#"
            i += 1
            while i <= s.len and s[i] == "#" {
                comment_start = "##"
                i += 1
            }
            content_start = i
            if not strip_noncommands {
                # We want entire line rather than just command:
                var had_nonwhitespace = no
                while i <= s.len and s[i] != '\r' and
                        s[i] != '\n' {
                    if _starts_command_comment(s, i, s.len) {
                        if had_nonwhitespace {
                            # To make it easier to parse later,
                            # ensure this command is on a separate line:
                            comment_lines.add(comment_start +
                                s.sub(content_start, i - 1))
                        }
                        comment_start += " "
                        content_start = i
                        while i <= s.len and s[i] != '\r' and
                                s[i] != '\n' {
                            i += 1
                        }
                        break
                    } elseif s[i] != ' ' and s[i] != '\t' {
                        had_nonwhitespace = yes
                    }
                    i += 1
                }
                comment_lines.add(
                    comment_start + s.sub(content_start, i - 1)
                )
                if i + 1 <= s.len and
                        s[i] == '\r' and
                        s[i + 1] == '\n' {
                    i += 1
                }
                i += 1
                line_had_comment = no
                continue
            }
        } elseif s[i] == '\n' or s[i] == '\r' {
            line_had_comment = no
        } elseif line_had_comment and strip_noncommands and
                _starts_command_comment(s, i, s.len) {
            # A special command we're meant to extract:
            var i2 = i
            var options_start = i2
            while i2 <= s.len and s[i2] != '\r' and
                    s[i2] != '\n' {
                i2 += 1
            }
            comment_lines.add("#" + if only_doc_comments
                ("#") else (" ") + s.sub(options_start, i2 - 1).trim())
            if s[i] == '\r' and i + 1 <= s.len and
                    s[i] == '\r' {
                i += 1
            }
        }
        i += 1
    }
    while comment_lines.len > 0 and
            comment_lines[comment_lines.len].len == 0 {
        comment_lines.pop()
    }
    return comment_lines
}

func get_build_options_from_str(s) {
    var lines = get_comments_from_str(
        s, stop_at_noncomment=yes, only_doc_comments=yes,
        strip_noncommands=yes
    )
    var opts_lines = []
    for line in lines {
        if not line.startswith("##@build_options ") {
            continue
        }
        opts_lines.add(line.sub("##@build_options ".len + 1))
    }

    var opts = {->}
    for line in opts_lines {
        var opt_start = 1
        var opt_unquoted_label = ""
        var opt_unquoted_value = none
        var opt_had_assign = no
        var in_quote = none
        var i = 1
        while i <= line.len {
            if i + 1 > line.len or (in_quote == none and (
                    line[i + 1] == ' ' or
                    line[i + 1] == '\t')) or
                    (in_quote != none and in_quote == line[i + 1]) {
                if line[i] != '=' and opt_had_assign {
                    opt_unquoted_value += line[i]
                } else {
                    if line[i] != '=' {
                        opt_unquoted_label += line[i]
                    } else {
                        opt_unquoted_value = ""
                    }
                }
                if opt_unquoted_label.trim().len > 0 {
                    opt_unquoted_label = opt_unquoted_label.trim()
                    if not opts.has(opt_unquoted_label) {
                        opts[opt_unquoted_label] = opt_unquoted_value
                    }
                }
                i += 2
                opt_start = i
                opt_unquoted_label = ""
                opt_unquoted_value = none
                opt_had_assign = no
                in_quote = none
                continue
            } elseif in_quote == none and (
                    line[i] == "'" or line[i] == '"') {
                in_quote = line[i]
                i += 1
                continue
            } elseif in_quote != none and in_quote == line[i] {
                in_quote = none
                i += 1
                continue
            } elseif not opt_had_assign and line[i] == '=' {
                opt_had_assign = yes
                opt_unquoted_value = ""
                i += 1
                continue
            } else {
                if opt_had_assign {
                    opt_unquoted_value += line[i]
                } else {
                    opt_unquoted_label += line[i]
                }
            }
            i += 1
        }
    }
    return opts
}

func get_build_options_from_file(path) {
    with io.open(path, "r") later as f {
        var file_str = f.read() later:

        await result
        return get_build_options_from_str(file_str)
    }
}

