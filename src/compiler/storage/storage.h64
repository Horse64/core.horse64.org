# @module compiler.storage
# Copyright (c) 2023, ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import compiler.ast as ast
import compiler.ast.expr as ast_expr
import compiler.ast.func_stmt as func_stmt
import compiler.ast.transform as transform
import compiler.cext as cext
import compiler.project as project
import compiler.storage.scope as scope
import compiler.storage.scope.global_scope as global_scope
import compiler.storage.ref as storage_ref

extend project.Project {
    var did_compute_scopes = no

    var last_global_storage_id = 0
}

extend ast_expr.IdRefExpr {
    var ref
}

func project.Project.get_free_global_storage_slot {
    var v = self.last_global_storage_id + 1
    self.last_global_storage_id = v
    return v
}

func project.Project.compute_all_scopes(msgs, debug=no) {
    if self.did_compute_scopes {
        if debug {
            print("compiler.ast.storage: compute_all_scopes() " +
                "got nothing to do, scopes already computed.")
        }
        return later yes
    }
    self.did_compute_scopes = yes
    if debug {
        print("compiler.ast.storage: compute_all_scopes() " +
            "starting...")
    }
    assert(msgs != none)
    func try_register_symbol(
            local_scope, symbol_name, msgs, pfile, line, col
            ) {
        if local_scope.name_to_symbol_map.has(symbol_name) {
            var old_symbol =
                local_scope.name_to_symbol_map[symbol_name]
            msgs.add(new msg.FileMsg(
                "Unexpected duplicate name '" + symbol_name + "'"
                ", name was already used in same "
                "scope in statement in line " +
                old_symbol.line.as_str() +
                ", column " + old_symbol.col.as_str() + ".",
                source_file=pfile,
                line=line, col=col
            ))
            return
        } elseif local_scope.func_scope == none {
            msgs.add(new msg.FileMsg(
                "Invalid statement declaring '" + symbol_name + "'"
                ", declaration must be inside type or "
                "func.",
                source_file=pfile,
                line=line, col=col
            ))
            return
        }
        local_scope.name_to_symbol_map[symbol_name] =
            new scope.SymbolInfo(symbol_name)
        local_scope.name_to_symbol_map[symbol_name].storage_id =
            local_scope.func_scope.last_storage_id + 1
        local_scope.name_to_symbol_map[symbol_name].line = line
        local_scope.name_to_symbol_map[symbol_name].col = col
        local_scope.func_scope.last_storage_id += 1
    }
    func compute_scope(pfile) {
        if debug {
            print("compiler.ast.storage: compute_all_scopes() " +
                "compute_scope() on: " + pfile.as_str())
        }
        if debug {
            # Print out if we got weirdly missing file associations:
            for entry in pfile.global_scope.name_to_stmt_map.values() {
                if typename(entry) != "list" or
                        entry[1].kind != ast.N_STMT_IMPORT {
                    continue
                }
                if entry[1].project_file != none or
                        entry[1].cext_modname != none {
                    continue
                }
                print("compiler.ast.storage: compute_all_scopes()'s " +
                    "compute_scope(): Warning, found import " +
                    "statement with no corresponding project file or "
                    "builtin module: " +
                    entry[1].as_str())
            }
        }

        # Do a visitation to figure out the local inner scopes:
        func assign_local_scope(node, parent) {
            if node.kind == ast.N_STMT_TYPE or
                    node.kind == ast.N_STMT_ENUM or
                    node.kind == ast.N_STMT_TYPEEXTEND or
                    node.kind == ast.N_STMT_ENUMEXTEND {
                node.scope = none
                node.func_scope = none
                var escope = pfile.make_type_or_enum_scope_from_node(
                    node, msgs=msgs, project_file=pfile
                )
                if escope == none {
                    # Note: error has already been emitted by
                    # make_type_or_enum_scope_from_node().
                    return later node
                }
                assert(node.type_or_enum_scope == none)
                node.type_or_enum_scope = escope
                # Since the global scope uses copied, separate stand-in
                # nodes, set the type/enum scope to this copy as well:
                if (node.kind == ast.N_STMT_ENUM or
                        node.kind == ast.N_STMT_TYPE) and
                        pfile.global_scope.name_to_stmt_map.has(
                            node.label) {
                    var gscope_node =
                        pfile.global_scope.name_to_stmt_map[node.label]
                    if typename(gscope_node) != "list" and
                            gscope_node.kind == node.kind {
                        gscope_node.type_or_enum_scope = escope
                    }
                }
                var is_enum = if node.kind == ast.N_STMT_ENUM or
                    node.kind == ast.N_STMT_ENUMEXTEND (yes) else (no)
                if not is_enum {
                    if node.subblocks.len < 1 {
                        # This must be a faulty node, abort.
                        return later node
                    }
                    for stmt in node.subblocks[1] {
                        if stmt.kind == ast.N_STMT_VAR {
                            var idx = 0
                            for label in stmt.var_labels {
                                idx += 1
                                if not escope.name_to_symbol_map.
                                        has(label) {
                                    var symbol_info =
                                        new scope.SymbolInfo(label)
                                    symbol_info.def_ine = stmt.line
                                    symbol_info.def_col = stmt.col
                                    symbol_info.def_uri =
                                        pfile.source_uri
                                    symbol_info.storage_id =
                                        escope.name_to_symbol_map.len + 1
                                    if idx <= stmt.subexprs.len {
                                        symbol_info.value_node =
                                            stmt.subexprs[idx]
                                    }
                                    escope.name_to_symbol_map[label] =
                                        symbol_info
                                    continue
                                }
                                # If we arrive here, this name is taken.
                                var old_symbol =
                                    escope.name_to_symbol_map[label]
                                var where = "elsewhere"
                                if old_symbol.def_uri != none {
                                    where = "in " + old_symbol.def_uri
                                    if old_symbol.def_line != none {
                                        where += ":" +
                                            old_symbol.def_line.as_str()
                                        if old_symbol.def_col != none {
                                            where += ":" +
                                                old_symbol.def_col.
                                                as_str()
                                        }
                                    }
                                }
                                if msgs != none {
                                    msgs.add(new msg.FileMsg(
                                        "Invalid var attribute "
                                        "with duplicate name '" +
                                        label +
                                        "', already defined " +
                                        where + ".",
                                        source_file=pfile,
                                        line=stmt.line, col=stmt.col,
                                    ))
                                } else {
                                    throw new ValueError("Invalid var "
                                        "attribute with duplicate name.")
                                }
                            }
                            continue
                        }
                        if msgs != none {
                            msgs.add(new msg.FileMsg(
                                "Invalid statement "
                                "of type " +
                                ast.NodeKind.num_label(stmt.kind) +
                                ", expected var attributes for "
                                "custom type starting in line " +
                                node.line.as_str() + ", column " +
                                node.column.as_str() + ".",
                                source_file=pfile,
                                line=stmt.line, col=stmt.col,
                            ))
                        } else {
                            throw new ValueError("Invalid statement "
                                "inside custom type of type " +
                                ast.NodeKind.num_label(stmt.kind) +
                                ", expected var or func attributes.")
                        }
                    }
                    return later node
                }
                var idx = 0
                for label in node.enum_entry_names {
                    idx += 1
                    if not escope.label_names.has(label) {
                        escope.label_names.add(label)
                        if node.kind == ast.N_STMT_ENUM and
                                escope.first_entry_pos == none {
                            escope.first_entry_pos = idx
                        }
                        var numval =
                            node.enum_entry_nums[idx]
                        if numval == none or
                                not escope.label_nums.has(
                                numval) {
                            escope.label_nums.add(
                                numval
                            )
                            continue
                        }
                        escope.label_nums.add(none)
                        if msgs != none {
                            msgs.add(new msg.FileMsg(
                                "Invalid enum entry "
                                "with duplicate number value " +
                                numval.as_str() +
                                " for label '" +
                                label + "', already used "
                                "previously.",
                                source_file=pfile,
                                line=node.line, col=node.col,
                            ))
                        } else {
                            throw new ValueError("Invalid enum "
                                "entry with duplicate "
                                "number value.")
                        }
                        continue
                    }
                    # If we arrive here, this name is taken.
                    if msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Invalid enum entry "
                            "with duplicate name '" +
                            label +
                            "', already defined "
                            "previously.",
                            source_file=pfile,
                            line=node.line, col=node.col,
                        ))
                    } else {
                        throw new ValueError("Invalid enum "
                            "entry with duplicate name.")
                    }
                }
                return later node
            }
            if node.scope == none and has_attr(parent, "scope") {
                node.scope = parent.scope
            }
            if node.subblocks.len > 0 and
                    # (Note: The following is to skip "clause" nodes,
                    # since these are handled later)
                    (not has_attr(parent, "kind") or
                     (parent.kind != ast.N_STMT_IF and
                      parent.kind != ast.N_STMT_DO)) {
                var inner_scope = new scope.LocalScope()
                inner_scope.parent = node.scope
                if inner_scope.parent != none {
                    inner_scope.func_scope =
                        inner_scope.parent.func_scope
                }
                assert(node.kind != ast.N_STMT_IF or
                    node.subblocks.len == 0)
                for block in node.subblocks {
                    for stmt in block {
                        assert(stmt.scope == none)
                        stmt.scope = inner_scope
                    }
                }
                if node.kind == ast.N_STMT_FUNC {
                    inner_scope.func_scope = new scope.FuncScope()
                    node.func_scope = inner_scope.func_scope
                    if inner_scope.parent != none {
                        inner_scope.func_scope.parent =
                            inner_scope.parent.func_scope
                    }
                    if node.type_path == none {
                        try_register_symbol(inner_scope,
                            node.label, msgs,
                            pfile, node.line, node.col)
                    } else {
                        inner_scope.func_scope.is_type_attr = yes
                    }
                    for label in node.arg_labels {
                        try_register_symbol(inner_scope,
                            label, msgs,
                            pfile, node.line, node.col)
                    }
                } elseif node.kind == ast.N_STMT_FOR {
                    try_register_symbol(inner_scope,
                        node.label, msgs,
                        pfile, node.line, node.col)
                } elseif node.kind == ast.N_STMT_WITH {
                    try_register_symbol(inner_scope,
                        node.label, msgs,
                        pfile, node.line, node.col)
                }
            }
            if node.kind == ast.N_STMT_IF or
                    node.kind == ast.N_STMT_DO {
                for clause in node.subexprs {
                    var inner_scope = new scope.LocalScope()
                    inner_scope.parent = node.scope
                    if inner_scope.parent != none and
                            has_attr(inner_scope.parent, "func_scope") {
                        inner_scope.func_scope =
                            inner_scope.parent.func_scope
                    }
                    for block in clause.subblocks {
                        for stmt in block {
                            assert(stmt.scope == none)
                            stmt.scope = inner_scope
                        }
                    }
                    if clause.kind == ast.N_EXPR_RESCUECLAUSE {
                        for elabel in clause.error_labels {
                            if elabel == none {
                                continue
                            }
                            try_register_symbol(inner_scope,
                                elabel, msgs,
                                pfile, clause.line, clause.col)
                        }
                    }
                }
            }
            if node.kind == ast.N_STMT_VAR and
                    node.scope != none {
                # Inside a function.
                for label in node.var_labels {
                    try_register_symbol(node.scope,
                        label, msgs,
                        pfile, node.line, node.col)
                }
            }
            if node.kind == ast.N_STMT_FUNC and
                    node.scope != none {
                try_register_symbol(node.scope,
                    node.label, msgs,
                    pfile, node.line, node.col)
            }
            return later node
        }
        pfile.ensure_ast() later:

        var success = transform.visit_ast_tree(
            pfile.ast, assign_local_scope
            ) later:

        await success
        assert(success == yes)
        return later yes
    }
    var success = self.do_for_all_files(compute_scope)
    later:

    await success
    func resolve_scope(pfile) {
        pfile.global_scope.ensure_assigned_storage(
            msgs=msgs, project_file=pfile)
        func expr_idref_resolve_visitor(node, parent) {
            if node.kind == ast.N_STMT_FUNC and
                    node.func_scope != none {
                var is_global = no
                var storage_id = 0
                if (parent == none or not has_attr(parent, "kind")) and
                        node.type_path == none {
                    # Global function. Get it from global scope:
                    is_global = yes
                    if pfile.global_scope.
                            name_to_stmt_map.has(node.label) {
                        var el = pfile.global_scope.
                            name_to_stmt_map[node.label]
                        if typename(el) != "list" and
                                el.kind == ast.N_STMT_FUNC and
                                el.symbol_info.storage_id != none {
                            storage_id = el.symbol_info.storage_id
                        }
                    }
                    if storage_id > 0 {
                        # Will only not get here as a run-on error
                        # in damaged code.
                        node.func_scope.global_storage_id = storage_id
                    }
                } else {
                    assert(node.func_scope.global_storage_id == 0 or
                        node.func_scope.global_storage_id == none)
                    storage_id = self.get_free_global_storage_slot()
                    assert(storage_id != 0 and storage_id != none)
                    node.func_scope.global_storage_id = storage_id
                }
                if storage_id > 0 and not is_global {
                    # Register this without a name, we need all funcs in
                    # their global scope.
                    var stand_in_node = new func_stmt.FuncStmt()
                    pfile.global_scope.storage_id_to_entry[
                        storage_id] = stand_in_node
                    stand_in_node.line = node.line
                    stand_in_node.col = node.col
                }
                if storage_id > 0 and
                        pfile.global_scope.storage_id_to_entry.
                        has(storage_id) {
                    pfile.global_scope.storage_id_to_entry[storage_id].
                        func_scope = node.func_scope
                }
            }
            if node.kind == ast.N_EXPR_IDREF {
                if parent.kind == ast.N_EXPR_BINOP and
                        parent.optoken.str == "." {
                    return later node
                }
                if (parent.kind == ast.N_STMT_TYPE or
                        parent.kind == ast.N_STMT_TYPEEXTEND or
                        parent.kind == ast.N_STMT_ENUMEXTEND) and
                        parent.subexprs.len > 0 and
                        parent.subexprs[1] == node {
                    return later none
                }
                var result = pfile.try_lookup_symbol_path(
                    pfile, node.scope,
                    name=node.label,
                    type_path=node.type_path
                )
                if result == none {
                    var ref_name = node.label
                    if node.type_path != none {
                        ref_name = node.type_path.join(".") + "." +
                            ref_name
                    }
                    if msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Unknown reference '" +
                            ref_name +
                            "', can't find what it refers to.",
                            source_file=pfile,
                            line=node.line, col=node.col,
                        ))
                    } else {
                        throw new ValueError(
                            "Unknown reference."
                        )
                    }
                }
            } elseif node.kind == ast.N_EXPR_BINOP and
                    node.optoken.str == "." and
                    (parent.kind != ast.N_EXPR_BINOP or
                     parent.optoken.str != ".") {
                var label = []
                var type_path = []
                var lefthand = node.subexprs[1]
                while yes {
                    if lefthand.kind == ast.N_EXPR_IDREF {
                        var tpath = lefthand.type_path
                        if tpath == none {
                            tpath = []
                        }
                        type_path = tpath +
                            [lefthand.label] + type_path
                        break
                    } elseif lefthand.kind == ast.N_EXPR_BINOP and
                            lefthand.optoken.str == "." {
                        type_path = [lefthand.subexprs[2].label] +
                            type_path
                        assert(lefthand.subexprs[2].type_path == none or
                            lefthand.subexprs[2].type_path.len == 0)
                        lefthand = lefthand.subexprs[1]
                        continue
                    } else {
                        return later node
                    }
                }
                label = type_path.pop()

            }
            return later node
        }
        pfile.ensure_ast() later:

        success = transform.visit_ast_tree(
            pfile.ast, expr_idref_resolve_visitor) later:

        await success
        for storage_id in pfile.global_scope.
                storage_id_to_entry.keys() {
            assert(not self.storage_id_to_global_scope_map.
                   has(storage_id))
            self.storage_id_to_global_scope_map[storage_id] =
                pfile.global_scope
        }
        assert(success == yes)
        return later success
    }
    success = self.do_for_all_files(resolve_scope)
    later:

    await success
    return success
}

extend project.Project {
    var did_compute_storage = no
}

func project.Project.check_all_storage(msgs, debug=no) {
    if self.did_compute_storage {
        if debug {
            print("compiler.ast.storage: check_all_storage() " +
                "got nothing to do, scopes already checked.")
        }
        return later yes
    }
    self.did_compute_storage = yes
    if debug {
        print("compiler.ast.storage: check_all_storage() " +
            "starting...")
    }
    var success = self.compute_all_scopes(msgs, debug=debug) later:

    await success
    if not success {
        return later no
    }
    func check_scope(pfile) {
        if debug {
            print("compiler.ast.storage: check_all_storage() " +
                "check_scope() on: " + pfile.as_str())
        }
        func check_node_scope(node, parent) {
            return later node
        }
        var success = transform.visit_ast_tree(
            pfile.ast, check_node_scope
            ) later:

        await success
        assert(success == yes)
        return later success
    }
    success = self.do_for_all_files(check_scope)
    later:

    await success
    return later success
}

