## @module compiler.storage
# Copyright (c) 2023-2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import debugger from core.horse64.org

import compiler.ast as ast
import compiler.ast.analyze as ast_analyze
import compiler.ast.expr as ast_expr
import compiler.ast.func_stmt as func_stmt
import compiler.ast.transform as transform
import compiler.cext as cext
import compiler.msg as msg
import compiler.project as project
import compiler.storage.scope as st_scope
import compiler.storage.scope.manage as scope_manage
import compiler.storage.scope.global_scope as global_scope
import compiler.storage.ref as st_ref

extend type project.Project {
    var did_compute_scopes = no

    var last_global_storage_id = 0
    var storage_id_to_entry = {->}
    var storage_id_to_project_file = {->}
}

extend type ast_expr.IdRefExpr {
    var ref
}

func project.Project.is_ref_a_type(ref, node=none) {
    if ref.kind == st_ref.ST_CEXT {
        return cext.check_cext_is_type_by_id(self, ref.id)
    } elseif ref.kind == st_ref.ST_GLOBAL {
        if not self.storage_id_to_anscope_map.has(ref.id) {
            return no
        }
        var anscope = self.storage_id_to_anscope_map[ref.id]
        return not anscope.is_enum
    } elseif {st_ref.ST_LOCAL,
            st_ref.ST_CCAPTURE,
            st_ref.ST_ARG,
            st_ref.ST_NUMLITERAL}.has(ref.kind) {
        return no
    } elseif {st_ref.ST_SELF,
            st_ref.ST_BASE,
            st_ref.ST_EXTENDED}.has(ref.kind) {
        # Since this refers to an actual object instance,
        # the correct answer here is it's not a type.
        return no
    } else {
        throw new RuntimeError("Unsupported kind of ref for check.")
    }
}

func project.Project.is_ref_of_given_type_an_error(ref, node=none) {
    if ref.kind == st_ref.ST_CEXT {
        return cext.check_cext_given_type_is_error_by_id(self, ref.id)
    } elseif ref.kind == st_ref.ST_GLOBAL {
        if not self.storage_id_to_anscope_map.has(ref.id) {
            throw new RuntimeError("This ref doesn't refer to a type.")
        }
        var anscope = self.storage_id_to_anscope_map[ref.id]
        if anscope.is_enum or anscope.is_struct {
            throw new RuntimeError("This ref doesn't refer to a type.")
        }
        return anscope.is_error
    } else {
        throw new RuntimeError("This ref doesn't refer to a type.")
    }
}

func project.Project.is_ref_a_struct(ref, node=none) {
    if ref.kind == st_ref.ST_CEXT {
        return cext.check_cext_is_enum_by_id(self, ref.id)
    } elseif ref.kind == st_ref.ST_GLOBAL {
        if not self.storage_id_to_anscope_map.has(ref.id) {
            return no
        }
        var anscope = self.storage_id_to_anscope_map[ref.id]
        return anscope.is_struct
    } elseif {st_ref.ST_LOCAL, st_ref.ST_BASE,
            st_ref.ST_SELF, st_ref.ST_EXTENDED,
            st_ref.ST_NUMLITERAL}.has(ref.kind) {
        return no
    } else {
        throw new RuntimeError("Unsupported kind of ref for check.")
    }
}

func project.Project.is_ref_an_enum(ref, node=none) {
    if ref.kind == st_ref.ST_CEXT {
        return cext.check_cext_is_enum_by_id(self, ref.id)
    } elseif ref.kind == st_ref.ST_GLOBAL {
        if not self.storage_id_to_anscope_map.has(ref.id) {
            return no
        }
        var anscope = self.storage_id_to_anscope_map[ref.id]
        return anscope.is_enum
    } elseif {st_ref.ST_LOCAL, st_ref.ST_BASE,
            st_ref.ST_SELF, st_ref.ST_EXTENDED,
            st_ref.ST_NUMLITERAL}.has(ref.kind) {
        return no
    } else {
        throw new RuntimeError("Unsupported kind of ref for check.")
    }
}

func project.Project.get_free_global_storage_slot {
    var v = self.last_global_storage_id + 1
    self.last_global_storage_id = v
    return v
}

func project.Project.get_project_file_for_anscope(anscope) {
    var search_set
    if anscope.def_file != none {
        search_set = {anscope.def_file}
    } else {
        search_set = {}
        for pfile in self.module_to_uri_file_map.values() {
            search_set.add(pfile)
        }
        for pfile in self.no_uri_files {
                search_set.add(pfile)
        }
    }
    for pfile in search_set {
        if not pfile.global_scope.name_to_stmt_map.has(
                anscope.label) {
            continue
        }
        var entry = pfile.global_scope.name_to_stmt_map[
            anscope.label]
        if entry.attr_names_scope == anscope {
            return pfile
        }
    }
    return none
}

func project.Project.compute_all_scopes(
        msgs, is_moose64=no,
        debug=no, debug_global_storage=no) {
    if self.did_compute_scopes {
        if debug {
            print("compiler.ast.storage: compute_all_scopes() " +
                "got nothing to do, scopes already computed.")
        }
        return later yes
    }

    self.did_compute_scopes = yes
    if debug {
        print("compiler.ast.storage: compute_all_scopes() " +
            "starting...")
    }
    assert(msgs != none)

    if debug {
        print("compiler.ast.storage: compute_all_scopes(): "
            "calling project.init_builtin_syms()...")
    }
    self.init_builtin_syms(is_moose64=is_moose64)
    later:

    func finalize_enum_and_type_storage(project, msgs) {
        # Make sure all enums and types have a storage id:
        for anscope in project.attr_names_scope_map.values() {
            if anscope.is_enum {
                # First, check the specified values aren't conflicting:
                var nums_seen = {}
                var pos = 1
                while pos <= anscope.label_names.len {
                    if anscope.label_nums[pos] == none {
                        pos += 1
                        continue
                    }
                    if nums_seen.has(anscope.label_nums[pos]) {
                        if msgs != none {
                            anscope.damaged = yes
                            msgs.add(new msg.FileMsg(
                                "Unexpected duplicate enum value in "
                                "enum '" + anscope.label + "'"
                                ", value " +
                                anscope.label_nums[pos].as_str() +
                                " was seen twice.",
                                source_file=
                                    project.get_project_file_for_anscope(
                                        anscope),
                                line=anscope.def_line,
                                col=anscope.def_col
                            ))
                        } else {
                            throw new RuntimeError(
                                "Duplicate enum value found.")
                        }
                    } else {
                        nums_seen.add(anscope.label_nums[pos])
                    }
                    pos += 1
                }
                var last_used_num = 0
                # Then, compute the unspecified values:
                var first_run = yes
                while yes {
                    if first_run {
                        pos = anscope.first_entry_pos
                    } else {
                        pos = 1
                    }
                    while pos <= anscope.label_names.len {
                        if anscope.label_nums[pos] != none {
                            last_used_num = anscope.label_nums[pos]
                            pos += 1
                            continue
                        }
                        last_used_num += 1
                        while nums_seen.has(last_used_num) {
                            last_used_num += 1
                        }
                        anscope.label_nums[pos] = last_used_num
                        pos += 1
                    }
                    if not first_run {
                        break
                    }
                    first_run = no
                }
            }

            var gscope_entry_sinfo_found = no
            var search_set
            if anscope.def_file != none {
                search_set = {anscope.def_file}
            } else {
                search_set = {}
                for pfile in self.module_uri_to_file_map.values() {
                    search_set.add(pfile)
                }
                for pfile in self.no_uri_files {
                    search_set.add(pfile)
                }
            }
            for pfile in search_set {
                if not pfile.global_scope.name_to_stmt_map.has(
                        anscope.label) {
                    continue
                }
                var entry = pfile.global_scope.name_to_stmt_map[
                    anscope.label]
                if entry.attr_names_scope != anscope or
                        entry.symbol_info == none {
                    if search_set.len == 1 {
                        print("horsec: error: Fatal internal "
                            "inconsistency, it looks like this "
                            "type had the AttrNamesScope() created "
                            "twice: entry=" + entry.as_str() + " "
                            "entry.attr_names_scope=" +
                            entry.attr_names_scope.as_str() +
                            " vs expected anscope=" + anscope.as_str())
                        throw new RuntimeError("Internal error occured, "
                            "internal type registry is corrupted. "
                            "Please report this bug to the compiler "
                            "makers.")
                    }
                    continue
                }
                gscope_entry_sinfo_found = yes
                if anscope.storage_id != none {
                    if anscope.storage_id !=
                            entry.symbol_info.storage_id {
                        throw new RuntimeError(
                            "Internal error.")
                    }
                } else {
                    anscope.storage_id =
                        entry.symbol_info.storage_id
                }
                assert(not project.
                    storage_id_to_anscope_map.has(
                        anscope.storage_id) or
                    project.storage_id_to_anscope_map[
                        anscope.storage_id] == anscope)
                project.storage_id_to_anscope_map[
                    anscope.storage_id] = anscope
                break
            }
            if not gscope_entry_sinfo_found {
                var had_error = no
                for m in msgs {
                    if m.kind == msg.M_ERROR {
                        had_error = yes
                    }
                }
                if not had_error {
                    print("horsec: error: Fatal error in "
                        "compute_all_scopes(): " +
                        "Internal error occured, can't trace type '" +
                        anscope.label + "' to storage id, it " +
                        "has def_file=" +
                        anscope.def_file.as_str() + " "
                        "and we checked " +
                        search_set.len.as_str() + " "
                        "file(s) without success. "
                        "Full set of files: " +
                        search_set.as_str() + " "
                        "Please report this bug to the compiler "
                        "makers.")
                    for pfile in search_set {
                        print("horsec: debug: Will now dump " +
                            "symbols in global scope of file " +
                            pfile.as_str() + ": file.global_scope."
                            "name_to_stmt_map.keys()=" +
                            pfile.global_scope.
                            name_to_stmt_map.keys().as_str())
                    }
                }
                if not had_error {
                    throw new RuntimeError("Internal error occured, "
                        "failed to trace back type definition to "
                        "global scope storage id despite no malformed "
                        "AST, this should never happen. "
                        "Please report this bug to the compiler "
                        "makers.")
                }
            }
            if debug_global_storage {
                print("compiler.storage: "
                    "compute_all_scopes(): " +
                    "Found global storage id " +
                    anscope.storage_id.as_str() + " for "
                    "type or enum in file " +
                    anscope.def_file.as_str() +
                    " with name '" + anscope.label + "'.")
            }
        }
        # Set base type storage info for all types:
        var had_invalid_base = no
        for anscope_key in project.attr_names_scope_map {
            var anscope = project.attr_names_scope_map[anscope_key]
            if anscope.is_enum or anscope.is_struct {
                continue
            }
            if anscope.base_cext_id != none {
                assert(anscope.base_global_id == none)
                anscope._base_anscope_key = none
                if cext.check_cext_is_type_by_id(
                            project, anscope.base_cext_id) and
                        cext.check_cext_given_type_is_error_by_id(
                            project, anscope.base_cext_id) {
                    anscope.is_error = yes
                }
            }
            if anscope._base_anscope_key == none or
                    anscope.base_global_id != none {
                continue
            }
            if not project.attr_names_scope_map.has(
                    anscope._base_anscope_key) {
                if msgs != none {
                    if not anscope.damaged {
                        msgs.add(new msg.FileMsg(
                            "Unexpected type " +
                            anscope.display_name + " "
                            "deriving from a base type " +
                            anscope.base_display_name + " "
                            "that can't be found.",
                            source_file=project.
                                get_project_file_for_anscope(
                                    anscope),
                            line=anscope.def_line,
                            col=anscope.def_col
                        ))
                    }
                    anscope.damaged = yes
                } else {
                    anscope.damaged = yes
                    throw new RuntimeError(
                        "Base type not found.")
                }
                continue
            }
            var base_anscope_key = anscope._base_anscope_key
            var base_anscope = project.attr_names_scope_map[
                anscope._base_anscope_key]
            anscope._base_anscope_key = none
            anscope.base_global_id =
                base_anscope.storage_id

            # Verify that the base chain doesn't have a cycle:
            var look_at_anscope = anscope
            var seen_nodes = [look_at_anscope]
            var have_seen_damaged = anscope.damaged
            while look_at_anscope != none {
                if look_at_anscope.base_cext_id != none and
                        not cext.check_cext_is_type_by_id(
                        look_at_anscope.base_cext_id) {
                    look_at_anscope.damaged = yes
                }
                # See if this circle leads to an error type:
                if look_at_anscope.is_error or (
                        look_at_anscope.base_cext_id != none and
                        cext.check_cext_is_type_by_id(
                        look_at_anscope.base_cext_id)) {
                    if look_at_anscope.is_error or
                            cext.check_cext_given_type_is_error_by_id(
                            look_at_anscope.base_cext_id) {
                        for node in seen_nodes {
                            node.is_error = yes
                        }
                    }
                    break
                }
                if look_at_anscope.base_global_id == none {
                    break
                }
                if not project.storage_id_to_anscope_map.has(
                        look_at_anscope.base_global_id) {
                    # Should only be possible in case of error.
                    # Nothing we can do.
                    look_at_anscope.damaged = yes
                    break
                }
                if look_at_anscope.base_global_id ==
                        look_at_anscope.storage_id {
                    had_invalid_base = yes
                    if msgs != none {
                        if not have_seen_damaged {
                            msgs.add(new msg.FileMsg(
                                "Type '" + anscope_key + "' can't "
                                "be based on itself.",
                                source_file=project.
                                    get_project_file_for_anscope(
                                        anscope),
                                line=anscope.def_line,
                                col=anscope.def_col
                            ))
                        }
                        anscope.damaged = yes
                    } else {
                        throw new RuntimeError(
                            "Type found based on itself.")
                    }
                    break
                }
                look_at_anscope = project.
                    storage_id_to_anscope_map[
                        look_at_anscope.base_global_id]
                if look_at_anscope.damaged {
                    have_seen_damaged = yes
                }
                seen_nodes.add(look_at_anscope)
                if look_at_anscope.storage_id ==
                        anscope.storage_id {
                    had_invalid_base = yes
                    if msgs != none {
                        if not have_seen_damaged {
                            msgs.add(new msg.FileMsg(
                                "Type '" + anscope_key + "' has "
                                "base type cycle leading back "
                                "to itself, which isn't allowed.",
                                source_file=project.
                                    get_project_file_for_anscope(
                                        anscope),
                                line=anscope.def_line,
                                col=anscope.def_col
                            ))
                        }
                        anscope.damaged = yes
                    } else {
                        throw new RuntimeError(
                            "Base type cycle found.")
                    }
                    break
                }
            }
        }
    }

    func try_register_symbol(
            local_scope, symbol_name, msgs, pfile, line, col
            ) {
        assert(msgs != none)
        if local_scope.name_to_symbol_map.has(symbol_name) {
            var old_symbol =
                local_scope.name_to_symbol_map[symbol_name]
            msgs.add(new msg.FileMsg(
                "Unexpected duplicate name '" + symbol_name + "'"
                ", name was already used in same "
                "scope in statement in line " +
                old_symbol.line.as_str() +
                ", column " + old_symbol.col.as_str() + ".",
                source_file=pfile,
                line=line, col=col
            ))
            return
        } elseif local_scope.func_scope == none {
            msgs.add(new msg.FileMsg(
                "Invalid statement declaring '" + symbol_name + "'"
                ", declaration must be inside type or "
                "func.",
                source_file=pfile,
                line=line, col=col
            ))
            return
        }
        local_scope.add_symbol(symbol_name, pfile, line, col)
    }
    func compute_scope(pfile) {
        if debug {
            print("compiler.ast.storage: compute_all_scopes(): " +
                "compute_scope() on: " + pfile.as_str())
        }
        if debug {
            # Print out if we got weirdly missing file associations:
            for entry in pfile.global_scope.name_to_stmt_map.values() {
                if typename(entry) != "list" or
                        entry[1].kind != ast.N_STMT_IMPORT {
                    continue
                }
                if entry[1].project_file != none or
                        entry[1].cext_modname != none {
                    continue
                }
                print("compiler.ast.storage: compute_all_scopes(): " +
                    "compute_scope(): Warning, found import " +
                    "statement with no corresponding project file or "
                    "builtin module: " +
                    entry[1].as_str())
            }
        }

        # Do a visitation to figure out the local inner scopes:
        func assign_local_scope(node, parent) {
            if node.kind == ast.N_STMT_TYPE or
                    (node.kind == ast.N_STMT_STRUCT and
                    node.label != none) or
                    node.kind == ast.N_STMT_ENUM or
                    node.kind == ast.N_STMT_TYPEEXTEND or
                    node.kind == ast.N_STMT_STRUCTEXTEND or
                    node.kind == ast.N_STMT_ENUMEXTEND {
                assert(is_moose64 or node.kind != ast.N_STMT_STRUCT)
                assert(not is_moose64 or node.kind != ast.N_STMT_TYPE)
                node.scope = none
                node.func_scope = none
                var anscope = pfile.make_attr_names_scope_from_node(
                    node, msgs=msgs, is_moose64=is_moose64,
                    def_project_file=pfile
                )
                if anscope == none {
                    # Note: error has already been emitted by
                    # make_attr_names_scope_from_node().
                    return later node
                }
                assert(node.attr_names_scope == none)
                node.attr_names_scope = anscope
                # Since the global scope uses copied, separate stand-in
                # nodes, set the type/enum scope to this copy as well:
                if (node.kind == ast.N_STMT_ENUM or
                        node.kind == ast.N_STMT_STRUCT or
                        node.kind == ast.N_STMT_TYPE) and
                        pfile.global_scope.name_to_stmt_map.has(
                            node.label) {
                    var gscope_node =
                        pfile.global_scope.name_to_stmt_map[node.label]
                    if typename(gscope_node) != "list" and
                            gscope_node.kind == node.kind {
                        gscope_node.attr_names_scope = anscope
                    }
                    # Since we might have run into an extend first,
                    # we also want to reset the file URI being at the
                    # "core" definition:
                    anscope.def_file = pfile
                    anscope.def_line = node.line
                    anscope.def_col = node.col
                }
                var is_enum = if node.kind == ast.N_STMT_ENUM or
                    node.kind == ast.N_STMT_ENUMEXTEND (yes) else (no)
                var is_struct = if node.kind == ast.N_STMT_STRUCT or
                    node.kind == ast.N_STMT_STRUCTEXTEND (yes) else (no)
                if not is_enum {
                    if node.subblocks.len < 1 {
                        # This must be a faulty node, abort.
                        return later node
                    }
                    for stmt in node.subblocks[1] {
                        func emit_invalid_child_error(stmt, parent) {
                            var stmt_desc = "custom struct"
                            if parent.kind == ast.N_STMT_UNION {
                                stmt_desc = "custom union"
                            } elseif parent.kind == ast.N_STMT_TYPE {
                                stmt_desc = "custom type"
                            }
                            if msgs != none {
                                msgs.add(new msg.FileMsg(
                                    "Invalid statement "
                                    "of type " +
                                    ast.NodeKind.num_label(stmt.kind) +
                                    ", expected var attributes for " +
                                    stmt_desc + " starting in line " +
                                    parent.line.as_str() + ", column " +
                                    parent.col.as_str() + ".",
                                    source_file=pfile,
                                    line=stmt.line, col=stmt.col,
                                ))
                            } else {
                                throw new ValueError("Invalid statement "
                                    "inside custom type or struct or union, "
                                    "expected var or func attributes.")
                            }
                        }
                        func register_var_at_root(var_labels) {
                            var idx = 0
                            for label in var_labels {
                                idx += 1
                                if not anscope.name_to_symbol_map.
                                        has(label) {
                                    var symbol_info =
                                        new st_scope.SymbolInfo(label)
                                    symbol_info.kind = st_scope.SINFO_VARATTR
                                    symbol_info.def_line = stmt.line
                                    symbol_info.def_col = stmt.col
                                    symbol_info.def_file = pfile
                                    symbol_info.storage_id =
                                        anscope.name_to_symbol_map.len + 1
                                    if idx <= stmt.subexprs.len {
                                        symbol_info.value_node =
                                            stmt.subexprs[idx]
                                    }
                                    anscope.name_to_symbol_map[label] =
                                        symbol_info
                                    assert(not anscope.
                                        id_to_symbol_map.has(label))
                                    anscope.id_to_symbol_map[label] =
                                        symbol_info.storage_id
                                    if stmt.symbol_info == none {
                                        stmt.symbol_info = []
                                    }
                                    stmt.symbol_info.add(symbol_info)
                                    continue
                                }
                                # If we arrive here, this name is taken.
                                var old_symbol =
                                    anscope.name_to_symbol_map[label]
                                var where = "elsewhere"
                                if old_symbol.def_file != none and
                                        old_symbol.def_file.
                                            source_uri != none {
                                    where = "in " +
                                        old_symbol.def_file.source_uri
                                    if old_symbol.def_line != none {
                                        where += ":" +
                                            old_symbol.def_line.as_str()
                                        if old_symbol.def_col != none {
                                            where += ":" +
                                                old_symbol.def_col.as_str()
                                        }
                                    }
                                }
                                if msgs != none {
                                    msgs.add(new msg.FileMsg(
                                        "Invalid var attribute "
                                        "with duplicate name '" +
                                        label +
                                        "', already defined " +
                                        where + ".",
                                        source_file=pfile,
                                        line=stmt.line, col=stmt.col,
                                    ))
                                } else {
                                    throw new ValueError("Invalid var "
                                        "attribute with duplicate name.")
                                }
                            }
                            return stmt.symbol_info
                        }
                        if stmt.kind == ast.N_STMT_VAR {
                            register_var_at_root(stmt.var_labels)
                            continue
                        } elseif stmt.kind == ast.N_STMT_UNION or
                                stmt.kind == ast.N_STMT_STRUCT {
                            func handle_nested_struct_or_union(
                                    stmt, name_path=[]
                                    ) {
                                var name_path = name_path.copy()
                                if stmt.kind == ast.N_STMT_STRUCT and
                                        stmt.label != none {
                                    name_path.add(stmt.label)
                                }
                                for st in stmt.subblocks[1] {
                                    if st.kind == ast.N_STMT_UNION or
                                            st.kind == ast.N_STMT_STRUCT {
                                        handle_nested_struct_or_union(
                                            st, name_path=name_path
                                        )
                                        continue
                                    } elseif st.kind != ast.N_STMT_VAR {
                                        emit_invalid_child_error(st, stmt)
                                        continue
                                    }
                                    assert(st.kind == ast.N_STMT_VAR)
                                    var var_paths = []
                                    for lbl in st.var_labels {
                                        var_paths.add(name_path + [lbl])
                                    }
                                    var add_names = []
                                    for vpath in var_paths {
                                        add_names.add(vpath.join("."))
                                    }
                                    var root_sinfo =
                                        register_var_at_root(add_names)
                                    assert(st.symbol_info == none)
                                    st.symbol_info = []
                                    assert(typename(root_sinfo) == "list")
                                    st.symbol_info = root_sinfo
                                }
                            }
                            handle_nested_struct_or_union(stmt)
                            continue
                        }
                        # If we arrive here, it's an invalid item.
                        emit_invalid_child_error(stmt, node)
                    }
                    return later node
                }
                var idx = 0
                for label in node.enum_entry_names {
                    idx += 1
                    if not anscope.label_names.has(label) {
                        anscope.label_names.add(label)
                        if node.kind == ast.N_STMT_ENUM and
                                anscope.first_entry_pos == none {
                            anscope.first_entry_pos = idx
                        }
                        var numval =
                            node.enum_entry_nums[idx]
                        if numval == none or
                                not anscope.label_nums.has(
                                numval) {
                            anscope.label_nums.add(
                                numval
                            )
                            continue
                        }
                        anscope.label_nums.add(none)
                        if msgs != none {
                            msgs.add(new msg.FileMsg(
                                "Invalid enum entry "
                                "with duplicate number value " +
                                numval.as_str() +
                                " for label '" +
                                label + "', already used "
                                "previously.",
                                source_file=pfile,
                                line=node.line, col=node.col,
                            ))
                        } else {
                            throw new ValueError("Invalid enum "
                                "entry with duplicate "
                                "number value.")
                        }
                        continue
                    }
                    # If we arrive here, this name is taken.
                    if msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Invalid enum entry "
                            "with duplicate name '" +
                            label +
                            "', already defined "
                            "previously.",
                            source_file=pfile,
                            line=node.line, col=node.col,
                        ))
                    } else {
                        throw new ValueError("Invalid enum "
                            "entry with duplicate name.")
                    }
                }
                return later node
            }
            if node.kind == ast.N_STMT_STRUCT or
                    node.kind == ast.N_STMT_UNION {
                return later node
            }
            if node.scope == none and has_attr(parent, "scope") {
                node.scope = parent.scope
            }
            if node.subblocks.len > 0 and
                    # (Note: The following is to skip "clause"
                    # nodes since these are handled later)
                    (not has_attr(parent, "kind") or
                     (parent.kind != ast.N_STMT_IF and
                      parent.kind != ast.N_STMT_DO)) {
                var inner_scope = new st_scope.LocalScope()
                inner_scope.start_line = node.line
                inner_scope.start_col = node.col
                inner_scope.parent = node.scope
                if inner_scope.parent != none {
                    inner_scope.func_scope =
                        inner_scope.parent.func_scope
                }
                assert(node.kind != ast.N_STMT_IF or
                    node.subblocks.len == 0)
                for block in node.subblocks {
                    for stmt in block {
                        assert(stmt.scope == none)
                        stmt.scope = inner_scope
                    }
                }
                if node.kind == ast.N_STMT_FUNC or
                        node.kind == ast.N_STMT_FUNCEXTEND {
                    var is_extend =
                        (node.kind == ast.N_STMT_FUNCEXTEND)

                    # Get or construct func scope and base func scope:
                    var base_func_scope =
                        st_scope.get_base_func_scope_from_func_node(
                            pfile, node, msgs=msgs, is_moose64=is_moose64
                        )
                    if node.kind == ast.N_STMT_FUNCEXTEND {
                        inner_scope.func_scope = new st_scope.FuncScope()
                        inner_scope.func_scope.base_func_scope =
                            base_func_scope
                    } else {
                        inner_scope.func_scope = base_func_scope
                        if inner_scope.func_scope == none {
                            assert(node.damaged)
                            inner_scope.func_scope =
                                new st_scope.FuncScope()
                        }
                    }
                    if node.kind == ast.N_STMT_FUNC {
                        inner_scope.func_scope.is_override =
                            node.is_override
                        inner_scope.func_scope.has_failable =
                            node.has_failable
                    }
                    node.func_scope = inner_scope.func_scope
                    node.func_scope.inner_scope = inner_scope

                    # Correctly set the parent scopes:
                    var is_toplevel = yes
                    if inner_scope.parent != none {
                        inner_scope.func_scope.parent =
                            inner_scope.parent.func_scope
                        assert(node.type_path == none)
                        is_toplevel = no
                    }
                    if node.type_path == none {
                        assert(node.kind == ast.N_STMT_FUNC)
                        try_register_symbol(inner_scope,
                            node.label, msgs,
                            pfile, node.line, node.col)
                    } else {
                        inner_scope.func_scope.is_type_attr = yes
                        inner_scope.func_scope.
                            is_type_extend_attr = is_extend
                    }

                    # Make sure our own FuncScope() is found via
                    # the global scope, which has a copy of the node:
                    var gscope = pfile.global_scope
                    if is_toplevel and node.type_path == none {
                        assert(gscope.name_to_stmt_map.has(
                            node.label))
                        var gnode = gscope.name_to_stmt_map[node.label]
                        assert(gnode.kind == ast.N_STMT_FUNC)
                        assert(gnode.func_scope == none)
                        gnode.func_scope = node.func_scope
                    } elseif is_toplevel and node.type_path != none {
                        var tpath = node.type_path.copy()
                        tpath += [node.label]
                        var action = if is_extend ("extended")
                            else ("declared")
                        var type_gnode = none
                        if node.type_path.len == 1 and
                                gscope.name_to_stmt_map.has(
                                    node.type_path[1]
                                ) {
                            type_gnode =
                                gscope.name_to_stmt_map[
                                    node.type_path[1]
                                ]
                        } else {
                            var type_path_without_type =
                                node.type_path.sub(
                                    1, node.type_path.len - 1
                                )
                            var type_name =
                                node.type_path[node.type_path.len]
                            var target_pfile = pfile.global_scope.
                                type_path_to_project_file(
                                    type_path_without_type
                                )
                            if target_pfile != none and
                                    target_pfile.global_scope.
                                    name_to_stmt_map.has(type_name) {
                                type_gnode =
                                    target_pfile.global_scope.
                                    name_to_stmt_map[type_name]
                            }
                        }
                        if type_gnode == none {
                            if msgs != none {
                                if not node.damaged {
                                    msgs.add(new msg.FileMsg(
                                        "Unexpected " + action +
                                        " func attribute '" +
                                        node.label +
                                        "' where underlying type '" +
                                        node.type_path.join(".") +
                                        "' wasn't found.",
                                        source_file=pfile,
                                        line=node.line, col=node.col,
                                    ))
                                }
                                node.damaged = yes
                            } else {
                                throw new ValueError(
                                    "Trying to add func attr to item "
                                    "that isn't a type."
                                )
                            }
                        } elseif not {ast.N_STMT_STRUCT,
                                ast.N_STMT_TYPE
                                }.has(type_gnode.kind) {
                            var have_structs = is_moose64
                            if msgs != none {
                                if not node.damaged {
                                    msgs.add(new msg.FileMsg(
                                        "Unexpected " + action + " "
                                        "func attribute '" +
                                        node.label + "', '" +
                                        node.type_path.join(".").as_str() +
                                        "' exists but isn't a "
                                        "type" + if have_structs
                                            (" or struct.") else ("."),
                                        source_file=pfile,
                                        line=node.line, col=node.col,
                                    ))
                                }
                                node.damaged = yes
                            } else {
                                throw new ValueError(
                                    "Trying to add func attr to item "
                                    "that isn't a type or struct."
                                )
                            }
                        }
                    }
                    # Remember the return type:
                    if node.kind == ast.N_STMT_FUNC {
                        node.func_scope.has_return_type =
                            node.has_return_type
                        assert(node.func_scope.return_type_expr == none)
                        if node.has_return_type {
                            node.func_scope.return_type_expr =
                                node.subexprs[node.subexprs.len]
                        }
                    } elseif node.has_return_type {
                        if msgs != none {
                            if not node.damaged {
                                msgs.add(new msg.FileMsg(
                                    "Unexpected return type for "
                                    "func extend, this can only be "
                                    "specified for the base function.",
                                    source_file=pfile,
                                    line=node.line, col=node.col,
                                ))
                            }
                            node.damaged = yes
                        } else {
                            throw new ValueError(
                                "Can't have return type on func extend."
                            )
                        }
                    }

                    # Register with our base type:
                    if node.kind == ast.N_STMT_FUNCEXTEND and
                            base_func_scope != none {
                        if not base_func_scope.extended_by_scopes.has(
                                node.func_scope) {
                            base_func_scope.extended_by_scopes.add(
                                node.func_scope)
                        }
                    }

                    # If this is a func attribute, set association
                    # with the owning type:
                    var in_anscope = none
                    if is_toplevel and node.type_path != none {
                        var gnode_info =
                            pfile.get_gscope_type_node_info_from_funcattr(
                                node, def_project_file=pfile,
                                msgs=msgs, is_moose64=is_moose64
                            )
                        var gnode = gnode_info[1]
                        if gnode == none {
                            node.damaged = yes
                        }
                        if gnode != none and
                                gnode.symbol_info != none {
                            # (In case of wrong code, this can be none.)
                            assert(gnode.symbol_info.storage_id != none and
                                gnode.symbol_info.storage_id > 0)
                            node.func_scope.owning_type_storage_id =
                                gnode.symbol_info.storage_id
                        }
                        in_anscope =
                            pfile.make_attr_names_scope_from_funcattr(
                                node, def_project_file=pfile,
                                msgs=msgs, is_moose64=is_moose64
                            )
                        if in_anscope == none {
                            node.damaged = yes
                        }
                        node.func_scope.owning_type_scope = in_anscope
                    }

                    # Verify the final func arg list:
                    var final_arg_labels = []
                    var final_pos_args = []
                    var final_arg_count = 0
                    var final_kw_arg_count = 0
                    var invalid = no
                    if node.kind == ast.N_STMT_FUNCEXTEND and
                            node.kw_arg_count < node.arg_labels.len {
                        if msgs != none {
                            if not node.damaged {
                                msgs.add(new msg.FileMsg(
                                    "Unexpectedly seeing new positional "
                                    "arguments in extend func statement, "
                                    "this is not allowed.",
                                    source_file=pfile,
                                    line=node.line, col=node.col,
                                ))
                            }
                            node.damaged = yes
                        } else {
                            throw new ValueError(
                                "Invalid extend func that adds "
                                "pos args."
                            )
                        }
                        invalid = yes
                    }
                    if not node.damaged {
                        final_arg_count = node.extended_final_arg_count()
                        final_arg_labels = node.extended_final_arg_names()
                        final_pos_args = final_arg_labels.copy()
                        final_kw_arg_count = node.extended_final_kw_arg_count()
                    }
                    var final_pos_args = []
                    if final_kw_arg_count < final_arg_count {
                        final_arg_labels = base_arg_labels.sub(
                            1, final_arg_count - final_kw_arg_count
                        )
                    }
                    var idx = 0
                    for new_arg_label in node.arg_labels {
                        idx += 1
                        if idx > final_arg_count - final_kw_arg_count {
                            continue
                        }
                        # XXX/note: final_arg_labels doesn't contain the
                        # new argument info yet.
                        if final_arg_labels.has(new_arg_label) {
                            if msgs != none {
                                msgs.add(new msg.FileMsg(
                                    "Unexpectedly seeing "
                                    "positional argument '" +
                                    new_arg_label +
                                    "' overridden in "
                                    "extend func statement, "
                                    "this is not allowed.",
                                    source_file=pfile,
                                    line=node.line, col=node.col,
                                ))
                                node.damaged = yes
                            } else {
                                throw new ValueError(
                                    "Invalid extend func that "
                                    "overrides a pos arg."
                                )
                            }
                            invalid = yes
                            break
                        }
                    }
                    if not node.damaged and
                            base_func_scope.arg_symbol_info == none {
                        assert(node.func_scope.arg_symbol_info == none)
                        base_func_scope.arg_symbol_info = []
                        node.func_scope.arg_symbol_info =
                            base_func_scope.arg_symbol_info
                        assert(node.func_scope == base_func_scope or
                            node.func_scope.base_func_scope ==
                                base_func_scope)
                        var idx = 0
                        for label in node.arg_labels {
                            idx += 1
                            node.func_scope.add_arg(
                                label, ast_node=node, project_file=pfile,
                                type_expr=final_arg_type_exprs[
                                    node.kw_arg_count + idx
                                ], kw_arg=(idx <=
                                    node.arg_label.len - node.kw_arg_count)
                            )
                        }
                    }
                    assert(base_func_scope == none or node.damaged or
                        node.func_scope.arg_symbol_info ==
                            base_func_scope.arg_symbol_info)
                } elseif node.kind == ast.N_STMT_FOR {
                    try_register_symbol(inner_scope,
                        node.label, msgs,
                        pfile, node.line, node.col)
                } elseif node.kind == ast.N_STMT_WITH {
                    try_register_symbol(inner_scope,
                        node.label, msgs,
                        pfile, node.line, node.col)
                }
            }
            if node.kind == ast.N_STMT_IF or
                    node.kind == ast.N_STMT_DO {
                for clause in node.subexprs {
                    var inner_scope = new st_scope.LocalScope()
                    inner_scope.start_line = node.line
                    inner_scope.start_col = node.col
                    inner_scope.parent = node.scope
                    if inner_scope.parent != none and
                            has_attr(inner_scope.parent, "func_scope") {
                        inner_scope.func_scope =
                            inner_scope.parent.func_scope
                    }
                    for block in clause.subblocks {
                        for stmt in block {
                            assert(stmt.scope == none)
                            stmt.scope = inner_scope
                        }
                    }
                    if clause.kind == ast.N_EXPR_RESCUECLAUSE {
                        var previous_symbol_info = none
                        var elabels_seen = {}
                        for elabel in clause.error_labels {
                            if elabel == none {
                                if clause.symbol_info == none {
                                    clause.symbol_info = []
                                }
                                clause.symbol_info.add(none)
                                continue
                            }
                            if elabels_seen.has(elabel) {
                                # For rescue clauses, we allow duplicate
                                # names. They'll be linked up then.
                                if previous_symbol_info != none {
                                    # (Could be none in case of a
                                    # previous error.)
                                    var dup_sinfo =
                                        previous_symbol_info.copy()
                                    assert(clause.symbol_info != none)
                                    clause.symbol_info.add(dup_sinfo)
                                }
                                continue
                            }
                            elabels_seen.add(elabel)

                            # Register the name:
                            try_register_symbol(inner_scope,
                                elabel, msgs,
                                pfile, clause.line, clause.col)

                            # Add symbol info to our clause:
                            if inner_scope.name_to_symbol_map.
                                    has(elabel) {
                                var symbol_info = inner_scope.
                                    name_to_symbol_map[elabel]
                                if clause.symbol_info == none {
                                    clause.symbol_info = []
                                }
                                clause.symbol_info.add(symbol_info)
                                previous_symbol_info = symbol_info
                            } else {
                                if debugger.is_debug_build {
                                    var had_error = no
                                    if msgs != none {
                                        for m in msgs {
                                            if m.kind == msg.M_ERROR {
                                                had_error = yes
                                            }
                                        }
                                    }
                                    assert(
                                        had_error or
                                        msgs == none
                                    )
                                }
                            }
                        }
                    }
                }
            }
            if node.kind == ast.N_STMT_VAR and
                    node.scope != none {
                # Inside a function.
                for label in node.var_labels {
                    try_register_symbol(node.scope,
                        label, msgs,
                        pfile, node.line, node.col)
                    if not node.scope.name_to_symbol_map.has(label) {
                        continue
                    }
                    var symbol_info = node.scope.name_to_symbol_map[
                        label
                    ]
                    if node.symbol_info == none {
                        node.symbol_info = []
                    }
                    symbol_info.def_line = node.line
                    symbol_info.def_col = node.col
                    symbol_info.def_file = pfile
                    symbol_info.storage_id =
                        node.scope.name_to_symbol_map[label].
                            storage_id
                    node.symbol_info.add(symbol_info)
                }
            }
            if node.kind == ast.N_STMT_FUNC and
                    node.scope != none {
                try_register_symbol(node.scope,
                    node.label, msgs,
                    pfile, node.line, node.col)
            }
            return later node
        }
        pfile.ensure_ast() later:

        var success = transform.visit_ast_tree(
            pfile.ast, assign_local_scope
            ) later:

        await success
        assert(success == yes)
        return later yes
    }
    var success = self.do_for_all_files(compute_scope)
    later:

    await success
    func ensure_global_storage_ids(pfile) {
        pfile.global_scope.ensure_assigned_storage(
            msgs=msgs, project_file=pfile,
            is_moose64=is_moose64,
            debug_global_storage=debug_global_storage)
        return later yes
    }
    success = self.do_for_all_files(ensure_global_storage_ids)
    later:

    await success
    finalize_enum_and_type_storage(self, msgs)

    self.finalize_global_scope_attr_storage(msgs)
    later:

    func resolve_scope(pfile) {
        func expr_idref_resolve_visitor(node, parents) {
            var parent = if parents.len > 0
                (parents[parents.len]) else (none)
            if node.kind == ast.N_STMT_FUNC and
                    node.func_scope != none {
                var is_global = no
                var storage_id = 0
                if (parent == none or not has_attr(parent, "kind")) and
                        node.type_path == none {
                    # Global function. Get it from global scope:
                    is_global = yes
                    if pfile.global_scope.
                            name_to_stmt_map.has(node.label) {
                        var el = pfile.global_scope.
                            name_to_stmt_map[node.label]
                        if typename(el) != "list" and
                                el.kind == ast.N_STMT_FUNC and
                                el.symbol_info.storage_id != none {
                            storage_id = el.symbol_info.storage_id
                        }
                    }
                    if storage_id > 0 {
                        # Will only not get here as a follow-up error
                        # in damaged code.
                        node.func_scope.storage_id = storage_id
                    }
                } else {
                    assert(node.func_scope.storage_id == 0 or
                        node.func_scope.storage_id == none)
                    storage_id = self.get_free_global_storage_slot()
                    assert(storage_id != 0 and storage_id != none)
                    node.func_scope.storage_id = storage_id
                }
                if storage_id > 0 and not is_global {
                    # Register this without a name, we need all funcs in
                    # their global scope.
                    var stand_in_node = new func_stmt.FuncStmt()
                    pfile.global_scope.storage_id_to_entry[
                        storage_id] = stand_in_node
                    stand_in_node.line = node.line
                    stand_in_node.col = node.col
                }
                if storage_id > 0 and
                        pfile.global_scope.storage_id_to_entry.
                        has(storage_id) {
                    pfile.global_scope.storage_id_to_entry[storage_id].
                        func_scope = node.func_scope
                }
            }
            if node.kind == ast.N_EXPR_IDREF {
                if (parent.kind == ast.N_EXPR_BINOP and
                        parent.optoken.str == ".") or
                        node.ref != none {
                    return later node
                }
                if (parent.kind == ast.N_STMT_TYPE or
                        parent.kind == ast.N_STMT_TYPEEXTEND or
                        parent.kind == ast.N_STMT_ENUMEXTEND) and
                        parent.subexprs.len > 0 and
                        parent.subexprs[1] == node {
                    return later node
                }
                var is_write_access =
                    not ast_analyze.is_idref_readonly_access(
                        node, parents)
                var result = pfile.try_lookup_symbol_path(
                    node.scope,
                    name=node.label,
                    type_path=node.type_path,
                    is_write_access=is_write_access,
                    is_moose64=is_moose64,
                )
                if result == none or result == no {
                    var ref_name = node.label
                    if node.type_path != none {
                        ref_name = node.type_path.join(".") + "." +
                            ref_name
                    }
                    if msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Unknown reference '" +
                            ref_name +
                            "', can't find what it refers to.",
                            source_file=pfile,
                            line=node.line, col=node.col,
                        ))
                    } else {
                        throw new ValueError(
                            "Unknown reference."
                        )
                    }
                } else {
                    node.ref = result
                }
                return later node
            } elseif node.kind == ast.N_EXPR_BINOP and
                    node.optoken.str == "." and
                    node.subexprs.len == 2 and
                    (parent.kind != ast.N_EXPR_BINOP or
                     parent.optoken.str != ".") and
                    node.subexprs[2].kind == ast.N_EXPR_IDREF {
                var is_write_access =
                    not ast_analyze.is_idref_readonly_access(
                        node, parents)
                var label = node.subexprs[2].label
                var type_path = []
                var lefthand = node.subexprs[1]
                while yes {
                    if lefthand.kind == ast.N_EXPR_IDREF {
                        var tpath = lefthand.type_path
                        if tpath == none {
                            tpath = []
                        }
                        type_path = tpath +
                            [lefthand.label] + type_path
                        break
                    } elseif lefthand.kind == ast.N_EXPR_BINOP and
                            lefthand.optoken.str == "." {
                        type_path = [lefthand.subexprs[2].label] +
                            type_path
                        assert(lefthand.subexprs[2].type_path == none or
                            lefthand.subexprs[2].type_path.len == 0)
                        lefthand = lefthand.subexprs[1]
                        continue
                    } else {
                        return later node
                    }
                }
                var most_lefthand = type_path[1]
                var omitted_righthands = 0
                var failed_item_name = most_lefthand
                var failed_item_name_from_import = no
                var ref
                while yes {
                    ref = pfile.try_lookup_symbol_path(
                        node.scope, name=label, type_path=type_path,
                        is_write_access=is_write_access,
                        is_moose64=is_moose64)
                    if ref != none or type_path.len == 0 {
                        if ref == no {
                            # -> import found, but doesn't have this item.
                            failed_item_name =
                                type_path.join(".") + "." + label
                            ref = none
                        }
                        break
                    }
                    if not failed_item_name_from_import {
                        var attempt_find_import =
                            pfile.global_scope.type_path_to_entry(
                                type_path)
                        if attempt_find_import != none and
                                attempt_find_import.kind ==
                                    ast.N_STMT_IMPORT {
                            failed_item_name_from_import = yes
                            failed_item_name =
                                type_path.join(".") + "." + label
                            # We must still continue trying, because
                            # with shadowing a local var might override
                            # an import and then this will still work
                            # out.
                            # Therefore, no 'break' here.
                        }
                    }
                    omitted_righthands += 1
                    label = type_path.pop()
                }
                if ref == none {
                    if msgs != none {
                        msgs.add(new msg.FileMsg(
                            "Unknown reference '" +
                            failed_item_name +
                            "', can't find what it refers to.",
                            source_file=pfile,
                            line=node.line, col=node.col,
                        ))
                    } else {
                        throw new ValueError(
                            "Unknown reference."
                        )
                    }
                } else {
                    var replacement_idref = new ast_expr.IdRefExpr()
                    replacement_idref.scope = node.scope
                    replacement_idref.line = node.line
                    replacement_idref.col = node.col
                    replacement_idref.label = label
                    assert(type_path == none or
                        typename(type_path) == "list")
                    if type_path.len == 0 {
                        type_path = none
                    }
                    replacement_idref.type_path = type_path
                    if replacement_idref.type_path == "" {
                        replacement_idref.type_path = none
                    }
                    replacement_idref.ref = ref

                    if omitted_righthands == 0 {
                        # Nuke the original node and subtree,
                        # replace with a new consolidated one:
                        return later replacement_idref
                    } else {
                        var lookat_parent = none
                        var lookat_node = node
                        var i = 1
                        while i <= omitted_righthands {
                            lookat_parent = lookat_node
                            lookat_node = lookat_node.subexprs[1]
                            i += 1
                        }
                        lookat_node = replacement_idref
                        lookat_parent.subexprs[1] = lookat_node
                        return later node
                    }
                }
            }
            return later node
        }
        pfile.ensure_ast() later:

        success = transform.visit_ast_tree(
            pfile.ast, expr_idref_resolve_visitor,
            parent_chain=yes) later:

        await success
        for storage_id in pfile.global_scope.
                storage_id_to_entry.keys() {
            assert(not self.storage_id_to_global_scope_map.
                   has(storage_id) or
                   self.storage_id_to_global_scope_map
                       [storage_id] == pfile.global_scope)
            self.storage_id_to_global_scope_map[storage_id] =
                pfile.global_scope
        }
        assert(success == yes)

        success = scope_manage.visit_to_resolve_known_attrs(
            pfile, msgs
        ) later:

        await success
        return later success
    }
    success = self.do_for_all_files(resolve_scope)
    later:

    await success
    return success
}

extend type project.Project {
    var did_compute_storage = no
}

func project.Project.compute_and_check_all_storage(
        msgs, build_options=none, debug=no,
        debug_global_storage=no
        ) {
    var is_moose64 = no
    if build_options != none and build_options.is_moose64 {
        is_moose64 = yes
    }
    if self.did_compute_storage {
        if debug {
            print("compiler.ast.storage: compute_and_check_all_storage() " +
                "got nothing to do, scopes already checked.")
        }
        return later yes
    }
    self.did_compute_storage = yes
    if debug {
        print("compiler.ast.storage: check_all_storage() " +
            "starting...")
    }
    var success = self.compute_all_scopes(
        msgs, is_moose64=is_moose64,
        debug=debug,
        debug_global_storage=debug_global_storage) later:

    await success
    return later success
}

