## @module compiler.storage.scope.global_scope
# Copyright (c) 2023-2025, ellie/@ell1e & Horse64's contributors
# (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import compiler.ast as ast
import compiler.ast.c_import_stmt as c_import_stmt
import compiler.ast.enum_stmt as enum_stmt
import compiler.ast.func_stmt as func_stmt
import compiler.ast.struct_or_union_stmt as struct_or_union_stmt
import compiler.ast.type_stmt as type_stmt
import compiler.ast.var_stmt as var_stmt
import compiler.msg as msg
import compiler.project as project
import compiler.storage.ref as st_ref
import compiler.storage.scope as st_scope
import compiler.token as token
import compiler.typeinfo.ast_typeref as ast_typeref

import compiler.moose64.c_importer as c_importer

type GlobalScope {
    var name_to_stmt_map = {->}
    var storage_id_to_entry = {->}
    var func_attr_nodes = {}

    var known_to_be_in_project_file = none

    var _did_final_ensuring_of_storage_ids = no
}

func GlobalScope.as_str {
    var result = "GlobalScope<"
    var isfirst = yes
    for name in self.name_to_stmt_map {
        if not isfirst {
            result += "; "
        } else {
            isfirst = no
        }
        result += "name='" + name + "',kind="
        result += ast.NodeKind.num_label(
            if typename(self.name_to_stmt_map[name]) == "list"
                (self.name_to_stmt_map[name][1].kind) else
                (self.name_to_stmt_map[name].kind))
    }
    result += ">"
    return result
}

func GlobalScope.as_json_obj {
    var result = []
    for name in self.name_to_stmt_map {
        var entry = {"name"-> name}
        entry["kind"] = ast.NodeKind.num_label(
            if typename(self.name_to_stmt_map[name]) == "list"
                (self.name_to_stmt_map[name][1].kind) else
                (self.name_to_stmt_map[name].kind))
        result.add(entry)
    }
    return result
}

func project.Project.get_true_global_node_from_shallow_node(
        shallow_node, project_file=none, is_moose64=no
        ) {
    if typename(shallow_node) == "list" or
            shallow_node.symbol_info == none or
            project_file == none {
        return later none
    }

    project_file.ensure_ast()
    later:

    if shallow_node.kind == ast.N_STMT_FUNC and
            shallow_node.func_scope != none and
            shallow_node.func_scope.is_closure {
        # FIXME: We need to walk the entire AST here to find it.
        return later none
    }
    for stmt in project_file.ast.stmts {
        if stmt.kind != shallow_node.kind {
            continue
        }
        if {ast.N_STMT_FUNC, ast.N_STMT_TYPE,
                ast.N_STMT_STRUCT}.has(stmt.kind) and
                (stmt.kind != ast.N_STMT_FUNC or
                 ((stmt.type_path == none or
                   stmt.type_path.len == 0) and
                  (shallow_node.type_path == none or
                   shallow_node.type_path.len == 0))) {
            if stmt.label != shallow_node.label {
                continue
            }
            return later stmt
        }
        if stmt.kind == ast.N_STMT_FUNC and
                shallow_node.type_path != none and
                shallow_node.type_path.len > 0 and
                stmt.type_path != none and
                stmt.type_path.len > 0 {
            if stmt.label != shallow_node.label or
                    stmt.type_path.len !=
                    shallow_node.type_path.len {
                continue
            }
            var mismatch = no
            var idx = 0
            for path_item in stmt.type_path {
                idx += 1
                if shallow_node.type_path[idx] != path_item {
                    mismatch = yes
                    break
                }
            }
            if mismatch {
                continue
            }
            return later stmt
        }
    }
    return later none
}

func project.Project.finalize_func_typerefs_all_files(
        msgs=none, is_moose64=no,
        ) {
    # XXX/WARNING: .ensure_assigned_storage() is required on ALL
    # scopes BEFORE calling this function.

    func fix_func_typeref_exprs_for_file(pfile) {
        assert(pfile.project.is_moose64 == is_moose64)
        for name in pfile.global_scope.name_to_stmt_map {
            var value = pfile.global_scope.name_to_stmt_map[name]
            if typename(value) == "list" {
                # Import entries have no storage or symbol info.
                continue
            } elseif has_attr(value, "is_enum_entry") and
                    value.is_enum_entry {
                # This is a single text entry of an enum, not a func.
                continue
            } elseif value.kind == ast.N_STMT_FUNC {
                # (Note: the func attrs are handled in the loop below.
                # This is just funcs which aren't attributes.)
                assert(value.type_path == none or
                    value.type_path.len == 0)
                var lbl = value.label
                assert(pfile.global_scope.name_to_stmt_map.has(lbl))
                var si = value.symbol_info
                si.typeref_expr =
                    ast_typeref.create_typeref_from_func_node(
                        pfile, value, debug=no
                    )
                assert(lbl == none or si.typeref_expr.name != none)
                assert(si.typeref_expr == none or
                    si.typeref_expr.is_func_ref)
                if is_moose64 and si.typeref_expr == none {
                    print("moosec: error: Internal error, unexpectedly "
                        "failed to compute typeref expr for func node: " +
                        value.as_str() + " Please report this error "
                        "to the compiler makers.")
                    throw new RuntimeError("Internal error.")
                }
                if si.typeref_expr != none {
                    si.typeref_expr.func_storage_ref = new st_ref.StorageRef(
                        st_ref.ST_GLOBAL, si.storage_id
                    )
                }
            }
        }
        return later yes
    }

    var success = self.do_for_all_files(
        fix_func_typeref_exprs_for_file)
    later:

    await success
    if not success {
        return later no
    }

    func fix_func_symbol_info_for_file(pfile) {
        if not is_moose64 {
            # For now, we won't set type expressions for horse64.
            return later yes
        }
        for stmt in pfile.ast.stmts {
            if stmt.kind == ast.N_STMT_FUNC and
                    stmt.type_path != none and
                    stmt.type_path.len > 0 {
                assert(stmt.scope == none)
                var anscope = pfile.
                    make_attr_names_scope_from_funcattr(
                        stmt, msgs=msgs, is_moose64=is_moose64,
                        def_project_file=pfile
                    )
                if anscope == none {
                    # Note: error has already been emitted by
                    # make_attr_names_scope_from_funcattr().
                    continue
                }
                var symbol_info = stmt.symbol_info
                assert(symbol_info.kind == st_scope.SINFO_FUNCATTR)
                assert(anscope.storage_id != none)
                if symbol_info.typeref_expr == none {
                    symbol_info.typeref_expr =
                        ast_typeref.create_typeref_from_func_node(
                            pfile, stmt
                        )
                    assert(symbol_info.typeref_expr.is_func_ref)
                }
                if symbol_info.type_storage_ref == none {
                    symbol_info.type_storage_ref =
                        new st_ref.StorageRef(
                            st_ref.ST_GLOBALATTR,
                            [anscope.storage_id,
                                symbol_info.storage_id]
                        )
                    symbol_info.typeref_expr.func_storage_ref =
                        symbol_info.type_storage_ref
                } else {
                    assert(symbol_info.type_storage_ref.kind ==
                        st_ref.ST_GLOBALATTR)
                }
                var lbl = stmt.label
                assert(not anscope.name_to_symbol_map.has(lbl) or
                    anscope.name_to_symbol_map[lbl] == symbol_info)
                anscope.name_to_symbol_map[lbl] =
                    symbol_info
                assert(not anscope.
                        id_to_symbol_map.has(symbol_info.storage_id) or
                    anscope.id_to_symbol_map[symbol_info.storage_id] ==
                        symbol_info)
                anscope.id_to_symbol_map[symbol_info.storage_id] =
                    symbol_info
                stmt.symbol_info = symbol_info
            }
        }
        return later yes
    }

    success = self.do_for_all_files(
        fix_func_symbol_info_for_file)
    later:

    await success
    if not success {
        return later no
    }

    func fix_func_symbol_info_for_file_2(pfile) {
        var queue = []
        func queue_funcs(block) {
            for stmt in block {
                if stmt.kind == ast.N_STMT_FUNC {
                    queue.add(stmt)
                }
                if stmt.subblocks.len > 0 {
                    for subblock in stmt.subblocks {
                        queue_funcs(subblock)
                    }
                }
                if {ast.N_STMT_IF, ast.N_STMT_DO}.has(
                        stmt.kind) {
                    for clause in stmt.subexprs {
                        for subblock in clause.subblocks {
                            queue_funcs(subblock)
                        }
                    }
                }
            }
        }
        queue_funcs(pfile.ast.stmts)

        func handle_func(stmt) {
            # Resolve all the function parameters, now that
            # targeting all nested function types and user types
            # should work.
            var symbol_info = stmt.symbol_info
            if not is_moose64 and symbol_info.typeref_expr == none {
                return later yes
            }
            var typeref_expr = symbol_info.typeref_expr
            assert(typeref_expr != none)
            var result =
                typeref_expr.try_resolve_to_user_type(
                    pfile, is_moose64=is_moose64
                ) later:

            await result
            if result.had_error {
                typeref_expr.try_resolve_to_user_type(
                    pfile, is_moose64=is_moose64,
                    debug=yes,
                ) later:

                if msgs != none and
                        not msg.msgs_contain_error(msgs) {
                    msgs.add(new msg.FileMsg(
                        "Unexpected use "
                        "of type " +
                        result.error_ast_typeref.describe_to_user(
                            project=pfile.project,
                            is_moose64=is_moose64) + ", "
                        "couldn't find definition for type.",
                        source_file=pfile,
                        line=stmt.line,
                        col=stmt.col,
                    ))
                }
                stmt.damaged = yes
                return later no
            }
            return later yes
        }
        if queue.len == 0 {
            return later yes
        }
        var item = queue.pop()
        var result = handle_func(item) later:

        await result
        if not result {
            return later no
        }
        if queue.len == 0 {
            return later yes
        }
        item = queue.pop()
        result = handle_func(item) later repeat
    }

    success = self.do_for_all_files(
        fix_func_symbol_info_for_file_2)
    later:

    await success
    if not success {
        return later no
    }

    return later success
}

func GlobalScope.ensure_basic_assigned_storage(
        msgs=none, project_file=none,
        is_moose64=no, debug_global_storage=no) {
    # Compute global storage for all values that don't have it yet:
    var storage_num = 1
    if project_file != none and project_file.project != none {
        storage_num = project_file.project.
            last_global_storage_id + 1
    }
    for name in self.name_to_stmt_map {
        var value = self.name_to_stmt_map[name]
        if typename(value) == "list" {
            # Import entries have no storage or symbol info.
            continue
        } elseif value.symbol_info == none and
                not {ast.N_STMT_ENUMEXTEND, ast.N_STMT_STRUCTEXTEND,
                ast.N_STMT_TYPEEXTEND}.has(value.kind) {
            assert(not self.storage_id_to_entry.has(storage_num))
            self.storage_id_to_entry[storage_num] = value
            if project_file != none and project_file.project != none {
                var pr = project_file.project
                assert(not pr.storage_id_to_entry.has(storage_num))
                pr.storage_id_to_entry[storage_num] = value
                pr.storage_id_to_project_file[storage_num] =
                    project_file
            }
            var si = new st_scope.SymbolInfo(name)
            if value.kind == ast.N_STMT_FUNC {
                si.kind = st_scope.SINFO_FUNC
            } elseif value.kind == ast.N_STMT_TYPE {
                si.kind = st_scope.SINFO_TYPE
            } elseif value.kind == ast.N_STMT_STRUCT {
                si.kind = st_scope.SINFO_STRUCT
            } elseif value.kind == ast.N_STMT_ENUM {
                si.kind = st_scope.SINFO_ENUM
            }
            si.def_line = value.line
            si.def_col = value.col
            if project_file != none {
                si.def_file = project_file
            }
            si.storage_id = storage_num
            if debug_global_storage {
                print("compiler.storage.scope.global_scope: "
                    "GlobalScope.ensure_assigned_storage(): " +
                    "Assigning global storage id " +
                    storage_num.as_str() + " to global scope "
                    "item in file " +
                    if project_file != none
                        (project_file.source_uri.as_str()) else
                        ("<unknown>") +
                    " with name '" + name + "'.")
            }
            if value.kind == ast.N_STMT_VAR {
                if value.symbol_info == none {
                    value.symbol_info = []
                }
                value.symbol_info.add(si)
            } else {
                value.symbol_info = si
            }
            if project_file != none and project_file.project != none {
                project_file.project.storage_id_to_global_scope_map
                    [storage_num] = self
            }
            storage_num += 1
        }
    }
    if project_file != none and project_file.project != none {
        project_file.project.last_global_storage_id =
            storage_num - 1
    }
}

func GlobalScope.ensure_assigned_storage(
        msgs=none, project_file=none, is_moose64=no,
        debug_global_storage=no) {
    if self._did_final_ensuring_of_storage_ids or
            self.name_to_stmt_map.len == 0 {
        return
    }
    self._did_final_ensuring_of_storage_ids = yes
    assert(project_file == none or
        project_file.global_scope == self)

    var ast_tree = none
    if project_file != none and project_file.ast != none {
        ast_tree = project_file.ast
    }

    # First, ensure the basic storage being set:
    self.ensure_basic_assigned_storage(
        msgs=msgs, project_file=project_file,
        is_moose64=is_moose64,
        debug_global_storage=debug_global_storage,
    )

    # Now register enum values in the global scope too:
    var names_unchanged = self.name_to_stmt_map.keys()
    for name in names_unchanged {
        var value = self.name_to_stmt_map[name]
        if typename(value) == "list" or
                value.kind != ast.N_STMT_ENUM {
            continue
        }
        if value.attr_names_scope == none {
            continue
        }
        assert(value.attr_names_scope.is_enum)
        var pos = 0
        for label in value.attr_names_scope.label_names {
            pos += 1
            if self.name_to_stmt_map.has(label) {
                if msgs != none {
                    var old_symbol = self.name_to_stmt_map[label]
                    if typename(old_symbol) == "list" {
                        old_symbol = old_symbol[1]
                    }
                    msgs.add(new msg.FileMsg(
                        "Unexpected duplicate name '" + label + "'"
                        ", name was already used in same "
                        "scope in statement in line " +
                        old_symbol.line.as_str() +
                        ", column " + old_symbol.col.as_str() + ".",
                        source_file=project_file,
                        line=value.line, col=value.col
                    ))
                }
                continue
            }
            var entry = new st_scope.GlobalScopeEnumEntry()
            assert(value.label != none)
            entry.enum_stmt_label = value.label
            var si = new st_scope.SymbolInfo(label)
            si.def_line = value.line
            si.def_col = value.col
            if project_file != none {
                si.def_file = project_file
            }
            si.storage_id = pos
            entry.symbol_info = si
            self.name_to_stmt_map[label] = entry
        }
    }

    # If an AST is available, transfer the symbol info over
    # to the original definitions:
    if project_file != none and ast_tree != none {
        self.finalize_gscope_with_ast_tree_info(
            project_file, ast_tree, msgs=msgs,
            is_moose64=is_moose64
        )
    }
}

func GlobalScope.get_import_path_for_global(
        project_file, storage_id
        ) {
    if typename(storage_id) != "num" {
        throw new TypeError("Storage id must be number.")
    }
    if self.storage_id_to_entry.has(storage_id) {
        return []
    }
    if not project_file.project.
            storage_id_to_global_scope_map.has(storage_id) {
        print("horsec: error: Fatal internal error: "
            "GlobalScope.get_import_path_for_global() was passed "
            "invalid storage_id G" + storage_id.as_str() + " that "
            "isn't registered anywhere.")
        throw new ValueError("Invalid unknown storage id.")
    }
    var target_gscope = project_file.project.
        storage_id_to_global_scope_map[storage_id]
    if target_gscope == self {
        return []
    }

    # It's in a different module, try to set the
    # import path according to our actual local import
    # statements:
    var found = no
    for name in self.name_to_stmt_map {
        var item = self.name_to_stmt_map[name]
        if typename(item) != "list" {  # Not an import.
            continue
        }
        for importst in item {
            if importst.kind != ast.N_STMT_IMPORT {
                continue
            }
            if importst.project_file != none and
                    importst.project_file.
                    global_scope == target_gscope {
                found = yes
                if importst.renamed_as != none {
                    return [
                        importst.renamed_as
                    ]
                } else {
                    return importst.module_path.copy()
                }
                break
            }
            if found {
                break
            }
        }
    }
    throw new ValueError("Unexpectedly failed "
        "to find out how to reach given global.")
}

func GlobalScope.finalize_gscope_with_ast_tree_info(
        project_file, ast_tree, msgs=none, is_moose64=no
        ) {
    if self.known_to_be_in_project_file == none {
        self.known_to_be_in_project_file = project_file
    }
    for stmt in ast_tree.stmts {
        if {ast.N_STMT_FUNC, ast.N_STMT_STRUCT,
                ast.N_STMT_TYPE}.has(stmt.kind) {
            var lbl = stmt.label
            if stmt.symbol_info == none and
                    stmt.kind == ast.N_STMT_FUNC and
                    stmt.type_path != none and
                    stmt.type_path.len > 0 {
                assert(stmt.scope == none)
                var anscope = project_file.
                    make_attr_names_scope_from_funcattr(
                        stmt, msgs=msgs, is_moose64=is_moose64,
                        def_project_file=project_file
                    )
                if anscope == none {
                    # Note: error has already been emitted by
                    # make_attr_names_scope_from_funcattr().
                    continue
                }
                if anscope.name_to_symbol_map.has(lbl) {
                    if msgs == none {
                        throw new ValueError(
                            "Duplicate func attr"
                        )
                    }
                    msgs.add(new msg.FileMsg(
                        "Invalid func attribute "
                        "with duplicate name '" +
                        lbl +
                        "', already defined elsewhere.",
                        source_file=project_file,
                        line=stmt.line, col=stmt.col,
                    ))
                    continue
                }
                var symbol_info = new st_scope.SymbolInfo(lbl)
                symbol_info.kind = st_scope.SINFO_FUNCATTR
                symbol_info.def_line = stmt.line
                symbol_info.def_col = stmt.col
                symbol_info.def_file = project_file
                var next_id = anscope.last_used_varattr_id + 1
                symbol_info.storage_id = next_id
                anscope.last_used_varattr_id = next_id

                stmt.symbol_info = symbol_info
                anscope.name_to_symbol_map[lbl] = symbol_info
                anscope.id_to_symbol_map[
                    symbol_info.storage_id] = symbol_info
                anscope.id_to_def_file_map[
                    symbol_info.storage_id] = self
                anscope.id_to_origin_gscope_map[
                    symbol_info.storage_id] = self
                continue
            }
            assert(self.name_to_stmt_map.has(lbl))
            var si = self.name_to_stmt_map[lbl].symbol_info
            assert(si != none)
            stmt.symbol_info = si
        } elseif stmt.kind == ast.N_STMT_VAR {
            if stmt.symbol_info == none {
                stmt.symbol_info = []
            }
            for lbl in stmt.var_labels {
                if not self.name_to_stmt_map.has(lbl) {
                    continue
                }

                var si_list = self.name_to_stmt_map[lbl].symbol_info
                assert(typename(si_list) == "list")
                var source_idx = none
                var i = 1
                while i <= si_list.len {
                    if si_list[i].name == lbl {
                        source_idx = i
                        break
                    }
                    i += 1
                }
                if source_idx == none {
                    continue
                }

                var target_idx = none
                i = 1
                while i <= stmt.symbol_info.len {
                    if stmt.symbol_info[i].name ==
                            si_list[source_idx].name {
                        stmt.symbol_info[i] = si_list[source_idx]
                        target_idx = i
                        break
                    }
                    i += 1
                }
                if not target_idx {
                    stmt.symbol_info.add(si_list[source_idx])
                }
            }
        }
    }
}

func GlobalScope.find_global_entry_in_full_project(
        tpath, debug=no
        ) {
    if typename(tpath) == "str" {
        tpath = tpath.split(".")
    }
    var gscope = self
    var entry_gnode = none
    if tpath.len == 1 and
            gscope.name_to_stmt_map.has(
                tpath[1]
            ) {
        entry_gnode =
            gscope.name_to_stmt_map[
                tpath[1]
            ]
        return entry_gnode
    } else {
        var type_path_without_type =
            tpath.sub(
                1, tpath.len - 1
            )
        var entry_name = tpath[tpath.len]
        var target_pfile = pfile.global_scope.
            type_path_to_project_file(
                type_path_without_type
            )
        if target_pfile != none and
                target_pfile.global_scope.
                name_to_stmt_map.has(entry_name) {
            entry_gnode =
                target_pfile.global_scope.
                name_to_stmt_map[entry_name]
        }
        return entry_gnode
    }
}

func GlobalScope.type_path_to_entry(tpath, debug=no) {
    if typename(tpath) == "str" {
        tpath = tpath.split(".")
    }
    if debug {
        print("horsec: debug: " +
            "type_path_to_entry(): Got tpath=" +
            tpath.as_str() + " and starting lookup.")
    }
    if tpath.len == 0 or
            not self.name_to_stmt_map.has(tpath[1]) {
        if debug {
            print("horsec: debug: " +
                "type_path_to_entry(): No global starting "
                "with this path, returning none.")
        }
        return none
    }
    # Handling of most things that aren't an import:
    if typename(self.name_to_stmt_map[tpath[1]]) != "list" {
        if tpath.len != 1 {
            if debug {
                print("horsec: debug: " +
                    "type_path_to_entry(): It's not an import "
                    "but tpath is multiple items, aborting.")
            }
            return none
        }
        if debug {
            print("horsec: debug: " +
                "type_path_to_entry(): Found match.")
        }
        return self.name_to_stmt_map[tpath[1]]
    }

    # Handling of imports:
    if debug {
        print("horsec: debug: " +
            "type_path_to_entry(): Type path start "
            "matched an import, searching for a match.")
    }
    var longest_match_len = -1
    var longest_match_entry = none
    for entry in self.name_to_stmt_map[tpath[1]] {
        assert(entry.kind == ast.N_STMT_IMPORT or
            entry.kind == ast.N_STMT_C_IMPORT)
        if tpath.len == 1 and entry.renamed_as != none and
                tpath[1] == entry.renamed_as {
            if entry.kind != ast.N_STMT_C_IMPORT and
                    entry.project_file == none and
                    entry.cext_modname != none {
                return (
                    entry.cext_modname + "@" +
                    entry.cext_pkgname
                )
            }
            return entry
        }
        if entry.kind == ast.N_STMT_C_IMPORT or
                entry.module_path.len != tpath.len {
            continue
        }
        var mismatch = no
        var idx = 2
        while idx <= entry.module_path.len {
            if entry.module_path[idx] != tpath[idx] {
                mismatch = yes
                break
            }
            idx += 1
        }
        if not mismatch {
            return entry
        }
    }
    return none
}

func GlobalScope.type_path_to_project_file(tpath) {
    var entry = self.type_path_to_entry(tpath)
    if entry == none or
            entry.kind != ast.N_STMT_IMPORT {
        return none
    }
    return entry.project_file
}

func has_global_scope_duplicate(
        scope, stmt, name, msgs, project_file=none,
        ignore_c_import_duplicates=yes
        ) {
    if scope.name_to_stmt_map.has(name) {
        if typename(scope.name_to_stmt_map[name]) != "list" or
                (stmt.kind != ast.N_STMT_IMPORT and
                stmt.kind != ast.N_STMT_C_IMPORT) {
            var duplicate_stmt = scope.name_to_stmt_map[name]
            if typename(duplicate_stmt) == "list" {
                duplicate_stmt = duplicate_stmt[1]
            }
            msgs.add(new msg.FileMsg(
                "Unexpected duplicate name '" +
                name +
                "', name was already used "
                "in statement in line " +
                duplicate_stmt.line.as_str() +
                ", column " +
                duplicate_stmt.col.as_str() + ".",
                source_file=project_file,
                line=stmt.line, col=stmt.col,
            ))
            return yes
        }
    }
    return no
}

func get_statement_global_names(statement) {
    if statement.kind == ast.N_STMT_IMPORT {
        if statement.renamed_as != none {
            return [statement.renamed_as]
        }
        assert(statement.module_path.len > 0)
        return [statement.module_path[1]]
    } elseif statement.kind == ast.N_STMT_C_IMPORT {
        if statement.renamed_as == none {
            assert(statement.has_damage())
            return []
        }
        return [statement.renamed_as]
    } elseif statement.kind == ast.N_STMT_FUNC {
        if statement.type_path != none {
            return []
        }
        return [statement.label]
    } elseif statement.kind == ast.N_STMT_TYPE {
        return [statement.label]
    } elseif statement.kind == ast.N_STMT_STRUCT {
        if statement.label != none {
            return [statement.label]
        }
        return []
    } elseif statement.kind == ast.N_STMT_ENUM {
        return [statement.label]
    } elseif statement.kind == ast.N_STMT_VAR {
        return statement.var_labels
    }
    return []
}

func GlobalScope.get_func_attr_node_by_anscope(
        anscope, attr_id
        ) {
    for fattr_node in self.func_attr_nodes {
        if fattr_node._owning_anscope_key !=
                anscope.anscope_key {
            continue
        }
        if fattr_node.symbol_info.storage_id != attr_id {
            continue
        }
        return fattr_node
    }
    return none
}

func GlobalScope.internal_find_func_attr_by_localpath(
        name, scope_local_type_path
        ) {
    var scope = self
    var type_path = scope_local_type_path
    var found_match = no
    for fattr_node in scope.func_attr_nodes {
        if fattr_node.label != name or
                type_path == none or
                fattr_node.type_path.len !=
                type_path.len {
            continue
        }
        var fits = yes
        var i = 1
        while i <= fattr_node.type_path.len {
            if fattr_node.type_path[i] !=
                    type_path[i] {
                fits = no
                break
            }
            i += 1
        }
        if not fits {
            continue
        }
        return fattr_node
    }
    return none
}

func process_toplevel_stmt(
        scope, statement, msgs,
        project_file=none, is_moose64=no,
        debug=no) {
    assert(statement != none)

    func get_func_statement_standin(statement) {
        stand_in_node = new func_stmt.FuncStmt()
        stand_in_node.label = statement.label
        stand_in_node.type_path =
            statement.type_path.copy()
        stand_in_node.arg_labels =
            statement.arg_labels.copy()
        stand_in_node.kw_arg_count =
            statement.kw_arg_count
        stand_in_node.has_failable =
            statement.has_failable
        stand_in_node.has_arg_types =
            statement.has_arg_types
        stand_in_node.is_override =
            statement.is_override
        stand_in_node.is_readonly =
            statement.is_readonly
        stand_in_node.kind = statement.kind
        stand_in_node.line = statement.line
        stand_in_node.col = statement.col
        stand_in_node.damaged = statement.damaged
        return stand_in_node
    }

    var names = get_statement_global_names(statement)
    if names.len == 0 {
        if typename(statement) != "list" and
                statement.kind == ast.N_STMT_FUNC and
                statement.type_path != none and
                statement.type_path.len > 0 {
            var found_match =
                scope.internal_find_func_attr_by_localpath(
                    statement.label,
                    statement.type_path) != none
            if not found_match {
                var snode = get_func_statement_standin(
                    statement
                )
                scope.func_attr_nodes.add(snode)
            }
        }
        return later
    }
    var c_importer_queue = []
    var idx = 0
    for name in names {
        idx += 1
        if has_global_scope_duplicate(
                scope, statement, name, msgs,
                project_file=project_file
                ) {
            continue
        }
        if statement.kind == ast.N_STMT_IMPORT {
            if not scope.name_to_stmt_map.has(name) {
                scope.name_to_stmt_map[name] = []
            }
            scope.name_to_stmt_map[name].add(statement.copy())
        } elseif statement.kind == ast.N_STMT_C_IMPORT {
            var c_import_with_name = statement.copy()
            if not scope.name_to_stmt_map.has(name) {
                scope.name_to_stmt_map[name] = []
            }
            var was_merged = no
            for merge_candidate in
                    scope.name_to_stmt_map[name] {
                if merge_candidate.
                        does_import_same_module_as(c_import_with_name) {
                    merge_candidate.file_paths +=
                        c_import_with_name.file_paths
                    if merge_candidate.c_importer == none {
                        merge_candidate.c_importer =
                            new c_importer.CImportInfo()
                    }
                    c_importer_queue.add([merge_candidate.c_importer,
                        c_import_with_name.file_paths])
                    c_import_with_name = merge_candidate
                    was_merged = yes
                    break
                }
            }
            if not was_merged {
                if c_import_with_name.c_importer == none {
                    c_import_with_name.c_importer =
                        new c_importer.CImportInfo()
                }
                c_importer_queue.add([c_import_with_name.c_importer,
                    c_import_with_name.file_paths])
                scope.name_to_stmt_map[name].add(c_import_with_name)
            }
        } else {
            # Note: to avoid keeping the entire AST in memory
            # indirectly through this global scope, we make a
            # fake shallow stand-in node that only retains
            # the info we care about later.
            var stand_in_node = none
            if statement.kind == ast.N_STMT_ENUM {
                stand_in_node = new enum_stmt.EnumStmt()
                stand_in_node.label = statement.label
            } elseif statement.kind == ast.N_STMT_ENUMEXTEND {
                stand_in_node = new enum_stmt.EnumExtendStmt()
            } elseif statement.kind == ast.N_STMT_STRUCT {
                stand_in_node = new struct_or_union_stmt.StructStmt()
                stand_in_node.label = statement.label
            } elseif statement.kind == ast.N_STMT_STRUCTEXTEND {
                stand_in_node =
                    new struct_or_union_stmt.StructExtendStmt()
            } elseif statement.kind == ast.N_STMT_TYPE {
                stand_in_node = new type_stmt.TypeStmt()
                stand_in_node.label = statement.label
            } elseif statement.kind == ast.N_STMT_TYPEEXTEND {
                stand_in_node = new type_stmt.TypeExtendStmt()
            } elseif statement.kind == ast.N_STMT_FUNC {
                stand_in_node = get_func_statement_standin(
                    statement
                )
            } elseif statement.kind == ast.N_STMT_VAR {
                stand_in_node = new var_stmt.VarStmt()
                stand_in_node.var_labels = [name]
                stand_in_node.subexprs.add(
                    statement.subexprs[idx]
                )
                stand_in_node.initial_values_known = [
                    statement.initial_values_known[idx]
                ]
                stand_in_node.initial_values = [
                    statement.initial_values[idx]
                ]
            } else {
                stand_in_node = new ast.StmtNode()
            }
            stand_in_node.kind = statement.kind
            stand_in_node.line = statement.line
            stand_in_node.col = statement.col
            scope.name_to_stmt_map[name] = stand_in_node
        }
    }

    # Actually load up the external headers for any outstanding
    # C imports (only used for moose64):

    if c_importer_queue.len == 0 {
        return later
    }
    assert(project_file != none and project_file.project != none)
    var project = project_file.project
    var next_entry = c_importer_queue.pop()
    var result = next_entry[1].add_import_paths(
        project, next_entry[2])
    later:

    await result
    if c_importer_queue.len == 0 {
        return later
    }
    next_entry = c_importer_queue.pop()
    result = next_entry[1].add_import_paths(
        project, next_entry[2])
    later repeat
}

func project.Project.finalize_global_scope_attr_storage(
        msgs
        ) {
    # XXX/Warning: this must be called after .ensure_assigned_storage()
    # was done project-wide on all global scopes, and after all local
    # storage has been run on all modules in the project.
    if msgs != none {
        for m in msgs {
            if m.kind == msg.M_ERROR {
                return later
            }
        }
    }
    var is_moose64 = self.is_moose64

    func finalize_gscope(pfile) {
        var gscope = pfile.global_scope
        for name in gscope.name_to_stmt_map {
            var value = gscope.name_to_stmt_map[name]
            if typename(value) == "list" or
                    (has_attr(value, "is_enum_entry") and
                     value.is_enum_entry) or
                    not {ast.N_STMT_TYPE, ast.N_STMT_ENUM,
                    ast.N_STMT_STRUCT}.has(value.kind) {
                continue
            }

            var anscope = pfile.
                make_attr_names_scope_from_node(
                    value, msgs=msgs, is_moose64=is_moose64,
                    def_project_file=pfile
                )
            if anscope == none {
                continue
            }
            anscope.storage_id = value.symbol_info.storage_id
            if not self.storage_id_to_global_scope_map.has(
                    anscope.storage_id) {
                self.storage_id_to_global_scope_map[
                    anscope.storage_id
                ] = gscope
            }
        }
        return later yes
    }

    var success = self.do_for_all_files(finalize_gscope)
    later:

    await success
    if not success {
        assert(msg.msgs_contain_error(msgs))
        return later
    }

    # XXX: Since typeref exprs can cross-reference modules, the
    # anscope storage id must have been set on ALL files.
    # Hence the following must be run after the previous
    # finalize_gscope, rather than together in the same loop:
    success = self.finalize_func_typerefs_all_files(
        msgs=msgs, is_moose64=is_moose64)
    later:

    await success
    if not success {
        assert(msg.msgs_contain_error(msgs))
        return later
    }

    func finalize_attr_storage(pfile) {
        pfile.ensure_ast() later:

        var ast_tree = pfile.ast
        for stmt in ast_tree.stmts {
            if {ast.N_STMT_FUNC, ast.N_STMT_STRUCT,
                    ast.N_STMT_TYPE}.has(stmt.kind) {
                var lbl = stmt.label
                if stmt.kind != ast.N_STMT_FUNC or
                        stmt.type_path == none or
                        stmt.type_path.len == 0 or
                        stmt.damaged {
                    continue
                }
                assert(stmt.symbol_info != none)
                assert(stmt.symbol_info.kind ==
                    st_scope.SINFO_FUNCATTR)
                var fattr_stand_in =
                    pfile.global_scope.
                        internal_find_func_attr_by_localpath(
                            stmt.label,
                            stmt.type_path)
                assert(fattr_stand_in != none)
                assert(fattr_stand_in.symbol_info == none or
                    fattr_stand_in.symbol_info.kind ==
                        stmt.symbol_info.kind and
                    fattr_stand_in.symbol_info.storage_id ==
                        stmt.symbol_info.storage_id)
                fattr_stand_in.symbol_info = stmt.symbol_info.copy()
                assert(stmt.func_scope != none)
                fattr_stand_in.func_scope = stmt.func_scope
                if is_moose64 {
                    assert(stmt.symbol_info.type_storage_ref != none)
                    assert(stmt.symbol_info.typeref_expr != none)
                    assert(stmt.symbol_info.type_storage_ref ==
                        stmt.symbol_info.typeref_expr.func_storage_ref)
                    assert(stmt.symbol_info.type_storage_ref.kind ==
                        st_ref.ST_GLOBALATTR)
                    assert(typename(stmt.symbol_info.
                        type_storage_ref.id) == "list")
                }
                assert(stmt.func_scope != none)

                var anscope = pfile.
                    make_attr_names_scope_from_funcattr(
                        stmt, msgs=msgs, is_moose64=is_moose64,
                        def_project_file=pfile
                    )
                if anscope == none {
                    continue
                }

                stmt._owning_anscope_key = anscope.anscope_key
                fattr_stand_in._owning_anscope_key =
                    anscope.anscope_key
                assert(anscope.storage_id != none)
                if is_moose64 {
                    stmt.symbol_info.type_storage_ref.id[1] =
                       anscope.storage_id
                }
            } elseif stmt.kind == ast.N_STMT_FUNCEXTEND {
                var base_func_scope = none
                if stmt.func_scope != none and
                        stmt.func_scope.base_func_scope != none {
                    base_func_scope = stmt.func_scope.base_func_scope
                }
                if base_func_scope == none {
                    continue
                }
                if stmt.type_path != none and stmt.type_path.len > 0 {
                    var anscope = pfile.
                        make_attr_names_scope_from_funcattr(
                            stmt, msgs=msgs, is_moose64=is_moose64,
                            def_project_file=pfile
                        )
                    if anscope == none {
                        continue
                    }
                    var type_id = anscope.storage_id
                    assert(anscope.name_to_symbol_map.has(stmt.label))
                    var sinfo = anscope.name_to_symbol_map[stmt.label]
                    assert(stmt.symbol_info == none)
                    assert(sinfo != none)
                    stmt.symbol_info = sinfo
                } else {
                    var global_storage_id =
                        base_func_scope.storage_id
                    if global_storage_id == none {
                        continue
                    }
                    var gscope = pfile.project.
                        storage_id_to_global_scope_map[
                            global_storage_id
                        ]
                    assert(gscope.name_to_stmt_map.has(stmt.label))
                    var base_stmt = gscope.name_to_stmt_map[
                        stmt.label
                    ]
                    assert(stmt.symbol_info == none)
                    assert(base_stmt.symbol_info != none)
                    stmt.symbol_info = base_stmt.symbol_info
                }
            }
        }

        return later yes
    }
    success = self.do_for_all_files(finalize_attr_storage)
    later:

    await success
}

