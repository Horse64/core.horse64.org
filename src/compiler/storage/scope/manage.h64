## @module compiler.storage.scope.manage
# Copyright (c) 2023-2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import compiler.ast as ast
import compiler.ast.analyze as ast_analyze
import compiler.ast.analyze.eval as ast_eval
import compiler.ast.expr as ast_expr
import compiler.ast.call_or_assign_stmt as call_or_assign_stmt
import compiler.ast.func_stmt as func_stmt
import compiler.ast.transform as transform
import compiler.ast.var_stmt as var_stmt
import compiler.builtin_syms as builtin_syms
import compiler.cext as cext
import compiler.msg as msg
import compiler.project as project
import compiler.storage.ref as st_ref
import compiler.storage.scope as st_scope
import compiler.typeinfo.ast_typeref as ast_typeref

func try_lookup_vardef_type_props(
        vardef_stmt,
        project_file=none,
        msgs=none,
        is_moose64=no
        ) {
    func try_evaluate_label_ref(label) {
        func get_var_stmt_val(stmt) {
            assert(stmt.initial_values_known != none and
                stmt.initial_values_known.len ==
                stmt.var_labels.len)
            var pos = 1
            while pos <= stmt.var_labels.len {
                if stmt.var_labels[pos] == label {
                    if stmt.initial_values_known[pos] {
                        return [yes,
                            stmt.initial_values[pos]]
                    }
                    return [no, none]
                }
                pos += 1
            }
            return [no, none]
        }
        var gscope = project_file.global_scope
        var entry = gscope.find_global_entry_in_full_project(
            label
        )
        if entry != none {
            var result = get_var_stmt_val(entry)
            return result
        }
        return [no, none]
    }

    if not vardef_stmt.has_type_expr {
        return
    }
    var type_expr = vardef_stmt.subexprs[
        vardef_stmt.subexprs.len
    ]
    for mod in type_expr.modifiers {
        for prop in mod.props {
            if prop.prop_name == "range" {
                if prop.range_value_label != none {
                    var result = try_evaluate_label_ref(
                        prop.range_value_label
                    )
                    if result[1] and
                            typename(result[2]) == "num" {
                        prop.range_value_num = result[2]
                        prop.range_value_label = none
                    }
                }
            }
        }
    }
}

func project.ProjectFile.type_path_to_full_module_path_and_pfile(
        tpath, msgs=none) {
    var pfile =
        self.global_scope.type_path_to_project_file(tpath)
    if pfile == none {
        var entry = self.global_scope.type_path_to_entry(tpath)
        if entry == none or entry.kind != ast.N_STMT_IMPORT {
            return none
        }
        # If we arrive here, it could be a C extension.
        var referenced_pkg = entry.package_name
        if referenced_pkg == none {
            referenced_pkg = self.project.package_name
        }
        if referenced_pkg == none or not self.project.
                package_name_to_cext.has(referenced_pkg) {
            return none
        }
        var modpath = self.project.
            package_name_to_cext[referenced_pkg].
                import_to_modname(entry)
        if modpath != none {
            return [modpath + "@" + referenced_pkg, none]
        }
        return none
    }
    var t = pfile.modinfo.module_name
    if pfile.modinfo.package_name != none {
        t += "@" + pfile.modinfo.package_name
    } else {
        t += "@<unknown>"
    }
    return [t, pfile]
}

func project.ProjectFile.try_lookup_symbol_path(
        local_scope, name=none, type_path=none,
        is_write_access=yes,
        found_in_line=none, found_in_col=none,
        is_moose64=no, debug=no,
        ) {
    if name == none and type_path == none {
        throw new ValueError("Need to supply at least one of "
            "name or type_path.")
    }
    var check_path = type_path
    if check_path == none {
        check_path = []
    } else {
        check_path = check_path.copy()
    }
    if typename(check_path) == "str" {
        check_path = check_path.split(".")
    }
    if name != none {
        check_path = check_path + [name]
    }
    if debug {
        var extra = ""
        if found_in_line != none {
            extra = " found in line " + found_in_line.as_str()
            if found_in_col != none {
                extra += ", column  " + found_in_col.as_str()
            }
        }
        print(if is_moose64 ("moosec") else ("horsec") +
            ": debug: try_lookup_symbol_path(): "
            "Invoked on: check_path=" + check_path.as_str() +
            extra)
    }
    if check_path.len == 0 {
        if debug {
            print(if is_moose64 ("moosec") else ("horsec") +
                ": debug: try_lookup_symbol_path(): "
                "Lookup path is empty, returning none.")
        }
        return none
    }

    # First, try local scopes:
    if local_scope != none {
        var lookup_pair =
            local_scope.lookup(check_path[1],
                is_write_access=is_write_access)
        if lookup_pair != none {
            var symbol_ref = lookup_pair[1]
            if check_path.len > 1 {
                if debug {
                    print(if is_moose64 ("moosec") else ("horsec") +
                        ": debug: try_lookup_symbol_path(): "
                        "Longer global path is being shadowed "
                        "by local scope result ref=" +
                        symbol_ref.as_str() + " so we return none.")
                }
                return none
            }
            if debug {
                print(if is_moose64 ("moosec") else ("horsec") +
                    ": debug: try_lookup_symbol_path(): "
                    "Found local scope result ref=" +
                    symbol_ref.as_str() + " so we return success.")
            }
            assert(typename(symbol_ref) != "list")
            return symbol_ref
        }
        if debug {
            print(if is_moose64 ("moosec") else ("horsec") +
            ": debug: try_lookup_symbol_path(): "
            "Local scope returned nothing.")
        }
    } else {
        if debug {
            print(if is_moose64 ("moosec") else ("horsec") +
            ": debug: try_lookup_symbol_path(): "
            "Skipping local scope, since none was supplied.")
        }
    }

    # Then, try 'self' and 'extended' built in names:
    if check_path[1] == "extended" and
            local_scope != none and local_scope.func_scope != none {
        var nested_in_type_extend_attr = no
        var type_anscope = none
        var check_func_scope = local_scope.func_scope
        while check_func_scope != none {
            if check_func_scope.is_type_extend_attr {
                nested_in_type_extend_attr = yes
                var base_fscope = check_func_scope
                while base_fscope.base_func_scope != none {
                    base_fscope = base_fscope.base_func_scope
                }
                type_anscope = base_fscope.owning_type_scope
                assert(type_anscope != none)
            }
            check_func_scope = check_func_scope.parent
        }
        if nested_in_type_extend_attr and check_path.len == 1 {
            if debug {
                print(if is_moose64 ("moosec") else ("horsec") +
                ": debug: try_lookup_symbol_path(): "
                "It's an extended in an extend func, "
                "returning success.")
            }
            return new st_ref.StorageRef(
                st_ref.ST_EXTENDED, 0)
        }
    }
    if check_path[1] == "self" and
            local_scope != none and local_scope.func_scope != none {
        var nested_in_type_attr = no
        var type_anscope = none
        var check_func_scope = local_scope.func_scope
        while check_func_scope != none {
            if check_func_scope.is_type_attr {
                nested_in_type_attr = yes
                var base_fscope = check_func_scope
                while base_fscope.base_func_scope != none {
                    base_fscope = base_fscope.base_func_scope
                }
                type_anscope = base_fscope.
                    owning_type_scope
                assert(type_anscope != none)
            }
            check_func_scope = check_func_scope.parent
        }
        if nested_in_type_attr and check_path.len == 1 {
            if debug {
                print(if is_moose64 ("moosec") else ("horsec") +
                    ": debug: try_lookup_symbol_path(): "
                    "It's a self in a func attr, "
                    "returning success.")
            }
            return new st_ref.StorageRef(
                st_ref.ST_SELF, 0)
        } elseif nested_in_type_attr and
                check_path.len == 2 {
            var result = type_anscope.get_item_if_present(
                check_path[2]
            )
            if result != none and check_path.len == 2 and
                    # XXX: In Moose64, `self.some_func_attr(...)`
                    # must not be pulled into one item, because
                    # if `self` doesn't remain a separate
                    # AST item then the call won't be identified
                    # as a call-with-self-reference by the type
                    # checker later.
                    # (This is because Moose64 doesn't treat
                    # func attrs as closures, unlike Hose64.)
                    # Enforce this here:
                    (not is_moose64 or
                     (type(result[1]) != "list" and
                      result[1].kind != st_scope.SINFO_FUNCATTR)) {
                assert(result[1].kind != st_scope.SINFO_FUNC)
                return result[2]
            } elseif result == none and not is_moose64 {
                # Return explicit missing attribute failure:
                return no
            }
        }
    }

    # Then, try the built-in symbols injector for things that
    # can't be "inside" e.g. an imported module:
    if debug {
        print(if is_moose64 ("moosec") else ("horsec") +
            ": debug: try_lookup_symbol_path(): "
            "Will try injections from compiler.builtin_syms module.")
    }
    if check_path.len >= 1 and
            not self.global_scope.name_to_stmt_map.has(
                check_path[1]
            ) {
        var builtin_lookup_result =
            builtin_syms.try_lookup_symbol(
                self.project, check_path.join("."),
                if self.modinfo != none (self.modinfo.module_name)
                    else (none),
                in_package_name=if self.modinfo != none
                    (self.modinfo.package_name) else (none),
            )
        if builtin_lookup_result != none {
            if debug {
                print(if is_moose64 ("moosec") else ("horsec") +
                ": debug: try_lookup_symbol_path(): "
                "Found matching built-in, "
                "returning success.")
            }
            return builtin_lookup_result
        }
    }

    # Then, try global scopes:
    if debug {
        print(if is_moose64 ("moosec") else ("horsec") +
            ": debug: try_lookup_symbol_path(): "
            "Will try regular global scope.")
    }
    var entry = self.global_scope.type_path_to_entry(
        check_path)
    if entry != none and has_attr(entry, "kind") and
            {ast.N_STMT_IMPORT,
            ast.N_STMT_C_IMPORT}.has(entry.kind) {
        # This can't be referenced directly.
        if debug {
            print(if is_moose64 ("moosec") else ("horsec") +
                ": debug: try_lookup_symbol_path(): It matched "
                "an import directly, but that's not valid.")
        }
        entry = none
    }
    if entry != none {
        if debug {
            print(if is_moose64 ("moosec") else ("horsec") +
                ": debug: try_lookup_symbol_path(): "
                "Examining global entry=" + entry.as_str() + " "
                "to consider a match.")
        }
        if has_attr(entry, "is_enum_entry") and
                entry.is_enum_entry {
            if debug {
                print(if is_moose64 ("moosec") else ("horsec") +
                    ": debug: try_lookup_symbol_path(): "
                    "Considering enum entry=" + entry.as_str() + " "
                    "as a match.")
            }
            if check_path.len > 1 {
                return none
            }
            if not self.global_scope.name_to_stmt_map.has(
                    entry.enum_stmt_label) {
                # Weird, maybe a follow-up error. Shouldn't
                # be possible in undamaged code.
                return none
            }
            var enum_stmt = self.global_scope.
                name_to_stmt_map[entry.enum_stmt_label]
            assert(enum_stmt.kind == ast.N_STMT_ENUM)
            var anscope = enum_stmt.attr_names_scope
            assert(entry.symbol_info != none and
                typename(entry.symbol_info) != "list")
            assert(entry.symbol_info.storage_id >= 1 and
                entry.symbol_info.storage_id <=
                    anscope.label_names.len)
            return new st_ref.StorageRef(
                st_ref.ST_NUMLITERAL,
                anscope.label_nums[
                    entry.symbol_info.storage_id]
            )
        }
        if entry.symbol_info == none {
            if debug {
                print(if is_moose64 ("moosec") else ("horsec") +
                    ": debug: try_lookup_symbol_path(): "
                    "Have global entry=" + entry.as_str() + " "
                    "but it has no symbol_info set. Aborting.")
            }
            return none
        }
        if typename(entry.symbol_info) == "list" {
            for sym_entry in entry.symbol_info {
                if sym_entry.name == check_path[check_path.len] {
                    if debug {
                        print(if is_moose64 ("moosec") else ("horsec") +
                        ": debug: try_lookup_symbol_path(): "
                        "Found global, returning success.")
                    }
                    return new st_ref.StorageRef(
                        st_ref.ST_GLOBAL,
                        sym_entry.storage_id
                    )
                }
            }
        } else {
            assert(entry.symbol_info != none)
            if debug {
                print(if is_moose64 ("moosec") else ("horsec") +
                ": debug: try_lookup_symbol_path(): "
                "Found global, returning success.")
            }
            return new st_ref.StorageRef(
                st_ref.ST_GLOBAL,
                entry.symbol_info.storage_id
            )
        }
    } else {
        if debug {
            print(if is_moose64 ("moosec") else ("horsec") +
                ": debug: try_lookup_symbol_path(): "
                "No global entry matched.")
        }
    }
    if check_path.len > 1 and
            not {"self", "extended"}.has(check_path[1]) {
        # Check if this is inside some imported item:
        if debug {
            print(if is_moose64 ("moosec") else ("horsec") +
                ": debug: try_lookup_symbol_path(): "
                "Now checking if this is an imported item.")
        }
        var module_item_path_without_item = check_path.sub(
            1, check_path.len - 1)
        var item_name = check_path[check_path.len]
        assert(module_item_path_without_item.len >= 1)
        entry = self.global_scope.type_path_to_entry(
            module_item_path_without_item)
        if entry != none and {ast.N_STMT_IMPORT,
                ast.N_STMT_C_IMPORT}.has(entry.kind) {
            if debug {
                print(if is_moose64 ("moosec") else ("horsec") +
                    ": debug: try_lookup_symbol_path(): "
                    "Found base of item_name=\"" +
                    item_name + "\" "
                    "in entry=" + entry.as_str() + ", investigating.")
            }
            var can_be_non_cext_non_cref = yes
            var stmt_map = none
            if entry.kind == ast.N_STMT_C_IMPORT or
                    entry.project_file == none or
                    entry.project_file.global_scope == none {
                # An import, but not to any actual code file.
                # This is only the case for C extension imports.
                can_be_non_cext_non_cref = no
            } else {
                stmt_map =
                    entry.project_file.global_scope.name_to_stmt_map
            }

            # First, check if this is a C extension item:
            var def_file
            var in_module_name = entry.module_path.join(".")
            var in_package_name =
                if entry.kind != ast.N_STMT_C_IMPORT
                    (entry.package_name) else (none)
            if entry.kind != ast.N_STMT_C_IMPORT and
                    entry.project_file != none {
                def_file = entry.project_file
                in_module_name = def_file.modinfo.module_name
                in_package_name = def_file.modinfo.package_name
            }
            var storage_id = none
            if not is_moose64 {
                if debug {
                    print(if is_moose64 ("moosec") else ("horsec") +
                        ": debug: try_lookup_symbol_path(): "
                        "Trying looking up item_name=\"" +
                        item_name + "\" in C exts.")
                }
                storage_id = cext.get_cext_item_storage_id(
                    item_name,
                    in_module_name=in_module_name,
                    in_package_name=in_package_name,
                    project=self.project,
                    can_match_moduleless=no,
                    debug=debug,
                )
                if storage_id != none {
                    if debug {
                        print(if is_moose64 ("moosec") else ("horsec") +
                        ": debug: try_lookup_symbol_path(): "
                        "Matched C ext, returning success.")
                    }
                    return new st_ref.StorageRef(
                        st_ref.ST_CEXT,
                        storage_id
                    )
                }
                if debug {
                    print(if is_moose64 ("moosec") else ("horsec") +
                        ": debug: try_lookup_symbol_path(): "
                        "Not found in C exts.")
                }
            }

            # Then, check if this is an added-in builtin item:
            if entry.kind == ast.N_STMT_IMPORT {
                var builtin_lookup_result =
                    builtin_syms.try_lookup_symbol(
                        self.project, item_name,
                        in_module_name,
                        in_package_name=in_package_name
                    )
                if builtin_lookup_result != none {
                    if debug {
                        print(if is_moose64 ("moosec") else ("horsec") +
                        ": debug: try_lookup_symbol_path(): "
                        "Found builtin inside module, "
                        "returning success.")
                    }
                    return builtin_lookup_result
                }
            }

            # Then, check if this is a C import:
            if entry.kind == ast.N_STMT_C_IMPORT {
                assert(entry.c_importer != none)
                if not entry.c_importer.known_items.has(item_name) or
                        entry.c_importer.known_items[item_name].
                            storage_id == none {
                    return no
                }
                if debug {
                    print(if is_moose64 ("moosec") else ("horsec") +
                    ": debug: try_lookup_symbol_path(): "
                    "Found C imported matching item, "
                    "returning success.")
                }
                return new st_ref.StorageRef(
                    st_ref.ST_MCREF,
                    entry.c_importer.known_items[item_name].storage_id
                )
            }
            if not can_be_non_cext_non_cref or
                    not stmt_map.has(item_name) {
                return no
            }

            # If we get here, it's a normal Horse64/Moose64 module item.
            def_file = entry.project_file
            entry = stmt_map[item_name]
            if typename(entry) == "list" {
                return no
            }
            if has_attr(entry, "is_enum_entry") and
                    entry.is_enum_entry {
                if not def_file.global_scope.
                        name_to_stmt_map.has(entry.enum_stmt_label) {
                    return no
                }
                var enum_stmt = def_file.global_scope.
                    name_to_stmt_map[entry.enum_stmt_label]
                assert(enum_stmt.kind == ast.N_STMT_ENUM)
                var anscope = enum_stmt.attr_names_scope
                assert(entry.symbol_info != none and
                    typename(entry.symbol_info) != "list")
                assert(entry.symbol_info.storage_id >= 1 and
                    entry.symbol_info.storage_id <=
                        anscope.label_names.len)
                return new st_ref.StorageRef(
                    st_ref.ST_NUMLITERAL,
                    anscope.label_nums[
                        entry.symbol_info.storage_id]
                )
            }
            if entry.symbol_info == none {
                return no
            }
            if debug {
                print(if is_moose64 ("moosec") else ("horsec") +
                ": debug: try_lookup_symbol_path(): "
                "Found matching global, "
                "returning success.")
            }
            if entry.kind == ast.N_STMT_VAR {
                assert(typename(entry.symbol_info) == "list")
                var idx = entry.var_labels.find(item_name)
                assert(idx != none)
                return new st_ref.StorageRef(
                    st_ref.ST_GLOBAL,
                    entry.symbol_info[idx].storage_id
                )
            }
            assert(typename(entry.symbol_info) != "list")
            return new st_ref.StorageRef(
                st_ref.ST_GLOBAL,
                entry.symbol_info.storage_id
            )
        }
        # This can no longer be resolved at this point.
        return none
    }
    var in_module_name = none
    var in_package_name = none
    if self.modinfo != none {
        in_module_name = self.modinfo.module_name
        in_package_name = self.modinfo.package_name
    }
    if debug {
        print(if is_moose64 ("moosec") else ("horsec") +
            ": debug: try_lookup_symbol_path(): "
            "Now trying C extensions lookup.")
    }
    if not is_moose64 {
        var st_id = cext.get_cext_item_storage_id(
            check_path[1], in_module_name=in_module_name,
            in_package_name=in_package_name,
            project=self.project,
            can_match_moduleless=yes,
            debug=debug
        )
        if st_id != none {
            return new st_ref.StorageRef(
                st_ref.ST_CEXT, st_id)
        }
    }
    if debug {
        print(if is_moose64 ("moosec") else ("horsec") +
            ": debug: try_lookup_symbol_path(): "
            "All lookups failed, returning none.")
    }
    return none
}

func project.ProjectFile.find_cext_injected_item_storage_id_by_modpkg(
        name, mod_pkg_path, limit_to_kind=none
        ) {
    var project = self.project
    if project == none {
        return none
    }
    var split_at = mod_pkg_path.find("@")
    if split_at == none {
        return none
    }
    var search_in_pkg = mod_pkg_path.sub(split_at + 1)
    var search_in_module = mod_pkg_path.sub(1, split_at - 1)
    var result = cext.get_cext_item_storage_id(
        name, in_module_name=search_in_module,
        in_package_name=search_in_pkg, project=project,
        can_match_moduleless=no,
        limit_to_kind=limit_to_kind
    )
    return result
}

func project.ProjectFile.check_item_exists_by_modpkg(
        name, mod_pkg_path, origin_project_file=none,
        limit_to_kind=none, project=none
        ) {
    if origin_project_file != none and
            origin_project_file.global_scope.
                name_to_stmt_map.has(name) {
        var entry = origin_project_file.global_scope.
            name_to_stmt_map[name]
        assert(entry != none)
        if typename(entry) == "list" {
            return no
        }
        if limit_to_kind != none and entry.kind != limit_to_kind {
            return no
        }
        return yes
    } elseif origin_project_file != none or project != none {
        if project == none {
            project = origin_project_file.project
        }
        var storage_id = cext.get_cext_item_storage_id(
            name,
            in_module_name=mod_pkg_path.sub(
                1, mod_pkg_path.find("@")
            ), in_package_name=mod_pkg_path.sub(
                mod_pkg_path.find("@") + 1
            ),
            project=project,
            can_match_moduleless=no,
            limit_to_kind=limit_to_kind)
        if storage_id != none {
            return yes
        }
    }
    return (self.find_cext_injected_item_storage_id_by_modpkg(
        name, mod_pkg_path, limit_to_kind=limit_to_kind) != none)
}

## Like @{compiler.project.ProjectFile.make_attr_names_scope_from_node},
## but instead of taking the N_STMT_TYPE or N_STMT_TYPEEXTEND node,
## this works from any N_STMT_FUNC or N_STMT_FUNCEXTEND node of
## the given type.
func project.ProjectFile.make_attr_names_scope_from_funcattr(
        node, msgs=none, is_moose64=no, def_project_file=none
        ) {
    assert(node.kind == ast.N_STMT_FUNC or
        node.kind == ast.N_STMT_FUNCEXTEND)
    if node.kind == ast.N_STMT_FUNC and
            node.func_scope != none and
            node.func_scope.owning_type_scope != none {
        return node.func_scope.owning_type_scope
    }
    assert(node.type_path != none)
    var info = self.get_gscope_type_node_info_from_funcattr(
        node, msgs=msgs, is_moose64=is_moose64,
        def_project_file=def_project_file
    )
    var type_node = info[1]
    var type_file = info[2]
    if type_node == none {
        return none
    }
    return self.make_attr_names_scope_from_node(
        type_node, msgs=msgs, is_moose64=is_moose64,
        def_project_file=type_file
    )
}

## Like @{compiler.project.ProjectFile.make_attr_names_scope_from_node},
## but instead this works by supplying the global storage id of
## the `type` or `struct` or `enum` definition in question.
func project.ProjectFile.make_attr_names_scope_from_gid(
        storage_id, msgs=none, is_moose64=no,
        ) {
    if not self.project.storage_id_to_global_scope_map.has(
            storage_id) {
        return none
    }
    var gscope = self.project.
        storage_id_to_global_scope_map[storage_id]
    var def_pfile = gscope.known_to_be_in_project_file
    if def_pfile == none {
        return none
    }
    var gscope_node = gscope.storage_id_to_entry[
        storage_id
    ]
    return self.make_attr_names_scope_from_node(
        gscope_node, msgs=msgs, is_moose64=is_moose64,
        def_project_file=def_pfile
    )
}

## Find the type underlying the given func attribute AST node,
## and get its stand-in global scope AST node from whatever
## project file it actually is defined in.
func project.ProjectFile.get_gscope_type_node_info_from_funcattr(
        func_attr_node, msgs=none, is_moose64=no,
        def_project_file=none
        ) {
    var node = func_attr_node
    assert(node.kind == ast.N_STMT_FUNC or
        node.kind == ast.N_STMT_FUNCEXTEND)
    var action = "declared"
    if node.kind == ast.N_STMT_FUNCEXTEND {
        action = "extended"
    }
    assert(node.type_path != none)
    if node.kind == ast.N_STMT_FUNC and
            node.func_scope != none and
            node.func_scope.owning_type_storage_id != none and
            def_project_file != none and
            def_project_file.project != none {
        # We can go the obvious and lazy path since it's set.
        var pr = def_project_file.project
        assert(pr.storage_id_to_entry.has(
            node.func_scope.owning_type_storage_id))
        var type_node = pr.storage_id_to_entry[
            node.func_scope.owning_type_storage_id
        ]
        var type_file = pr.storage_id_to_project_file[
            node.func_scope.owning_type_storage_id
        ]
        assert(node.kind == ast.N_STMT_TYPE or
               node.kind == ast.N_STMT_STRUCT)
        return [type_node, type_file]
    }
    if def_project_file == none or node.type_path.len <= 0 {
        return [none, none]
    }
    var global_entry_file = def_project_file
    var global_entry = none
    if node.type_path.len > 1 {
        var type_path_without_type_name =
            node.type_path.sub(1, node.type_path.len - 1)
        global_entry = def_project_file.global_scope.
            type_path_to_entry(type_path_without_type_name)
    } else {
        global_entry = def_project_file.global_scope.
            type_path_to_entry(node.type_path.sub(1, 1))
    }

    if global_entry == none {
        if msgs != none {
            var tpath = node.type_path + [node.label]
            assert(typename(tpath) == "list")
            var emsg =
                "Unexpected func "
                "attribute '" + node.label +
                "' " + action +
                " while referencing invalid "
                "type, "
            if node.type_path.len > 1 {
                emsg += "type '" + node.type_path.join(".") +
                    "' wasn't imported or found anywhere."
            } else {
                emsg += "base type '" + node.type_path[1] +
                    "' not found anywhere."
            }
            if not func_attr_node.damaged {
                msgs.add(new msg.FileMsg(
                    emsg,
                    source_file=def_project_file,
                    line=node.line, col=node.col,
                ))
            }
            func_attr_node.damaged = yes
        } else {
            throw new ValueError("Couldn't resolve func "
                "attribute's type path.")
        }
        return [none, none]
    }
    if global_entry.kind == ast.N_STMT_IMPORT {
        # We have to access the target file this is in,
        # since it's not ours, to find out what this is.
        var pfile = global_entry.project_file
        var type_name = node.type_path[node.type_path.len]
        var type_module = node.type_path.sub(
            1, node.type_path.len - 1
        )
        if not pfile.global_scope.name_to_stmt_map.
                    has(type_name) or
                pfile.global_scope.
                    name_to_stmt_map[type_name].kind !=
                    ast.N_STMT_TYPE {
            if msgs != none {
                assert(typename(node.type_path) == "list")
                var emsg =
                    "Unexpected func "
                    "attribute '" + node.label +
                    "' " + action +
                    " while referencing invalid "
                    "type, "
                    "module '" + type_module.join(".") +
                    "' doesn't contain a type named '" +
                    type_name + "'."
                if not func_attr_node.damaged {
                    msgs.add(new msg.FileMsg(
                        emsg,
                        source_file=def_project_file,
                        line=node.line, col=node.col,
                    ))
                }
                func_attr_node.damaged = yes
            } else {
                throw new ValueError("Couldn't resolve func "
                    "attribute's type path.")
            }
            return [none, none]
        }
        global_entry =
            pfile.global_scope.name_to_stmt_map[type_name]
        global_entry_file = pfile
    } elseif global_entry.kind != ast.N_STMT_TYPE and
            (not is_moose64 or
            global_entry.kind != ast.N_STMT_STRUCT) {
        if msgs != none {
            assert(typename(node.type_path) == "list")
            var emsg =
                "Unexpected func "
                "attribute '" + node.label +
                "' " + action +
                " while referencing invalid "
                "type, "
                "since '" + node.label + "' was found but "
                "isn't a type."
            if not func_attr_node.damaged {
                msgs.add(new msg.FileMsg(
                    emsg,
                    source_file=def_project_file,
                    line=node.line, col=node.col,
                ))
            }
            func_attr_node.damaged = yes
        } else {
            throw new ValueError("Couldn't resolve func "
                "attribute's type path.")
        }
    }
    assert(global_entry != none and
        (global_entry.kind == ast.N_STMT_TYPE or
        (is_moose64 and global_entry.kind == ast.N_STMT_STRUCT)))
    return [global_entry, global_entry_file]
}

## This function will obtain a project-wide, unique shared
## instance of a compiler.scope.AttrNameScope
## type to store everything about a type, struct, or enum.
## It can do this from both extends and enum or type definitions all
## over a project, and it will return the same scope if they refer
## to the same type.
## These project-wide scopes are stored in the map stored in
## @{compiler.project.Project.attr_names_scope_map} associated
## with a respective project.
func project.ProjectFile.make_attr_names_scope_from_node(
        node, msgs=none, is_moose64=no, def_project_file=none
        ) {
    assert(node.kind == ast.N_STMT_TYPE or
        node.kind == ast.N_STMT_TYPEEXTEND or
        node.kind == ast.N_STMT_ENUM or
        node.kind == ast.N_STMT_ENUMEXTEND or
        (is_moose64 and (node.kind == ast.N_STMT_STRUCT or
        node.kind == ast.N_STMT_STRUCTEXTEND)))
    var stmt_base_full_type_path
    var stmt_base_label
    var stmt_base_project_file
    var stmt_full_type_path
    var stmt_project_file
    var stmt_label

    var key
    var result_scope
    var is_enum
    var is_struct
    var based_on_cext_id = none
    var base_anscope_key = none
    if node.kind == ast.N_STMT_TYPE or
            node.kind == ast.N_STMT_ENUM or
            (is_moose64 and node.kind == ast.N_STMT_STRUCT) {
        # This is a self-contained new declaration and not an extends.
        is_enum = if node.kind == ast.N_STMT_TYPE or
                  node.kind == ast.N_STMT_STRUCT (no)
                  else (yes)
        is_struct = if node.kind == ast.N_STMT_STRUCT (yes)
                    else (no)
        stmt_full_type_path = "<inline>@<unknown>"
        var mod_info = none
        if def_project_file != none and def_project_file.modinfo != none {
            mod_info = def_project_file.modinfo
        } elseif self.modinfo != none {
            mod_info = self.modinfo
        }
        if mod_info != none {
            stmt_full_type_path = mod_info.module_name
            assert(stmt_full_type_path != none)
            if mod_info.package_name != none {
                stmt_full_type_path += "@" + mod_info.package_name
            } else {
                stmt_full_type_path += "@<unknown>"
            }
        }
        stmt_label = node.label
        assert(stmt_full_type_path != none)
        assert(stmt_label != none)

        # If it's a 'type' with a 'base', figure out what the base is:
        if node.kind == ast.N_STMT_TYPE and
                node.subexprs.len >= 1 and
                node.subexprs[1].kind == ast.N_EXPR_IDREF {
            var had_type_path_specified = no
            if node.subexprs[1].type_path != none {
                had_type_path_specified = yes
                var result =
                    self.type_path_to_full_module_path_and_pfile(
                        node.subexprs[1].type_path)
                if result != none {
                    stmt_base_full_type_path = result[1]
                    stmt_base_project_file = result[2]
                }
            } else {
                stmt_base_full_type_path = stmt_full_type_path
                assert(stmt_base_full_type_path != none)
                stmt_base_project_file = self
            }
            stmt_base_label = node.subexprs[1].label

            # Obtain storage of our base type:
            var item_exists = no
            if stmt_base_full_type_path != none {
                item_exists = self.check_item_exists_by_modpkg(
                    stmt_base_label, stmt_base_full_type_path,
                    limit_to_kind=ast.N_STMT_TYPE,
                    origin_project_file=stmt_base_project_file,
                    project=self.project)
            }
            if not item_exists {
                var self_module_name = "<inline>"
                var self_pkg = none
                if self.modinfo != none {
                    self_module_name = self.modinfo.module_name
                    self_pkg = self.modinfo.package_name
                }
                var storage_id = cext.get_cext_item_storage_id(
                    stmt_base_label,
                    in_module_name=self_module_name,
                    in_package_name=self_pkg,
                    project=self.project,
                    can_match_moduleless=yes)
                if storage_id != none {
                    item_exists = yes
                    based_on_cext_id = storage_id
                }
            }
            if stmt_base_full_type_path == none {
                if msgs != none {
                    var tpath = node.subexprs[1].type_path
                    assert(typename(tpath) == "list")
                    msgs.add(new msg.FileMsg(
                        "Unexpected type statement with invalid base "
                        "type, module '" + tpath.join(".") +
                        "' wasn't imported anywhere.",
                        source_file=def_project_file,
                        line=node.line, col=node.col,
                    ))
                } else {
                    throw new ValueError("Couldn't resolve type's "
                        "base type path.")
                }
                return none
            } elseif not item_exists {
                if msgs != none {
                    msgs.add(new msg.FileMsg(
                        "Unexpected type statement with invalid base "
                        "type '" + stmt_base_label + "', module '" +
                        stmt_base_full_type_path +
                        "' doesn't contain such a type.",
                        source_file=def_project_file,
                        line=node.line, col=node.col,
                    ))
                } else {
                    throw new ValueError("Base type module "
                        "doesn't contain given type.")
                }
                return none
            } else {
                base_anscope_key = stmt_base_full_type_path +
                    "@" + stmt_base_label
            }
        }

        # Project-wide unique key to look up this definition's scope:
        key = stmt_full_type_path + "@" + stmt_label
    } else {
        assert(node.kind == ast.N_STMT_TYPEEXTEND or
            node.kind == ast.N_STMT_ENUMEXTEND or
            node.kind == ast.N_STMT_STRUCTEXTEND)
        is_enum = if node.kind == ast.N_STMT_TYPEEXTEND or
                  node.kind == ast.N_STMT_STRUCTEXTEND (no)
                  else (yes)
        is_struct = if node.kind == ast.N_STMT_STRUCTEXTEND (yes)
                    else (no)
        var base_def_type = if is_enum (ast.N_STMT_ENUM) else
                            (ast.N_STMT_TYPE)
        if node.kind == ast.N_STMT_STRUCTEXTEND {
            base_def_type = ast.N_STMT_STRUCT
        }

        # See what enum or type we're extending:
        if node.subexprs.len < 1 or
                node.subexprs[1].kind != ast.N_EXPR_IDREF {
            if msgs != none {
                msgs.add(new msg.FileMsg(
                    "Unexpected extend statement with "
                    "no specified base.",
                    source_file=def_project_file,
                    line=node.line, col=node.col,
                ))
            } else {
                throw new ValueError("Found extend "
                    "statement with missing base parameter.")
            }
            return none
        }
        if node.subexprs[1].type_path != none {
            var result =
                self.type_path_to_full_module_path_and_pfile(
                    node.subexprs[1].type_path)
            if result != none {
                stmt_full_type_path = result[1]
                stmt_project_file = result[2]
            }
        } else {
            var mod_info = none
            if def_project_file != none and
                    def_project_file.modinfo != none {
                mod_info = def_project_file.modinfo
            } elseif self.modinfo != none {
                mod_info = self.modinfo
            }
            if mod_info != none {
                stmt_full_type_path = mod_info.module_name
                if mod_info.package_name != none {
                    stmt_full_type_path += "@" + mod_info.package_name
                } else {
                    stmt_full_type_path += "@<unknown>"
                }
            } else {
                stmt_full_type_path = "<inline>@<unknown>"
            }
            stmt_project_file = self
            assert(stmt_full_type_path != none)
        }
        stmt_label = node.subexprs[1].label
        if stmt_full_type_path == none {
            if msgs != none {
                msgs.add(new msg.FileMsg(
                    "Unexpected extend statement, "
                    "given module path '" +
                    node.subexprs[1].type_path.join(".") +
                    "' doesn't match any import.",
                    source_file=def_project_file,
                    line=node.line, col=node.col,
                ))
                return none
            } else {
                throw new ValueError("Couldn't resolve extend's "
                    "type path.")
            }
        } elseif stmt_project_file == none or
                not stmt_project_file.global_scope.
                    name_to_stmt_map.has(stmt_label) or
                stmt_project_file.global_scope.
                    name_to_stmt_map[stmt_label].kind !=
                    base_def_type {
            if msgs != none {
                if self.check_item_exists_by_modpkg(
                        stmt_label, stmt_full_type_path,
                        origin_project_file=none,
                        limit_to_kind=base_def_type,
                        project=self.project
                        ) {
                    # It exists but is not in the scope,
                    # this only happens for C extensions.
                    msgs.add(new msg.FileMsg(
                        "Unexpected extend statement, "
                        "cannot extend C extension " +
                        if is_enum ("enums") else ("types") + ".",
                        source_file=def_project_file,
                        line=node.line, col=node.col,
                    ))
                } else {
                    msgs.add(new msg.FileMsg(
                        "Unexpected extend statement, " +
                        if is_enum ("enum") else ("type") + " '" +
                        stmt_label + "' not found in "
                        "referenced module.",
                        source_file=def_project_file,
                        line=node.line, col=node.col,
                    ))
                }
                return none
            } else {
                throw new ValueError("Couldn't find extend's "
                    "referenced type, or its a C extension.")
            }
        }

        # Project-wide unique key of the type or enum we're extending:
        key = stmt_full_type_path + "@" + stmt_label
    }
    if not self.project.attr_names_scope_map.has(key) {
        # Not seen before, therefore add a new definition:
        result_scope = none
        if not is_enum {
            if not is_struct {
                result_scope = new st_scope.TypeNamesScope()
            } else {
                result_scope = new st_scope.StructNamesScope()
            }
        } else {
            result_scope = new st_scope.EnumNamesScope()
        }
        result_scope.display_name =
            "'" + stmt_label + "' from " +
            key.sub(1, key.rfind("@") - 1)
        result_scope.label = stmt_label
        result_scope.anscope_key = key
        assert(result_scope.is_enum == is_enum)
        assert(result_scope.is_struct == is_struct)
        result_scope.def_line = node.line
        result_scope.def_col = node.col
        if def_project_file != none {
            result_scope.def_file = def_project_file
        }
        self.project.attr_names_scope_map[key] = result_scope
        assert(self.project.attr_names_scope_map.has(key))
    } else {
        result_scope = self.project.attr_names_scope_map[key]
        assert(result_scope.anscope_key == key)
    }

    assert(based_on_cext_id == none or not is_enum)
    if not is_enum {
        if based_on_cext_id != none {
            result_scope.base_cext_id = based_on_cext_id
        }
        if stmt_base_full_type_path != none {
            var base_display_name = "'" + stmt_base_label + "' " +
                "from " + stmt_base_full_type_path
            result_scope.base_display_name = base_display_name
        }
        if base_anscope_key != none {
            assert(result_scope.base_display_name != none)
            result_scope._base_anscope_key = base_anscope_key
        }
    }

    if result_scope.is_enum != is_enum {
        var stmt_name = if is_enum ("enum") else ("type")
        if is_struct {
            stmt_name = "struct"
        }
        var opposite_name = "enum"
        if is_enum {
            if is_moose64 {
                opposite_name = "type or struct"
            } else {
                opposite_name = "type"
            }
        }
        if msgs != none {
            var where = "elsewhere"
            if result_scope.def_file != none and
                    result_scope.def_file.source_uri != none {
                where = "in " + result_scope.def_file.source_uri
                if result_scope.def_line != none {
                    where += ":" + result_scope.def_line.as_str()
                    if result_scope.def_col != none {
                        where += ":" + result_scope.def_col.as_str()
                    }
                }
            }
            msgs.add(new msg.FileMsg(
                "This " + stmt_name + " statement has "
                "a mismatched extend statement " + where + " "
                "treating it as " + opposite_name + ".",
                source_file=def_project_file,
                line=node.line, col=node.col,
            ))
        } else {
            throw new ValueError("Found " + stmt_name +
                "statement that has extend statement "
                "treating it as " + opposite_name + ".")
        }
        return none
    }
    return result_scope
}

func try_ensure_attr_ref(
        project_file, node_lefthand, node_righthand,
        parent_chain,
        error_on_invalid=no, msgs=none, is_moose64=no,
        debug=no
        ) {
    assert(typename(parent_chain) == "list")
    assert(node_righthand.kind == ast.N_EXPR_IDREF)
    if node_righthand.ref != none and
            node_righthand.value_typeref_expr != none {
        return later
    }
    visit_to_resolve_known_attrs(
        project_file, msgs,
        start_at_root=node_righthand,
        root_parents=parent_chain,
        is_moose64=is_moose64, debug=debug
        ) later:

    return later
}

func visit_to_mark_autoconst(
        project_file, msgs, is_moose64=no, debug=no
        ) {
    var pfile = project_file
    var prog_name = if is_moose64 ("moosec") else ("horsec")

    var success = yes
    func try_mark_autoconst(node, parents) {
        if node.kind != ast.N_STMT_VAR or
                node.symbol_info == none or
                node.symbol_info.len !=
                node.var_labels.len or
                node.scope == none or
                node.scope.func_scope == none {
            return later node
        }
        func var_is_for_sure_by_val(num) {
            assert(num >= 1 and num <= node.var_labels.len)
            if node.is_empty {
                return yes
            }
            var val = node.subexprs[num]
            if val.kind == ast.N_EXPR_LIT and
                    {"num", "str", "none"}.has(
                        val.value
                    ) {
                return yes
            }
            return no
        }
        if debug {
            print(prog_name + ": debug: " +
                "Considering these vars for auto-const: " +
                [node.var_labels, node.symbol_info].as_str())
        }
        var func_node = none
        var func_node_parent = none
        var i = parents.len
        while i >= 1 and parents[i].kind != ast.N_STMT_FUNC {
            i -= 1
        }
        if i < 1 {
            return later node
        }
        func_node = parents[i]
        func_node_parent = if i > 1
            (parents[i - 1]) else (none)

        var has_write_assign = []
        i = 1
        while i <= node.var_labels.len {
            has_write_assign.add(no)
            i += 1
        }

        var found_error = no
        func find_write_assign(inode, parents) {
            if inode.kind != ast.N_EXPR_IDREF or
                    not node.var_labels.has(inode.label) or
                    not st_scope.check_if_idref_matches_var_node(
                        inode, node
                    ) {
                return later inode
            }
            var idx = node.var_labels.find(inode.label)
            var is_by_val = var_is_for_sure_by_val(idx)

            if debug {
                print(prog_name + ": debug: " +
                    "Examining this use for auto-const: " +
                    [inode, parents[parents.len]].as_str())
            }
            var i = parents.len
            while i >= 1 {
                var child = if i < parents.len
                    (parents[i + 1]) else (inode)
                var parent = parents[i]
                if not is_by_val and ((
                        parent.kind == ast.N_EXPR_BINOP and
                        parent.optoken.str == ".") or
                        parent.kind == ast.N_EXPR_BINOP and
                        parent.optoken.str == "(") {
                    if debug {
                        print(prog_name + ": debug: " +
                            "  (Use IS potential write "
                            "for auto-const).")
                    }
                    has_write_assign[idx] = yes
                    return later inode
                }
                if parent.kind == ast.N_STMT_ASSIGN and
                        parent.subexprs.find(child) <=
                        parent.subexprs.len / 2 {
                    if debug {
                        print(prog_name + ": debug: " +
                            "  (Use IS potential write "
                            "for auto-const).")
                    }
                    if node.is_const and
                            i == parents.len and
                            not inode.is_damaged {
                        found_error = yes
                        inode.is_damaged = yes
                        if msgs != none {
                            msgs.add(new msg.FileMsg(
                                "Unexpected assignment to a "
                                "constant declared in line " +
                                node.line.as_str() + ", "
                                "column " +
                                node.col.as_str() + ". "
                                "This isn't allowed.",
                                source_file=pfile,
                                line=inode.line,
                                col=inode.col,
                            ))
                        }
                    }
                    has_write_assign[idx] = yes
                    return later inode
                }
                if parent.is_stmt {
                    break
                }
                i -= 1
            }
            if debug {
                print(prog_name + ": debug: " +
                    "  (Use isn't write for auto-const).")
            }
            return later inode
        }

        var inner_success = transform.visit_ast_tree(
            func_node, find_write_assign,
                subtree_parent=func_node_parent,
                parent_chain=yes) later:

        await inner_success
        if not inner_success or found_error {
            success = no
        }

        if not node.is_const {
            if not has_write_assign.has(yes) {
                if debug {
                    print(prog_name + ": debug: " +
                        "Making it auto-const.")
                }
                node.is_const = yes
            } else {
                node.vars_autoconst_list = []
                for has_write in has_write_assign {
                    node.vars_autoconst_list.add(
                        not has_write
                    )
                }
            }
        }

        return later node
    }
    var outer_success = transform.visit_ast_tree(
        project_file.ast, try_mark_autoconst,
            parent_chain=yes) later:

    await outer_success
    if not outer_success {
        success = no
    }
    return later success
}

func visit_to_resolve_known_attrs(
        project_file, msgs,
        start_at_root=none, root_parents=none,
        is_moose64=no, debug=no
        ) {
    var pfile = project_file
    var dbg_header = if is_moose64
        ("moosec: debug: ") else ("horsec: debug: ")

    var resolved_something = no
    var failure = no
    if debug {
        print(dbg_header +
            "visit_to_resolve_known_attrs(): "
            "Called with: start_at_root=" +
                start_at_root.as_str())
    }
    func try_resolve_item(node, parents) {
        if node.kind != ast.N_EXPR_IDREF {
            return later node
        }
        if node.ref != none and
                node.value_typeref_expr != none and
                node.ref.kind != st_ref._ST_RESOLVELATER {
            return later node
        }
        if debug {
            print(dbg_header +
                "visit_to_resolve_known_attrs(): "
                "Evaluating this idref node: " +
                    node.as_str())
        }
        if node.ref == none and (parents.len == 0 or
                parents[parents.len].kind != ast.N_EXPR_BINOP or
                parents[parents.len].optoken.str != '.') {
            # We can't actually ever resolve this node in a useful
            # way. Bail out, and emit error if this is Moose64.
            if is_moose64 {
                if msgs == none {
                    failure = yes
                    throw new ValueError("Found access to "
                        "non-existing item.")
                }
                msgs.add(new msg.FileMsg(
                    "Unknown reference '" + node.label +
                    "', can't find what it refers to.",
                    source_file=pfile,
                    line=node.line,
                    col=node.col,
                ))
                node.damaged = yes
                return later node
            }
            return later node
        }

        func resolve_lefthand_if_needed(node, parents) {
            var parent = if parents.len > 0
                (parents[parents.len])
                else (none)
            if parent.kind != ast.N_EXPR_BINOP or
                    parent.subexprs.len < 2 or
                    parent.subexprs[2] != node {
                return later yes
            }
            if parent.subexprs[1].kind == ast.N_EXPR_BINOP and
                    parent.subexprs[1].optoken.str == "." and
                    parent.subexprs[1].subexprs[2].kind ==
                        ast.N_EXPR_IDREF {
                if parent.subexprs[1].subexprs[2].ref != none and
                        parent.subexprs[1].subexprs[2].ref.kind !=
                        st_ref._ST_RESOLVELATER {
                    return later yes
                }
                parent.subexprs[1].subexprs[2].ref = none
                var result = try_resolve_item(
                    parent.subexprs[1].subexprs[2],
                    parents + [parent.subexprs[1]],
                ) later:

                await result
                if result == none {
                    return later no
                }
                return later yes
            }
            if parent.subexprs[1].kind == ast.N_EXPR_IDREF {
                if parent.subexprs[1].ref != none and
                        parent.subexprs[1].ref.kind !=
                        st_ref._ST_RESOLVELATER {
                    return later yes
                }
                parent.subexprs[1].ref = none
                var result = try_resolve_item(
                    parent.subexprs[1],
                    parents.copy(),
                ) later:

                await result
                if result == none {
                    return later no
                }
                return later yes
            }
            return later yes
        }
        var result = resolve_lefthand_if_needed(
            node, parents.copy()
        ) later:

        await result
        
        if debug {
            print(dbg_header +
                "visit_to_resolve_known_attrs(): "
                "Left-hand should be resolved now.")
        }
        if result == no {
            failure = yes
            return later node
        }

        var parent =
            if parents.len > 0 (parents[parents.len])
            else (none)
        var left_of_us = none
        if parent != none and
                parent.kind == ast.N_EXPR_BINOP and
                parent.optoken.str == "." and
                parent.subexprs.len >= 2 and
                parent.subexprs[1] != node {
            var left_of_us = parent.subexprs[1]
            if left_of_us.kind == ast.N_EXPR_BINOP and
                    left_of_us.optoken.str == "." {
                assert(left_of_us.subexprs[2].kind ==
                    ast.N_EXPR_IDREF)
                left_of_us = left_of_us.subexprs[2]
            }
            assert(left_of_us.kind == ast.N_EXPR_IDREF)
            assert(left_of_us != node)
        }
        if debug {
            print(dbg_header +
                "visit_to_resolve_known_attrs(): "
                "Got left_of_us=" + left_of_us.as_str())
        }
        if left_of_us == none {
            # This isn't an attribute, so we can't
            # go any deeper with our analysis here.
            return later node
        }

        var left_type_expr = none
        var left_type_global_ref = none
        var left_type_vnode = none
        var left_type_symbol_info = none
        if left_of_us.ref != none and
                left_of_us.ref.kind == st_ref.ST_LOCAL {
            var var_node =
                st_scope.find_def_node_from_idref_node(
                    left_of_us, parents
                )
            assert(var_node != none)
            left_type_vnode = var_node
        }
        var left_ref_result = ast_typeref.
            resolve_st_ref_to_type_ref_and_expr(
                project_file, left_of_us.ref,
                node=left_of_us,
                node_parents=parents,
                ignore_if_ref_none=yes,
                is_moose64=is_moose64,
                msgs=msgs,
                debug=no
            ) later:

        await left_ref_result
        if left_ref_result.storage_ref != none {
            left_type_global_ref = left_ref_result.storage_ref
        }
        if left_ref_result.type_expr != none {
            left_type_expr = left_ref_result.type_expr
        }
        if debug {
            print(dbg_header +
                "visit_to_resolve_known_attrs(): "
                "Got left_type_global_ref=" +
                    left_type_global_ref.as_str() + " "
                "left_type_expr=" +
                    left_type_expr.as_str())
        }

        var is_attr_error = no
        var attr_error_cause =
            "this value doesn't have this attribute"
        var our_type_ref = none
        var our_type_expr = none
        func resolve_usertype_attr_from_global_storage(
                storage_id, associated_type_expr_if_known=none,
                ) {
            assert(typename(storage_id) == "num")
            if associated_type_expr_if_known != none {
                if associated_type_expr_if_known.is_array() {
                    return no
                } elseif associated_type_expr_if_known.ref_count(
                        include_c_arrays=yes,
                        include_arrays=no,
                        include_implicit_refs=no,
                        include_explicit_refs=yes,
                        ) > 0 {
                    return no
                }
            }
            if not pfile.project.storage_id_to_anscope_map.has(
                    storage_id) {
                # This storage id refers to a global that isn't a type.
                return no
            }
            var anscope =
                pfile.project.storage_id_to_anscope_map[
                    storage_id
                ]
            if anscope.is_struct or anscope.is_type {
                if anscope.name_to_symbol_map.has(
                        node.label
                        ) {
                    var is_autoprop_func = no
                    var sym = anscope.name_to_symbol_map[
                        node.label]
                    if sym.kind == st_scope.SINFO_FUNCATTR {
                        var func_typeref_expr =
                            sym.typeref_expr
                        assert(func_typeref_expr != none)
                        is_autoprop_func =
                            func_typeref_expr.is_autoprop_func
                    }
                    our_type_ref = new st_ref.StorageRef(
                        st_ref.ST_GLOBALATTR,
                        [storage_id, sym.storage_id])
                } else {
                    is_attr_error = yes
                    var stmt_name = if anscope.is_struct
                        ("struct") else ("type")
                    attr_error_cause = stmt_name + " doesn't "
                        "have this attribute"
                }
            }
            return yes
        }
        var indexing_makes_it_readonly = no
        var indexing_worked = no
        if left_type_global_ref != none and
                left_type_global_ref.kind == st_ref.ST_GLOBAL and
                (left_type_expr == none or
                 left_type_expr.is_user_type()) {
            # Indexing a global user type, let's resolve this:
            indexing_worked =
                resolve_usertype_attr_from_global_storage(
                    left_type_global_ref.id,
                    associated_type_expr_if_known=left_type_expr,
                )
            if indexing_worked and left_type_expr != none and
                    left_type_expr.is_readonly() {
                indexing_makes_it_readonly = yes
            }
        }
        if debug {
            print(dbg_header +
                "visit_to_resolve_known_attrs(): "
                "Got indexing_worked=" +
                    indexing_worked.as_str() + " "
                "our_type_ref=" +
                    our_type_ref.as_str() + " "
                "indexing_makes_it_readonly=" +
                    indexing_makes_it_readonly.as_str())
        }
        if not indexing_worked and is_moose64 {
            if left_type_expr != none and
                    (not left_type_expr.is_user_type() or
                     left_type_global_ref != none) {
                if (node.label != "len" or
                         not left_type_expr.may_have_len_attr()) and
                        (node.label != "data" or
                         not left_type_expr.may_have_data_attr()) {
                    is_attr_error = yes
                }
            } else {
                is_attr_error = yes
            }
            var is_array = left_type_expr != none and
                left_type_expr.is_array()
            if not is_attr_error and
                    not left_type_expr.is_user_type() and
                    node.label == "len" {
                our_type_expr = new ast_typeref.TypeRefExpr()
                our_type_expr.is_special_madeup_builtin = yes
                our_type_expr.name = "size"
                var self_type = left_type_expr.copy()
                our_type_expr.special_madeup_builtin_base_expr =
                    self_type
            } elseif not is_attr_error and
                    is_array and
                    node.label == "data" {
                var array_info, array_typeinfo
                var our_type_expr_old = new ast_typeref.TypeRefExpr()
                our_type_expr_old.is_special_madeup_builtin = yes
                our_type_expr_old.name = "byte"
                if left_type_expr.is_readonly() {
                    our_type_expr_old.
                        modifiers.add(
                            new ast_typeref.TypeRefMod("readonly")
                        )
                }
                our_type_expr_old.
                    modifiers.add(
                        new ast_typeref.TypeRefMod("c_array")
                    )
                array_info =
                    left_type_expr.get_array_info(
                        project=pfile.project,
                        project_file=pfile,
                        is_moose64=is_moose64)
                array_typeinfo = array_info[2]
                our_type_expr =
                    array_typeinfo.convert_to_typeref_expr(
                        project=project, is_moose64=is_moose64,
                    )
                our_type_expr.modifiers.add(
                    new ast_typeref.TypeRefMod("c_array"))
                var self_type = left_type_expr.copy()
                our_type_expr.special_madeup_builtin_base_expr =
                    self_type
            } elseif not is_attr_error and
                    left_type_expr != none and
                    left_type_expr.is_user_type() {
                assert(left_type_global_ref != none)
                resolve_usertype_attr_from_global_storage(
                    left_type_global_ref.id,
                    associated_type_expr_if_known=left_type_expr,
                )
            }
        } elseif not is_moose64 and
                left_type_global_ref != none and
                left_type_global_ref.kind == st_ref.ST_LOCAL and
                left_type_orig_var_node != none and
                (left_type_orig_var_node.is_const or
                    (left_type_vnode.
                    vars_autoconst_list != none and
                    left_type_vnode.
                    vars_autoconst_list[
                        left_type_vnode.var_labels.find(node.label)
                    ])) {
            var value_eval = [ast_eval.AR_VALUE, none]
            var value_expr = none
            if left_type_vnode.subexprs.len > 0 {
                value_expr = left_type_vnode.subexprs[
                    left_type_vnode.var_labels.find(node.label)
                ]
            }
            if value_expr != none {
                value_eval = ast_eval.try_eval_ast_node_type(
                    value_expr, is_moose64=is_moose64,
                )
            }
            if value_eval[1] == ast_eval.AR_VALUE and
                    {"num", "bool", "none"}.has(typename(
                        value_eval[2])) and
                    node.label != "as_str" {
                is_attr_error = yes
                attr_error_cause = typename(value_eval[2]) + " "
                    "value doesn't have this attribute"
            }
        }
        if is_attr_error {
            if debug {
                print(dbg_header +
                    "visit_to_resolve_known_attrs(): "
                    "Got an attribute error.")
            }
            if is_moose64 {
                if msgs == none {
                    failure = yes
                    throw new ValueError("Found access to "
                        "non-existing attribute.")
                }
                if not node.damaged and
                        (left_of_us == none or
                        not left_of_us.damaged) {
                    msgs.add(new msg.FileMsg(
                        "Unexpected attribute name '" +
                            node.label +
                        "', " + attr_error_cause + ".",
                        source_file=pfile,
                        line=node.line,
                        col=node.col,
                    ))
                    resolved_something = yes
                }
                node.damaged = yes
            } else {
                var error_is_valid = ast_analyze.
                    ast_node_is_allowed_to_cause_type_error(
                        node, parents, allow_typename_guard=yes,
                        allow_attributeerror=yes,
                    )
                if not error_is_valid {
                    if msgs == none {
                        throw new ValueError(
                            "Found access to "
                            "non-existing attribute "
                            "without guard.")
                    }
                    if not node.damaged {
                        msgs.add(new msg.FileMsg(
                            "Unexpected attribute name '" +
                                node.label +
                            "', " + attr_error_cause + " "
                            "and the access isn't guarded.",
                            source_file=pfile,
                            line=node.line,
                            col=node.col,
                        ))
                        resolved_something = yes
                    }
                    node.damaged = yes
                } else {
                    is_attr_error = no
                }
            }
        }
        func resolve_our_type_ref_if_needed {
            if our_type_expr == none or
                    our_type_ref != none {
                return later
            }
            var result =
                our_type_expr.try_resolve_to_user_type(
                    project_file, force_recompute=no,
                    is_moose64=is_moose64
                ) later:

            await result
            our_type_ref = result.resolved_storage_ref
        }
        resolve_our_type_ref_if_needed()
        later:

        func resolve_our_type_expr_if_needed {
            if our_type_expr != none or
                    our_type_ref == none {
                return later
            }
            var result = ast_typeref.
                resolve_st_ref_to_type_ref_and_expr(
                    project_file, our_type_ref, node=node,
                    is_moose64=is_moose64, msgs=msgs,
                    debug=debug,
                ) later:

            await result
            our_type_expr = result.type_expr
            if indexing_makes_it_readonly and
                    not our_type_expr.is_readonly() and
                    not our_type_expr.is_func_ref and
                    our_type_expr.ref_count(
                        include_c_arrays=yes,
                        include_arrays=no,
                        include_implicit_refs=yes,
                        include_explicit_refs=yes,
                    ) > 0 {
                our_type_expr.modifiers.add(
                    new ast_typeref.TypeRefMod("readonly")
                )
            }
        }
        resolve_our_type_expr_if_needed()
        later:

        if debug {
            print(dbg_header +
                "visit_to_resolve_known_attrs(): "
                "Got our_type_expr=" +
                    our_type_expr.as_str())
        }
        if our_type_expr != none and
                node.value_typeref_expr == none {
            node.value_typeref_expr = our_type_expr.copy()
            if debug {
                print(dbg_header +
                    "visit_to_resolve_known_attrs(): "
                    "Setting node.value_typeref_expr to: " +
                    node.value_typeref_expr.as_str())
            }
            resolved_something = yes
        }
        if our_type_ref != none and
                node.kind == ast.N_EXPR_IDREF and
                node.ref == none {
            node.ref = our_type_ref.copy()
            resolved_something = yes
        }
        if debug {
            print(dbg_header +
                "visit_to_resolve_known_attrs(): " +
                "is_moose64=" + is_moose64.as_str() + " "
                "node=" + node.as_str() + " "
                "our_type_expr=" + our_type_expr.as_str() + " "
                "our_type_ref=" + our_type_ref.as_str() + " "
                "left_of_us=" + left_of_us.as_str() + " "
                "left_of_us.ref=" + if left_of_us != none
                    (left_of_us.ref.as_str()) else (none) + " "
                "left_type_global_ref=" +
                    left_type_global_ref.as_str() + " "
                "left_type_expr=" +
                    left_type_expr.as_str() + " "
                "is_attr_error=" +
                    is_attr_error.as_str())
        }
        return later node
    }

    if start_at_root == none {
        start_at_root = project_file.ast
        if root_parents != none {
            throw new ValueError(
                "Cannot set root parents if root isn't used."
            )
        }
    } else {
        if root_parents == none {
            root_parents = []
        }
        if typename(root_parents) != "list" {
            throw new TypeError(
                "The parents of the root must be supplied "
                "as a list of the complete parent chain."
            )
        }
    }
    var success = transform.visit_ast_tree(
        start_at_root, try_resolve_item,
        subtree_parent=root_parents,
        parent_chain=yes) later:

    await success
    if not success or failure {
        return no
    }
    if not resolved_something {
        return yes
    }
    resolved_something = no
    success = transform.visit_ast_tree(
        start_at_root, try_resolve_item,
        subtree_parent=root_parents,
        parent_chain=yes
    ) later repeat
}

