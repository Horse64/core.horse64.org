## @module compiler.moose64.codegen.c
# Copyright (c) 2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import io from core.horse64.org
import math from core.horse64.org
import path from core.horse64.org
import uri from core.horse64.org
import textfmt from core.horse64.org

import compiler.ast as ast
import compiler.ast.analyze as ast_analyze
import compiler.compiler_log as clog
import compiler.limit as climit
import compiler.moose64.ast.analyze as m64_ast_analyze
import compiler.moose64.builtins as m64_builtins
import compiler.msg as msg
import compiler.project
import compiler.storage.scope as st_scope
import compiler.storage.scope.manage as scope_manage
import compiler.storage.ref as st_ref
import compiler.typeinfo as typeinfo

type CExportResult {
    var project
    var build_base_dir_uri = none
    var build_c_source_uris = []
    var build_c_include_uris = []
}

func truncate_path_src_dir_if_present(
        fpath, project=none) {
    if project == none {
        throw new ValueError("The project option must "
            "be specified.")
    }
    if project.source_dir_prefix != none and
            project.source_dir_prefix.len > 0 and
            (fpath == project.source_dir_prefix or
                fpath.starts(
                    project.source_dir_prefix +
                    path.sep) or
                fpath.starts(
                    project.source_dir_prefix +
                    "/")) {
        fpath = fpath.sub(
            project.source_dir_prefix.len + 1
        )
        while fpath.starts(path.sep) or
                fpath.starts("/") {
            fpath = fpath.sub(2)
        }
    }
    return fpath
}

func get_global_symbol_c_name(global_name, project_file=none) {
    if project_file == none {
        throw new ValueError("The project_file option must be "
            "specified.")
    }
    var pkg_name = "unknown_moose64_package"
    var mod_name = "unknown_moose64_module"
    if project_file.modinfo != none {
        if project_file.modinfo.module_name != none {
            mod_name = project_file.modinfo.module_name
        }
        if project_file.modinfo.package_name != none {
            pkg_name = project_file.modinfo.package_name
        }
    }
    return "m64__" + pkg_name.replace(".", "_") + "__" +
        mod_name.replace(".", "__") + "__" + global_name
}

func get_c_func_signature_or_body(
        from_node=none, from_node_project_file=none,
        from_type_expr=none, from_storage_ref=none,
        indent=0,
        generate_code=no,
        generate_code_ast_parents_if_closure=none,
        generate_code_add_to_header_callback=none,
        generate_code_build_options=none,
        project=none,
        msgs=none, is_moose64=no) {
    var func_info = ast_analyze.get_func_info_with_true_node(
        from_node=from_node,
        from_node_project_file=from_node_project_file,
        from_type_expr=from_type_expr,
        from_storage_ref=from_storage_ref,
        project=project, is_moose64=is_moose64
    ) later:

    await func_info
    if func_info == none {
        return later none
    }
    var func_c_name = none
    var func_name = func_info.name
    var func_typeref_expr = func_info.typeref_expr
    var func_shallow_node = func_info.shallow_node
    var func_node = func_info.true_node
    var func_scope = func_info.func_scope
    var func_project_file = func_info.node_project_file
    if func_info.is_func_attr {
        var type_mod_name = "unnamed_code_file"
        assert(func_info.owning_type_project_file != none)
        func_c_name = get_global_symbol_c_name(
            func_info.owning_type_anscope.label + "__" + func_name,
            project_file=func_info.owning_type_project_file
        )
    } else {
        func_c_name = get_global_symbol_c_name(
            func_name, project_file=func_info.node_project_file
        )
    }

    func_project_file.ensure_ast() later:

    var c_return_type = "void"
    var func_tinfo = m64_ast_analyze.get_c_or_m64_type_of_node(
        func_project_file, func_node, [],
        store_self_value_ref_for_funcs=no,
        msgs=msgs
    ) later:

    await func_tinfo
    if func_tinfo == none or
            func_tinfo.kind != typeinfo.TI_FUNCREF or
            func_tinfo.func_typeexpr == none {
        throw new RuntimeError("Unexpectedly failed "
            "to get usable function type info.")
    }
    if func_tinfo.func_typeexpr.return_typeref_expr != none {
        var rexpr = func_tinfo.func_typeexpr.
            return_typeref_expr
        c_return_type = rexpr.as_c_code(
            global_name_assign_callback=
                get_global_symbol_c_name,
            global_register_m64_array_callback=
                project.c_export_tracker.
                    register_m64_array_type,
            project=project,
            project_file=func_info.node_project_file,
            is_moose64=is_moose64)
    }
    var indent_str = " ".rep(indent)
    var t = indent_str + c_return_type + " " +
        func_c_name + "("
    var arg_exprs = func_scope.extended_final_arg_type_exprs()
    var arg_names = func_scope.extended_final_arg_names()
    var arg_idx = 0
    for arg_name in arg_names {
        arg_idx += 1
        if arg_idx > 1 {
            t += ", "
        }
        t += arg_exprs[arg_idx].as_c_code(
            global_name_assign_callback=
                get_global_symbol_c_name,
            global_register_m64_array_callback=
                project.c_export_tracker.
                    register_m64_array_type,
            project=project,
            project_file=func_info.node_project_file,
            is_moose64=is_moose64)
        t += " "
        t += arg_names[arg_idx]
    }

    if not generate_code {
        t += ")"
        return later t
    }
    if not is_moose64 {
        throw new RuntimeError("Can't generate C code "
            "if not in moose64 mode.")
    }
    t += ") {\n"

    var contents = node_list_to_c_strings(
        func_info.node_project_file, func_node.subblocks[1],
        generate_code_ast_parents_if_closure + [func_node],
        indent=(indent + 4),
        add_to_header_callback=
            generate_code_add_to_header_callback,
        msgs=msgs, build_options=generate_code_build_options
    )
    later:

    await contents
    for line in contents {
        t += line + "\n"
    }
    t += indent_str + "}"

    return later t
}

type CHeaderUriInfo {
    var c_header_uri
    var c_header_rel_path
    var type_storage_ref
    var type_def_file
}

func get_c_header_uri_and_info_for_type(
        c_output_dir_uri,
        type_node=none, type_storage_ref=none,
        base_header_uri=none,
        name_as_temp_file=no,
        project_file=none, project=none,
        ) {
    var result = new CHeaderUriInfo()
    if c_output_dir_uri == none {
        return none
    }
    if project_file != none and project == none {
        project = project_file.project
    }
    if type_storage_ref != none and
            not {st_ref.ST_GLOBAL}.has(
                type_storage_ref.kind) {
        type_storage_ref = none
    }
    if type_storage_ref == none and
            type_node != none and
            type_node.kind == ast.N_EXPR_IDREF and
            type_node.ref != none and
            {st_ref.ST_GLOBAL}.has(type_node.ref.kind) {
        type_storage_ref = type_node.ref
    } elseif type_storage_ref == none and
            type_node != none and
            {ast.N_STMT_TYPE, ast.N_STMT_STRUCT}.has(
                type_node.kind
            ) and project_file.global_scope.name_to_stmt_map.has(
                type_node.label
            ) and typename(
                project_file.global_scope.name_to_stmt_map[
                    type_node.label
                ]
            ) != "list" and
            project_file.global_scope.name_to_stmt_map[
                    type_node.label
            ].kind == type_node.kind and
            project_file.global_scope.name_to_stmt_map[
                    type_node.label
            ].label == type_node.label {
        var found_storage_id
        for check_storage_id in project_file.global_scope.
                storage_id_to_entry {
            var entry = project_file.global_scope.
                storage_id_to_entry[check_storage_id]
            if typename(entry) != "list" and
                    entry.kind == type_node.kind and
                    entry.label == type_node.label {
                found_storage_id = check_storage_id
                break
            }
        }
        if found_storage_id != none {
            type_storage_ref = new st_ref.StorageRef(
                st_ref.ST_GLOBAL, found_storage_id
            )
        }
    } elseif type_storage_ref == none and
            type_node != none and
            type_node.kind == ast.N_EXPR_BINOP and
            type_node.optoken.str == "." and
            type_node.subexprs.len >= 2 and
            type_node.subexprs[2].kind == ast.N_EXPR_IDREF and
            type_node.subexprs[2].ref != none and
            {st_ref.ST_GLOBAL}.has(
                type_node.subexprs[2].ref.kind
            ) {
        type_storage_ref = type_node.subexprs[2].ref
    }
    if type_storage_ref == none {
        return none
    }
    assert(type_storage_ref.kind == st_ref.ST_GLOBAL)
    if project == none {
        return none
    }
    assert(project.storage_id_to_global_scope_map.has(
        type_storage_ref.id))
    var type_gscope =
        project.storage_id_to_global_scope_map[type_storage_ref.id]
    assert(type_gscope != none)
    assert(type_gscope.storage_id_to_entry.has(
        type_storage_ref.id))
    var def_node =
        type_gscope.storage_id_to_entry[type_storage_ref.id]
    if def_node.kind != ast.N_STMT_STRUCT and
            def_node.kind != ast.N_STMT_TYPE {
        throw new TypeError("Referenced item isn't a "
            "Horse64 type or Moose64 struct.")
    }
    var def_pfile = none
    for pfile in project.no_uri_files {
        if pfile.global_scope == type_gscope {
            def_pfile = pfile
            break
        }
    }
    if def_pfile == none {
        for pfile_uri in project.module_uri_to_file_map {
            var cmp_file = project.module_uri_to_file_map[
                pfile_uri
            ]
            if cmp_file.global_scope == type_gscope {
                def_pfile = cmp_file
                break
            }
        }
    }
    if def_pfile == none {
        throw new RuntimeError("Unexpectedly failed to "
            "find project_file for a type's "
            "global scope. This shouldn't ever happen.")
    }
    var pfile_c_uri = base_header_uri
    if pfile_c_uri == none {
        pfile_c_uri = get_c_output_uri_from_project_file(
            def_pfile, c_output_dir_uri,
            name_as_temp_file=name_as_temp_file
        )
    } elseif pfile_c_uri.ends(".h") {
        pfile_c_uri = pfile_c_uri.sub(
            1, pfile_c_uri.len - ".h".len
        ) + ".c"
    }
    assert(pfile_c_uri != none and
        pfile_c_uri.ends(".c"))
    var header_skeleton_uri = uri.add_part(
        c_output_dir_uri,
        get_rel_path_inside_output_dir(
            c_output_dir_uri, pfile_c_uri,
            project=project
        ))
    if name_as_temp_file {
        assert(header_skeleton_uri.ends(".m64.tmp.c"))
        header_skeleton_uri = header_skeleton_uri.sub(
            1, header_skeleton_uri.len - ".m64.tmp.c".len
        ) + ".type-skeleton." + def_node.label + ".m64.tmp.h"
    } else {
        assert(header_skeleton_uri.ends(".m64.c"))
        header_skeleton_uri = header_skeleton_uri.sub(
            1, header_skeleton_uri.len - ".m64.c".len
        ) + ".type-skeleton." + def_node.label + ".m64.h"
    }
    assert(header_skeleton_uri.ends(".h"))

    var c_header_rel_path = get_rel_path_inside_output_dir(
        c_output_dir_uri, header_skeleton_uri,
        project=project)
    assert(c_header_rel_path.ends(".h"))

    result.c_header_uri = header_skeleton_uri
    result.c_header_rel_path = c_header_rel_path
    result.type_storage_ref = type_storage_ref
    result.type_def_file = def_pfile
    return result
}

type CExportTracker {
    var project

    var known_array_types_map = {->}
}

extend type compiler.project.Project {
    var c_export_tracker
}

func CExportTracker.register_m64_array_type(array_info) {
    if array_info == none {
        throw new ValueError("Could not register this "
            "type as array type, it's invalid.")
    }
    if not self.known_array_types_map.has(
            array_info[1]) {
        self.known_array_types_map[array_info[1]] =
            array_info[2].copy()
    }
    return array_info
}

func m64_identifier_to_c_identifier(label) {
    return label
}

func get_rel_path_inside_output_dir(
        output_base_dir_uri, inner_file_uri,
        project=none, include_src_dir_prefix=yes) {
    if project == none {
        throw new ValueError("The project option "
            "must be set.")
    }
    output_base_dir_uri = uri.normalize(output_base_dir_uri)
    inner_file_uri = uri.normalize(inner_file_uri)

    var rel_dir_path
    if inner_file_uri.starts(output_base_dir_uri) {
        rel_dir_path = inner_file_uri.sub(
            output_base_dir_uri.len + 1)
        while rel_dir_path.starts(path.sep) or
                rel_dir_path.starts("/") {
            rel_dir_path = rel_dir_path.sub(2)
        }
        rel_dir_path = path.normalize(rel_dir_path)
        if not include_src_dir_prefix {
            rel_dir_path = truncate_path_src_dir_if_present(
                rel_dir_path, project=project
            )
        }
    } else {
        rel_dir_path = uri.basename(inner_file_uri)
        if include_src_dir_prefix and
                project.source_dir_prefix != none and
                project.source_dir_prefix.len > 0 {
            rel_dir_path = path.join(
                project.source_dir_prefix,
                rel_dir_path
            )
        }
    }
    return rel_dir_path
}

type CExportTrackerHeaderAndTypesInfo {
    var main_header_str = ""
    var other_headers_map = {->}
    var type_func_attrs_code = ""
}

func CExportTracker.generate_c_types_and_header_info(
        project_file, c_output_dir_uri,
        base_header_uri=none,
        build_options=none, msgs=none,
        name_as_temp_file=no) {
    const is_moose64 = yes

    var header_result = new CExportTrackerHeaderAndTypesInfo()

    var t = "\n"
    var t_c_include_str =
        "#include <stdlib.h>\n#include <stdint.h>\n"
    var c_file_include_paths = []

    var t_m64_include_str = "\n"
    var include_project_files_set = {}

    var types_include_str = "\n"
    var types_additional_header_str = "\n"
    var other_headers_map = {->}

    func ast_to_c_header_callback(
            project_file, header_line,
            msgs=none, build_options=none) {
        while header_line.starts("\n") {
            header_line = header_line.sub(2)
        }
        while header_line.ends("\n") {
            header_line = header_line.sub(
                1, header_line.len - 1)
        }
        types_additional_header_str += "\n" + header_line
    }

    func handle_gscope_entry(entry_name, entry) {
        if entry.kind == ast.N_STMT_C_IMPORT {
            for fpath in entry.file_paths {
                c_file_include_paths.add(fpath + "")
                t_c_include_str += "\n#include " +
                    textfmt.as_escaped_code_string(
                        fpath, for_c_code=yes
                    )
            }
        } elseif entry.kind == ast.N_STMT_IMPORT {
            if entry.project_file != none {
                var found = no
                for existing_entry in include_project_files_set {
                    if existing_entry == entry or
                            (existing_entry.source_uri != none and
                             entry.source_uri != none and
                             existing_entry.source_uri ==
                                entry.source_uri) {
                         found = yes
                     }
                }
                if not found {
                    include_project_files_set.add(entry.project_file)
                    var target_path = entry.project_file.
                        modinfo.rel_path
                    assert(target_path != none)
                    target_path += ".h"
                    target_path = truncate_path_src_dir_if_present(
                        target_path, project=project_file.project
                    )
                    t_m64_include_str += "\n#include " +
                        textfmt.as_escaped_code_string(
                            target_path, for_c_code=yes
                        )
                }
            }
        } elseif entry.kind == ast.N_STMT_STRUCT {
            assert(is_moose64)
            var result = get_c_header_uri_and_info_for_type(
                c_output_dir_uri, type_node=entry,
                base_header_uri=base_header_uri,
                name_as_temp_file=name_as_temp_file,
                project_file=project_file,
            )
            if result == none {
                throw new RuntimeError("Failed to get "
                    "C header URI for type.")
            }
            var c_header_uri = result.c_header_uri
            var type_st_ref = result.type_storage_ref
            var type_def_file = result.type_def_file
            var c_header_rel_path = result.c_header_rel_path

            var type_pkg_name = ["unnamed_pkg"]
            var type_mod_path = ["unnamed_code_file"]
            if type_def_file != none and
                    type_def_file.modinfo != none and
                    type_def_file.modinfo.module_name != none {
                type_mod_path = type_def_file.modinfo.module_name
                if typename(type_mod_path) == "str" {
                    type_mod_path = type_mod_path.split(".")
                } else {
                    type_mod_path = type_mod_path.copy()
                }
            }
            if type_def_file != none and
                    type_def_file.modinfo != none and
                    type_def_file.modinfo.package_name != none {
                type_pkg_name = type_def_file.modinfo.package_name
                assert(typename(type_pkg_name) == "str")
            }

            var t_struct = "\n"
            var header_guard_name = "UNNAMED_CODE_FILE"
            if project_file.modinfo != none and
                    project_file.modinfo.rel_path != none {
                var guardappend = project_file.modinfo.rel_path
                guardappend = guardappend.upper()
                if guardappend.ends(".M64") {
                    guardappend = guardappend.sub(
                        1, guardappend.len - ".M64".len)
                }
                guardappend = guardappend.replace("/", "__")
                guardappend = guardappend.replace("\\", "__")
                guardappend = guardappend.replace(".", "__")
                while "___" in guardappend {
                    guardappend = guardappend.replace("___", "__")
                }
                while guardappend.ends("_") {
                    guardappend = guardappend.sub(
                        1, guardappend.len - 1)
                }
                while guardappend.starts("_") {
                    guardappend = guardappend.sub(2)
                }
                header_guard_name = m64_identifier_to_c_identifier(
                    guardappend
                )
            }
            header_guard_name += "__TYPE_SKELETON__"
            header_guard_name += m64_identifier_to_c_identifier(
                entry.label.upper()
            ) + "__H_"
            t_struct += "#ifndef " + header_guard_name + "\n"
            t_struct += "#define " + header_guard_name + "\n"

            var struct_lbl = m64_identifier_to_c_identifier(
                "m64__" + type_pkg_name.replace(".", "_") +
                "__" + type_mod_path.join("__") + "__" +
                entry.label)
            t_struct += "struct " + struct_lbl + " {\n"
            t_struct += "};\n"
            t_struct += "typedef struct " + struct_lbl +
                " " + struct_lbl + ";\n"
            t_struct += "#endif  // " + header_guard_name + "\n"
            other_headers_map[c_header_uri] = t_struct

            var include_path = path.normalize(c_header_rel_path)
            include_path = truncate_path_src_dir_if_present(
                include_path, project=project_file.project
            )
            
            types_include_str += "#include " +
                textfmt.as_escaped_code_string(
                    include_path, for_c_code=yes
                ) + "\n"

            var anscope = project_file.
                make_attr_names_scope_from_node(
                    entry, msgs=msgs, is_moose64=is_moose64,
                    def_project_file=project_file
                )
            var func_attr_queue = []
            for attr_name in anscope.name_to_symbol_map {
                var sym = anscope.name_to_symbol_map[attr_name]
                assert(sym.kind != st_scope.SINFO_FUNC)
                if sym.kind != st_scope.SINFO_FUNCATTR {
                    continue
                }
                func_attr_queue.add([
                    attr_name,
                    new st_ref.StorageRef(st_ref.ST_GLOBALATTR,
                        [anscope.storage_id, sym.storage_id])
                ])
            }
            func handle_func_attr(attr_name, attr_st_ref) {
                var sig_result = get_c_func_signature_or_body(
                    from_storage_ref=attr_st_ref,
                    indent=0,
                    generate_code=yes,
                    generate_code_ast_parents_if_closure=none,
                    generate_code_add_to_header_callback=
                        ast_to_c_header_callback,
                    generate_code_build_options=build_options,
                    project=project_file.project,
                    msgs=msgs, is_moose64=is_moose64
                ) later:

                await sig_result
                if sig_result == none {
                    print("moosec: error: Internal error: "
                        "Unexpectedly failed to get C signature "
                        "for function: " + attr_st_ref.as_str())
                    throw new RuntimeError("Internal error, "
                        "C code gen for func unexpectedly failed.")
                }
                header_result.type_func_attrs_code += sig_result
                return later yes
            }
            func handle_func_attr_queue() {
                if func_attr_queue.len == 0 {
                    return later yes
                }
                var next_entry = func_attr_queue.pop()
                var result = handle_func_attr(
                    next_entry[1], next_entry[2]
                ) later:

                await result
                if not result {
                    return later no
                }
                if func_attr_queue.len == 0 {
                    return later yes
                }
                next_entry = func_attr_queue.pop()
                result = handle_func_attr(
                    next_entry[1], next_entry[2]
                ) later repeat
            }
            var success = handle_func_attr_queue()
            later:

            await success
            if not success {
                throw new RuntimeError("Unexpected problem "
                    "processing func attrs of struct.")
            }
        } elseif entry.kind == ast.N_STMT_TYPE {
            throw new RuntimeError("Type statements "
                "aren't supported for Moose64.")
        }
        return later
    }
    var handle_queue = []
    for entry_name in project_file.global_scope.name_to_stmt_map {
        var entry = project_file.global_scope.name_to_stmt_map[
            entry_name
        ]
        if typename(entry) == "list" {
            for item in entry {
                handle_queue.add([entry_name, item])
            }
        } else {
            handle_queue.add([entry_name, entry])
        }
    }
    func process_queue {
        if handle_queue.len == 0 {
            return later
        }
        var next_entry = handle_queue.pop()
        var result = handle_gscope_entry(
            next_entry[1], next_entry[2]
        ) later:

        await result
        if handle_queue.len == 0 {
            return later
        }
        next_entry = handle_queue.pop()
        result = handle_gscope_entry(
            next_entry[1], next_entry[2]
        ) later repeat
    }
    process_queue() later:

    for array_key in self.known_array_types_map {
        var arr_struct_name = "__m64arraystruct__" + array_key
        var arr_struct_guard = "ARRAYDEFINED__" +
            arr_struct_name.upper()
        t += "#ifndef " + arr_struct_guard + "\n"
        t += "#define " + arr_struct_guard + "\n"
        t += "struct " + arr_struct_name + " {\n"
        t += "    uint64_t len;\n"
        t += "};\n"
        t += "#endif  // " + arr_struct_guard + "\n"
    }
    header_result.main_header_str =
        "\n#ifdef __M64_DO_INCLUDE_C_TYPES\n" +
        t_c_include_str +
        "\n#undef __M64_DO_INCLUDE_C_TYPES\n"
        "#endif  // __M64_DO_INCLUDE_C_TYPES\n" +
        types_include_str + "\n" +
        t_m64_include_str + t + "\n" +
        types_additional_header_str
    header_result.other_headers_map =
        other_headers_map
    return header_result
}

func optoken_to_c_token(token) {
    if token.str == "^^" {
        return "^"
    }
    return token.str
}

func node_list_to_c_strings(project_file, node_list, parents,
        indent=0, add_to_header_callback=none,
        msgs=none, build_options=none) {
    var queue = node_list.copy()
    var result = []
    if queue.len == 0 {
        return later result
    }
    var node = queue.pop_at(1)
    var next_result = node_to_c_string(
        project_file, node, parents, indent=indent,
        add_to_header_callback=add_to_header_callback,
        msgs=msgs, build_options=build_options)
        later:

    await next_result
    if next_result == none {
        return later none
    }
    if next_result.trim().len > 0 {
        result.add(next_result)
    }
    if queue.len == 0 {
        return later result
    }
    node = queue.pop_at(1)
    next_result = node_to_c_string(
        project_file, node, parents, indent=indent,
        add_to_header_callback=add_to_header_callback,
        msgs=msgs, build_options=build_options)
        later repeat
}

func node_to_c_string(project_file, node, parents,
        indent=0, add_to_header_callback=none,
        msgs=none, build_options=none) {
    const is_moose64 = yes
    const project = project_file.project
    var indent_str = " ".rep(indent)
    if node.kind == ast.N_EXPR_LIT and
            typename(node.value) == "str" and
            not node.is_big_num {
        return later textfmt.as_escaped_code_string(
            node.value, for_c_code=yes
        )
    } elseif node.kind == ast.N_STMT_CALL {
        var call_expr = node.subexprs[1]
        var inner_result = node_to_c_string(
            project_file, call_expr, parents + [node],
            indent=indent,
            add_to_header_callback=add_to_header_callback,
            msgs=msgs, build_options=build_options)
        later:

        await inner_result
        return indent_str + inner_result + ";"
    } elseif node.kind == ast.N_STMT_IF {
        var is_first = yes
        func handle_single_clause(clause) {
            if clause.kind == ast.N_EXPR_IFELSECLAUSE {
                if clause.is_else {
                    is_first = no
                    var contents_strs = node_list_to_c_strings(
                        project_file, clause.subblocks[1],
                        parents + [node, clause],
                        indent=(indent + 4),
                        add_to_header_callback=
                            add_to_header_callback,
                        msgs=msgs, build_options=build_options)
                    later:

                    await contents_strs
                    var t = indent_str + "else {"
                    for line in contents_strs {
                        t += "\n" + line
                    }
                    t += "\n" + indent_str + "}"
                    return later t
                }
                var conditional_str = node_to_c_string(
                    project_file, clause.subexprs[1],
                    parents + [node, clause],
                    indent=indent,
                    add_to_header_callback=
                        add_to_header_callback,
                    msgs=msgs, build_options=build_options)
                later:

                await conditional_str
                var contents_strs = node_list_to_c_strings(
                    project_file, clause.subblocks[1],
                    parents + [node, clause],
                    indent=(indent + 4),
                    add_to_header_callback=
                        add_to_header_callback,
                    msgs=msgs, build_options=build_options)
                later:

                await contents_strs
                var t = indent_str
                if is_first {
                    is_first = no
                    t += "if (" + conditional_str + ") {"
                } else {
                    t += "else if (" + conditional_str + ") {"
                }
                for line in contents_strs {
                    t += "\n" + line
                }
                t += "\n" + indent_str + "}"
                return later t
            }
            return later ""
        }

        func handle_clauses {
            var result = []
            var queue = node.subexprs
            if queue.len == 0 {
                return later result
            }
            var clause = queue.pop_at(1)
            var cls_result = handle_single_clause(
                clause
            ) later:

            await cls_result
            result.add(cls_result)
            if queue.len == 0 {
                return later result
            }
            clause = queue.pop_at(1)
            cls_result = handle_single_clause(
                clause
            ) later repeat
        }
        var result = handle_clauses() later:

        await result
        var t = ""
        for clause_str in result {
            t += clause_str
        }
        if t.ends("\n") {
            t = t.sub(1, t.len - 1)
        }
        return later t
    } elseif node.kind == ast.N_STMT_WHILE {
        var expression_str = node_to_c_string(
            project_file, node.subexprs[1],
            parents + [node],
            indent=indent,
            add_to_header_callback=add_to_header_callback,
            msgs=msgs, build_options=build_options)
        later:

        await expression_str
        var contents = node_list_to_c_strings(
            project_file, node.subblocks[1],
            parents + [node], indent=(indent + 4),
            add_to_header_callback=add_to_header_callback,
            msgs=msgs, build_options=build_options
        )
        later:

        await contents
        var t = indent_str + "while (" +
            expression_str + ") {\n"
        for line in contents {
            t += line + "\n"
        }
        return t + indent_str + "}"
    } elseif node.kind == ast.N_STMT_RETURN {
        var expr_str = none
        func get_expression_if_needed() {
            if node.is_empty {
                return later
            }
            expr_str = node_to_c_string(
                project_file, node.subexprs[1],
                parents + [node],
                indent=indent,
                add_to_header_callback=
                    add_to_header_callback,
                msgs=msgs, build_options=build_options)
            later:

            await expr_str
        }
        get_expression_if_needed() later:

        var t = indent_str + "return"
        if expr_str != none and expr_str.len > 0 {
            t += " " + expr_str
        }
        t += ";"
        return later t
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.optoken.str == "." {
        if node.subexprs[2].kind == ast.N_EXPR_IDREF and
                node.subexprs[2].ref != none and
                node.subexprs[2].ref.kind ==
                    st_ref.ST_GLOBALATTR {
            var sinfo = st_ref.ref_to_symbol_info(
                node.subexprs[2].ref,
                project=project,
                is_moose64=is_moose64
            )
            if sinfo != none and
                    sinfo.kind == st_scope.SINFO_FUNCATTR {
                # XXX: This is a func attr on an object.
                # We don't care about the self value here,
                # since N_EXPR_BINOP '(' for calls doesn't
                # ever call this N_EXPR_BINOP '.' directly.
                # This means we're outside of the context of
                # a call.
                var result_str = node_to_c_string(
                    project_file, node.subexprs[2],
                    parents + [node],
                    indent=indent,
                    add_to_header_callback=
                        add_to_header_callback,
                    msgs=msgs, build_options=build_options)
                later:

                await result_str
                if parents.len == 0 or
                        parents[parents.len].kind !=
                            ast.N_EXPR_BINOP or
                        parents[parents.len].optoken.str != "." {
                    # Usually, we want to return this as
                    # explicit address reference.
                    return later "&(" + result_str + ")"
                }
                return later result_str
            }
        }
        var left_hand_str = node_to_c_string(
            project_file, node.subexprs[1],
            parents + [node],
            indent=indent,
            add_to_header_callback=add_to_header_callback,
            msgs=msgs, build_options=build_options)
        later:

        await left_hand_str
        var right_hand_str = node_to_c_string(
            project_file, node.subexprs[2],
            parents + [node],
            indent=indent,
            add_to_header_callback=add_to_header_callback,
            msgs=msgs, build_options=build_options)
        later:

        await right_hand_str
        return later left_hand_str + "." + right_hand_str
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.optoken.str == "(" {
        var left_hand_str = none
        var right_closing_str = ""
        var self_call_arg_str = none

        func try_get_left_hand_self_call {
            if left_hand_str != none {
                return later
            }
            if node.subexprs[1].kind != ast.N_EXPR_BINOP or
                    node.subexprs[1].optoken.str != "." or
                    node.subexprs[1].subexprs.len < 2 or
                    node.subexprs[1].subexprs[2].kind !=
                        ast.N_EXPR_IDREF or
                    node.subexprs[1].subexprs[2].ref == none or
                    node.subexprs[1].subexprs[2].ref.kind !=
                        st_ref.ST_GLOBALATTR {
                return later
            }

            var self_expr = node.subexprs[1].subexprs[1]
            var self_st_ref = none
            if self_expr.kind == ast.N_EXPR_IDREF {
                self_st_ref = self_expr.ref
            } elseif self_expr.kind == ast.N_EXPR_BINOP and
                    self_expr.optoken.str == "." and
                    self_expr.subexprs.len >= 2 and
                    self_expr.subexprs[2].kind ==
                        ast.N_EXPR_IDREF and
                    self_expr.subexprs[2].ref != none {
                self_st_ref = self_expr.subexprs[2].ref
            } else {
                return later
            }
            if not {st_ref.ST_GLOBAL, st_ref.ST_LOCAL,
                    st_ref.ST_SELF, st_ref.ST_MCREF,
                    st_ref.ST_ARG}.has(self_st_ref.kind) {
                return later
            }
            var self_arg_tinfo = m64_ast_analyze.
                get_c_or_m64_type_of_node(
                    project_file, self_expr,
                    parents + [node, node.subexprs[1]],
                    store_self_value_ref_for_funcs=no,
                    msgs=msgs
                ) later:

            await self_arg_tinfo
            var add_extra_ref = (
                self_arg_tinfo.ref_count(
                    include_c_arrays=no,
                    include_arrays=no
                ) == 0)

            left_hand_str = node_to_c_string(
                project_file, node.subexprs[1].subexprs[2],
                parents + [node, node.subexprs[1]],
                indent=indent,
                add_to_header_callback=
                    add_to_header_callback,
                msgs=msgs, build_options=build_options)
            later:

            await left_hand_str
            self_call_arg_str = node_to_c_string(
                project_file, self_expr,
                parents + [node, node.subexprs[1]],
                indent=indent,
                add_to_header_callback=
                    add_to_header_callback,
                msgs=msgs, build_options=build_options)
            later:

            await self_call_arg_str
            if add_extra_ref {
                self_call_arg_str = "&(" +
                    self_call_arg_str + ")"
            }
        }
        try_get_left_hand_self_call() later:

        func try_get_left_hand_builtins {
            if left_hand_str != none {
                return later
            }
            var is_as_ref = m64_builtins.
                is_ast_node_referring_to_m64_std_as_ref(
                    project_file, node.subexprs[1],
                    is_moose64=is_moose64
                )
            var is_deref = m64_builtins.
                is_ast_node_referring_to_m64_std_deref(
                    project_file, node.subexprs[1],
                    is_moose64=is_moose64
                )
            var is_size_of = m64_builtins.
                is_ast_node_referring_to_m64_std_size_of(
                    project_file, node.subexprs[1],
                    is_moose64=is_moose64
                )
            if not is_as_ref and not is_deref and
                    not is_size_of {
                return later
            }
            if is_as_ref {
                left_hand_str = "(&"
                right_closing_str = ")"
            } elseif is_deref {
                left_hand_str = "(*"
                right_closing_str = ")"
            } else {
                left_hand_str = "sizeof"
            }
        }
        try_get_left_hand_builtins() later:

        func try_get_left_hand_regular {
            if left_hand_str != none {
                return later
            }
            left_hand_str = node_to_c_string(
                project_file, node.subexprs[1],
                parents + [node],
                indent=indent,
                msgs=msgs, build_options=build_options)
            later:

            await left_hand_str
        }
        try_get_left_hand_regular() later:

        var t = left_hand_str + "("
        var is_first_arg = yes
        if self_call_arg_str != none {
            is_first_arg = no
            t += self_call_arg_str
        }

        func handle_arg_value(arg_expr) {
            var arg_expr_str = node_to_c_string(
                project_file, arg_expr,
                parents + [node, node.subexprs[2]],
                indent=indent,
                msgs=msgs, build_options=build_options)
            later:

            await arg_expr_str
            if is_first_arg {
                is_first_arg = no
            } else {
                t += ", "
            }
            t += arg_expr_str
        }

        assert(node.subexprs[2].kind == ast.N_EXPR_CALLARGS)
        var queue = node.subexprs[2].subexprs
        if queue.len == 0 {
            return later t
        }
        var entry = queue.pop_at(1)
        var result = handle_arg_value(entry)
        later:

        await result
        if queue.len == 0 {
            return later t + ")" + right_closing_str
        }
        entry = queue.pop()
        result = handle_arg_value(entry)
        later repeat
    } elseif node.kind == ast.N_EXPR_UNOP {
        var left_hand = node_to_c_string(
            project_file, node.subexprs[1],
            parents + [node],
            indent=indent,
            add_to_header_callback=add_to_header_callback,
            msgs=msgs, build_options=build_options)
        later:

        await left_hand
        return node.optoken.str + left_hand
    } elseif node.kind == ast.N_EXPR_BINOP {
        var left_hand = node_to_c_string(
            project_file, node.subexprs[1],
            parents + [node],
            indent=indent,
            add_to_header_callback=add_to_header_callback,
            msgs=msgs, build_options=build_options)
        later:

        await left_hand
        var right_hand = node_to_c_string(
            project_file, node.subexprs[2],
            parents + [node],
            indent=indent,
            add_to_header_callback=add_to_header_callback,
            msgs=msgs, build_options=build_options)
        later:

        await right_hand
        var trail = ""
        if optoken_to_c_token(node.optoken) == '[' {
            trail = "]"
        }
        return "(" + left_hand + ") " + optoken_to_c_token(
            node.optoken) + " (" + right_hand + ")" + trail
    } elseif node.kind == ast.N_STMT_ASSIGN {
        var assign_count = math.floor(node.subexprs.len / 2)
        if assign_count < 1 {
            return ""
        }
        var queue = []
        var idx = 1
        while idx <= assign_count {
            queue.add([
                node.subexprs[idx],
                node.subexprs[idx + assign_count]
            ])
            idx += 1
        }
        var t = ""
        func handle_assigned_value(entry) {
            var left_hand_str = node_to_c_string(
                project_file, entry[1],
                parents + [node], indent=indent,
                add_to_header_callback=
                    add_to_header_callback,
                msgs=msgs, build_options=build_options)
            later:

            await left_hand_str
            var right_hand_str = node_to_c_string(
                project_file, entry[2],
                parents + [node], indent=indent,
                add_to_header_callback=
                    add_to_header_callback,
                msgs=msgs, build_options=build_options)
            later:

            await right_hand_str
            t += indent_str + left_hand_str + " " +
                optoken_to_c_token(
                    node.assign_token) + " " +
                right_hand_str + ";\n"
        }

        if queue.len == 0 {
            return later t
        }
        var entry = queue.pop_at(1)
        var result = handle_assigned_value(entry)
        later:

        await result
        if queue.len == 0 {
            if t.ends("\n") {
                t = t.sub(1, t.len - 1)
            }
            return later t
        }
        entry = queue.pop()
        result = handle_assigned_value(entry)
        later repeat
    } elseif node.kind == ast.N_EXPR_IDREF {
        if node.ref == none {
            return node.label
        }
        if {st_ref.ST_GLOBAL, st_ref.ST_GLOBALATTR}.has(
                node.ref.kind) {
            var sinfo = st_ref.ref_to_symbol_info(
                node.ref,
                project=project,
                is_moose64=is_moose64
            )
            assert(sinfo != none)
            var effective_name = sinfo.name
            if sinfo.def_file != none {
                effective_name =
                    get_global_symbol_c_name(
                        sinfo.name,
                        project_file=sinfo.def_file)
            }
            assert(effective_name != none)
            return effective_name
        }
        assert(node.label != none)
        return node.label
    } elseif node.kind == ast.N_EXPR_LIT and
            typename(node.value) == "bool" {
        return if node.value ("1") else ("0")
    } elseif node.kind == ast.N_EXPR_LIT and
            node.value == none {
        return "((void*) 0)"
    } elseif node.kind == ast.N_EXPR_LIT and
            (typename(node.value) == "num" or
             (typename(node.value) == "str" and
              node.is_big_num)) {
        return node.value.as_str()
    } elseif node.kind == ast.N_STMT_VAR {
        var c_var_type = "void"
        var var_tinfo = m64_ast_analyze.get_c_or_m64_type_of_node(
            project_file, node, parents,
            store_self_value_ref_for_funcs=no,
            msgs=msgs
        ) later:

        await var_tinfo
        if var_tinfo == none {
            throw new RuntimeError("Unexpectedly failed "
                "to get usable var def type info.")
        }
        var texpr = var_tinfo.convert_to_typeref_expr(
            project=project_file.project,
            in_local_scope=node.scope,
            in_project_file=project_file,
            is_moose64=is_moose64
        )
        var c_var_type = texpr.as_c_code(
            global_name_assign_callback=
                get_global_symbol_c_name,
            global_register_m64_array_callback=
                project_file.project.c_export_tracker.
                    register_m64_array_type,
            project=project, project_file=project_file,
            is_moose64=is_moose64)
        assert(not c_var_type.has("."))

        var t = ""
        var is_global = no
        if node.scope == none {
            is_global = yes
            # This must be a global variable.
            for lbl in node.var_labels {
                t += indent_str + c_var_type + " " +
                    get_global_symbol_c_name(
                        lbl, project_file=project_file) + ";\n"
            }
        } else {
            for lbl in node.var_labels {
                t += indent_str + c_var_type + " " +
                    lbl + ";\n"
            }
        }
        func handle_assigned_values_if_needed {
            if node.is_empty {
                return later
            }
            var assigned_exprs = node.subexprs
            if node.has_type_expr and assigned_exprs.len > 0 {
                assigned_exprs = assigned_exprs.sub(
                    1, assigned_exprs.len - 1
                )
            }

            func handle_assigned_value(entry) {
                var expr_result = node_to_c_string(
                    project_file, entry[2], parents + [node],
                    indent=indent,
                    msgs=msgs, build_options=build_options)
                later:

                await expr_result
                if expr_result == none or
                        expr_result.trim() == "" {
                    return later
                }
                t += indent_str
                if is_global {
                    t += get_global_symbol_c_name(
                        entry[1], project_file=project_file)
                } else {
                    t += entry[1]
                }
                t += " = " + expr_result + ";\n"
            }

            var queue = []
            var idx = 0
            for lbl in node.var_labels {
                idx += 1
                if idx < 1 or idx > assigned_exprs.len {
                    continue
                }
                queue.add([
                    lbl, assigned_exprs[idx]
                ])
            }
            if queue.len == 0 {
                return later
            }
            var entry = queue.pop_at(1)
            var result = handle_assigned_value(entry)
            later:

            await result
            if queue.len == 0 {
                return later
            }
            entry = queue.pop()
            result = handle_assigned_value(entry)
            later repeat
        }
        handle_assigned_values_if_needed()
        later:

        if t.ends("\n") {
            t = t.sub(1, t.len - 1)
        }
        return later t
    } elseif node.kind == ast.N_STMT_FUNC {
        var t = get_c_func_signature_or_body(
            from_node=node,
            from_node_project_file=project_file,
            indent=indent,
            generate_code=yes,
            generate_code_ast_parents_if_closure=parents,
            generate_code_add_to_header_callback=
                add_to_header_callback,
            generate_code_build_options=build_options,
            project=project_file.project,
            msgs=msgs, is_moose64=is_moose64
        ) later:

        await t
        if t == none {
            return ""
        }
        return later t
    }
    return later ""
}

func ast_to_c(project_file, msgs=none, build_options=none,
        target_write_dir_uri=none, target_write_uri=none) {
    if project_file.project.c_export_tracker == none {
        project_file.project.c_export_tracker =
            new CExportTracker()
    }

    var max_nesting = math.round((climit.max_statement_nesting +
        climit.max_expression_nesting) * 1.5)

    var header_contents = ""
    var target_rel_path_without_src = "unnamed_code_file.m64.c"
    if target_write_uri != none {
        if target_write_dir_uri != none {
            target_rel_path_without_src =
                get_rel_path_inside_output_dir(
                    target_write_dir_uri, target_write_uri,
                    project=project_file.project,
                    include_src_dir_prefix=no
                )
        } else {
            target_rel_path_without_src = uri.basename(
                target_write_uri
            )
        }
    } elseif project_file.modinfo != none and
            project_file.modinfo.rel_path != none {
        target_rel_path_without_src =
            project_file.modinfo.rel_path
        target_rel_path_without_src =
            truncate_path_src_dir_if_present(
                target_rel_path_without_src,
                project=project_file.project
            )
        if not target_rel_path_without_src.ends(".m64") {
            target_rel_path_without_src += ".m64"
        }
        target_rel_path_without_src += ".c"
    }
        
    assert(target_rel_path_without_src != none)
    var header_name = target_rel_path_without_src
    assert(header_name.ends(".c"))
    header_name = header_name.sub(
        1, header_name.len - ".c".len) + ".h"
    func ast_to_c_header_callback(
            project_file, header_line,
            msgs=none, build_options=none) {
        while header_line.starts("\n") {
            header_line = header_line.sub(2)
        }
        while header_line.ends("\n") {
            header_line = header_line.sub(
                1, header_line.len - 1)
        }
        header_contents += "\n" + header_line
    }

    var stmt_strs = node_list_to_c_strings(
        project_file, project_file.ast.stmts, [],
        add_to_header_callback=
            ast_to_c_header_callback,
        msgs=msgs, build_options=build_options)
    later:

    await stmt_strs
    if stmt_strs == none {
        # There was an error.
        return later none
    }
    var t = "#include <stdio.h>\n"
        "#include <stdlib.h>\n"
        "#include <stdint.h>\n"
    t += "\n#include " +
        textfmt.as_escaped_code_string(
            header_name, for_c_code=yes
        ) + "\n"
    for stmt_s in stmt_strs {
        t += stmt_s + "\n"
    }
    var include_guard_name = "__M64_HEADER_"
    include_guard_name += get_global_symbol_c_name(
        "GUARD", project_file=project_file)
    header_contents =
        "\n#ifndef " + include_guard_name + "\n" +
        "#define " + include_guard_name + "\n" +
        "// FIXME: moosec will insert type info here later.\n" +
        header_contents +
        "\n#endif  // " + include_guard_name + "\n"
    return later [t, header_contents]
}

func guess_build_dir_from_build_options(build_options, project) {
    var boptions = build_options

    if boptions.moose64_build_dir != none {
        return later boptions.moose64_build_dir
    }
    var build_base_dir_uri
    if boptions.output_dir != none {
        build_base_dir_uri = uri.normalize(
            boptions.output_dir
        )
    } elseif boptions.output_file != none {
        build_base_dir_uri = uri.normalize(
            uri.dirname(boptions.output_file)
        )
    }
    if build_base_dir_uri == none {
        build_base_dir_uri = project.base_dir_uri
        if build_base_dir_uri == none {
            return later none
        }
    }

    # See if the build dir exists at all:
    var exists_check = io.exists(build_base_dir_uri)
    later:

    await exists_check
    if not exists_check {
        # Just return this unchanged.
        return later build_base_dir_uri
    }

    # See if the build dir ends with a common source nesting dir:
    var path_part = uri.get_path(build_base_dir_uri)
    var removable_component = none
    for ndir in compiler.project.valid_source_nesting_dirs {
        if path_part.ends("/" + ndir) or
                path_part.ends("/" + ndir + "/") {
            removable_component = ndir
            break
        }
    }
    if removable_component == none {
        return later build_base_dir_uri
    }

    var parent_dir_uri = uri.traverse_up(build_base_dir_uri)
    var test_result = compiler.project.check_is_project_dir(
        parent_dir_uri
    ) later:

    await test_result
    if test_result {
        return later parent_dir_uri
    }
    return later build_base_dir_uri
}

func get_c_output_uri_from_project_file(
        project_file, c_output_dir_uri,
        name_as_temp_file=no
        ) {
    var output_file_uri = c_output_dir_uri
    var file_relpath = none
    if project_file.modinfo != none and
                project_file.modinfo.rel_path != none {
        file_relpath = path.normalize(
            project_file.modinfo.rel_path
        )
        if file_relpath.starts(path.sep) {
            file_relpath = file_relpath.sub(2)
        }
    } else {
        file_relpath = "unnamed_code_file.m64"
        if project_file.project.source_dir_prefix != none and
                project_file.project.
                    source_dir_prefix.len > 0 and
                file_relpath.starts(
                    project_file.project.
                        source_dir_prefix + path.sep
                ) {
            file_relpath = file_relpath.sub(
                (project_file.project.
                    source_dir_prefix + path.sep).len
            )
        }
    }
    file_relpath = path.normalize(file_relpath + ".c")
    if name_as_temp_file {
        var fname = path.basename(file_relpath)
        fname = ".moosec." + fname
        assert(fname.ends(".c"))
        fname = fname.sub(1, fname.len - 2) + ".tmp.c"
        file_relpath = path.join(
            path.dirname(file_relpath), fname
        )
    }

    output_file_uri = uri.add_part(
        output_file_uri, file_relpath.replace(path.sep, "/")
    )
    return output_file_uri
}

func export_moose_project_to_c(
        project, name_as_temp_file=no,
        limit_to_entrypoint_file=no,
        msgs=none, build_options=none,
        ) {
    var boptions = build_options
    if boptions == none {
        throw new ValueError("C export requires "
            "build_options to be passed in.")
    }
    var program_name = boptions.build_program_name
    var export_result = new CExportResult()
    export_result.project = project

    var output_as_string = no
    if boptions.output_file == none and
            boptions.output_dir == none and
            not name_as_temp_file {
        output_as_string = yes
        if not limit_to_entrypoint_file {
            throw new ValueError("C export not as temp file "
                "with no output file or output dir must "
                "be limited as entrypoint file so it can be "
                "returned as one string.")
        }
    }
    var c_output_file_uri = boptions.output_file
    var c_output_dir_uri = boptions.output_dir
    if name_as_temp_file {
        # The output file or dir refers to something else,
        # like a final binary, not a C file.
        c_output_file_uri = none
        c_output_dir_uri = uri.normalize(
            project.base_dir_uri
        )
        export_result.build_base_dir_uri = uri.normalize(
            project.base_dir_uri
        )
        if project.source_dir_prefix != none and
                project.source_dir_prefix.len > 0 {
            c_output_dir_uri = uri.add_part(
                c_output_dir_uri,
                project.source_dir_prefix
            )
        }
    }
    # Figure out the build dir if needed:
    func find_build_dir {
        if export_result.build_base_dir_uri != none {
            return later
        }
        var uri =
            guess_build_dir_from_build_options(
                boptions, project
            ) later:

        await uri
        export_result.build_base_dir_uri = uri
    }
    find_build_dir() later:

    # Now process each file to translate it to C:
    var output_string_result = none
    var pfile_to_header_uri_map = {->}
    func process_file(pfile) {
        var c_result
        var header_result
        var combined_result = ast_to_c(
            pfile, msgs=msgs, build_options=boptions,
            target_write_dir_uri=c_output_dir_uri,
            target_write_uri=c_output_file_uri,
        ) later:

        await combined_result
        if combined_result == none {
            var goterror = no
            if msgs != none {
                for m in msgs {
                    if m.kind == msg.M_ERROR {
                        goterror = yes
                        break
                    }
                }
            }
            if not goterror {
                if msgs == none {
                    throw new RuntimeError("Internal error, "
                        "unexpectedly failed to generate C code "
                        "but no error was returned.")
                }
                msgs.add(new msg.FileMsg(
                    "Internal error, unexpectedly failed to "
                    "generate C code with no error for this file: " +
                    if pfile.source_uri != none (pfile.source_uri)
                        else ("<unknown anonymous file>"),
                    source_file=pfile,
                    line=none,
                    col=none,
                ))
            }
            return later no
        }
        c_result = combined_result[1]
        header_result = combined_result[2]

        if limit_to_entrypoint_file and
                not pfile.is_entrypoint {
            return later yes
        } elseif limit_to_entrypoint_file and
                pfile.is_entrypoint and output_as_string {
            output_string_result = c_result
            return later yes
        }

        var output_file_uri
        var output_header_file_uri
        var output_file_dir_uri
        var c_output_dir_uri_concrete = c_output_dir_uri
        if c_output_dir_uri_concrete == none {
            assert(c_output_file_uri != none)
            c_output_dir_uri_concrete = path.dirname(
                c_output_file_uri
            )
            output_file_uri = c_output_file_uri
        }
        if output_file_uri == none {
            output_file_uri = c_output_dir_uri_concrete
            output_file_uri =
                get_c_output_uri_from_project_file(
                    pfile, c_output_dir_uri_concrete,
                    name_as_temp_file=name_as_temp_file
                )
        }
        if output_file_dir_uri == none {
            output_file_dir_uri = uri.traverse_up(
                output_file_uri
            )
        }
        if output_header_file_uri == none {
            var header_name = uri.basename(
                output_file_uri
            )
            if header_name.lower().ends(".c") {
                header_name = header_name.sub(
                    1, header_name.len - 2
                )
            }
            header_name += ".h"
            output_header_file_uri = uri.add_part(
                uri.traverse_up(output_file_uri), header_name
            )
            pfile_to_header_uri_map[pfile] =
                output_header_file_uri
        }

        if not {"file"}.has(uri.get_protocol(output_file_uri)) {
            if msgs == none {
                throw new RuntimeError("This type of URI "
                "is currently not handled by the "
                "compiler.moose64.codegen.c_gen."
                "export_moose_project_to_c function.")
            }
            msgs.add(new msg.FileMsg(
                "Unexpected " + uri.get_protocol(output_file_uri) +
                ":// URI, this protocol is currently not "
                "supported by the C code generator.",
                source_file=pfile,
            ))
            return later no
        }

        if boptions.verbose_mode {
            clog.log_or_print(new msg.FileMsg(
                "export_moose_project_to_c(): "
                "Ensuring folder exists: " +
                    output_file_dir_uri,
                kind=msg.M_INFO,
                source_file=pfile,
            ), msgs=msgs, program_name=program_name)
        }
        io.make_dir(
            uri.to_file_or_vfs_path(
                output_file_dir_uri
            ), allow_vfs=no,
            allow_nested=yes, ignore_exists=yes
        ) later:

        func write_main_file() {
            if boptions.verbose_mode {
                clog.log_or_print(new msg.FileMsg(
                    "export_moose_project_to_c(): "
                    "Writing to: " + output_file_uri,
                    kind=msg.M_INFO,
                    source_file=pfile,
                ), msgs=msgs, program_name=program_name)
            }
            export_result.build_c_source_uris.add(
                output_file_uri)

            var disk_path = uri.to_file_or_vfs_path(
                output_file_uri)
            with io.open(disk_path, "w") later as f {
                f.write(c_result)
                later:

                return later
            }
        }
        write_main_file() later:

        func write_header_file() {
            if boptions.verbose_mode {
                clog.log_or_print(new msg.FileMsg(
                    "export_moose_project_to_c(): "
                    "Writing to: " + output_header_file_uri,
                    kind=msg.M_INFO,
                    source_file=pfile,
                ), msgs=msgs, program_name=program_name)
            }
            export_result.build_c_include_uris.add(
                output_header_file_uri)

            var disk_path = uri.to_file_or_vfs_path(
                output_header_file_uri)
            with io.open(disk_path, "w") later as f {
                f.write(header_result)
                later:

                return later
            }
        }
        var write_success = write_header_file()
        later:

        await write_success
        return later yes
    }
    var result = project.do_for_all_files(process_file)
    later:

    await result
    assert(result == yes or result == no)

    if output_as_string {
        if result and output_string_result != none {
            return later output_string_result
        }
        return later none
    }
    if not result {
        return none
    }

    func process_header_types_for_file(pfile) {
        if not pfile_to_header_uri_map.has(pfile) {
            # Somehow, we're not generating headers for this file.
            # Could be the case if output is limited to a single
            # file in the project.
            return later yes
        }

        var c_output_dir_uri_concrete = c_output_dir_uri
        if c_output_dir_uri_concrete == none {
            assert(c_output_file_uri != none)
            c_output_dir_uri_concrete = path.dirname(
                c_output_file_uri
            )
            output_file_uri = c_output_file_uri
        }
        var header_types_result = pfile.project.
            c_export_tracker.generate_c_types_and_header_info(
                pfile, c_output_dir_uri_concrete,
                base_header_uri=
                    pfile_to_header_uri_map[pfile],
                build_options=build_options,
                msgs=msgs,
                name_as_temp_file=name_as_temp_file
            ) later:

        await header_types_result
        var header_types_str = header_types_result.main_header_str
        var ancillary_headers_map =
            header_types_result.other_headers_map


        var output_header_file_uri =
            pfile_to_header_uri_map[pfile]

        func output_ancillary_header(header_uri, content) {
            if not {"file"}.has(uri.get_protocol(header_uri)) {
                if msgs == none {
                    throw new RuntimeError("This type of URI "
                    "is currently not handled by the "
                    "compiler.moose64.codegen.c_gen."
                    "export_moose_project_to_c function.")
                }
                msgs.add(new msg.FileMsg(
                    "Unexpected " + uri.get_protocol(header_uri) +
                    ":// URI, this protocol is currently not "
                    "supported by the C code generator.",
                    source_file=pfile,
                ))
                return later no
            }
            if boptions.verbose_mode {
                clog.log_or_print(new msg.FileMsg(
                    "export_moose_project_to_c(): "
                    "Writing to: " + header_uri,
                    kind=msg.M_INFO,
                    source_file=pfile,
                ), msgs=msgs, program_name=program_name)
            }
            var disk_path = uri.to_file_or_vfs_path(header_uri)
            with io.open(disk_path, "w") later as f {
                f.write(content)
                later:

                return later yes
            }
            return later yes
        }
        func output_ancillary_headers() {
            var queue = []
            for key in ancillary_headers_map {
                queue.add([key, ancillary_headers_map[key]])
            }
            if queue.len == 0 {
                return later
            }
            var item = queue.pop()
            var result = output_ancillary_header(
                item[1], item[2]
            ) later:

            await result
            if not result {
                return later
            }
            if queue.len == 0 {
                return later
            }
            item = queue.pop()
            result = output_ancillary_header(
                item[1], item[2]
            ) later repeat
        }
        output_ancillary_headers() later:

        if boptions.verbose_mode {
            clog.log_or_print(new msg.FileMsg(
                "export_moose_project_to_c(): "
                "Inserting full type info for: " +
                output_header_file_uri,
                kind=msg.M_INFO,
                source_file=pfile,
            ), msgs=msgs, program_name=program_name)
        }
        var header_str = none
        func read_header_file() {
            var disk_path = uri.to_file_or_vfs_path(
                output_header_file_uri)
            with io.open(disk_path, "r") later as f {
                header_str = f.read()
                later:

                await header_str
                return later yes
            }
        }
        var read_success = read_header_file()
        later:

        await read_success
        var placeholder =
            "// FIXME: moosec will insert type info here later."
        var pos = header_str.find(placeholder)
        if pos == none {
            return later yes
        }
        header_str = header_str.sub(1, pos - 1) +
            header_types_str + header_str.sub(pos + placeholder.len)

        func write_header_file() {
            var disk_path = uri.to_file_or_vfs_path(
                output_header_file_uri)
            with io.open(disk_path, "w") later as f {
                f.write(header_str)
                later:

                return later yes
            }
        }
        var write_success = write_header_file()
        later:

        await write_success
        return later yes
    }
    result = project.do_for_all_files(
        process_header_types_for_file)
    later:

    await result
    assert(result == yes or result == no)
    return later export_result
}

