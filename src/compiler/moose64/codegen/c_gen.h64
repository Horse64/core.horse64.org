## @module compiler.moose64.codegen.c
# Copyright (c) 2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import io from core.horse64.org
import math from core.horse64.org
import path from core.horse64.org
import uri from core.horse64.org
import textfmt from core.horse64.org

import compiler.ast as ast
import compiler.compiler_log as clog
import compiler.limit as climit
import compiler.moose64.ast.analyze as m64_ast_analyze
import compiler.msg as msg
import compiler.project
import compiler.storage.ref as st_ref
import compiler.typeinfo as typeinfo

type CExportResult {
    var project
    var build_base_dir_uri = none
    var build_c_source_uris = []
}

func get_global_symbol_c_name(global_name, project_file=none) {
    if project_file == none {
        throw new ValueError("The project_file opion must be "
            "specified.")
    }
    var pkg_name = "unknown_moose64_package"
    var mod_name = "unknown_moose64_module"
    if project_file.modinfo != none {
        if project_file.modinfo.module_name != none {
            mod_name = project_file.modinfo.module_name
        }
        if project_file.modinfo.package_name != none {
            pkg_name = project_file.modinfo.package_name
        }
    }
    return "m64__" + pkg_name.replace(".", "_") + "__" +
        mod_name.replace(".", "__") + "__" + global_name
}

func node_list_to_c_strings(project_file, node_list, parents,
        indent=0, msgs=none, build_options=none) {
    var queue = node_list.copy()
    var result = []
    if queue.len == 0 {
        return later result
    }
    var node = queue.pop_at(1)
    var next_result = node_to_c_string(
        project_file, node, parents, indent=indent,
        msgs=msgs, build_options=build_options)
        later:

    await next_result
    if next_result == none {
        return later none
    }
    result.add(next_result)
    if queue.len == 0 {
        return later result
    }
    node = queue.pop_at(1)
    next_result = node_to_c_string(
        project_file, node, parents, indent=indent,
        msgs=msgs, build_options=build_options)
        later repeat
}

func node_to_c_string(project_file, node, parents,
        indent=0, msgs=none, build_options=none) {
    const is_moose64 = yes
    const project = project_file.project
    var indent_str = " ".rep(indent)
    if node.kind == ast.N_EXPR_LIT and
            typename(node.value) == "str" and
            not node.is_big_num {
        return later textfmt.as_escaped_code_string(
            node.value
        )
    } elseif node.kind == ast.N_STMT_CALL {
        var call_expr = node.subexprs[1]
        var inner_result = node_to_c_string(
            project_file, call_expr, parents + [node],
            indent=indent,
            msgs=msgs, build_options=build_options)
        later:

        await inner_result
        return indent_str + inner_result + ";"
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.optoken.str == "." {
        var left_hand = node_to_c_string(
            project_file, node.subexprs[1],
            parents + [node],
            indent=indent,
            msgs=msgs, build_options=build_options)
        later:

        await left_hand
        var right_hand = node_to_c_string(
            project_file, node.subexprs[2],
            parents + [node],
            indent=indent,
            msgs=msgs, build_options=build_options)
        later:

        await right_hand
        return left_hand + "." + right_hand
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.optoken.str == "(" {
        var left_hand = node_to_c_string(
            project_file, node.subexprs[1],
            parents + [node],
            indent=indent,
            msgs=msgs, build_options=build_options)
        later:

        await left_hand
        var t = left_hand + "("

        var is_first_arg = yes
        func handle_arg_value(arg_expr) {
            var arg_expr_str = node_to_c_string(
                project_file, arg_expr,
                parents + [node, node.subexprs[2]],
                indent=indent,
                msgs=msgs, build_options=build_options)
            later:

            await arg_expr_str
            if is_first_arg {
                is_first_arg = no
            } else {
                t += ", "
            }
            t += arg_expr_str
        }

        assert(node.subexprs[2].kind == ast.N_EXPR_CALLARGS)
        var queue = node.subexprs[2].subexprs
        if queue.len == 0 {
            return later t
        }
        var entry = queue.pop_at(1)
        var result = handle_arg_value(entry)
        later:

        await result
        if queue.len == 0 {
            return later t + ")"
        }
        entry = queue.pop()
        result = handle_arg_value(entry)
        later repeat
    } elseif node.kind == ast.N_EXPR_UNOP {
        var left_hand = node_to_c_string(
            project_file, node.subexprs[1],
            parents + [node],
            indent=indent,
            msgs=msgs, build_options=build_options)
        later:

        await left_hand
        return node.optoken.str + left_hand
    } elseif node.kind == ast.N_EXPR_BINOP {
        var left_hand = node_to_c_string(
            project_file, node.subexprs[1],
            parents + [node],
            indent=indent,
            msgs=msgs, build_options=build_options)
        later:

        await left_hand
        var right_hand = node_to_c_string(
            project_file, node.subexprs[2],
            parents + [node],
            indent=indent,
            msgs=msgs, build_options=build_options)
        later:

        await right_hand
        return left_hand + node.optoken.str + right_hand
    } elseif node.kind == ast.N_STMT_ASSIGN {
        var assign_count = math.floor(node.subexprs.len / 2)
        if assign_count < 1 {
            return ""
        }
        var queue = []
        var idx = 1
        while idx <= assign_count {
            queue.add([
                node.subexprs[idx],
                node.subexprs[idx + assign_count]
            ])
            idx += 1
        }
        var t = ""
        func handle_assigned_value(entry) {
            var left_hand_str = node_to_c_string(
                project_file, entry[1],
                parents + [node], indent=indent,
                msgs=msgs, build_options=build_options)
            later:

            await left_hand_str
            var right_hand_str = node_to_c_string(
                project_file, entry[2],
                parents + [node], indent=indent,
                msgs=msgs, build_options=build_options)
            later:

            await right_hand_str
            t += left_hand_str + " = " +
                right_hand_str + ";\n"
        }

        if queue.len == 0 {
            return later t
        }
        var entry = queue.pop_at(1)
        var result = handle_assigned_value(entry)
        later:

        await result
        if queue.len == 0 {
            if t.ends("\n") {
                t = t.sub(1, t.len - 1)
            }
            return later t
        }
        entry = queue.pop()
        result = handle_assigned_value(entry)
        later repeat
    } elseif node.kind == ast.N_EXPR_IDREF {
        if node.ref == none {
            return node.label
        }
        if {st_ref.ST_GLOBAL, st_ref.ST_GLOBALATTR}.has(
                node.ref) {
            var sinfo = st_ref.ref_to_symbol_info(
                self.storage_ref,
                project=project,
                is_moose64=is_moose64
            )
            assert(sinfo != none)
            var effective_name = sinfo.label
            if sinfo.def_file != none {
                effective_name =
                    get_global_symbol_c_name(
                        sinfo.label,
                        project_file=sinfo.def_file)
            }
            return effective_name
        }
        return node.label
    } elseif node.kind == ast.N_EXPR_LIT and
            typename(node.value) == "bool" {
        return if node.value (1) else (0)
    } elseif node.kind == ast.N_EXPR_LIT and
            node.value == none {
        return "((void*) 0)"
    } elseif node.kind == ast.N_EXPR_LIT and
            (typename(node.value) == "num" or
             (typename(node.value) == "str" and
              node.is_big_num)) {
        return node.value.as_str()
    } elseif node.kind == ast.N_STMT_VAR {
        var c_var_type = "void"
        var var_tinfo = m64_ast_analyze.get_c_or_m64_type_of_node(
            project_file, node, parents,
            store_self_value_ref_for_funcs=no,
            msgs=msgs
        ) later:

        await var_tinfo
        if var_tinfo == none {
            throw new RuntimeError("Unexpectedly failed "
                "to get usable var def type info.")
        }
        var texpr = var_tinfo.convert_to_typeref_expr(
            project=project_file.project,
            in_local_scope=node.scope,
            in_project_file=project_file,
            is_moose64=is_moose64
        )
        var c_var_type = texpr.as_c_code(
            global_name_assign_callback=
                get_global_symbol_c_name,
            project=project, is_moose64=is_moose64)
        var t = ""
        var is_global = no
        if node.scope == none {
            is_global = yes
            # This must be a global variable.
            for lbl in node.var_labels {
                t += indent_str + c_var_type + " " +
                    get_global_symbol_c_name(
                        lbl, project_file=project_file) + ";\n"
            }
        } else {
            for lbl in node.var_labels {
                t += indent_str + c_var_type + " " +
                    lbl + ";\n"
            }
        }
        func handle_assigned_values_if_needed {
            if node.is_empty {
                return later
            }
            var assigned_exprs = node.subexprs
            if node.has_type_expr and assigned_exprs.len > 0 {
                assigned_exprs = assigned_exprs.sub(
                    1, assigned_exprs.len - 1
                )
            }

            func handle_assigned_value(entry) {
                var expr_result = node_to_c_string(
                    project_file, entry[2], parents + [node],
                    indent=indent,
                    msgs=msgs, build_options=build_options)
                later:

                await expr_result
                if expr_result == none or
                        expr_result.trim() == "" {
                    return later
                }
                t += indent_str
                if is_global {
                    t += get_global_symbol_c_name(
                        entry[1], project_file=project_file)
                } else {
                    t += entry[1]
                }
                t += " = " + expr_result + ";\n"
            }

            var queue = []
            var idx = 0
            for lbl in node.var_labels {
                idx += 1
                if idx < 1 or idx > assigned_exprs.len {
                    continue
                }
                queue.add([
                    lbl, assigned_exprs[idx]
                ])
            }
            if queue.len == 0 {
                return later
            }
            var entry = queue.pop_at(1)
            var result = handle_assigned_value(entry)
            later:

            await result
            if queue.len == 0 {
                return later
            }
            entry = queue.pop()
            result = handle_assigned_value(entry)
            later repeat
        }
        handle_assigned_values_if_needed()
        later:

        if t.ends("\n") {
            t = t.sub(1, t.len - 1)
        }
        return later t
    } elseif node.kind == ast.N_STMT_FUNC {
        if node.type_path != none and node.type_path.len > 0 {
            return later ""
        }
        var c_return_type = "void"
        var func_tinfo = m64_ast_analyze.get_c_or_m64_type_of_node(
            project_file, node, parents,
            store_self_value_ref_for_funcs=no,
            msgs=msgs
            ) later:

        await func_tinfo
        if func_tinfo == none or
                func_tinfo.kind != typeinfo.TI_FUNCREF or
                func_tinfo.func_typeexpr == none {
            throw new RuntimeError("Unexpectedly failed "
                "to get usable function type info.")
        }
        if func_tinfo.func_typeexpr.return_typeref_expr != none {
            var rexpr = func_tinfo.func_typeexpr.
                return_typeref_expr
            c_return_type = rexpr.as_c_code(
                global_name_assign_callback=
                    get_global_symbol_c_name,
                project=project, is_moose64=is_moose64)
        }
        var t = indent_str + c_return_type + " " +
            get_global_symbol_c_name(
                node.label, project_file=project_file
            ) + "() {\n"

        var contents = node_list_to_c_strings(
            project_file, node.subblocks[1],
            parents + [node], indent=(indent + 4),
            msgs=msgs, build_options=build_options)
            later:

        await contents
        for line in contents {
            t += line + "\n"
        }
        t += indent_str + "}"
        return later t
    }
    return later ""
}

func ast_to_c(project_file, msgs=none, build_options=none) {
    var max_nesting = math.round((climit.max_statement_nesting +
        climit.max_expression_nesting) * 1.5)

    var stmt_strs = node_list_to_c_strings(
        project_file, project_file.ast.stmts, [],
        msgs=msgs, build_options=build_options)
    later:

    await stmt_strs
    if stmt_strs == none {
        # There was an error.
        return later none
    }
    var t = "#include <stdio.h>\n"
        "#include <stdlib.h>\n"
    for stmt_s in stmt_strs {
        t += stmt_s + "\n"
    }
    return later t
}

func guess_build_dir_from_build_options(build_options, project) {
    var boptions = build_options

    if boptions.moose64_build_dir != none {
        return later boptions.moose64_build_dir
    }
    var build_base_dir_uri
    if boptions.output_dir != none {
        build_base_dir_uri = uri.normalize(
            boptions.output_dir
        )
    } elseif boptions.output_file != none {
        build_base_dir_uri = uri.normalize(
            uri.dirname(boptions.output_file)
        )
    }
    if build_base_dir_uri == none {
        build_base_dir_uri = project.base_dir_uri
        if build_base_dir_uri == none {
            return later none
        }
    }

    # See if the build dir exists at all:
    var exists_check = io.exists(build_base_dir_uri)
    later:

    await exists_check
    if not exists_check {
        # Just return this unchanged.
        return later build_base_dir_uri
    }

    # See if the build dir ends with a common source nesting dir:
    var path_part = uri.get_path(build_base_dir_uri)
    var removable_component = none
    for ndir in compiler.project.valid_source_nesting_dirs {
        if path_part.ends("/" + ndir) or
                path_part.ends("/" + ndir + "/") {
            removable_component = ndir
            break
        }
    }
    if removable_component == none {
        return later build_base_dir_uri
    }

    var parent_dir_uri = uri.traverse_up(build_base_dir_uri)
    var test_result = compiler.project.check_is_project_dir(
        parent_dir_uri
    ) later:

    await test_result
    if test_result {
        return later parent_dir_uri
    }
    return later build_base_dir_uri
}

func export_moose_project_to_c(
        project, name_as_temp_file=no,
        limit_to_entrypoint_file=no,
        msgs=none, build_options=none,
        ) {
    var boptions = build_options
    if boptions == none {
        throw new ValueError("C export requires "
            "build_options to be passed in.")
    }
    var program_name = boptions.build_program_name
    var export_result = new CExportResult()
    export_result.project = project

    var output_as_string = no
    if boptions.output_file == none and
            boptions.output_dir == none and
            not name_as_temp_file {
        output_as_string = yes
        if not limit_to_entrypoint_file {
            throw new ValueError("C export not as temp file "
                "with no output file or output dir must "
                "be limited as entrypoint file so it can be "
                "returned as one string.")
        }
    }
    var c_output_file_uri = boptions.output_file
    var c_output_dir_uri = boptions.output_dir
    if name_as_temp_file {
        # The output file or dir refers to something else,
        # like a final binary, not a C file.
        c_output_file_uri = none
        c_output_dir_uri = uri.normalize(
            project.base_dir_uri
        )
        export_result.build_base_dir_uri = uri.normalize(
            project.base_dir_uri
        )
        if project.source_dir_prefix != none and
                project.source_dir_prefix.len > 0 {
            c_output_dir_uri = uri.add_part(
                c_output_dir_uri,
                project.source_dir_prefix
            )
        }
    }
    # Figure out the build dir if needed:
    func find_build_dir {
        if export_result.build_base_dir_uri != none {
            return later
        }
        var uri =
            guess_build_dir_from_build_options(
                boptions, project
            ) later:

        await uri
        export_result.build_base_dir_uri = uri
    }
    find_build_dir() later:

    # Now process each file to translate it to C:
    var output_string_result = none
    func process_file(pfile) {
        var c_result = ast_to_c(
            pfile, msgs=msgs, build_options=boptions
        ) later:

        await c_result
        if c_result == none {
            var goterror = no
            if msgs != none {
                for m in msgs {
                    if m.kind == msg.M_ERROR {
                        goterror = yes
                        break
                    }
                }
            }
            if not goterror {
                if msgs == none {
                    throw new RuntimeError("Internal error, "
                        "unexpectedly failed to generate C code "
                        "but no error was returned.")
                }
                msgs.add(new msg.FileMsg(
                    "Internal error, unexpectedly failed to "
                    "generate C code with no error for this file: " +
                    if pfile.source_uri != none (pfile.source_uri)
                        else ("<unknown anonymous file>"),
                    source_file=pfile,
                    line=none,
                    col=none,
                ))
            }
            return later no
        }
        if limit_to_entrypoint_file and
                not pfile.is_entrypoint {
            return later yes
        } elseif limit_to_entrypoint_file and
                pfile.is_entrypoint and output_as_string {
            output_string_result = c_result
            return later yes
        }

        var output_file_uri
        if c_output_dir_uri == none {
            assert(c_output_file_uri != none)
            c_output_dir_uri = path.dirname(c_output_file_uri)
            output_file_uri = c_output_file_uri
        }
        if output_file_uri == none {
            output_file_uri = c_output_dir_uri
            var file_relpath = none
            if pfile.modinfo != none and
                        pfile.modinfo.rel_path != none {
                file_relpath = path.normalize(
                    pfile.modinfo.rel_path
                )
                if project.source_dir_prefix != none and
                        project.source_dir_prefix.len > 0 and
                        file_relpath.starts(
                            project.source_dir_prefix + path.sep
                        ) {
                    file_relpath = file_relpath.sub(
                        (project.source_dir_prefix + path.sep).len
                    )
                }
            } else {
                file_relpath = "unnamed_code_file.m64"
            }
            file_relpath = path.normalize(file_relpath + ".c")
            if name_as_temp_file {
                var fname = path.basename(file_relpath)
                fname = ".moosec." + fname
                assert(fname.ends(".c"))
                fname = fname.sub(1, fname.len - 2) + ".tmp.c"
                file_relpath = path.join(
                    path.dirname(file_relpath), fname
                )
            }
            output_file_uri = uri.add_part(
                output_file_uri, file_relpath.replace(path.sep, "/")
            )
        }
        if boptions.verbose_mode {
            clog.log_or_print(new msg.FileMsg(
                "export_moose_project_to_c(): "
                "Writing to: " + output_file_uri,
                kind=msg.M_INFO,
                source_file=pfile,
            ), msgs=msgs, program_name=program_name)
        }
        export_result.build_c_source_uris.add(output_file_uri)

        if not {"file"}.has(uri.get_protocol(output_file_uri)) {
            if msgs == none {
                throw new RuntimeError("This type of URI "
                    "is currently not handled by the "
                    "compiler.moose64.codegen.c_gen."
                    "export_moose_project_to_c function.")
            }
            msgs.add(new msg.FileMsg(
                "Unexpected " + uri.get_protocol(output_file_uri) +
                ":// URI, this protocol is currently not supported by "
                "the C code generator.",
                source_file=pfile,
            ))
            return later no
        }
        var disk_path = uri.to_file_or_vfs_path(output_file_uri)
        with io.open(disk_path, "w") later as f {
            f.write(c_result)
            later:

            return later yes
        }
        return later yes
    }
    var result = project.do_for_all_files(process_file)
    later:

    await result
    assert(result == yes or result == no)

    if output_as_string {
        if result and output_string_result != none {
            return later output_string_result
        }
        return later none
    }
    if not result {
        return none
    }
    return later export_result
}

