## @module compiler.moose64.ast.transform
# Copyright (c) 2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import random from core.horse64.org

import compiler.ast as ast
import compiler.ast.return_stmt as return_stmt
import compiler.ast.transform as ast_transform
import compiler.moose64.ast.analyze as m64_ast_analyze
import compiler.msg as msg

type DeferInfo {
    var sorting_prio
    var called_name = "$called" + random.gen_id()
    var called_storage_ref = none
    var arg_names = []
    var arg_storage_refs = []
}

type DeferAddedStatements {
    var defer_infos = []
    var stmts_added_to_inner_block = []
    var stmts_added_before_node = []
}

func transform_defer(project_file, ast_result, msgs) {
    var node_to_defer_added_stmts_map = {->}
    var last_sorting_prio = 1

    func get_node_defer_added(node, defer_info) {
        var defer_added = none
        if not node_to_defer_added_stmts_map.has(node) {
            defer_added = new DeferAddedStatements()
        }
        defer_added = node_to_defer_added_stmts_map[node]
        if not defer_added.defer_infos.has(defer_info) {
            defer_added.defer_infos.add(defer_info)
        }
        return defer_added
    }

    var had_no_error = yes
    func do_transform_defer(node, parent) {
        if node.kind != ast.N_STMT_DEFER {
            return later node
        }

        last_sorting_prio += 1
        var defer_info = new DeferInfo()
        defer_info.called_name += "_prio" + last_sorting_prio.as_str()
        assert(node.subexprs.len == 1)
        assert(node.subexprs[1].kind == ast.N_EXPR_BINOP)
        assert(node.subexprs[1].optoken.str == '(')
        var func_type = m64_ast_analyze.get_c_or_m64_type_of_node(
            project_file, node.subexprs[1].subexprs[1],
            node.subexprs[1], msgs=msgs
        ) later:

        await func_type
        if func_type == none {
            msgs.add(new msg.FileMsg(
                "Unexpectedly failed to determine C type of "
                "deferred function. Did you use cyclic references?",
                kind=msg.M_ERROR, source_file=project_file,
                line=node.subexprs[1].line,
                col=node.subexprs[1].col,
            ))
            node.damaged = yes
            had_no_error = no
            return later node
        }

        if parent.kind == ast.N_STMT_FUNC {
            assert(parent.subblocks[1].len > 0)
            var block = parent.subblocks[1]
            if block[block.len].kind != ast.N_STMT_RETURN {
                var defer_added = get_node_defer_added(node, defer_info)
            }
        } else {
            var parent_block = get_node_parent_block(node, parent)
            assert(parent_block != none)
            if parent_block.len == 0 or
                    not {ast.N_STMT_BREAK, ast.N_STMT_CONTINUE,
                    ast.N_STMT_RETURN}.has(
                        parent_block[parent_block.len].kind
                    ) {
                var defer_added = get_node_defer_added(node, defer_info)
            }
        }
        
        func attach_defer_resolution(node, parent) {
            # FIXME
        }

        var stmts = ast.get_neighbor_statements_after(
            node, parent, stop_at_return=yes
        )

        # Find all block exit points and add the defer info:
        var queue = stmts.copy()
        if queue.len == 0 {
            return later
        }
        var next_node = queue.pop_at(1)
        var result = ast_transform.visit_ast_tree(
            next_node, attach_defer_resolution,
            pass_func_boundaries=no, parent_chain=no, backward=no)
        later:

        await result
        assert(result == yes)
        if queue.len == 0 {
            return later
        }
        next_node = queue.pop_at(1)
        result = ast_transform.visit_ast_tree(
            next_node, attach_defer_resolution,
            pass_func_boundaries=no, parent_chain=no, backward=no)
        later repeat
        return later node
    }
    var result = ast_transform.visit_ast_tree(
        ast_result, do_transform_defer, pass_func_boundaries=yes,
        parent_chain=no, backward=no, subtree_parent=none,
        return_new_root=no
    ) later:

    await result
    if result and not had_no_error {
        result = no
    }
    return result
}

func do_moose64_transforms(project_file, msgs) {
    var result = transform_defer(
        project_file, project_file.ast, msgs
    ) later:

    await result

    return result
}

