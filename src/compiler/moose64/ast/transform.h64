## @module compiler.moose64.ast.transform
# Copyright (c) 2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import math from core.horse64.org
import random from core.horse64.org

import compiler.ast as ast
import compiler.ast.analyze as ast_analyze
import compiler.ast.builder as ast_builder
import compiler.ast.call_or_assign_stmt as call_or_assign_stmt
import compiler.ast.expr as ast_expr
import compiler.ast.return_stmt as return_stmt
import compiler.ast.transform as ast_transform
import compiler.builtin_syms as builtin_syms
import compiler.moose64.ast.analyze as m64_ast_analyze
import compiler.msg as msg
import compiler.storage.ref as st_ref
import compiler.token as token
import compiler.typeinfo as typeinfo
import compiler.typeinfo.ast_typeref as ast_typeref

type DeferInfo {
    var sorting_prio
    var called_name = "$called" + random.gen_id()
    var called_storage_ref = none
    var arg_names = []
    var defer_func_var_name = none
}

type DeferAddedStatements {
    var defer_infos = []
    var stmts_added_after_node = []
    var stmts_added_before_node = []
}

func transform_defer(
        project_file, ast_result, msgs, is_moose64=yes
        ) {
    if not is_moose64 {
        throw new RuntimeError("Not implemented.")
    }
    var node_to_defer_added_stmts_map = {->}
    var last_sorting_prio = 1

    func get_node_defer_added(node, defer_info) {
        var defer_added = none
        if not node_to_defer_added_stmts_map.has(node) {
            defer_added = new DeferAddedStatements()
            node_to_defer_added_stmts_map[node] = defer_added
        }
        defer_added = node_to_defer_added_stmts_map[node]
        if not defer_added.defer_infos.has(defer_info) {
            defer_added.defer_infos.add(defer_info)
        }
        return defer_added
    }

    var builder = new ast_builder.ASTBuilder(project_file)

    var had_no_error = yes
    func do_transform_defer(node, parents) {
        var parent = if parents.len > 0
            (parents[parents.len]) else (none)
        if node.kind != ast.N_STMT_DEFER or node.damaged {
            return later node
        }

        last_sorting_prio += 1
        var defer_info = new DeferInfo()
        defer_info.called_name += "_prio" + last_sorting_prio.as_str()
        assert(node.subexprs.len == 1)
        assert(node.subexprs[1].kind == ast.N_EXPR_BINOP)
        assert(node.subexprs[1].optoken.str == '(')
        var parent_block = ast.get_node_parent_block(
            node, parent
        )
        if parent_block == none {
            throw new RuntimeError("Internal error, failed to "
                "obtain parent block of node. Please report "
                "this error to the compiler makers.")
        }
        var cnode = node.subexprs[1].subexprs[1]
        var result = ast_analyze.get_called_or_assigned_func_types(
            project_file, node.subexprs[1].subexprs[1],
            parents + [node, node.subexprs[1]],
            allow_matching_func_override=(
                cnode.kind ==
                    ast.N_EXPR_IDREF or
                (cnode.kind == ast.N_EXPR_BINOP and
                cnode.optoken.str == "." and
                cnode.subexprs[2].kind == ast.N_EXPR_IDREF)
            ),
            ignore_arg_mismatch=no,
            msgs=msgs, is_moose64=is_moose64,
            debug=no
        ) later:

        await result
        if result == none or node.damaged {
            return later node
        }
        if result.func_was_overridden {
            if cnode.kind == ast.N_EXPR_IDREF {
                if cnode.label ==
                        result.func_var_preoverridden_name {
                    cnode.label = result.func_var_name
                }
            } else {
                assert(cnode.subexprs[2].kind == ast.N_EXPR_IDREF)
                if cnode.subexprs[2].label ==
                        result.func_var_preoverridden_name {
                    cnode.subexprs[2].label = result.func_var_name
                }
            }
        }

        var func_var_typeref = result.func_var_type_expr
        var self_typeref_expr = result.self_var_type_expr
        var arg_var_typerefs = result.arg_var_type_exprs
        var idx = parent_block.find(node)
        assert(idx != none)
        var expr_copy = node.subexprs[1].subexprs[1]
        var func_var_node = builder.make_var_node(
            node.scope, "defer_called_func_",
            typeref_expr=func_var_typeref, expr=expr_copy,
            line=node.line, col=node.col, add_unique_suffix=yes
        )
        assert(func_var_node.symbol_info != none and
            typename(func_var_node.symbol_info) == "list" and
            func_var_node.symbol_info.len == 1)
        defer_info.defer_func_var_name = func_var_node.var_labels[1]
        parent_block = parent_block.sub(1, idx) + [func_var_node] +
            parent_block.sub(idx + 1)
        var self_var_node = none
        if self_typeref_expr != none {
            var self_typeref_ref_expr = self_typeref_expr.copy()
            self_typeref_ref_expr.modifiers.add(
                new ast_typeref.TypeRefMod("ref")
            )
            assert(expr_copy.kind == ast.N_EXPR_BINOP)
            assert(expr_copy.optoken.str == '.')
            var assigned_self_ref_inner = expr_copy.subexprs[1].copy()
            var assigned_self_ref_called = new ast_expr.IdRefExpr()
            assigned_self_ref_called.scope = node.scope
            assigned_self_ref_called.line = node.line
            assigned_self_ref_called.col = node.col
            assigned_self_ref_called.label = "as_ref"
            assigned_self_ref_called.type_path = ["std"]
            if project_file.modinfo != none and
                    project_file.modinfo.
                        package_name == "m64.horse64.org" and
                    project_file.modinfo.
                        module_name == "std" {
                assigned_self_ref_called.type_path = none
            }
            assigned_self_ref_called.ref =
                builtin_syms.try_lookup_symbol(
                    project_file.project, "as_ref", "std",
                    in_package_name="m64.horse64.org"
                )
            var assigned_self_ref_callargs =
                new ast_expr.CallArgsExpr()
            assigned_self_ref_callargs.scope = node.scope
            assigned_self_ref_callargs.line = node.line
            assigned_self_ref_callargs.col = node.col
            assigned_self_ref_callargs.subexprs = [
                assigned_self_ref_inner
            ]
            var optoken = new token.Token('(', token.T_ENCLOSE,
                node.line, node.col)
            assert(node.scope != none)
            var assigned_self_ref = new ast_expr.BinopExpr(
                optoken
            )
            assigned_self_ref.scope = node.scope
            assigned_self_ref.line = node.line
            assigned_self_ref.col = node.col
            assigned_self_ref.subexprs = [
                assigned_self_ref_called,
                assigned_self_ref_callargs
            ]
            self_var_node = builder.make_var_node(
                node.scope, "defer_called_func_self_",
                typeref_expr=self_typeref_ref_expr,
                expr=assigned_self_ref,
                line=node.line, col=node.col, add_unique_suffix=yes
            )
            parent_block = parent_block.sub(1, idx) + [self_var_node] +
                parent_block.sub(idx + 1)
        }

        var arg_var_nodes = []
        var i = 0
        for arg_typeref in arg_var_typerefs {
            i += 1
            var arg_type_node = builder.make_var_node(
                node.scope,
                "defer_called_func_" + i.as_str() + "nth_arg_",
                typeref_expr=arg_typeref,
                line=node.line, col=node.col, add_unique_suffix=yes
            )
            arg_var_nodes.add(arg_type_node)
            parent_block = parent_block.sub(1, idx) + [arg_type_node] +
                parent_block.sub(idx + 1)
        }
        ast.set_node_parent_block(node, parent, parent_block)

        var defer_resolve_node = new call_or_assign_stmt.CallStmt()
        defer_resolve_node.scope = node.scope
        defer_resolve_node.line = node.line
        defer_resolve_node.col = node.col
        var optoken = new token.Token(
            '(', token.T_ENCLOSE, node.line, node.col
        )
        var defer_resolve_called_expr = new ast_expr.IdRefExpr()
        defer_resolve_called_expr.scope = node.scope
        defer_resolve_called_expr.label = func_var_node.var_labels[1]
        defer_resolve_called_expr.line = node.line
        defer_resolve_called_expr.col = node.col
        defer_resolve_called_expr.ref =
            node.scope.lookup(
                func_var_node.var_labels[1], is_write_access=no
            )[1]
        var defer_resolve_args_expr = new ast_expr.CallArgsExpr()
        defer_resolve_args_expr.scope = node.scope
        defer_resolve_args_expr.line = node.line
        defer_resolve_args_expr.col = node.col
        var effective_arg_names = []
        if self_var_node != none {
            assert(self_var_node.var_labels.len == 1)
            effective_arg_names.add(self_var_node.var_labels[1])
        }
        for arg_node in arg_var_nodes {
            assert(arg_node.var_labels.len == 1)
            effective_arg_names.add(arg_node.var_labels[1])
        }
        defer_info.arg_names = effective_arg_names
        var defer_resolve_call = new ast_expr.BinopExpr(optoken)
        defer_resolve_call.scope = node.scope
        defer_resolve_call.line = node.line
        defer_resolve_call.col = node.col
        defer_resolve_call.subexprs = [
            defer_resolve_called_expr, defer_resolve_args_expr
        ]
        defer_resolve_node.subexprs = [defer_resolve_call]

        func copy_node_with_fixed_call_args(defer_info, node) {
            if node.kind != ast.N_STMT_CALL or
                    node.subexprs[1].kind != ast.N_EXPR_BINOP or
                    node.subexprs[1].subexprs[1].kind !=
                        ast.N_EXPR_IDREF or
                    node.subexprs[1].subexprs[1].label !=
                        defer_info.defer_func_var_name {
                return node.copy()
            }
            var result = node.copy()
            assert(result.subexprs[1].subexprs[2].subexprs.len == 0)
            for name in defer_info.arg_names {
                var ref = node.scope.lookup(name)[1]
                var idref = new ast_expr.IdRefExpr()
                idref.label = name
                idref.ref = ref
                idref.line = node.line
                idref.col = node.col
                idref.scope = node.scope
                result.subexprs[1].subexprs[2].subexprs.add(idref)
            }
            return result
        }

        func get_resolve_copy_in_scope(defer_info, scope) {
            var copy = copy_node_with_fixed_call_args(
                defer_info, defer_resolve_node
            )
            copy.scope = scope
            copy.subexprs[1].scope = scope
            copy.subexprs[1].subexprs[1].scope = scope
            copy.subexprs[1].subexprs[2].scope = scope
            assert(not copy.subexprs[1].subexprs[2].has_types)
            for arg_expr in copy.subexprs[1].subexprs[2].subexprs {
                arg_expr.scope = scope
            }
            return copy
        }
        if parent.kind == ast.N_STMT_FUNC {
            assert(parent.subblocks[1].len > 0)
            var block = parent.subblocks[1]
            if block[block.len].kind != ast.N_STMT_RETURN {
                var defer_added = get_node_defer_added(
                    block[block.len], defer_info
                )
                defer_added.stmts_added_before_node.add(none)
                defer_added.stmts_added_after_node.add(
                    get_resolve_copy_in_scope(defer_info, node.scope)
                )
            }
        } else {
            assert(parent_block != none)
            if parent_block.len == 0 or
                    not {ast.N_STMT_BREAK, ast.N_STMT_CONTINUE,
                    ast.N_STMT_RETURN}.has(
                        parent_block[parent_block.len].kind
                    ) {
                var last_node = parent_block[parent_block.len]
                var defer_added = get_node_defer_added(
                    last_node, defer_info)
                defer_added.stmts_added_before_node.add(none)
                defer_added.stmts_added_after_node.add(
                    get_resolve_copy_in_scope(defer_info, node.scope)
                )
            }
        }

        var outer_parent = parent
        func attach_defer_resolution(node, parents) {
            var parent = parents[parents.len]
            if {ast.N_STMT_BREAK, ast.N_STMT_CONTINUE}.has(
                    node.kind) {
                var associated_loop = none
                var i = parents.len
                while i >= 1 and parents.len > 0 and
                        parents[i] != outer_parent {
                    if {ast.N_STMT_FOR, ast.N_STMT_WHILE}.has(
                            parents[i].kind) {
                        associated_loop = parents[i]
                        break
                    }
                    i -= 1
                }
                if associated_loop != none {
                    # This doesn't exit our block, so ignore it.
                    return later node
                }
            } elseif node.kind != ast.N_STMT_RETURN {
                return later node
            }
            assert(node.kind == ast.N_STMT_RETURN)

            var return_var_node = none
            if not node.is_empty and
                    (node.subexprs[1].kind != ast.N_EXPR_LIT or
                     (node.subexprs[1].value != none and
                      (typename(node.subexprs[1].value) != "num" or
                       math.abs(node.subexprs[1].value) > 10000))) {
                var associated_func_node = none
                var i = parents.len
                while i >= 1 and parents[i].kind != ast.N_STMT_FUNC {
                    i -= 1
                }
                if i < 1 {
                    throw new RuntimeError("Internal error, "
                        "failed to find func around return statement.")
                }
                associated_func_node = parents[i]
                assert(associated_func_node != none)
                if not associated_func_node.has_return_type {
                    if msgs == none {
                        throw new RuntimeError("Found return with "
                            "value in func without return type.")
                    }
                    msgs.add(new msg.FileMsg(
                        "Unexpected return statement with a "
                        "returned value, when surrounding func doesn't "
                        "have a return type.",
                        kind=msg.M_ERROR, source_file=project_file,
                        line=node.line,
                        col=node.col,
                    ))
                    node.damaged = yes
                } else {
                    return_var_node = builder.make_var_node(
                        node.scope, "defer_early_return_val",
                        typeref_expr=associated_func_node.
                            subexprs[associated_func_node.subexprs.len],
                        expr=node.subexprs[1],
                        line=node.line, col=node.col,
                        add_unique_suffix=yes
                    )
                    node.is_empty = no
                    var idexpr = new ast_expr.IdRefExpr()
                    idexpr.label = return_var_node.var_labels[1]
                    idexpr.scope = node.scope
                    idexpr.line = node.line
                    idexpr.col = node.col
                    idexpr.ref = node.scope.lookup(
                        return_var_node.var_labels[1],
                        is_write_access=no
                    )[1]
                    node.subexprs = [idexpr]
                }
            }
            var defer_added = get_node_defer_added(node, defer_info)
            if return_var_node != none {
                defer_added.stmts_added_before_node.add([
                    return_var_node,
                    get_resolve_copy_in_scope(defer_info, node.scope),
                ])
            } else {
                defer_added.stmts_added_before_node.add(
                    get_resolve_copy_in_scope(defer_info, node.scope),
                )
            }
            defer_added.stmts_added_after_node.add(none)
            return later node
        }

        var stmts = ast.get_neighbor_statements_after(
            node, parent, stop_at_return=yes,
            copy_stmts_themselves=no
        )

        # Find all block exit points and add the defer info:
        var queue = stmts.copy()
        if queue.len == 0 {
            return later node
        }
        var next_node = queue.pop_at(1)
        var visit_result = ast_transform.visit_ast_tree(
            next_node, attach_defer_resolution,
            subtree_parent=[parent],
            pass_func_boundaries=no, parent_chain=yes, backward=no)
        later:

        await visit_result
        assert(visit_result == yes)
        if queue.len == 0 {
            return later node
        }
        next_node = queue.pop_at(1)
        visit_result = ast_transform.visit_ast_tree(
            next_node, attach_defer_resolution,
            subtree_parent=[parent],
            pass_func_boundaries=no, parent_chain=yes, backward=no)
        later repeat
        return later node
    }
    var result = ast_transform.visit_ast_tree(
        ast_result, do_transform_defer, pass_func_boundaries=yes,
        parent_chain=yes, backward=no, subtree_parent=none,
        return_new_root=no
    ) later:

    await result
    if result and not had_no_error {
        result = no
    }
    if not result {
        return no
    }

    # Now that we have all the defer resolutions assembled,
    # revisit everything and emit the actual code in correct order:
    func do_transform_defer_2(node, parent) {
        if not node_to_defer_added_stmts_map.has(node) {
            if node.kind == ast.N_STMT_DEFER {
                return later none
            }
            return later node
        }
        var defer_added = node_to_defer_added_stmts_map[node]
        assert(defer_added.stmts_added_after_node.len ==
            defer_added.stmts_added_before_node.len)
        assert(defer_added.stmts_added_after_node.len ==
            defer_added.defer_infos.len)
        var result = [node]
        var result_node_idx = 1
        var idx = 1
        while idx <= defer_added.stmts_added_before_node.len {
            if defer_added.stmts_added_before_node[idx] != none {
                var stmts = defer_added.
                    stmts_added_before_node[idx]
                if typename(stmts) != "list" {
                    stmts = [stmts]
                }
                result = stmts + result
                result_node_idx += 1
            }
            if defer_added.stmts_added_after_node[idx] != none {
                var stmts = defer_added.
                    stmts_added_after_node[idx]
                if typename(stmts) != "list" {
                    stmts = [stmts]
                }
                result = result.sub(1, result_node_idx) +
                    stmts + result.sub(result_node_idx + 1)
            }
            idx += 1
        }
        if node.kind == ast.N_STMT_DEFER {
            result = result.sub(1, result_node_idx - 1) +
                result.sub(result_node_idx + 1)
            if result.len == 0 {
                return later none
            }
            return later result
        } elseif node.kind == ast.N_STMT_RETURN and
                not node.is_empty and no {
            assert(node.subexprs.len > 0)
            var arg_typeref
            var arg_typeinfo = m64_ast_analyze.get_c_or_m64_type_of_node(
                project_file, node.subexprs[1],
                node, msgs=msgs
            ) later:

            await arg_typeinfo
            assert(arg_typeinfo != none)
            var arg_type_expr = arg_typeinfo.convert_to_typeref_expr()
            var return_preeval_node = builder.make_var_node(
                node.scope, "defer_return_preeval_",
                typeref_expr=arg_type_expr, expr=node.subexprs[1],
                line=node.line, col=node.col, add_unique_suffix=yes
            )
            return later [return_preeval_node] + result
        }
        return later result
    }
    result = ast_transform.visit_ast_tree(
        ast_result, do_transform_defer_2, pass_func_boundaries=yes,
        parent_chain=no, backward=no, subtree_parent=none,
        return_new_root=no
    ) later:

    await result
    return result
}

func transform_associate_failed_checks(
        project_file, project_ast, msgs,
        call_expr_to_failed_check_map=none,
        failed_check_to_call_expr_map=none,
        parent_stmt_to_call_exprs_map=none,
        is_moose64=no
        ) {
    if call_expr_to_failed_check_map == none or
            failed_check_to_call_expr_map == none or
            parent_stmt_to_call_exprs_map == none {
        throw new TypeError("Map parameters weren't set.")
    }
    func find_followup_failed_check(
            node, node_parent, called_obj,
            called_item_name_if_known=none, debug=no
            ) {
        assert(node != node_parent)
        var parent_block = none
        if node_parent == none {
            parent_block = project_ast.stmts
        } else {
            parent_block = ast.get_node_parent_block(
                node, node_parent
            )
        }
        if parent_block == none {
            print("horsec: error: Fatal error in "
                "transform_associate_failed_checks(), somehow "
                "couldn't get parent of node: " + node.as_str())
            print("horsec: debug: node_parent parameter "
                "was set to: " + node.as_str())
            throw new RuntimeError("Internal error, failed to "
                "obtain parent block of node. Please report "
                "this error to the compiler makers.")
        }

        # A helper function to check if expressions are loosely
        # syntatically the same, it's not required to be exact
        # since failed(...) checks are only meant to be used
        # right after a call anyway, especially if ambiguous:
        func loose_cmp_exprs(expr1, expr2, debug=no) {
            if debug {
                print("horsec: debug: loose_cmp_exprs(): "
                    "checking expr1=" + expr1.as_str() +
                    ", expr2=" + expr2.as_str())
            }
            func expr_as_path(e) {
                if e.kind == ast.N_EXPR_IDREF {
                    var t = e.label
                    if e.type_path != none and
                            e.type_path.len > 0 {
                        assert(typename(e.type_path) == "list")
                        t = e.type_path.join(".") + "." + t
                    }
                    return t
                } elseif e.kind == ast.N_EXPR_BINOP and
                        e.optoken.str == "." {
                    var right_hand_path = expr_as_path(e.subexprs[2])
                    if right_hand_path == none {
                        return none
                    }
                    var left_hand_path = expr_as_path(e.subexprs[1])
                    if left_hand_path == none {
                        return none
                    }
                    return left_hand_path + "." + right_hand_path
                }
                return none
            }
            var e1path = expr_as_path(expr1)
            if e1path != none and e1path == expr_as_path(expr2) {
                return yes
            }
            if expr1.kind != expr2.kind {
                return no
            }
            if has_attr(expr1, "label") and
                    expr1.label != expr2.label {
                return no
            }
            if expr1.subexprs.len != expr2.subexprs.len {
                return no
            }
            var idx = 1
            while idx <= expr1.subexprs.len {
                if not loose_cmp_exprs(expr1.subexprs[idx],
                        expr2.subexprs[idx], debug=debug) {
                    return no
                }
                idx += 1
            }
            return yes
        }

        func find_failed_check_in_subexprs(subexprs, debug=no) {
            if debug {
                print("horsec: debug: "
                    "find_failed_check_in_subexprs(): "
                    "scanning list: " +
                    subexprs.as_str())
            }
            for sexpr in subexprs {
                assert(sexpr.kind != ast.N_EXPR_FAILEDCHECK or
                    sexpr.check_expr != none)
                if debug and sexpr.kind == ast.N_EXPR_FAILEDCHECK {
                    print("horsec: debug: "
                        "find_followup_failed_check(): "
                        "comparing failed() check: " +
                        sexpr.as_str())
                }
                if sexpr.kind == ast.N_EXPR_FAILEDCHECK and
                        loose_cmp_exprs(sexpr.check_expr,
                            called_obj, debug=debug) {
                    return sexpr
                }
            }
            for sexpr in subexprs {
                var result = find_failed_check_in_subexprs(
                    sexpr.subexprs, debug=debug
                )
                if result != none {
                    return result
                }
            }
            return none
        }

        var idx = parent_block.find(node)
        assert(idx != none)
        idx += 1
        while idx <= parent_block.len {
            var stmt = parent_block[idx]
            if debug {
                print("horsec: debug: "
                    "find_followup_failed_check(): "
                    "checking stmt=" + stmt.as_str())
            }
            if not {ast.N_STMT_VAR, ast.N_STMT_CALL,
                    ast.N_STMT_IF,
                    ast.N_STMT_ASSIGN}.has(stmt.kind) {
                if debug {
                    print("horsec: debug: "
                        "find_followup_failed_check(): "
                        "bailing, there's no follow-up.")
                }
                return none
            }
            var check = find_failed_check_in_subexprs(
                stmt.subexprs, debug=debug
            )
            if check != none {
                return check
            } else {
                if debug {
                    print("horsec: debug: "
                        "find_followup_failed_check(): "
                        "no matching failed() expr found "
                        "inside this stmt.")
                }
            }
            if stmt.kind == ast.N_STMT_VAR and
                    (called_item_name_if_known == none or
                    stmt.var_labels.has(
                        called_item_name_if_known
                    )) {
                if debug {
                    print("horsec: debug: "
                        "find_followup_failed_check(): "
                        "bailing, there's no follow-up.")
                }
                return none
            }
            idx += 1
        }
        if debug {
            print("horsec: debug: "
                "find_followup_failed_check(): "
                "reached end of block, there's no follow-up.")
        }
        return none
    }
    func do_transform_step(node, parents) {
        var debug = no

        if node.kind == ast.N_STMT_VAR and
                node.has_type_expr and
                node.is_empty and
                parents.len > 0 and
                node.subexprs[node.subexprs.len].has_init_expr {
            assert(node.var_labels.len == 1)
            if debug {
                print("horsec: debug: "
                    "transform_associate_failed_checks(): "
                    "examining to find failed() follow-up: "
                    "node=" + node.as_str())
            }
            var init_expr = node.subexprs[node.subexprs.len]
            var idref = new ast_expr.IdRefExpr()
            idref.label = init_expr.name
            idref.type_path = init_expr.type_path.copy()
            assert(ast.get_node_parent_block(
                node, parents[parents.len]
            ).find(node) != none)
            var check = find_followup_failed_check(
                node, parents[parents.len], idref,
                called_item_name_if_known=node.var_labels[1],
                debug=debug
            )
            if debug {
                print("horsec: debug: "
                    "transform_associate_failed_checks(): "
                    "result: check=" + check.as_str())
            }
            if check != none {
                call_expr_to_failed_check_map[node] = check
                if not parent_stmt_to_call_exprs_map.has(node) {
                    parent_stmt_to_call_exprs_map[node] = []
                }
                parent_stmt_to_call_exprs_map[node].add(node)
                failed_check_to_call_expr_map[check] = node
            }
            return later node
        }
        if node.kind != ast.N_EXPR_BINOP or
                node.optoken.str != "(" or
                parents.len == 0 {
            return later node
        }
        var idx = parents.len
        var parent_stmt_parent = if idx > 1
            (parents[idx - 1]) else (none)
        var parent_stmt = parents[idx]
        while not parent_stmt.is_stmt {
            idx -= 1
            if idx < 1 {
                return later node
            }
            parent_stmt_parent = if idx > 1
                (parents[idx - 1]) else (none)
            parent_stmt = parents[idx]
        }
        assert(parent_stmt.is_stmt)
        assert(parent_stmt_parent == none or
            ast.get_node_parent_block(
                parent_stmt, parent_stmt_parent
            ).find(parent_stmt) != none)
        var check = find_followup_failed_check(
            parent_stmt, parent_stmt_parent, node.subexprs[1]
        )
        if check != none {
            call_expr_to_failed_check_map[node] = check
            if not parent_stmt_to_call_exprs_map.has(parent_stmt) {
                parent_stmt_to_call_exprs_map[parent_stmt] = []
            }
            parent_stmt_to_call_exprs_map[parent_stmt].add(node)
            failed_check_to_call_expr_map[check] = node
        }
        return later node
    }
    var result = ast_transform.visit_ast_tree(
        project_ast, do_transform_step, pass_func_boundaries=yes,
        parent_chain=yes, backward=no, subtree_parent=none,
        return_new_root=no
    ) later:

    await result
    if not result {
        return later result
    }

    var found_error = no
    func do_error_check_step(node, parents) {
        if node.kind != ast.N_EXPR_FAILEDCHECK {
            return later node
        }
        if not failed_check_to_call_expr_map.has(node) {
            if msgs == none {
                throw new ValueError("Found invalid "
                    "N_EXPR_FAILEDCHECK that can't be matched "
                    "to any call.")
            }
            msgs.add(new msg.FileMsg(
                "Unexpected failed(...) check used on "
                "unrecgnized expression, must correspond to "
                "a preceding call.",
                kind=msg.M_ERROR, source_file=project_file,
                line=node.line,
                col=node.col,
            ))
            node.damaged = yes
            found_error = yes
        }
        return later node
    }
    result = ast_transform.visit_ast_tree(
        project_ast, do_error_check_step, pass_func_boundaries=yes,
        parent_chain=no, backward=no, subtree_parent=none,
        return_new_root=no
    ) later:

    await result
    if found_error {
        return later no
    }
    return later result
}

func do_moose64_transforms_pre_nameresolution(
        project_file, msgs) {
    var call_expr_to_failed_check_map = {->}
    var failed_check_to_call_expr_map = {->}
    var parent_stmt_to_call_exprs_map = {->}

    var result = transform_associate_failed_checks(
        project_file, project_file.ast, msgs,
        call_expr_to_failed_check_map=
            call_expr_to_failed_check_map,
        failed_check_to_call_expr_map=
            failed_check_to_call_expr_map,
        parent_stmt_to_call_exprs_map=
            parent_stmt_to_call_exprs_map,
        is_moose64=yes
    ) later:

    await result
    result = ast_transform.transform_typeref_inline_constructor(
        project_file, project_file.ast, msgs,
        call_expr_to_failed_check_map=
            call_expr_to_failed_check_map,
        failed_check_to_call_expr_map=
            failed_check_to_call_expr_map,
        parent_stmt_to_call_exprs_map=
            parent_stmt_to_call_exprs_map,
        is_moose64=yes
    ) later:

    await result

    return result
}

func transform_desugar_failed_checks(
        project_file, project_ast, msgs,
        call_expr_to_failed_check_map=none,
        failed_check_to_call_expr_map=none,
        parent_stmt_to_call_exprs_map=none,
        is_moose64=no
        ) {
    if call_expr_to_failed_check_map == none or
            failed_check_to_call_expr_map == none or
            parent_stmt_to_call_exprs_map == none {
        throw new TypeError("Map parameters weren't set.")
    }

    var parent_statements_processed = {}
    var builder = new ast_builder.ASTBuilder(project_file)
    var exprs_to_result_var_name_map = {->}

    func transform_failable_calls(
            node, parents, debug=no
            ) {
        var node_parent
        if parents.len == 0 {
            node_parent = project_ast
        } else {
            node_parent = parents[parents.len]
        }

        assert(node != node_parent)
        if node.kind != ast.N_EXPR_BINOP or
                node.optoken.str != '(' or
                node.subexprs.len < 2 or
                node.subexprs[2].kind != ast.N_EXPR_CALLARGS or
                not call_expr_to_failed_check_map.has(node) {
            return later node
        }

        var idx = parents.len
        var parent_stmt_parent = if idx > 1
            (parents[idx - 1]) else (none)
        var parent_stmt = parents[idx]
        while not parent_stmt.is_stmt {
            idx -= 1
            if idx < 1 {
                return later node
            }
            parent_stmt_parent = if idx > 1
                (parents[idx - 1]) else (none)
            parent_stmt = parents[idx]
        }
        assert(parent_stmt.is_stmt)

        assert(parent_stmt_to_call_exprs_map.has(parent_stmt))
        if parent_statements_processed.has(parent_stmt) {
            return later node
        }

        var exprs = parent_stmt_to_call_exprs_map[parent_stmt]
        if debug {
            print("horsec: debug: transform_failable_calls() will "
                "now transform: " + parent_stmt.as_str())
        }
        var parent_block = none
        if parent_stmt_parent == none {
            parent_block = project_ast.stmts
        } else {
            parent_block = ast.get_node_parent_block(
                parent_stmt, parent_stmt_parent
            )
        }
        if parent_block == none {
            print("horsec: error: Fatal error in "
                "transform_failable_calls(), somehow "
                "couldn't get parent of node: " +
                parent_stmt.as_str())
            print("horsec: debug: parent_stmt_parent parameter "
                "was set to: " + parent_stmt_parent.as_str())
            throw new RuntimeError("Internal error, failed to "
                "obtain parent block of node. Please report "
                "this error to the compiler makers.")
        }
        idx = parent_block.find(parent_stmt)
        assert(idx != none)

        var temp_var_names = []
        for expr in exprs {
            var failable_var_type = new ast_typeref.TypeRefExpr()
            failable_var_type.name = "moose64_failed_result_t"
            var failable_init_val = new ast_expr.LiteralExpr()
            failable_init_val.value = 0
            failable_init_val.scope = node.scope
            failable_init_val.line = node.line
            failable_init_val.col = node.col
            assert(node.scope != none)
            var failable_result_node = builder.make_var_node(
                node.scope, "failable_result_val_",
                typeref_expr=failable_var_type,
                expr=failable_init_val,
                line=node.line, col=node.col, add_unique_suffix=yes
            )
            temp_var_names.add(failable_result_node.var_labels[1])
            exprs_to_result_var_name_map[expr] =
                failable_result_node.var_labels[1]
            parent_block.add_at(idx, failable_result_node)

            # Now add this new variable as a call argument:
            assert(expr.kind == ast.N_EXPR_BINOP)
            assert(expr.subexprs.len == 2)
            assert(expr.subexprs[2].kind == ast.N_EXPR_CALLARGS)
            var additional_arg_node = new ast_expr.IdRefExpr()
            additional_arg_node.label =
                failable_result_node.var_labels[1]
            additional_arg_node.ref = node.scope.lookup(
                failable_result_node.var_labels[1]
            )[1]
            additional_arg_node.line = node.line
            additional_arg_node.col = node.col
            additional_arg_node.scope = node.scope
            var args_node = new ast_expr.CallArgsExpr()
            args_node.scope = node.scope
            args_node.line = node.line
            args_node.col = node.col
            args_node.subexprs = [additional_arg_node]
            var as_ref_node = new ast_expr.IdRefExpr()
            as_ref_node.scope = node.scope
            as_ref_node.line = node.line
            as_ref_node.col = node.col
            as_ref_node.label = "as_ref"
            as_ref_node.type_path = ["std"]
            if project_file.modinfo != none and
                    project_file.modinfo.
                        package_name == "m64.horse64.org" and
                    project_file.modinfo.
                        module_name == "std" {
                as_ref_node.type_path = none
            }
            as_ref_node.ref =
                builtin_syms.try_lookup_symbol(
                    project_file.project, "as_ref", "std",
                    in_package_name="m64.horse64.org"
                )
            var combined_optoken = new token.Token(
                '(', token.T_ENCLOSE, node.line, node.col
            )
            var combined_node = new ast_expr.BinopExpr(
                combined_optoken
            )
            combined_node.scope = node.scope
            combined_node.line = node.line
            combined_node.col = node.col
            combined_node.subexprs = [as_ref_node,
                args_node]
            expr.subexprs[2].subexprs.add(combined_node)
        }

        return later node
    }

    var result = ast_transform.visit_ast_tree(
        project_ast, transform_failable_calls,
        pass_func_boundaries=yes, parent_chain=yes,
        backward=no, subtree_parent=none,
        return_new_root=no
    ) later:

    await result
    if not result {
        return later result
    }

    func transform_failable_checks(
            node, parents, debug=no
            ) {
        var node_parent
        if parents.len == 0 {
            node_parent = project_ast
        } else {
            node_parent = parents[parents.len]
        }

        assert(node != node_parent)
        if node.kind != ast.N_EXPR_FAILEDCHECK or
                not failed_check_to_call_expr_map.has(node) {
            return later node
        }

        var failable_call = failed_check_to_call_expr_map[node]
        var var_name = exprs_to_result_var_name_map[failable_call]

        var failable_result_node = new ast_expr.IdRefExpr()
        failable_result_node.label = var_name
        failable_result_node.ref = node.scope.lookup(var_name)[1]
        failable_result_node.line = node.line
        failable_result_node.col = node.col
        failable_result_node.scope = node.scope
        return later failable_result_node
    }
    result = ast_transform.visit_ast_tree(
        project_ast, transform_failable_checks,
        pass_func_boundaries=yes, parent_chain=yes,
        backward=no, subtree_parent=none,
        return_new_root=no
    ) later:

    await result

    return later result
}

func do_moose64_transforms_post_nameresolution(
        project_file, msgs) {

    var call_expr_to_failed_check_map = {->}
    var failed_check_to_call_expr_map = {->}
    var parent_stmt_to_call_exprs_map = {->}

    var result = transform_associate_failed_checks(
        project_file, project_file.ast, msgs,
        call_expr_to_failed_check_map=
            call_expr_to_failed_check_map,
        failed_check_to_call_expr_map=
            failed_check_to_call_expr_map,
        parent_stmt_to_call_exprs_map=
            parent_stmt_to_call_exprs_map,
        is_moose64=yes
    ) later:

    await result
    if not result {
        return later no
    }

    result = transform_desugar_failed_checks(
        project_file, project_file.ast, msgs,
        call_expr_to_failed_check_map=
            call_expr_to_failed_check_map,
        failed_check_to_call_expr_map=
            failed_check_to_call_expr_map,
        parent_stmt_to_call_exprs_map=
            parent_stmt_to_call_exprs_map,
        is_moose64=yes,
    ) later:

    await result
    if not result {
        return later no
    }

    result = transform_defer(
        project_file, project_file.ast, msgs, is_moose64=yes
    ) later:

    await result
    if not result {
        return later no
    }
    return result
}

