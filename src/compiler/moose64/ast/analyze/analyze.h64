## @module compiler.moose64.ast.analyze
# Copyright (c) 2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import bignum from core.horse64.org
import random from core.horse64.org
import textfmt from core.horse64.org

import compiler.ast as ast
import compiler.ast.analyze as ast_analyze
import compiler.builtin_syms as builtin_syms
import compiler.moose64.autocast as autocast
import compiler.moose64.builtins as m64_builtins
import compiler.msg as msg
import compiler.storage.ref as st_ref
import compiler.storage.scope as st_scope
import compiler.storage.scope.manage as scope_manage
import compiler.token as token
import compiler.typeinfo as typeinfo
import compiler.typeinfo.ast_typeref as ast_typeref

func get_c_or_m64_type_of_typeref(
        project_file, typeref,
        store_self_value_ref_for_funcs=no, msgs=none
        ) {
    var is_moose64 = yes
    if not typeref.is_user_type() {
        var c_name = typeref.get_c_builtin_for_m64_base_type()
        assert(c_name != none)
        var tinfo = new typeinfo.TypeInfo(typeinfo.TI_C_TYPE)
        tinfo._set_orig_type_expr(typeref)
        tinfo.orig_type_name = typeref.name
        tinfo.c_type_name = c_name
        for mod in typeref.modifiers {
            tinfo.modifiers.add(mod.copy())
        }
        return later tinfo
    }
    var m64_type_ref = typeref.try_resolve_to_user_type(
        project_file, is_moose64=yes
    ) later:

    await m64_type_ref
    assert(m64_type_ref.kind != st_ref.ST_LOCAL)
    if m64_type_ref == none {
        return later none
    }
    var m64_symbol_info = st_ref.ref_to_symbol_info(
        m64_type_ref, project=project_file.project,
        is_moose64=is_moose64,
    )
    if m64_symbol_info == none {
        return later none
    }

    var tinfo = new typeinfo.create_typeinfo_from_global_ref(
        m64_type_ref,
        base_symbol_info_if_known=m64_symbol_info,
        base_typeref_expr_if_known=typeref,
        store_self_value_ref_for_funcs=
            store_self_value_ref_for_funcs,
        project=project_file.project,
        is_moose64=yes,
    )
    return later tinfo
}

func get_c_or_m64_type_of_sym_info(
        project_file, target_sym_info,
        node_with_reference=none,
        node_with_reference_parents=none,
        store_self_value_ref_for_funcs=no,
        msgs=none, debug=no
        ) {
    const is_moose64 = yes
    var dbg_prefix = ""
    if debug {
        d_id = random.gen_id()
        dbg_prefix = "moosec: debug: "
            "get_c_or_m64_type_of_sym_info() #" + d_id
    }
    if debug {
        print(dbg_prefix + " Examining target_sym_info=" +
            target_sym_info.as_str() + " "
            "node_with_reference=" +
                node_with_reference.as_str() + " "
            "node_with_reference.ref=" +
                if node_with_reference != none
                    (node_with_reference.ref.as_str()) else
                    ("<is none>") + " "
            "node_with_reference_parents.len=" +
                if node_with_reference_parents != none
                    (node_with_reference_parents.len.as_str()) else
                    ("<is none>"))
    }

    var typeref_expr = none
    var target_ref = target_sym_info.type_storage_ref
    if debug {
        print(dbg_prefix + " Found initial target_ref=" +
            target_ref.as_str())
    }
    if target_ref == none and node_with_reference != none and
            node_with_reference.ref != none and
            node_with_reference_parents != none and
            node_with_reference_parents.len > 0 and
            node_with_reference.ref.kind == st_ref.ST_LOCAL {
        var var_node = st_scope.find_def_node_from_idref_node(
            node_with_reference, node_with_reference_parents
        )
        if debug {
            print(dbg_prefix + " Tried to get var_node=" +
                var_node.as_str())
        }
        if var_node != none or var_node.kind != ast.N_STMT_VAR {
            if not var_node.has_type_expr {
                return later none
            }
            typeref_expr = var_node.subexprs[var_node.subexprs.len]
        }
    } elseif target_ref == none and
            node_with_reference != none and
            node_with_reference.ref.kind == st_ref.ST_LOCAL {
        if debug {
            print(dbg_prefix + " Warning: this is a local var "
                "ref, but there's not enough info supplied to "
                "even try to trace back to the var_node "
                "defining it.")
        }
    }
    if target_ref == none and node_with_reference.ref != none and
            {st_ref.ST_GLOBAL, st_ref.ST_GLOBALATTR,
                st_ref.ST_CEXT, st_ref.ST_MCREF}.has(
                    node_with_reference.ref.kind) {
        target_ref = node_with_reference.ref
    }
    if target_ref == none and node_with_reference.ref != none and
            node_with_reference.ref.kind == st_ref.ST_SELF and
            node_with_reference_parents != none and
            node_with_reference_parents.len >= 1 {
        var owning_func_attr_node = none
        var i = node_with_reference_parents.len
        while i >= 1 {
            if {ast.N_STMT_FUNC, ast.N_STMT_FUNCEXTEND}.has(
                    node_with_reference_parents[i].kind) {
                owning_func_attr_node =
                    node_with_reference_parents[i]
                break
            }
            i -= 1
        }
        if debug {
            var owning_func_attr_str = "none"
            if owning_func_attr_node != none {
                owning_func_attr_str = owning_func_attr_node.as_str() +
                    "..."
            }
            print(dbg_prefix + " Found self ref with "
                "owning_func_attr_node=" +
                    owning_func_attr_str)
        }
        if owning_func_attr_node != none {
            var anscope = project_file.
                make_attr_names_scope_from_funcattr(
                    owning_func_attr_node, msgs=msg,
                    is_moose64=is_moose64,
                    def_project_file=project_file
                )
            if debug {
                print(dbg_prefix + " Found associated "
                    "anscope for self: anscope=" +
                    anscope.as_str())
            }
            if anscope != none {
                target_ref = new st_ref.StorageRef(
                    st_ref.ST_GLOBAL, anscope.storage_id
                )
            }
        }
    }
    if target_ref != none {
        assert(target_ref == none or has_attr(target_ref, "kind"))
        assert(target_ref.kind != st_ref.ST_LOCAL)
        var tinfo = new typeinfo.create_typeinfo_from_global_ref(
            target_ref,
            base_symbol_info_if_known=target_sym_info,
            base_node_if_known=node_with_reference,
            project=project_file.project,
            is_moose64=is_moose64,
        )
        if debug {
            print(dbg_prefix + " create_typeinfo_from_global_ref "
                "returned tinfo=" + tinfo.as_str())
        }
        return later tinfo
    }
    if typeref_expr == none {
        typeref_expr = target_sym_info.typeref_expr
    }
    if typeref_expr == none {
        return later none
    }
    var result = get_c_or_m64_type_of_typeref(
        project_file, typeref_expr,
        store_self_value_ref_for_funcs=
            store_self_value_ref_for_funcs,
        msgs=msgs
    ) later:

    await result
    return result
}

func _get_c_or_m64_type_of_node_do(
        project_file, node, parents,
        _known_typeinfo_map=none,
        store_self_value_ref_for_funcs=no,
        disable_binop_parent_fallback=no,
        msgs=none, debug=no
        ) {
    var is_moose64 = yes
    if _known_typeinfo_map == none {
        _known_typeinfo_map = {->}
    }
    if _known_typeinfo_map.has(node) and
            not store_self_value_ref_for_funcs {
        var result = _known_typeinfo_map[node].copy()
        print("moosec: debug: "
            "_get_c_or_m64_type_of_node_do() FAST PATH: " +
            "Returning cached result=" + result.as_str())
        return later result
    }
    var parent = if parents.len > 0 (parents[parents.len]) else (none)

    var d_id = none
    var dbg_prefix = ""
    if debug {
        d_id = random.gen_id()
        dbg_prefix = "moosec: debug: "
            "_get_c_or_m64_type_of_node_do() #" + d_id
        print(dbg_prefix + " Running on: " +
            node.as_str() + " with store_self_value_ref_for_funcs=" +
            store_self_value_ref_for_funcs.as_str())
    }
    func trigger_no_symbol_info_on(node) {
        if node.damaged {
            return
        }
        if msgs == none {
            if debug {
                print("moosec: debug: "
                    "Unexpectedly failed to "
                    "get symbol info on node=" +
                    node.as_str())
            }
            throw new ValueError(
                "Internal error: Unexpectedly failed to "
                "get symbol info."
            )
        }
        node.damaged = yes
        msgs.add(new msg.FileMsg(
            "Internal error: Unexpectedly failed to trace "
            "back this identifier to resolved target: " +
            node.as_str() +
            " (with node.ref: " + if has_attr(node, "ref")
                    (node.ref.as_str())
                    else ("<no .ref attr>") + ") "
            "Please report this to the compiler makers.",
            source_file=project_file,
            line=node.line, col=node.col,
        ))
    }

    func trigger_no_such_attribute_on(node, aname) {
        if node.damaged {
            return
        }
        if msgs == none {
            throw new ValueError(
                "The given type doesn't have this attribute."
            )
        }
        node.damaged = yes
        msgs.add(new msg.FileMsg(
            "The attribute " + textfmt.as_escaped_code_string(
                aname
            ) + " cannot be found on this type.",
            source_file=project_file,
            line=node.line, col=node.col,
        ))
    }

    var left_hand_instance_ref = none
    func evaluate_lefthand_sides_if_needed(node) {
        if debug {
            print(dbg_prefix +
                " In evaluate_lefthand_sides_if_needed(): "
                "Starting with node=" + node.as_str())
        }
        if node.kind != ast.N_EXPR_BINOP or
                node.optoken.str != "." {
            return later yes
        }
        if has_attr(node.subexprs[1], "ref") and
                node.subexprs[1].ref != none {
            left_hand_instance_ref =
                node.subexprs[1].ref.copy()
        } elseif node.subexprs[1].kind == ast.N_EXPR_BINOP and
                node.subexprs[1].optoken.str == "." and
                has_attr(node.subexprs[1].subexprs[2], "ref") and
                node.subexprs[1].subexprs[2].ref != none {
            left_hand_instance_ref =
                node.subexprs[1].subexprs[2].ref.copy()
        }
        if (has_attr(node.subexprs[2], "ref") and
                node.subexprs[2].ref != none) or
                _known_typeinfo_map.has(node.subexprs[2]) {
            return later yes
        }
        if debug {
            print(dbg_prefix +
                " In evaluate_lefthand_sides_if_needed(): "
                "Now trying to get type on node.subexprs[1]=" +
                node.subexprs[1].as_str())
        }
        var c_type = _get_c_or_m64_type_of_node_do(
            project_file, node.subexprs[1], parents + [node],
            _known_typeinfo_map=_known_typeinfo_map,
            disable_binop_parent_fallback=yes,
            msgs=msgs,
        ) later:

        await c_type
        if debug {
            print(dbg_prefix +
                " In evaluate_lefthand_sides_if_needed(): "
                "Result: c_type=" + c_type.as_str())
        }
        if c_type == none and (
                has_attr(node.subexprs[1], "ref") and
                node.subexprs[1].ref == none) {
            return later no
        }
        _known_typeinfo_map[node.subexprs[1]] = c_type
        return later yes
    }
    var result = evaluate_lefthand_sides_if_needed(node)
    later:

    await result
    if not result {
        # This means there isn't a useful way we can derive
        # any type from a left hand that's present.
        if debug {
            print(dbg_prefix + " Aborting: "
                "no useful left-hand from which we could derive "
                "type of full expression")
        }
        return later none
    }

    if debug {
        print(dbg_prefix + " Continuing after checking left-hand: "
            "left_hand_instance_ref=" +
            left_hand_instance_ref.as_str() + " "
            "node.kind=" + ast.NodeKind.num_label(node.kind))
    }
    if node.kind == ast.N_STMT_VAR {
        if not node.has_type_expr {
            return later none
        }
        var result = get_c_or_m64_type_of_typeref(
            project_file, node.subexprs[node.subexprs.len],
            store_self_value_ref_for_funcs=
                store_self_value_ref_for_funcs,
            msgs=msgs
        ) later:

        await result
        if debug {
            print(dbg_prefix + " Got N_STMT_VAR result=" +
                result.as_str())
        }
        return later result
    } elseif node.kind == ast.N_EXPR_LIT and
            typename(node.value) == "bool" {
        var result = typeinfo.
            create_from_simple_m64_type("bool")
        return result
    } elseif node.kind == ast.N_EXPR_LIT and
            typename(node.value) == "str" and
            not node.is_big_num {
        var result = typeinfo.
            create_from_simple_m64_type("byte")
        result.modifiers.add(new ast_typeref.TypeRefMod(
            "readonly"
        ))
        result.modifiers.add(new ast_typeref.TypeRefMod(
            "c_array"
        ))
        return result
    } elseif node.kind == ast.N_EXPR_LIT and
            (typename(node.value) == "num" or
             (typename(node.value) == "str" and
              node.is_big_num)) {
        var num_as_str = node.value.as_str()
        if num_as_str.find(".") == none {
            if bignum.compare_nums(
                    num_as_str, "2147483647") > 0 or
                    bignum.compare_nums(
                    num_as_str, "-2147483648") < 0 {
                var result = typeinfo.
                    create_from_simple_m64_type("i64")
                return result
            }
            var result = typeinfo.
                create_from_simple_m64_type("i32")
            return result
        }
        var result = typeinfo.
            create_from_simple_m64_type("f64")
        return result
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.subexprs.len >= 2 and
            token.math_ops.has(node.optoken.str) {
        if debug {
            print(dbg_prefix + " Found math binary op '" +
                node.optoken.str + "', evaluating types of "
                "operands...")
        }

        var left_side_type = _get_c_or_m64_type_of_node_do(
            project_file, node.subexprs[1], parents + [node],
            _known_typeinfo_map=_known_typeinfo_map,
            store_self_value_ref_for_funcs=no,
            msgs=msgs, debug=debug
        ) later:

        await left_side_type
        var right_side_type = _get_c_or_m64_type_of_node_do(
            project_file, node.subexprs[2], parents + [node],
            _known_typeinfo_map=_known_typeinfo_map,
            store_self_value_ref_for_funcs=no,
            msgs=msgs, debug=debug
        ) later:

        await right_side_type
        if left_side_type == none or right_side_type == none {
            if debug {
                print(dbg_prefix + " Failed to get one side of "
                    "the binary op, aborting: left_side_type=" +
                    left_side_type.as_str() + " "
                    "right_side_type=" +
                    right_side_type.as_str() + " "
                    "left_hand_node=" +
                        node.subexprs[1].as_str() + " "
                    "right_hand_node=" +
                        node.subexprs[2].as_str())
            }
            return later none
        }
        if debug {
            print(dbg_prefix + " Obtained operand types: "
                "left_side_type=" + left_side_type.as_str() + " "
                "right_side_type=" + right_side_type.as_str() + " "
                "optoken.str='" + node.optoken.str.as_str() + "'")
        }
        var result = autocast.get_math_binop_autocast(
            left_side_type, right_side_type, is_cmp_op=no
        )
        if debug {
            print(dbg_prefix + " Obtained autocast info for "
                "binop: result=" + result.as_str())
        }
        if result.incompatible {
            if msgs == none {
                throw new ValueError("Found binary operator "
                    "applied on incompatible operators.")
            }
            msgs.add(new msg.FileMsg(
                "Unexpected '" + node.optoken.str.as_str() +
                "' operator applied to incompatible types " +
                left_side_type.describe_to_user(
                    project=project_file.project,
                    add_quotes_where_useful=yes,
                    is_moose64=yes
                ) + " "
                "and " + right_side_type.describe_to_user(
                    project=project_file.project,
                    add_quotes_where_useful=yes,
                    is_moose64=yes
                ) + ".",
                source_file=project_file,
                line=node.line, col=node.col,
            ))
            node.damaged = yes
            return later none
        }
        return later result.result_type
    } elseif node.kind == ast.N_EXPR_IDREF {
        if parent.kind == ast.N_EXPR_BINOP and
                parent.optoken.str == "." and
                not disable_binop_parent_fallback {
            if debug {
                print(dbg_prefix + " The parent is an "
                    "attr access binop, "
                    "so we're getting parent result "
                    "instead...")
            }
            var inner_result = _get_c_or_m64_type_of_node_do(
                project_file, parent, parents.sub(1, parents.len - 1),
                _known_typeinfo_map=_known_typeinfo_map,
                store_self_value_ref_for_funcs=
                    store_self_value_ref_for_funcs,
                msgs=msgs, debug=debug
            ) later:

            await inner_result
            if debug {
                print(dbg_prefix + " Will return "
                    "parent result now.")
            }
            if inner_result != none and
                    not _known_typeinfo_map.has(node) {
                _known_typeinfo_map[node] = inner_result.copy()
                _known_typeinfo_map[node].func_self_ref = none
            }
            return inner_result
        }

        var return_type_with_ref_modifier = no
        var sym_info = none
        if node.ref != none and node.ref.kind == st_ref.ST_SELF {
            var func_node = none
            var i = parents.len
            while i >= 1 {
                if parents[i].kind == ast.N_STMT_FUNC or
                        parents[i].kind == ast.N_STMT_FUNCEXTEND {
                    func_node = parents[i]
                    break
                }
                i -= 1
            }
            if func_node == none {
                if not node.damaged {
                    if msgs == none {
                        throw new ValueError(
                            "Found invalid use of 'self "
                            "outside of function."
                        )
                    }
                    msgs.add(new msg.FileMsg(
                        "Invalid use of 'self' outside "
                        "of a function.",
                        line=node.line, col.node.col
                    ))
                }
                node.damaged = yes
                return none
            }
            var anscope = project_file.
                make_attr_names_scope_from_funcattr(
                    func_node, msgs=msgs, is_moose64=is_moose64,
                    def_project_file=project_file,
                )
            if anscope == none {
                return none
            }
            var type_st_ref = new st_ref.StorageRef(
                st_ref.ST_GLOBAL, anscope.storage_id
            )
            sym_info = st_ref.ref_to_symbol_info(
                type_st_ref, project=project_file.project,
                is_moose64=is_moose64,
            )
            return_type_with_ref_modifier = yes
        } elseif node.ref != none {
            sym_info = st_ref.ref_to_symbol_info(
                node.ref, node=node,
                project=project_file.project,
                is_moose64=is_moose64,
            )
            if debug {
                print(dbg_prefix + " Got a node.ref set, "
                    "called st_ref.ref_to_symbol_info(): " +
                    "node.ref=" + node.ref.as_str() + " "
                    "sym_info=" + sym_info.as_str())
            }
        }

        if sym_info == none {
            if node.ref != none and
                    node.ref.kind == st_ref.ST_MCREF and
                    (node.ref.id == builtin_syms.get_item_by_name(
                        project_file.project, "size_of",
                        in_package_name="m64.horse64.org",
                        in_module_name="std").symbol_storage_ref.id or
                    node.ref.id == builtin_syms.get_item_by_name(
                        project_file.project, "deref",
                        ).symbol_storage_ref.id or
                    node.ref.id == builtin_syms.get_item_by_name(
                        project_file.project, "as_ref",
                        ).symbol_storage_ref.id) {
                if msgs == none {
                    throw new ValueError("Unexpected reference "
                        "to a compiler "
                        "built-in special func that can only be called, "
                        "not referenced.")
                }
                if not node.damaged {
                    node.damaged = yes
                    msgs.add(new msg.FileMsg(
                        "Unexpected reference "
                        "to built-in special func \"" + node.label +
                        "\" that can only be called, not referenced.",
                        source_file=project_file,
                        line=node.line, col=node.col,
                    ))
                }
                return later none
            } elseif node.ref != none and
                    node.ref.kind == st_ref.ST_MCREF {
                # FIXME: Obtain C func signature. For now,
                # we don't support this.
                var builtin_item = builtin_syms.get_item_by_storage_ref(
                    project_file.project, node.ref
                )
                if debug {
                    print(dbg_prefix + " Obtained built-in symbol item "
                        "for this node.ref: builtin_item=" +
                        builtin_item.as_str())
                }
                if builtin_item == none or
                        builtin_item.func_signature_expr == none {
                    return later none
                }
                var func_result = new typeinfo.TypeInfo(
                    typeinfo.TI_FUNCREF
                )
                func_result.orig_type_name = builtin_item.symbol_name
                if builtin_item.is_csymbol {
                    func_result.user_type_ref =
                        new st_ref.StorageRef(st_ref.ST_MCREF,
                            builtin_item.storage_id)
                } else {
                    func_result.user_type_ref =
                        builtin_item.symbol_storage_ref.copy()
                }
                func_result.func_typeexpr =
                    builtin_item.func_signature_expr.copy()
                func_result._orig_typeexpr =
                    func_result.func_typeexpr
                return func_result
            }

            if debug {
                print(dbg_prefix + " Failed "
                    "to find symbol info for: " + [
                        node, node.ref
                    ].as_str())
            }
            trigger_no_symbol_info_on(node)
            return later none
        }
        if debug {
            print(dbg_prefix + " Got "
                "symbol info: " + sym_info.as_str())
        }
        var result = get_c_or_m64_type_of_sym_info(
            project_file, sym_info, node_with_reference=node,
            node_with_reference_parents=parents,
            msgs=msgs, debug=debug
        ) later:

        await result

        if result != none and
                return_type_with_ref_modifier {
            result.add_ref_modifier()
        }
        if result != none and
                not _known_typeinfo_map.has(node) {
            _known_typeinfo_map[node] = result.copy()
            _known_typeinfo_map[node].func_self_ref = none
        }
        if debug {
            print(dbg_prefix + " Got N_EXPR_IDREF result=" +
                result.as_str())
        }
        return later result
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.optoken.str == "(" {
        if m64_builtins.is_ast_node_referring_to_m64_std_as_ref(
                project_file, node.subexprs[1], is_moose64=yes) {
            if debug {
                print(dbg_prefix + " Got call binop on " +
                    "built-in 'as_ref'.")
            }
            if debug {
                print(dbg_prefix + " Get typeinfo on what as_ref() "
                    "was called on...")
            }
            assert(node.subexprs[2].kind == ast.N_EXPR_CALLARGS)
            if node.subexprs[2].subexprs.len != 1 {
                if msgs == none {
                    print(if is_moose64 ("hoosec")
                        else ("moosec") + ": "
                            "error: Internal error, "
                            "as_ref call with not exactly 1 arg "
                            "found: " + node.as_str())
                    throw new RuntimeError(
                        "Call has wrong number of "
                        "arguments.")
                }
                if not node.damaged and
                        not node.subexprs[2].damaged {
                    var called_args =
                        node.subexprs[2].subexprs.len
                    var called_s = "s"
                    msgs.add(new msg.FileMsg(
                        "Unexpected number of args, " +
                        "'as_ref' expects 1 arg " +
                        "but this call provides " +
                        called_args.as_str() + " "
                        "arg" + called_s + ".",
                        kind=msg.M_ERROR, source_file=project_file,
                        line=node.subexprs[1].line,
                        col=node.subexprs[1].col,
                    ))
                }
                node.damaged = yes
                node.subexprs[1].damaged = yes
                node.subexprs[2].damaged = yes
                return none
            }
            var inner_result = _get_c_or_m64_type_of_node_do(
                project_file, node.subexprs[2].subexprs[1],
                parents + [node, node.subexprs[2]],
                _known_typeinfo_map=_known_typeinfo_map,
                store_self_value_ref_for_funcs=
                    store_self_value_ref_for_funcs,
                msgs=msgs, debug=debug
            ) later:

            await inner_result
            if debug {
                print(dbg_prefix + " Got as_ref() arg typeinfo=" +
                    inner_result.as_str())
            }
            if inner_result == none {
                if node.subexprs[2].damaged or
                        node.subexprs[2].subexprs[1].damaged {
                    node.damaged = yes
                }
                return later none
            }

            var stripped_implicit_ref = no
            if inner_result.modifiers.len > 0 and
                    inner_result.modifiers[
                        inner_result.modifiers.len
                    ].name == "implicit ref" {
                stripped_implicit_ref = yes
                inner_result.modifiers =
                    inner_result.modifiers.sub(
                        1,
                        inner_result.modifiers.len - 1
                    )
            }
            inner_result.modifiers.add(
                new ast_typeref.TypeRefMod("ref")
            )
                
            if inner_result.kind == typeinfo.TI_USERTYPE and
                    inner_result._orig_typeexpr != none {
                if stripped_implicit_ref {
                    assert(inner_result._orig_typeexpr.
                        modifiers.len > 0)
                    assert(inner_result._orig_typeexpr.
                        modifiers[inner_result._orig_typeexpr.
                            modifiers.len].name == "implicit ref")
                    inner_result._orig_typeexpr.modifiers =
                    inner_result._orig_typeexpr.modifiers.sub(
                        1,
                        inner_result.modifiers.len - 1
                    )
                }
                inner_result._orig_typeexpr.modifiers.add(
                    new ast_typeref.TypeRefMod("ref")
                )
            }
            if debug {
                print(dbg_prefix + " Returning final ref type "
                    "typeinfo=" + inner_result.as_str())
            }
            return later inner_result
        } elseif m64_builtins.is_ast_node_referring_to_m64_std_deref(
                project_file, node.subexprs[1], is_moose64=yes) {
            if debug {
                print(dbg_prefix + " Got call binop on " +
                "built-in 'deref'.")
            }
            if debug {
                print(dbg_prefix + " Get typeinfo on what deref() "
                "was called on...")
            }
            assert(node.subexprs[2].kind == ast.N_EXPR_CALLARGS)
            if node.subexprs[2].subexprs.len != 1 {
                if msgs == none {
                    print(if is_moose64 ("hoosec")
                        else ("moosec") + ": "
                            "error: Internal error, "
                            "deref call with not exactly 1 arg "
                            "found: " + node.as_str())
                    throw new RuntimeError(
                        "Call has wrong number of "
                        "arguments.")
                }
                if not node.damaged and
                        not node.subexprs[2].damaged {
                    var called_args =
                    node.subexprs[2].subexprs.len
                    var called_s = "s"
                    msgs.add(new msg.FileMsg(
                        "Unexpected number of args, " +
                        "'deref' expects 1 arg " +
                        "but this call provides " +
                        called_args.as_str() + " "
                        "arg" + called_s + ".",
                        kind=msg.M_ERROR, source_file=project_file,
                        line=node.subexprs[1].line,
                        col=node.subexprs[1].col,
                    ))
                }
                node.damaged = yes
                node.subexprs[1].damaged = yes
                node.subexprs[2].damaged = yes
                return later none
            }
            var inner_result = _get_c_or_m64_type_of_node_do(
                project_file, node.subexprs[2].subexprs[1],
                parents + [node, node.subexprs[2]],
                _known_typeinfo_map=_known_typeinfo_map,
                store_self_value_ref_for_funcs=
                store_self_value_ref_for_funcs,
                msgs=msgs, debug=debug
            ) later:

            await inner_result
            if debug {
                print(dbg_prefix + " Got size_of() arg typeinfo=" +
                inner_result.as_str())
            }
            if inner_result == none {
                if node.subexprs[2].damaged or
                        node.subexprs[2].subexprs[1].damaged {
                    node.damaged = yes
                }
                return later none
            }
            var type_result = inner_result.copy()
            var old_deref_counter = 0
            var new_modifiers = []
            for mod in type_result.modifiers {
                if {"c_array", "ref"}.has(mod.name) {
                    old_deref_counter += 1
                    if old_deref_counter > 1 {
                        new_modifiers.add(mod)
                    }
                }
            }
            if old_deref_counter <= 0 {
                if msgs == none {
                    print(if is_moose64 ("hoosec")
                        else ("moosec") + ": "
                            "error: Internal error, "
                            "deref called on item that isn't "
                            "a ref.")
                    throw new RuntimeError(
                        "Call has wrong number of "
                        "arguments.")
                }
                if not node.damaged and
                        not node.subexprs[2].damaged {
                    var called_args =
                    node.subexprs[2].subexprs.len
                    var called_s = "s"
                    msgs.add(new msg.FileMsg(
                        "Unexpected use of 'deref' "
                        "since type " +
                        inner_result.describe_to_user(
                            project=project_file.project,
                            add_quotes_where_useful=yes,
                            is_moose64=is_moose64
                        ) + " isn't a reference.",
                        kind=msg.M_ERROR,
                        source_file=project_file,
                        line=node.subexprs[1].line,
                        col=node.subexprs[1].col,
                    ))
                }
                node.damaged = yes
                node.subexprs[1].damaged = yes
                node.subexprs[2].damaged = yes
                return later none
            }
            type_result.modifiers = new_modifiers
            if type_result.kind == typeinfo.TI_USERTYPE and
                    type_result._orig_typeexpr != none {
                type_result._orig_typeexpr.modifiers = []
                for mod in new_modifiers {
                    type_result._orig_typeexpr.
                        modifiers.add(mod.copy())
                }
            }
            return later type_result
        } elseif m64_builtins.is_ast_node_referring_to_m64_std_size_of(
                project_file, node.subexprs[1], is_moose64=yes) {
            if debug {
                print(dbg_prefix + " Got call binop on " +
                    "built-in 'size_of'.")
            }
            if debug {
                print(dbg_prefix + " Get typeinfo on what size_of() "
                    "was called on...")
            }
            assert(node.subexprs[2].kind == ast.N_EXPR_CALLARGS)
            if node.subexprs[2].subexprs.len != 1 {
                if msgs == none {
                    print(if is_moose64 ("hoosec")
                        else ("moosec") + ": "
                            "error: Internal error, "
                            "as_ref call with not exactly 1 arg "
                            "found: " + node.as_str())
                    throw new RuntimeError(
                        "Call has wrong number of "
                        "arguments.")
                }
                if not node.damaged and
                        not node.subexprs[2].damaged {
                    var called_args =
                        node.subexprs[2].subexprs.len
                    var called_s = "s"
                    msgs.add(new msg.FileMsg(
                        "Unexpected number of args, " +
                        "'size_of' expects 1 arg " +
                        "but this call provides " +
                        called_args.as_str() + " "
                        "arg" + called_s + ".",
                        kind=msg.M_ERROR, source_file=project_file,
                        line=node.subexprs[1].line,
                        col=node.subexprs[1].col,
                    ))
                }
                node.damaged = yes
                node.subexprs[1].damaged = yes
                node.subexprs[2].damaged = yes
                return none
            }
            var inner_result = _get_c_or_m64_type_of_node_do(
                project_file, node.subexprs[2].subexprs[1],
                parents + [node, node.subexprs[2]],
                _known_typeinfo_map=_known_typeinfo_map,
                store_self_value_ref_for_funcs=
                store_self_value_ref_for_funcs,
                msgs=msgs, debug=debug
            ) later:

            await inner_result
            if debug {
                print(dbg_prefix + " Got size_of() arg typeinfo=" +
                    inner_result.as_str())
            }
            if inner_result == none {
                if node.subexprs[2].damaged or
                        node.subexprs[2].subexprs[1].damaged {
                    node.damaged = yes
                }
                return later none
            }
            var size_result = new typeinfo.TypeInfo(
                typeinfo.TI_C_TYPE
            )
            size_result.orig_type_name = "size"
            size_result.c_type_name =
                ast_typeref.get_c_builtin_for_m64_base_type("size")
            if debug {
                print(dbg_prefix + " Returning final ref type "
                    "typeinfo=" + size_result.as_str())
            }
            var try_get_size =
                typeinfo.get_known_type_size(
                    inner_result
                )
            if try_get_size != none {
                size_result.known_literal_value_token =
                    new token.Token(
                        try_get_size.as_str(), token.T_NUM,
                        node.subexprs[2].subexprs[1].line,
                        node.subexprs[2].subexprs[1].col
                    )
            }
            return later size_result
        }
        if debug {
            print(dbg_prefix + " Got generic call binop, calling "
                "get_called_or_assigned_func_types()...")
        }
        var called_node = node.subexprs[1]
        var called_node_parents =
            parents + [node]

        var result = ast_analyze.get_called_or_assigned_func_types(
            project_file, called_node, called_node_parents,
            allow_matching_func_override=yes,
            allow_noncall_ref=no,
            ignore_arg_mismatch=no,
            msgs=none, is_moose64=no, debug=no
        ) later:

        await result
        var func_type_expr =
            if result != none (result.func_var_type_expr) else (none)
        if func_type_expr == none {
            if debug {
                print(dbg_prefix + " No result from "
                    "get_called_or_assigned_func_types(), "
                    "seems like this node can't be resolved: "
                    "called_node=" + called_node.as_str()
                )
            }
            return later none
        }
        if debug {
            print(dbg_prefix + " Obtained func_type_expr=" +
                func_type_expr.as_str())
        }
        if func_type_expr.return_typeref_expr == none or
                (not return_typeref_expr.is_user_type and
                return_typeref_expr.name == "empty") {
            var tinfo = new typeinfo.TypeInfo(typeinfo.TI_C_TYPE)
            tinfo.c_type_name = "void"
            tinfo._orig_typeexpr = new ast_typeref.TypeRefExpr()
            tinfo._orig_typeexpr.name = "empty"
            return tinfo
        }

        var tinfo = get_c_or_m64_type_of_typeref(
            project_file,
            func_type_expr.return_typeref_expr,
            store_self_value_ref_for_funcs=no, msgs=msgs
        ) later:

        await tinfo
        return tinfo
    } elseif {ast.N_STMT_FUNC,
              ast.N_STMT_FUNCEXTEND}.has(node.kind) {
        if debug {
            print(dbg_prefix + " Got a func node " +
                "(func scope set: " +
                if node.func_scope != none ("yes")
                    else ("no") + ")")
        }
        var fscope = node.func_scope
        if fscope == none {
            return later none
        }
        if node.type_path == none or node.type_path.len == 0 {
            var global_ref = new st_ref.StorageRef(
                st_ref.ST_GLOBAL, fscope.storage_id)
            if debug {
                print(dbg_prefix + " The func node " +
                    "is a standalone, getting type from "
                    "storage: global_ref=" +
                    global_ref.as_str())
            }
            var tinfo = typeinfo.
                create_typeinfo_from_global_ref(
                    global_ref, base_node_if_known=node,
                    project=project_file.project,
                    is_moose64=is_moose64, debug=debug,
                )
            assert(tinfo == none or tinfo.kind == typeinfo.TI_FUNCREF)
            if debug {
                print(dbg_prefix + " Type result: "
                    "tinfo=" + tinfo.as_str())
            }
            return later tinfo
        }
        if debug {
            print(dbg_prefix + " The func node " +
                "is a func attr. Obtaining anscope...")
        }
        var anscope = project_file.
            make_attr_names_scope_from_funcattr(
                node, msgs=msgs, is_moose64=is_moose64,
                def_project_file=project_file
            )
        if debug {
            print(dbg_prefix + " Got anscope=" +
                anscope.as_str())
        }
        if anscope == none {
            return later none
        }
        var symbol_info = anscope.name_to_symbol_map[
            node.label]
        if debug {
            print(dbg_prefix + " Got symbol_info=" +
                symbol_info.as_str())
        }
        var global_ref = new st_ref.StorageRef(
            st_ref.ST_GLOBALATTR, [anscope.storage_id,
            symbol_info.storage_id])
        if debug {
            print(dbg_prefix + " Getting type from "
                "storage: global_ref=" +
                global_ref.as_str())
        }
        var tinfo = typeinfo.
            create_typeinfo_from_global_ref(
                global_ref, base_node_if_known=node,
                base_symbol_info_if_known=symbol_info,
                project=project_file.project,
                is_moose64=is_moose64
            )
        assert(tinfo == none or tinfo.kind == typeinfo.TI_FUNCREF)
        if debug {
            print(dbg_prefix + " Type result: "
                "tinfo=" + tinfo.as_str())
        }
        return later tinfo
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.optoken.str == "." {
        var rhand = node.subexprs[2]
        assert(rhand.kind == ast.N_EXPR_IDREF)
        if debug {
            print(dbg_prefix + " Now evaluating binop with "
                "rhand=" + rhand.as_str())
        }

        func resolve_rhand_via_lhand_if_needed {
            if rhand.ref != none {
                return later rhand.ref
            }
            var lhand = node.subexprs[1]
            if not has_attr(lhand, "ref") and
                    (lhand.kind != ast.N_EXPR_BINOP or
                    lhand.optoken.str != "." or
                    lhand.subexprs.len != 2 or
                    lhand.subexprs[2].kind != ast.N_EXPR_IDREF) {
                return later none
            }

            if debug {
                print(dbg_prefix + " Calling "
                    "try_ensure_attr_ref on "
                    "lhand=" + lhand.as_str() + ", "
                    "rhand=" + rhand.as_str())
            }
            scope_manage.try_ensure_attr_ref(
                project_file, lhand, rhand,
                parents + [node],
                error_on_invalid=yes, is_moose64=is_moose64,
                msgs=msgs, debug=debug,
            ) later:
        }
        resolve_rhand_via_lhand_if_needed()
        later:

        if debug {
            print(dbg_prefix + " Got rhand.ref=" + rhand.ref.as_str())
        }
        if rhand.ref == none {
            if rhand.kind == ast.N_EXPR_IDREF and
                    has_attr(rhand, "value_typeref_expr") and
                    rhand.value_typeref_expr != none and
                    rhand.value_typeref_expr.
                        is_special_madeup_builtin {
                # This is a built-in like .len on an array.
                # We can't get a symbol info for this.
                if debug {
                    print(dbg_prefix + " The right hand is a special "
                        "made up built-in, "
                        "rhand.value_typeref_expr=" +
                            rhand.value_typeref_expr.as_str())
                }
                var tinfo = new typeinfo.TypeInfo(
                    typeinfo.TI_M64BUILTIN_TYPE
                )
                tinfo._orig_typeexpr = rhand.value_typeref_expr.copy()
                if rhand.value_typeref_expr.is_func_ref {
                    tinfo.func_typeexpr = tinfo._orig_typeexpr
                } else {
                    assert(not rhand.value_typeref_expr.is_user_type())
                    tinfo.kind = typeinfo.TI_C_TYPE
                    tinfo.orig_type_name =
                        rhand.value_typeref_expr.name
                    assert(tinfo.orig_type_name != none)
                    tinfo.c_type_name =
                        ast_typeref.get_c_builtin_for_m64_base_type(
                            rhand.value_typeref_expr.name
                        )
                    tinfo.modifiers = []
                    for mod in rhand.value_typeref_expr.modifiers {
                        tinfo.modifiers.add(mod.copy())
                    }
                }
                if debug {
                    print(dbg_prefix + " The right hand builtin " +
                        "was resolved to: tinfo=" + tinfo.as_str())
                }
                return tinfo
            }
            trigger_no_symbol_info_on(node)
            return later none
        }
        var sym_info = st_ref.ref_to_symbol_info(
            rhand.ref, node=rhand,
            project=project_file.project,
            is_moose64=is_moose64,
        )
        if debug {
            print(dbg_prefix + " Got sym_info=" + sym_info.as_str())
        }
        if sym_info == none {
            trigger_no_symbol_info_on(node)
            return later none
        }
        var result = get_c_or_m64_type_of_sym_info(
            project_file, sym_info, node_with_reference=rhand,
            node_with_reference_parents=parents + [node],
            msgs=msgs, debug=debug
        ) later:

        await result
        if result != none and
                not _known_typeinfo_map.has(node) {
            _known_typeinfo_map[node] = result.copy()
            _known_typeinfo_map[node].func_self_ref = none
        }
        if store_self_value_ref_for_funcs and
                left_hand_instance_ref != none {
            if debug {
                print(dbg_prefix + " Setting result.func_self_ref=" +
                    left_hand_instance_ref.as_str())
            }
            result.func_self_ref = left_hand_instance_ref
        } else {
            if debug {
                print(dbg_prefix + " Unsetting result.func_self_ref.")
            }
        }
        if debug {
            print(dbg_prefix + " Got N_EXPR_BINOP '.' result=" +
                result.as_str())
        }
        return later result
    }
    return later none
}

### Get the C or m64 type that is assoiated with the given
### AST node in the form of a @{compiler.typeinfo.TypeInfo} object.
### @returns (compiler.typeinfo.TypeInfo, none) The type info for
###     the node, or `none` if it can't be determined.
func get_c_or_m64_type_of_node(
        project_file, node, parents,
        store_self_value_ref_for_funcs=no,
        msgs=none, debug=no
        ) {
    assert(typename(parents) == "list")
    var result = _get_c_or_m64_type_of_node_do(
        project_file, node, parents,
        _known_typeinfo_map=none,
        store_self_value_ref_for_funcs=
            store_self_value_ref_for_funcs,
        msgs=msgs,
        debug=debug
    ) later:

    await result
    return result
}

