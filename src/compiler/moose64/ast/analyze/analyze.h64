## @module compiler.moose64.ast.analyze
# Copyright (c) 2024-2025, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import random from core.horse64.org
import textfmt from core.horse64.org

import compiler.ast as ast
import compiler.ast.analyze as ast_analyze
import compiler.ast.expr as ast_expr
import compiler.builtin_syms as builtin_syms
import compiler.moose64.autocast as m64_autocast
import compiler.moose64.builtins as m64_builtins
import compiler.msg as msg
import compiler.storage.ref as st_ref
import compiler.storage.scope as st_scope
import compiler.storage.scope.manage as scope_manage
import compiler.token as token
import compiler.typeinfo as typeinfo
import compiler.typeinfo.ast_typeref as ast_typeref

type ComputeBinopTypesResult {
    var left_hand_type
    var left_hand_cast_to_type
    var right_hand_type
    var right_hand_cast_to_type
    var result_type
}

func ComputeBinopTypesResult.as_str {
    var t = "ComputeBinopTypeResult{"
    t += "left_hand_type=" +
        self.left_hand_type.as_str() + ","
    t += "left_hand_cast_to_type=" +
        self.left_hand_cast_to_type.as_str() + ","
    t += "right_hand_type=" +
        self.right_hand_type.as_str() + ","
    t += "right_hand_cast_to_type=" +
        self.right_hand_cast_to_type.as_str() + ","
    t += "result_type=" +
        self.result_type.as_str()
    t += "}"
    return t
}

func compute_and_verify_regular_m64_binop_types(
        binop_node, binop_node_parents,
        _known_typeinfo_map=none,
        project_file=none,
        msgs=msgs, debug=no) {
    const is_moose64 = yes
    const program_name =
        if is_moose64 ("moosec") else ("horsec")
    const node = binop_node
    const parents = binop_node_parents
    if binop_node == none or
            binop_node.kind != ast.N_EXPR_BINOP {
        throw new ValueError(
            "This isn't a binary operator."
        )
    }
    if {"[", "(", "."}.has(binop_node.optoken.str) {
        throw new ValueError(
            "This isn't a regular type binary operator."
        )
    }
    var is_comparison = token.compare_ops.has(node.optoken.str)
    var is_bool_cmp = token.bool_compare_ops.has(node.optoken.str)
    if debug {
        print(program_name + ": debug: "
            "compute_and_verify_regular_m64_binop_types(): "
            "Found " +
            if is_comparison ("comparison") else
                ("math") + " binary op '" +
            node.optoken.str + "', evaluating types of "
            "operands. node=" + node.as_str())
    }

    var left_side_type = _get_c_or_m64_type_of_node_do(
        project_file, node.subexprs[1], parents + [node],
        _known_typeinfo_map=_known_typeinfo_map,
        store_self_value_ref_for_funcs=no,
        msgs=msgs, debug=debug
    ) later:

    await left_side_type
    var right_side_type = _get_c_or_m64_type_of_node_do(
        project_file, node.subexprs[2], parents + [node],
        _known_typeinfo_map=_known_typeinfo_map,
        store_self_value_ref_for_funcs=no,
        msgs=msgs, debug=debug
    ) later:

    await right_side_type
    if left_side_type == none or right_side_type == none {
        if debug {
            print(program_name + "debug: "
                "compute_and_verify_regular_m64_binop_types(): "
                "Failed to get one side of "
                "the binary op, aborting: left_side_type=" +
                left_side_type.as_str() + " "
                "right_side_type=" +
                right_side_type.as_str() + " "
                "left_hand_node=" +
                    node.subexprs[1].as_str() + " "
                "right_hand_node=" +
                    node.subexprs[2].as_str() + " "
                "node.optoken=" +
                    node.optoken.as_str())
        }
        if node.subexprs[1].damaged or node.subexprs[2].damaged {
            binop_node.damaged = yes
        }
        return later none
    }
    if debug {
        print(program_name + ": debug: "
            "compute_and_verify_regular_m64_binop_types(): "
            "Obtained operand types: "
            "left_side_type=" + left_side_type.as_str() + " "
            "right_side_type=" + right_side_type.as_str() + " "
            "optoken.str='" + node.optoken.str.as_str() + "'")
    }
    if is_bool_cmp {
        if left_side_type.kind != typeinfo.TI_C_TYPE or
                left_side_type.orig_type_name != "bool" or
                left_side_type.ref_count() > 0 {
            if msgs == none {
                throw new ValueError("Found binary operator "
                    "applied on incompatible operators.")
            }
            if not node.damaged {
                msgs.add(new msg.FileMsg(
                    "Unexpected '" + node.optoken.str.as_str() +
                    "' operator applied to incompatible " 
                    "left operand of type " +
                    left_side_type.describe_to_user(
                        project=project_file.project,
                        add_quotes_where_useful=yes,
                        is_moose64=yes
                    ) + " which isn't a bool.",
                    source_file=project_file,
                    line=node.line, col=node.col,
                ))
            }
            node.damaged = yes
            return later none
        }
        if right_side_type.kind != typeinfo.TI_C_TYPE or
                right_side_type.orig_type_name != "bool" or
                right_side_type.ref_count() > 0 {
            if msgs == none {
                throw new ValueError("Found binary operator "
                    "applied on incompatible operators.")
            }
            if not node.damaged {
                msgs.add(new msg.FileMsg(
                    "Unexpected '" + node.optoken.str.as_str() +
                    "' operator applied to incompatible " 
                    "right operand of type " +
                    right_side_type.describe_to_user(
                        project=project_file.project,
                        add_quotes_where_useful=yes,
                        is_moose64=yes
                    ) + " which isn't a bool.",
                    source_file=project_file,
                    line=node.line, col=node.col,
                ))
            }
            node.damaged = yes
            return later none
        }
        var result = new ComputeBinopTypesResult()
        result.left_hand_type = left_side_type.copy()
        result.left_hand_cast_to_type =
            left_side_type.copy()
        result.right_hand_type = right_side_type.copy()
        result.right_hand_cast_to_type =
            right_side_type.copy()
        result.result_type =
            typeinfo.create_from_simple_m64_type(
                "bool"
            )
        return result
    }
    var math_cast_result = m64_autocast.
        get_math_binop_autocast(
            left_side_type, right_side_type,
            left_side_is_literal_none=
                (node.subexprs.len >= 2 and
                 node.subexprs[1].kind == ast.N_EXPR_LIT and
                 node.subexprs[1].value == none),
            right_side_is_literal_none=
                (node.subexprs.len >= 2 and
                 node.subexprs[2].kind == ast.N_EXPR_LIT and
                 node.subexprs[2].value == none),
            is_cmp_op=is_comparison,
            is_moose64=is_moose64,
        )
    if debug {
        print(program_name + "debug: "
            "compute_and_verify_regular_m64_binop_types(): "
            "Obtained autocast info for "
            "binop: math_cast_result=" +
                math_cast_result.as_str())
    }
    if math_cast_result.incompatible {
        if msgs == none {
            throw new ValueError("Found binary operator "
                "applied on incompatible operators.")
        }
        if not node.damaged {
            msgs.add(new msg.FileMsg(
                "Unexpected '" + node.optoken.str.as_str() +
                "' operator applied to incompatible types " +
                left_side_type.describe_to_user(
                    project=project_file.project,
                    add_quotes_where_useful=yes,
                    is_moose64=yes
                ) + " "
                "and " + right_side_type.describe_to_user(
                    project=project_file.project,
                    add_quotes_where_useful=yes,
                    is_moose64=yes
                ) + ".",
                source_file=project_file,
                line=node.line, col=node.col,
            ))
        }
        node.damaged = yes
        return later none
    }

    var result = new ComputeBinopTypesResult()
    result.left_hand_type = left_side_type.copy()
    result.left_hand_cast_to_type =
        math_cast_result.cast_lefthand_to.copy()
    result.right_hand_type = right_side_type.copy()
    result.right_hand_cast_to_type =
        math_cast_result.cast_righthand_to.copy()
    if is_comparison {
        result.result_type =
            typeinfo.create_from_simple_m64_type(
                "bool"
            )
        return later result
    }
    result.result_type = math_cast_result.result_type.copy()
    return later result
}

func get_c_or_m64_type_of_sym_info(
        project_file, target_sym_info,
        node_with_reference=none,
        node_with_reference_parents=none,
        store_self_value_ref_for_funcs=no,
        msgs=none, debug=no
        ) {
    const is_moose64 = yes
    var dbg_prefix = ""
    if debug {
        d_id = random.gen_id()
        dbg_prefix = "moosec: debug: "
            "get_c_or_m64_type_of_sym_info() #" + d_id
    }
    if debug {
        print(dbg_prefix + " Examining target_sym_info=" +
            target_sym_info.as_str() + " "
            "node_with_reference=" +
                node_with_reference.as_str() + " "
            "node_with_reference.ref=" +
                if node_with_reference != none
                    (node_with_reference.ref.as_str()) else
                    ("<is none>") + " "
            "node_with_reference_parents.len=" +
                if node_with_reference_parents != none
                    (node_with_reference_parents.len.as_str()) else
                    ("<is none>"))
    }

    var typeref_expr = none
    var target_ref = target_sym_info.type_storage_ref
    if debug {
        print(dbg_prefix + " Found initial target_ref=" +
            target_ref.as_str())
    }
    if target_ref == none and node_with_reference != none and
            node_with_reference.ref != none and
            node_with_reference_parents != none and
            node_with_reference_parents.len > 0 and
            node_with_reference.ref.kind == st_ref.ST_LOCAL {
        var var_node = st_scope.find_def_node_from_idref_node(
            node_with_reference, node_with_reference_parents
        )
        if debug {
            print(dbg_prefix + " Tried to get var node. "
                "var_node=" +
                var_node.as_str())
        }
        if var_node != none or var_node.kind != ast.N_STMT_VAR {
            if not var_node.has_type_expr {
                return later none
            }
            typeref_expr = var_node.subexprs[var_node.subexprs.len]
            if debug {
                print(dbg_prefix + " Got var node type. "
                    "typeref_expr=" +
                    typeref_expr.as_str())
            }
        }
    } elseif target_ref == none and
            node_with_reference != none and
            node_with_reference.ref.kind == st_ref.ST_LOCAL {
        if debug {
            print(dbg_prefix + " Warning: this is a local var "
                "ref, but there's not enough info supplied to "
                "even try to trace back to the var_node "
                "defining it.")
        }
    }
    if target_ref == none and node_with_reference.ref != none and
            {st_ref.ST_GLOBAL, st_ref.ST_GLOBALATTR,
                st_ref.ST_CEXT, st_ref.ST_MCREF}.has(
                    node_with_reference.ref.kind) {
        target_ref = node_with_reference.ref
    }
    if target_ref == none and node_with_reference.ref != none and
            node_with_reference.ref.kind == st_ref.ST_SELF and
            node_with_reference_parents != none and
            node_with_reference_parents.len >= 1 {
        var owning_func_attr_node = none
        var i = node_with_reference_parents.len
        while i >= 1 {
            if {ast.N_STMT_FUNC, ast.N_STMT_FUNCEXTEND}.has(
                    node_with_reference_parents[i].kind) {
                owning_func_attr_node =
                    node_with_reference_parents[i]
                break
            }
            i -= 1
        }
        if debug {
            var owning_func_attr_str = "none"
            if owning_func_attr_node != none {
                owning_func_attr_str = owning_func_attr_node.as_str() +
                    "..."
            }
            print(dbg_prefix + " Found self ref with "
                "owning_func_attr_node=" +
                    owning_func_attr_str)
        }
        if owning_func_attr_node != none {
            var anscope = project_file.
                make_attr_names_scope_from_funcattr(
                    owning_func_attr_node, msgs=msg,
                    is_moose64=is_moose64,
                    def_project_file=project_file
                )
            if debug {
                print(dbg_prefix + " Found associated "
                    "anscope for self: anscope=" +
                    anscope.as_str())
            }
            if anscope != none {
                target_ref = new st_ref.StorageRef(
                    st_ref.ST_GLOBAL, anscope.storage_id
                )
            }
        }
    }
    if target_ref != none {
        assert(target_ref == none or has_attr(target_ref, "kind"))
        assert(target_ref.kind != st_ref.ST_LOCAL)
        var tinfo = new typeinfo.create_typeinfo_from_global_ref(
            target_ref,
            base_symbol_info_if_known=target_sym_info,
            base_node_if_known=node_with_reference,
            project=project_file.project,
            is_moose64=is_moose64,
        )
        if debug {
            print(dbg_prefix + " Called "
                "create_typeinfo_from_global_ref "
                "and got tinfo=" + tinfo.as_str())
        }
        return later tinfo
    }
    if typeref_expr == none {
        typeref_expr = target_sym_info.typeref_expr
    }
    if typeref_expr == none {
        return later none
    }
    if debug {
        print(dbg_prefix + " Will now call "
            "create_typeinfo_from_typeexpr_and_verify "
            "on: typeref_expr=" + typeref_expr.as_str())
    }
    var result = typeinfo.
        create_typeinfo_from_typeexpr_and_verify(
            typeref_expr,
            project_file=project_file, 
            store_self_value_ref_for_funcs=
                store_self_value_ref_for_funcs,
            base_node_if_known=node_with_reference,
            base_node_parents_if_known=
                node_with_reference_parents,
            is_moose64=is_moose64, debug=debug,
        ) later:

    await result
    if debug {
        print(dbg_prefix + " Got typeinfo "
            "result: result=" + result.as_str())
    }
    return result
}

type ListArgNodeInfo {
    var is_forward = no
    var is_len = no
    var is_get = no
    var arg_type_expr = none
}

func get_list_arg_node_info(
        project_file, node, parents,
        is_moose64=no, msgs=none,
        ) {
    var is_forward = m64_builtins.
        is_ast_node_referring_to_m64_list_arg_forward(
            project_file, node,
            is_moose64=is_moose64)
    var is_len = m64_builtins.
        is_ast_node_referring_to_m64_list_arg_len(
            project_file, node,
            is_moose64=is_moose64)
    var is_get = m64_builtins.
        is_ast_node_referring_to_m64_list_arg_get(
            project_file, node,
            is_moose64=is_moose64)
    if not is_forward and not is_len and not is_get {
        return new ListArgNodeInfo()
    }
    var result = new ListArgNodeInfo()
    result.is_forward = is_forward
    result.is_len = is_len
    result.is_get = is_get

    var i = parents.len
    while i >= 1 {
        if parents[i].kind == ast.N_STMT_FUNC or
                parents[i].kind == ast.N_STMT_FUNCEXTEND {
            func_node = parents[i]
            break
        }
        i -= 1
    }
    if func_node == none {
        if not node.damaged {
            if msgs == none {
                throw new ValueError(
                    "Found invalid use of 'list_arg' "
                    "outside of function."
                )
            }
            msgs.add(new msg.FileMsg(
                "Invalid use of 'list_arg' outside "
                "of a function.",
                line=node.line, col.node.col
            ))
        }
        node.damaged = yes
        return result
    }
    var func_scope = node.scope.func_scope
    assert(func_scope != none)

    var arg_type_exprs = func_scope.
        extended_final_arg_type_exprs()
    var list_arg_idx = none
    var idx = 0
    for arg_expr in arg_type_exprs {
        idx += 1
        if arg_expr.is_list_arg {
            if list_arg_idx != none {
                if not node.damaged {
                    if msgs == none {
                        throw new ValueError(
                            "Found invalid use of 'list_arg' "
                            "in a function with more than "
                            "one list arg parameter."
                        )
                    }
                    msgs.add(new msg.FileMsg(
                        "Invalid use of 'list_arg' "
                        "in a function with more than "
                        "one list arg parameter.",
                        line=node.line, col.node.col
                    ))
                }
                node.damaged = yes
                return result
            }
            list_arg_idx = idx
        }
    }
    if list_arg_idx == none {
        if not node.damaged {
            if msgs == none {
                throw new ValueError(
                    "Found invalid use of 'list_arg' "
                    "in a function without "
                    "any list arg parameter."
                )
            }
            msgs.add(new msg.FileMsg(
                "Invalid use of 'list_arg' "
                "in a function without "
                "any list arg parameter.",
                line=node.line, col.node.col
            ))
        }
        node.damaged = yes
        return result
    }

    result.arg_type_expr =
        arg_type_exprs[list_arg_idx].copy()
    return result
}

func _get_c_or_m64_type_of_node_do(
        project_file, node, parents,
        _known_typeinfo_map=none,
        store_self_value_ref_for_funcs=no,
        disable_binop_parent_fallback=no,
        msgs=none, debug=no
        ) {
    var is_moose64 = yes
    if _known_typeinfo_map == none {
        _known_typeinfo_map = {->}
    }
    if _known_typeinfo_map.has(node) and
            not store_self_value_ref_for_funcs {
        var result = _known_typeinfo_map[node].copy()
        if debug {
            print("moosec: debug: "
                "_get_c_or_m64_type_of_node_do() FAST PATH: " +
                "Returning cached result=" + result.as_str())
        }
        return later result
    }
    var parent = if parents.len > 0
        (parents[parents.len]) else (none)

    var d_id = none
    var dbg_prefix = ""
    if debug {
        d_id = random.gen_id()
        dbg_prefix = "moosec: debug: "
            "_get_c_or_m64_type_of_node_do() #" + d_id
        print(dbg_prefix + " Running on: " +
            node.as_str() + " with store_self_value_ref_for_funcs=" +
            store_self_value_ref_for_funcs.as_str())
    }
    func get_type_from_stored_typeref_expr_if_any {
        if (node.kind == ast.N_EXPR_IDREF and
                node.value_typeref_expr != none) or
                (node.kind == ast.N_EXPR_BINOP and
                node.optoken.str == "." and
                node.subexprs.len >= 2 and
                node.subexprs[2].kind == ast.N_EXPR_IDREF and
                node.subexprs[2].value_typeref_expr != none) {
            var texpr = if node.kind == ast.N_EXPR_IDREF
                (node.value_typeref_expr.copy()) else
                (node.subexprs[2].value_typeref_expr.copy())
            if debug {
                print(dbg_prefix + " "
                    "get_type_from_stored_typeref_expr_if_any(): "
                    "We got node.value_typeref_expr "
                    "set, returning it. "
                    "texpr=" + texpr.as_str() + " "
                    "node.line=" + node.line.as_str() + " "
                    "node.col=" + node.col.as_str())
            }
            return typeinfo.create_typeinfo_from_typeexpr(
                texpr,
                is_moose64=is_moose64,
            )
        }
        return none
    }
    func trigger_no_symbol_info_on(node) {
        if node.damaged {
            return
        }
        if debug {
            print("moosec: debug: "
                "WARNING, unexpectedly failed to "
                "get symbol info on node=" +
                node.as_str())
        }
        if msgs == none {
            throw new ValueError(
                "Internal error: Unexpectedly failed to "
                "get symbol info."
            )
        }
        node.damaged = yes
        msgs.add(new msg.FileMsg(
            "Internal error: Unexpectedly failed to trace "
            "back this identifier to resolved target: " +
            node.as_str() +
            " (with node.ref: " + if has_attr(node, "ref")
                    (node.ref.as_str())
                    else ("<no .ref attr>") + ") "
            "Please report this to the compiler makers.",
            source_file=project_file,
            line=node.line, col=node.col,
        ))
    }

    func trigger_no_such_attribute_on(node, aname) {
        if node.damaged {
            return
        }
        if msgs == none {
            throw new ValueError(
                "The given type doesn't have this attribute."
            )
        }
        node.damaged = yes
        msgs.add(new msg.FileMsg(
            "Unexpected attribute name " +
            textfmt.as_escaped_code_string(
                aname
            ) + ", this value doesn't have this attribute.",
            source_file=project_file,
            line=node.line, col=node.col,
        ))
    }

    var left_hand_instance_ref = none
    func evaluate_lefthand_sides_if_needed(node) {
        if debug {
            print(dbg_prefix +
                " In evaluate_lefthand_sides_if_needed(): "
                "Starting with node=" + node.as_str())
        }
        if node.kind != ast.N_EXPR_BINOP or
                node.optoken.str != "." {
            if debug {
                print(dbg_prefix +
                    " In evaluate_lefthand_sides_if_needed(): "
                    "Got no left-hand to evaluate.")
            }
            return later yes
        }
        if has_attr(node.subexprs[1], "ref") and
                node.subexprs[1].ref != none {
            left_hand_instance_ref =
                node.subexprs[1].ref.copy()
        } elseif node.subexprs[1].kind == ast.N_EXPR_BINOP and
                node.subexprs[1].optoken.str == "." and
                has_attr(node.subexprs[1].subexprs[2], "ref") and
                node.subexprs[1].subexprs[2].ref != none {
            left_hand_instance_ref =
                node.subexprs[1].subexprs[2].ref.copy()
        }
        if (has_attr(node.subexprs[2], "ref") and
                node.subexprs[2].ref != none) or
                _known_typeinfo_map.has(node.subexprs[2]) {
            return later yes
        }
        if debug {
            print(dbg_prefix +
                " In evaluate_lefthand_sides_if_needed(): "
                "Now trying to get type on node.subexprs[1]=" +
                node.subexprs[1].as_str())
        }
        var c_type = _get_c_or_m64_type_of_node_do(
            project_file, node.subexprs[1], parents + [node],
            _known_typeinfo_map=_known_typeinfo_map,
            disable_binop_parent_fallback=yes,
            msgs=msgs,
        ) later:

        await c_type
        if debug {
            print(dbg_prefix +
                " In evaluate_lefthand_sides_if_needed(): "
                "Result: c_type=" + c_type.as_str())
        }
        if c_type == none and (
                has_attr(node.subexprs[1], "ref") and
                node.subexprs[1].ref == none) {
            return later no
        }
        _known_typeinfo_map[node.subexprs[1]] = c_type
        return later yes
    }
    var result = evaluate_lefthand_sides_if_needed(node)
    later:

    await result
    if not result {
        # This means there isn't a useful way we can derive
        # any type from a left hand that's present.
        if debug {
            print(dbg_prefix + " Aborting: "
                "no useful left-hand from which we could derive "
                "type of full expression")
        }
        return later none
    }

    if debug {
        print(dbg_prefix + " Continuing after checking left-hand: "
            "left_hand_instance_ref=" +
            left_hand_instance_ref.as_str() + " "
            "node.kind=" + ast.NodeKind.num_label(node.kind))
        if node.kind == ast.N_EXPR_BINOP {
            print(dbg_prefix + " Binop optoken=" +
                node.optoken.as_str())
        }
    }
    if node.kind == ast.N_STMT_VAR {
        if not node.has_type_expr {
            return later none
        }
        var result = typeinfo.
            create_typeinfo_from_typeexpr_and_verify(
                node.subexprs[node.subexprs.len],
                project_file=project_file, 
                store_self_value_ref_for_funcs=
                    store_self_value_ref_for_funcs,
                base_node_if_known=node,
                base_node_parents_if_known=parents,
                is_moose64=is_moose64,
            ) later:

        await result
        if debug {
            print(dbg_prefix + " Got N_STMT_VAR result=" +
                result.as_str())
        }
        return later result
    } elseif node.kind == ast.N_EXPR_TYPECAST {
        var typeref_expr = node.typeref_expr
        if debug {
            print(dbg_prefix + " Got an N_EXPR_TYPECAST. "
                "typeref_expr=" + typeref_expr.as_str())
        }
        var result = typeinfo.
            create_typeinfo_from_typeexpr_and_verify(
                typeref_expr,
                store_self_value_ref_for_funcs=no,
                self_node_if_known=none,
                base_node_if_known=node,
                base_node_parents_if_known=parents,
                project_file=project_file,
                is_moose64=is_moose64, debug=no,
            ) later:

        await result
        return result
    } elseif node.kind == ast.N_EXPR_LIT {
        return later m64_autocast.
            ast_literal_node_to_suggested_m64_type(
                node, parents=parents,
            )
    } elseif node.kind == ast.N_EXPR_UNOP and
            node.subexprs.len >= 1 and
            node.optoken.str == 'not' {
        var inner_type = _get_c_or_m64_type_of_node_do(
            project_file, node.subexprs[1], parents + [node],
            _known_typeinfo_map=_known_typeinfo_map,
            store_self_value_ref_for_funcs=no,
            msgs=msgs, debug=debug
        ) later:

        await inner_type
        if inner_type == none {
            if debug {
                print(dbg_prefix + " Failed to get operand of "
                    "the unary op, aborting: inner_type=" +
                        inner_type.as_str() + " "
                    "node.subexprs[1]=" +
                        node.subexprs[1].as_str())
            }
            return later none
        }
        if debug {
            print(dbg_prefix + " Obtained operand type: "
                "inner_type=" + left_side_type.as_str() + " "
                "optoken.str='" + node.optoken.str.as_str() + "'")
        }
        if inner_type.kind != typeinfo.TI_C_TYPE or
                inner_type.orig_type_name != "bool" or
                inner_type.ref_count() > 0 {
            if msgs == none {
                throw new ValueError("Found binary operator "
                    "applied on incompatible operators.")
            }
            if not node.damaged {
                msgs.add(new msg.FileMsg(
                    "Unexpected '" + node.optoken.str.as_str() +
                    "' operator applied to incompatible " 
                    "operand of type " +
                    inner_type.describe_to_user(
                        project=project_file.project,
                        add_quotes_where_useful=yes,
                        is_moose64=yes
                    ) + " which isn't a bool.",
                    source_file=project_file,
                    line=node.line, col=node.col,
                ))
            }
            node.damaged = yes
            return later none
        }
        var result = typeinfo.
            create_from_simple_m64_type("bool")
        return result
    } elseif node.kind == ast.N_EXPR_UNOP and
            node.subexprs.len >= 1 and
            node.optoken.str == '-' {
        var right_side_type = _get_c_or_m64_type_of_node_do(
            project_file, node.subexprs[1], parents + [node],
            _known_typeinfo_map=_known_typeinfo_map,
            store_self_value_ref_for_funcs=no,
            msgs=msgs, debug=debug
        ) later:

        await right_side_type
        if right_side_type == none {
            return later none
        }
        if right_side_type.kind == typeinfo.TI_USERTYPE {
            if right_side_type.ref_count(
                    include_c_arrays=yes, include_arrays=no,
                    include_implicit_refs=no,
                    include_explicit_refs=yes) > 0 {
                var result_type =
                    typeinfo.create_from_simple_m64_type(
                        "addr_diff"
                    )
                return result_type
            }
            return none
        } elseif right_side_type.kind == typeinfo.TI_C_TYPE {
            return right_side_type
        }
        return none
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.subexprs.len >= 2 and
            node.optoken.str == '[' {
        if debug {
            print(dbg_prefix + " Found indexing op '" +
                node.optoken.str + "', evaluating type of "
                "container...")
        }
        var left_side_type = _get_c_or_m64_type_of_node_do(
            project_file, node.subexprs[1], parents + [node],
            _known_typeinfo_map=_known_typeinfo_map,
            store_self_value_ref_for_funcs=no,
            msgs=msgs, debug=debug
        ) later:

        await left_side_type
        if left_side_type == none {
            return later none
        }
        var c_array_or_expl_ref_count = left_side_type.ref_count(
            include_c_arrays=yes, include_arrays=no,
            include_implicit_refs=no,
            include_explicit_refs=yes,
        )
        var normal_array_ref_count = left_side_type.ref_count(
            include_c_arrays=no, include_arrays=yes,
            include_implicit_refs=no,
            include_explicit_refs=no,
        )
        assert(c_array_or_expl_ref_count == 0 or
            normal_array_ref_count == 0)
        if c_array_or_expl_ref_count > 0 or
                normal_array_ref_count > 0 {
            var drop_names = none
            if c_array_or_expl_ref_count {
                drop_names = {"ref", "c_array"}
            } else {
                drop_names = {"array"}
            }
            var new_type = left_side_type.copy()
            var mod_idx = new_type.modifiers.len
            var drop_successful = no
            while mod_idx >= 1 {
                var mod = new_type.modifiers[mod_idx]
                if drop_names.has(mod.name) {
                    new_type.modifiers = new_type.modifiers.sub(
                        1, mod_idx - 1
                    ) + new_type.modifiers.sub(mod_idx + 1)
                    drop_successful = yes
                    break
                }
                mod_idx -= 1
            }
            if not drop_successful {
                return none
            }
            return new_type
        } else {
            msgs.add(new msg.FileMsg(
                "Unexpected '[' indexing "
                "operator applied to "
                "incompatible container " +
                left_side_type.describe_to_user(
                    project=project_file.project,
                    add_quotes_where_useful=yes,
                    is_moose64=yes
                ) + ", which cannot be indexed.",
                source_file=project_file,
                line=node.line, col=node.col,
            ))
            node.damaged = yes
            return later none
        }
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.subexprs.len >= 2 and
            (token.compare_ops.has(node.optoken.str) or
            token.bool_compare_ops.has(node.optoken.str) or
            token.math_ops.has(node.optoken.str)) {
        if debug {
            print(dbg_prefix + " Calling "
                "compute_and_verify_regular_m64_binop_types() "
                "to get casting and type info...")
        }
        var binop_type_result =
            compute_and_verify_regular_m64_binop_types(
                node, parents,
                _known_typeinfo_map=_known_typeinfo_map,
                project_file=project_file,
                msgs=msgs, debug=debug)
        later:

        await binop_type_result
        if debug {
            print(dbg_prefix + " Got "
                "casting and type info. "
                "binop_type_result=" +
                    binop_type_result.as_str() + " "
                "node=" + node.as_str())
        }
        if binop_type_result == none {
            assert(node.has_damage())
            return later none
        }
        return later binop_type_result.result_type
    } elseif node.kind == ast.N_EXPR_IDREF {
        if parent != none and
                parent.kind == ast.N_EXPR_BINOP and
                parent.optoken.str == "." and
                parent.subexprs.len >= 2 and
                parent.subexprs[2] == node and
                not disable_binop_parent_fallback {
            if debug {
                print(dbg_prefix + " The parent is an "
                    "attr access binop, "
                    "so we're getting parent result "
                    "instead...")
            }
            var inner_result = _get_c_or_m64_type_of_node_do(
                project_file, parent, parents.sub(1, parents.len - 1),
                _known_typeinfo_map=_known_typeinfo_map,
                store_self_value_ref_for_funcs=
                    store_self_value_ref_for_funcs,
                msgs=msgs, debug=debug
            ) later:

            await inner_result
            if debug {
                print(dbg_prefix + " Will return "
                    "parent result now: " +
                    inner_result.as_str())
            }
            if inner_result != none and
                    not _known_typeinfo_map.has(node) {
                _known_typeinfo_map[node] = inner_result.copy()
                _known_typeinfo_map[node].func_self_ref = none
            }
            return inner_result
        }

        var return_type_with_ref_modifier = no
        var return_type_with_implicit_ref_modifier = no
        var sym_info = none
        if node.ref != none and node.ref.kind == st_ref.ST_SELF {
            var func_node = none
            var i = parents.len
            while i >= 1 {
                if parents[i].kind == ast.N_STMT_FUNC or
                        parents[i].kind == ast.N_STMT_FUNCEXTEND {
                    func_node = parents[i]
                    if func_node.type_path == none or
                            func_node.type_path.len == 0 {
                        i -= 1
                        while i >= 1 {
                            if (parents[i].kind == ast.N_STMT_FUNC or
                                    parents[i].kind ==
                                    ast.N_STMT_FUNCEXTEND) and
                                    parents[i].type_path != none and
                                    parents[i].type_path.len > 0 {
                                func_node = parents[i]
                                break
                            }
                            i -= 1
                        }
                    }
                    break
                }
                i -= 1
            }
            if func_node == none {
                if not node.damaged {
                    if msgs == none {
                        throw new ValueError(
                            "Found invalid use of 'self' "
                            "outside of function."
                        )
                    }
                    msgs.add(new msg.FileMsg(
                        "Invalid use of 'self' outside "
                        "of a function.",
                        line=node.line, col.node.col
                    ))
                }
                node.damaged = yes
                return none
            } elseif func_node.type_path == none or
                    func_node.type_path.len == 0 {
                if not node.damaged {
                    if msgs == none {
                        throw new ValueError(
                            "Found invalid use of 'self' "
                            "in function that isn't func attr."
                        )
                    }
                    msgs.add(new msg.FileMsg(
                        "Invalid use of 'self' in func "
                        "that isn't a func attr.",
                        line=node.line, col.node.col
                    ))
                }
                node.damaged = yes
                return none
            }
            var anscope = project_file.
                make_attr_names_scope_from_funcattr(
                    func_node, msgs=msgs, is_moose64=is_moose64,
                    def_project_file=project_file,
                )
            if anscope == none {
                return none
            }
            var type_st_ref = new st_ref.StorageRef(
                st_ref.ST_GLOBAL, anscope.storage_id
            )
            sym_info = st_ref.ref_to_symbol_info(
                type_st_ref, project=project_file.project,
                is_moose64=is_moose64,
            )
            return_type_with_implicit_ref_modifier = yes
        } elseif node.ref != none {
            sym_info = st_ref.ref_to_symbol_info(
                node.ref, node=node,
                project=project_file.project,
                is_moose64=is_moose64,
            )
            if debug {
                print(dbg_prefix + " Got a node.ref set, "
                    "called st_ref.ref_to_symbol_info(): " +
                    "node.ref=" + node.ref.as_str() + " "
                    "sym_info=" + sym_info.as_str())
            }
        }

        if sym_info == none {
            if node.ref != none and
                    node.ref.kind == st_ref.ST_MCREF and
                    (node.ref.id == builtin_syms.get_item_by_name(
                        project_file.project, "size_of",
                        in_package_name="m64.horse64.org",
                        in_module_name="memory").
                        symbol_storage_ref.id or
                    node.ref.id == builtin_syms.get_item_by_name(
                        project_file.project, "deref",
                        ).symbol_storage_ref.id or
                    node.ref.id == builtin_syms.get_item_by_name(
                        project_file.project, "as_ref",
                        ).symbol_storage_ref.id) {
                if msgs == none {
                    throw new ValueError("Unexpected reference "
                        "to a compiler "
                        "built-in special func that can only be called, "
                        "not referenced.")
                }
                if not node.damaged {
                    node.damaged = yes
                    msgs.add(new msg.FileMsg(
                        "Unexpected reference "
                        "to built-in special func \"" + node.label +
                        "\" that can only be called, not referenced.",
                        source_file=project_file,
                        line=node.line, col=node.col,
                    ))
                }
                return later none
            } elseif node.ref != none and
                    node.ref.kind == st_ref.ST_MCREF and
                    (m64_builtins.
                     is_ast_node_referring_to_m64_list_arg_forward(
                        project_file, node,
                        is_moose64=is_moose64) or
                     m64_builtins.
                     is_ast_node_referring_to_m64_list_arg_len(
                        project_file, node,
                        is_moose64=is_moose64) or
                     m64_builtins.
                     is_ast_node_referring_to_m64_list_arg_get(
                        project_file, node,
                        is_moose64=is_moose64)) {
                if debug {
                    print(dbg_prefix + " Got a match for one "
                        "of the list arg built-ins...")
                }
                var list_arg_info = get_list_arg_node_info(
                    project_file, node, parents,
                    is_moose64=is_moose64, msgs=msgs,
                )
                if list_arg_info.arg_type_expr == none {
                    assert(node.damaged)
                    return later none
                }

                if list_arg_info.is_len {
                    var type_result = new typeinfo.TypeInfo(
                        typeinfo.TI_C_TYPE
                    )
                    type_result.orig_type_name = "size"
                    type_result.c_type_name =
                        ast_typeref.get_c_builtin_for_m64_base_type(
                            "size")
                    return later type_result
                } else {
                    # It must be a .get or a .forward,
                    # but those only can be type analyzed
                    # as the complete call and not the
                    # inner call expression.
                    if not node.damaged and (
                            parents.len == 0 or
                            parents[parents.len].
                                kind != ast.N_EXPR_BINOP or
                            parents[parents.len].
                                optoken.str != "(" or
                            parents[parents.len].
                                subexprs.len < 2 or
                            parents[parents.len].
                                subexprs[1] != node) {
                        node.damaged = yes
                        msgs.add(new msg.FileMsg(
                            "Unexpected reference "
                            "to built-in special func \"" + node.label +
                            "\" that can only be called, not referenced.",
                            source_file=project_file,
                            line=node.line, col=node.col,
                        ))
                    }
                    if not node.damaged {
                        throw new RuntimeError("Invalid analysis "
                            "directly on internal list node.")
                    }
                    return later none
                }
            } elseif node.ref != none and
                    node.ref.kind == st_ref.ST_MCREF {
                var builtin_item = builtin_syms.get_item_by_storage_ref(
                    project_file.project, node.ref
                )
                if debug {
                    print(dbg_prefix + " Obtained built-in symbol item "
                        "for this node.ref: builtin_item=" +
                        builtin_item.as_str())
                }
                if builtin_item == none or
                        builtin_item.func_signature_expr == none {
                    return later none
                }
                var func_result = new typeinfo.TypeInfo(
                    typeinfo.TI_FUNCREF
                )
                func_result.orig_type_name = builtin_item.symbol_name
                if builtin_item.is_csymbol {
                    func_result.user_type_ref =
                        new st_ref.StorageRef(st_ref.ST_MCREF,
                            builtin_item.storage_id)
                } else {
                    func_result.user_type_ref =
                        builtin_item.symbol_storage_ref.copy()
                }
                func_result.func_typeexpr =
                    builtin_item.func_signature_expr.copy()
                func_result._orig_typeexpr =
                    func_result.func_typeexpr
                return func_result
            }

            if debug {
                print(dbg_prefix + " Failed "
                    "to find symbol info for: " + [
                        node, node.ref
                    ].as_str())
            }
            trigger_no_symbol_info_on(node)
            return later none
        }
        if debug {
            print(dbg_prefix + " Got "
                "symbol info: " + sym_info.as_str())
        }
        var result = get_c_or_m64_type_of_sym_info(
            project_file, sym_info, node_with_reference=node,
            node_with_reference_parents=parents,
            msgs=msgs, debug=debug
        ) later:

        await result

        if result != none and
                return_type_with_ref_modifier {
            result.add_ref_modifier()
        } elseif result != none and
                return_type_with_implicit_ref_modifier {
            result.add_implicit_ref_modifier()
        }
        if result != none and
                not _known_typeinfo_map.has(node) {
            _known_typeinfo_map[node] = result.copy()
            _known_typeinfo_map[node].func_self_ref = none
        }
        if debug {
            print(dbg_prefix + " Got N_EXPR_IDREF result=" +
                result.as_str())
        }
        return later result
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.optoken.str == "(" {
        if m64_builtins.is_ast_node_referring_to_m64_memory_as_ref(
                project_file, node.subexprs[1], is_moose64=yes) {
            if debug {
                print(dbg_prefix + " Got call binop on " +
                    "built-in 'as_ref'.")
            }
            if debug {
                print(dbg_prefix + " Get typeinfo on what as_ref() "
                    "was called on...")
            }
            assert(node.subexprs[2].kind == ast.N_EXPR_CALLARGS)
            if node.subexprs[2].subexprs.len != 1 {
                if msgs == none {
                    print(if is_moose64 ("horsec")
                        else ("moosec") + ": "
                            "error: Internal error, "
                            "as_ref call with not exactly 1 arg "
                            "found: " + node.as_str())
                    throw new RuntimeError(
                        "Call has wrong number of "
                        "arguments.")
                }
                if not node.damaged and
                        not node.subexprs[2].damaged {
                    var called_args =
                        node.subexprs[2].subexprs.len
                    var called_s = "s"
                    msgs.add(new msg.FileMsg(
                        "Unexpected number of args, " +
                        "'as_ref' expects 1 arg " +
                        "but this call provides " +
                        called_args.as_str() + " "
                        "arg" + called_s + ".",
                        kind=msg.M_ERROR, source_file=project_file,
                        line=node.subexprs[1].line,
                        col=node.subexprs[1].col,
                    ))
                }
                node.damaged = yes
                node.subexprs[1].damaged = yes
                node.subexprs[2].damaged = yes
                return none
            }
            var inner_result = _get_c_or_m64_type_of_node_do(
                project_file, node.subexprs[2].subexprs[1],
                parents + [node, node.subexprs[2]],
                _known_typeinfo_map=_known_typeinfo_map,
                store_self_value_ref_for_funcs=
                    store_self_value_ref_for_funcs,
                msgs=msgs, debug=debug
            ) later:

            await inner_result
            if debug {
                print(dbg_prefix + " Got as_ref() arg typeinfo=" +
                    inner_result.as_str())
            }
            if inner_result == none {
                if node.subexprs[2].damaged or
                        node.subexprs[2].subexprs[1].damaged {
                    node.damaged = yes
                }
                return later none
            }

            var stripped_implicit_ref = no
            if inner_result.modifiers.len > 0 and
                    inner_result.modifiers[
                        inner_result.modifiers.len
                    ].name == "implicit ref" {
                stripped_implicit_ref = yes
                inner_result.modifiers =
                    inner_result.modifiers.sub(
                        1,
                        inner_result.modifiers.len - 1
                    )
            }
            inner_result.modifiers.add(
                new ast_typeref.TypeRefMod("ref")
            )
                
            if inner_result.kind == typeinfo.TI_USERTYPE and
                    inner_result._orig_typeexpr != none {
                if stripped_implicit_ref {
                    assert(inner_result._orig_typeexpr.
                        modifiers.len > 0)
                    assert(inner_result._orig_typeexpr.
                        modifiers[inner_result._orig_typeexpr.
                            modifiers.len].name == "implicit ref")
                    inner_result._orig_typeexpr.modifiers =
                    inner_result._orig_typeexpr.modifiers.sub(
                        1,
                        inner_result.modifiers.len - 1
                    )
                }
                inner_result._orig_typeexpr.modifiers.add(
                    new ast_typeref.TypeRefMod("ref")
                )
            }
            if debug {
                print(dbg_prefix + " Returning final ref type "
                    "typeinfo=" + inner_result.as_str())
            }
            return later inner_result
        } elseif m64_builtins.
                is_ast_node_referring_to_m64_memory_deref(
                    project_file, node.subexprs[1],
                    is_moose64=yes) {
            if debug {
                print(dbg_prefix + " Got call binop on " +
                "built-in 'deref'.")
            }
            if debug {
                print(dbg_prefix + " Get typeinfo on what deref() "
                "was called on...")
            }
            assert(node.subexprs[2].kind == ast.N_EXPR_CALLARGS)
            if node.subexprs[2].subexprs.len != 1 {
                if msgs == none {
                    print(if is_moose64 ("horsec")
                        else ("moosec") + ": "
                            "error: Internal error, "
                            "deref call with not exactly 1 arg "
                            "found: " + node.as_str())
                    throw new RuntimeError(
                        "Call has wrong number of "
                        "arguments.")
                }
                if not node.damaged and
                        not node.subexprs[2].damaged {
                    var called_args =
                    node.subexprs[2].subexprs.len
                    var called_s = "s"
                    msgs.add(new msg.FileMsg(
                        "Unexpected number of args, " +
                        "'deref' expects 1 arg " +
                        "but this call provides " +
                        called_args.as_str() + " "
                        "arg" + called_s + ".",
                        kind=msg.M_ERROR, source_file=project_file,
                        line=node.subexprs[1].line,
                        col=node.subexprs[1].col,
                    ))
                }
                node.damaged = yes
                node.subexprs[1].damaged = yes
                node.subexprs[2].damaged = yes
                return later none
            }
            var inner_result = _get_c_or_m64_type_of_node_do(
                project_file, node.subexprs[2].subexprs[1],
                parents + [node, node.subexprs[2]],
                _known_typeinfo_map=_known_typeinfo_map,
                store_self_value_ref_for_funcs=
                store_self_value_ref_for_funcs,
                msgs=msgs, debug=debug
            ) later:

            await inner_result
            if debug {
                print(dbg_prefix + " Got size_of() arg typeinfo=" +
                inner_result.as_str())
            }
            if inner_result == none {
                if node.subexprs[2].damaged or
                        node.subexprs[2].subexprs[1].damaged {
                    node.damaged = yes
                }
                return later none
            }
            var type_result = inner_result.copy()
            var old_deref_counter = 0
            var new_modifiers = []
            for mod in type_result.modifiers {
                if {"c_array", "ref"}.has(mod.name) {
                    old_deref_counter += 1
                    if old_deref_counter > 1 {
                        new_modifiers.add(mod)
                    }
                }
            }
            if old_deref_counter <= 0 {
                if msgs == none {
                    print(if is_moose64 ("horsec")
                        else ("moosec") + ": "
                            "error: Internal error, "
                            "deref called on item that isn't "
                            "a ref.")
                    throw new RuntimeError(
                        "Call has wrong number of "
                        "arguments.")
                }
                if not node.damaged and
                        not node.subexprs[2].damaged {
                    var called_args =
                    node.subexprs[2].subexprs.len
                    var called_s = "s"
                    msgs.add(new msg.FileMsg(
                        "Unexpected use of 'deref' "
                        "since type " +
                        inner_result.describe_to_user(
                            project=project_file.project,
                            add_quotes_where_useful=yes,
                            is_moose64=is_moose64
                        ) + " isn't a reference.",
                        kind=msg.M_ERROR,
                        source_file=project_file,
                        line=node.subexprs[1].line,
                        col=node.subexprs[1].col,
                    ))
                }
                node.damaged = yes
                node.subexprs[1].damaged = yes
                node.subexprs[2].damaged = yes
                return later none
            }
            type_result.modifiers = new_modifiers
            if type_result.kind == typeinfo.TI_USERTYPE and
                    type_result._orig_typeexpr != none {
                type_result._orig_typeexpr.modifiers = []
                for mod in new_modifiers {
                    type_result._orig_typeexpr.
                        modifiers.add(mod.copy())
                }
            }
            return later type_result
        } elseif m64_builtins.
                is_ast_node_referring_to_m64_memory_size_of(
                    project_file, node.subexprs[1],
                    is_moose64=yes) {
            if debug {
                print(dbg_prefix + " Got call binop on " +
                    "built-in 'size_of'.")
            }
            if debug {
                print(dbg_prefix + " Get typeinfo on what size_of() "
                    "was called on...")
            }
            assert(node.subexprs[2].kind == ast.N_EXPR_CALLARGS)
            if node.subexprs[2].subexprs.len != 1 {
                if msgs == none {
                    print(if is_moose64 ("horsec")
                        else ("moosec") + ": "
                            "error: Internal error, "
                            "as_ref call with not exactly 1 arg "
                            "found: " + node.as_str())
                    throw new RuntimeError(
                        "Call has wrong number of "
                        "arguments.")
                }
                if not node.damaged and
                        not node.subexprs[2].damaged {
                    var called_args =
                        node.subexprs[2].subexprs.len
                    var called_s = "s"
                    msgs.add(new msg.FileMsg(
                        "Unexpected number of args, " +
                        "'size_of' expects 1 arg " +
                        "but this call provides " +
                        called_args.as_str() + " "
                        "arg" + called_s + ".",
                        kind=msg.M_ERROR, source_file=project_file,
                        line=node.subexprs[1].line,
                        col=node.subexprs[1].col,
                    ))
                }
                node.damaged = yes
                node.subexprs[1].damaged = yes
                node.subexprs[2].damaged = yes
                return none
            }
            var inner_result = _get_c_or_m64_type_of_node_do(
                project_file, node.subexprs[2].subexprs[1],
                parents + [node, node.subexprs[2]],
                _known_typeinfo_map=_known_typeinfo_map,
                store_self_value_ref_for_funcs=
                store_self_value_ref_for_funcs,
                msgs=msgs, debug=debug
            ) later:

            await inner_result
            if debug {
                print(dbg_prefix + " Got size_of() arg typeinfo=" +
                    inner_result.as_str())
            }
            if inner_result == none {
                if node.subexprs[2].damaged or
                        node.subexprs[2].subexprs[1].damaged {
                    node.damaged = yes
                }
                return later none
            }
            var size_result = new typeinfo.TypeInfo(
                typeinfo.TI_C_TYPE
            )
            size_result.orig_type_name = "size"
            size_result.c_type_name =
                ast_typeref.get_c_builtin_for_m64_base_type("size")
            if debug {
                print(dbg_prefix + " Returning final ref type "
                    "typeinfo=" + size_result.as_str())
            }
            var try_get_size =
                typeinfo.get_known_type_size(
                    inner_result
                )
            if try_get_size != none {
                size_result.known_literal_value_token =
                    new token.Token(
                        try_get_size.as_str(), token.T_NUM,
                        node.subexprs[2].subexprs[1].line,
                        node.subexprs[2].subexprs[1].col
                    )
            }
            return later size_result
        } elseif node.subexprs.len >= 2 and
                node.subexprs[1].kind == ast.N_EXPR_IDREF and
                node.subexprs[1].ref != none and
                node.subexprs[1].ref.kind == st_ref.ST_MCREF and
                (m64_builtins.
                    is_ast_node_referring_to_m64_list_arg_forward(
                    project_file, node.subexprs[1],
                    is_moose64=is_moose64) or
                    m64_builtins.
                    is_ast_node_referring_to_m64_list_arg_get(
                    project_file, node.subexprs[1],
                    is_moose64=is_moose64)) {
            if debug {
                print(dbg_prefix + " Got call binop on "
                    "list_arg.forward() or list_arg.get()...")
            }
            var list_arg_info = get_list_arg_node_info(
                project_file, node.subexprs[1],
                [node] + parents,
                is_moose64=is_moose64, msgs=msgs,
            )
            if list_arg_info.arg_type_expr == none {
                assert(node.subexprs[1].damaged)
                node.damaged = yes
                return later none
            }
            
            if list_arg_info.is_forward {
                var type_result =
                    new typeinfo.create_typeinfo_from_typeexpr(
                        list_arg_info.arg_type_expr,
                        is_moose64=is_moose64,
                    )
                return later type_result
            } elseif list_arg_info.is_get {
                assert(list_arg_info.arg_type_expr.is_list_arg)
                var type_result =
                    new typeinfo.create_typeinfo_from_typeexpr(
                        list_arg_info.arg_type_expr.arg_type,
                        is_moose64=is_moose64,
                    )
                return later type_result
            }
        }
        if debug {
            print(dbg_prefix + " Got generic call binop, calling "
                "get_called_or_assigned_func_types()...")
        }
        var called_node = node.subexprs[1]
        var called_node_parents =
            parents + [node]

        var result = ast_analyze.get_called_or_assigned_func_types(
            project_file, called_node, called_node_parents,
            allow_matching_func_override=yes,
            allow_noncall_ref=no,
            ignore_arg_mismatch=no,
            msgs=msgs, is_moose64=is_moose64,
        ) later:

        await result
        if result == none and called_node.damaged {
            return none
        }
        var func_type_expr =
            if result != none (result.func_var_type_expr) else (none)
        func obtain_func_type_expr_if_needed {
            if func_type_expr != none {
                return later yes
            }
            if called_node.ref != none and
                    called_node.ref.kind == st_ref.ST_MCREF {
                if debug {
                    print(dbg_prefix + " No result from "
                        "get_called_or_assigned_func_types(), "
                        "but left-hand seems an MCREF which "
                        "we'll now try to resolve directly.")
                }
                var func_typeinfo = _get_c_or_m64_type_of_node_do(
                    project_file, called_node,
                    called_node_parents,
                    _known_typeinfo_map=_known_typeinfo_map,
                    store_self_value_ref_for_funcs=
                        store_self_value_ref_for_funcs,
                    msgs=msgs, debug=debug
                ) later:

                await func_typeinfo
                if debug {
                    print(dbg_prefix + " Got "
                        "called_node=" + called_node.as_str() + " "
                        "func_typeinfo=" + func_typeinfo.as_str())
                }
                if func_typeinfo == none {
                    if debug {
                        print(dbg_prefix + " Bail returning none.")
                    }
                    return later no
                }
                func_type_expr =
                    func_typeinfo.convert_to_typeref_expr(
                        project=project_file.project,
                        is_moose64=is_moose64,
                    )
                assert(func_type_expr != none)
                return later yes
            } else {
                if debug {
                    print(dbg_prefix + " No result from "
                        "get_called_or_assigned_func_types(), "
                        "seems like this node can't be resolved: "
                        "called_node=" + called_node.as_str()
                    )
                }
                return later no
            }
        }
        var was_successful = obtain_func_type_expr_if_needed()
        later:

        await was_successful
        if not was_successful {
            return later none
        }
        assert(func_type_expr != none)

        if debug {
            print(dbg_prefix + " Obtained func_type_expr=" +
                func_type_expr.as_str())
        }
        if not func_type_expr.is_func_ref {
            if msgs == none {
                throw new ValueError(
                    "Found an invalid call on a "
                    "non-func value.")
            }
            if not node.damaged {
                msgs.add(new msg.FileMsg(
                    "This value isn't a func "
                    "and cannot be called.",
                    kind=msg.M_ERROR,
                    source_file=project_file,
                    line=node.subexprs[1].line,
                    col=node.subexprs[1].col,
                ))
            }
            node.damaged = yes
            return later none
        }
        assert(func_type_expr.is_func_ref)
        if func_type_expr.return_typeref_expr == none or
                (not func_type_expr.
                return_typeref_expr.is_user_type and
                func_type_expr.
                return_typeref_expr.name == "empty") {
            var tinfo = new typeinfo.TypeInfo(typeinfo.TI_C_TYPE)
            tinfo.c_type_name = "void"
            tinfo._orig_typeexpr = new ast_typeref.TypeRefExpr()
            tinfo._orig_typeexpr.name = "empty"
            return tinfo
        }

        var tinfo = typeinfo.
            create_typeinfo_from_typeexpr_and_verify(
                func_type_expr.return_typeref_expr,
                project_file=project_file, 
                store_self_value_ref_for_funcs=no,
                is_moose64=is_moose64,
            ) later:

        await tinfo
        return tinfo
    } elseif {ast.N_STMT_FUNC,
              ast.N_STMT_FUNCEXTEND}.has(node.kind) {
        if debug {
            print(dbg_prefix + " Got a func node " +
                "(func scope set: " +
                if node.func_scope != none ("yes")
                    else ("no") + ")")
        }
        var fscope = node.func_scope
        if fscope == none {
            return later none
        }
        if node.type_path == none or node.type_path.len == 0 {
            var global_ref = new st_ref.StorageRef(
                st_ref.ST_GLOBAL, fscope.storage_id)
            if debug {
                print(dbg_prefix + " The func node " +
                    "is a standalone, getting type from "
                    "storage: global_ref=" +
                    global_ref.as_str())
            }
            var tinfo = typeinfo.
                create_typeinfo_from_global_ref(
                    global_ref, base_node_if_known=node,
                    project=project_file.project,
                    is_moose64=is_moose64, debug=debug,
                )
            assert(tinfo == none or tinfo.kind == typeinfo.TI_FUNCREF)
            if debug {
                print(dbg_prefix + " Type result: "
                    "tinfo=" + tinfo.as_str())
            }
            return later tinfo
        }
        if debug {
            print(dbg_prefix + " The func node " +
                "is a func attr. Obtaining anscope...")
        }
        var anscope = project_file.
            make_attr_names_scope_from_funcattr(
                node, msgs=msgs, is_moose64=is_moose64,
                def_project_file=project_file
            )
        if debug {
            print(dbg_prefix + " Got anscope=" +
                anscope.as_str())
        }
        if anscope == none {
            return later none
        }
        var symbol_info = anscope.name_to_symbol_map[
            node.label]
        if debug {
            print(dbg_prefix + " Got symbol_info=" +
                symbol_info.as_str())
        }
        var global_ref = new st_ref.StorageRef(
            st_ref.ST_GLOBALATTR, [anscope.storage_id,
            symbol_info.storage_id])
        if debug {
            print(dbg_prefix + " Getting type from "
                "storage: global_ref=" +
                global_ref.as_str())
        }
        var tinfo = typeinfo.
            create_typeinfo_from_global_ref(
                global_ref, base_node_if_known=node,
                base_symbol_info_if_known=symbol_info,
                project=project_file.project,
                is_moose64=is_moose64
            )
        assert(tinfo == none or tinfo.kind == typeinfo.TI_FUNCREF)
        if debug {
            print(dbg_prefix + " Type result: "
                "tinfo=" + tinfo.as_str())
        }
        return later tinfo
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.optoken.str == "." {
        var rhand = node.subexprs[2]
        var lhand = node.subexprs[1]
        var lhand_typeinfo = none
        assert(rhand.kind == ast.N_EXPR_IDREF)
        if debug {
            print(dbg_prefix + " Now evaluating binop with "
                "rhand=" + rhand.as_str())
        }

        func resolve_rhand_via_lhand_if_needed {
            if rhand.ref != none and
                    rhand.value_typeref_expr != none {
                if debug {
                    t = (dbg_prefix + " (The rhand.ref "
                        "value and rhand.value_typeref_expr "
                        "were already set before "
                        "we got to evaluate anything, with "
                        "rhand.value_typeref_expr=" +
                            rhand.value_typeref_expr.as_str() + " "
                        "rhand.ref=" + rhand.ref.as_str())
                    if rhand.value_typeref_expr.is_user_type() and
                            not rhand.value_typeref_expr.
                                is_func_ref and
                            not rhand.value_typeref_expr.
                                is_multi_type and
                            not rhand.value_typeref_expr.
                                is_list_arg {
                        t += (" rhand.value_typeref_expr."
                            "storage_ref=" +
                            rhand.value_typeref_expr.
                            storage_ref.as_str())
                    }
                    t += ".)"
                    print(t)
                }
                return later rhand.ref
            }
            if not has_attr(lhand, "ref") and
                    (lhand.kind != ast.N_EXPR_BINOP or
                    lhand.optoken.str != "." or
                    lhand.subexprs.len != 2 or
                    lhand.subexprs[2].kind != ast.N_EXPR_IDREF) {
                return later none
            }
            lhand_typeinfo = _get_c_or_m64_type_of_node_do(
                project_file, lhand, parents + [node],
                _known_typeinfo_map=_known_typeinfo_map,
                disable_binop_parent_fallback=yes,
                store_self_value_ref_for_funcs=no,
                msgs=msgs,
            ) later:

            await lhand_typeinfo
            if debug {
                print(dbg_prefix + " Calling "
                    "try_ensure_attr_ref on "
                    "lhand=" + lhand.as_str() + " now. "
                    "lhand_typeinfo=" + 
                        lhand_typeinfo.as_str() + " "
                    "rhand=" + rhand.as_str())
            }
            scope_manage.try_ensure_attr_ref(
                project_file, lhand, rhand,
                parents + [node],
                error_on_invalid=yes, is_moose64=is_moose64,
                msgs=msgs, debug=debug,
            ) later:
        }
        resolve_rhand_via_lhand_if_needed()
        later:

        if debug {
            print(dbg_prefix + " Got rhand.ref=" + rhand.ref.as_str())
        }
        if (node.subexprs[1].kind == ast.N_EXPR_IDREF and
                node.subexprs[1].ref != none) or
                (node.subexprs[1].kind == ast.N_EXPR_BINOP and
                node.subexprs[1].optoken.str == "." and
                node.subexprs[1].subexprs.len >= 2 and
                node.subexprs[1].subexprs[2].
                    kind == ast.N_EXPR_IDREF and
                node.subexprs[1].subexprs[2].ref != none) {
            var lhand_idref = node.subexprs[1]
            if lhand_idref.kind == ast.N_EXPR_BINOP {
                lhand_idref = lhand_idref.subexprs[2]
            }
            if lhand_idref.ref.kind == st_ref.ST_GLOBAL {
                var item = st_scope.global_id_to_item(
                    project_file.project, lhand_idref.ref.id)
                if item != none and
                        typename(item) != "list" and
                        {ast.N_STMT_TYPE, ast.N_STMT_STRUCT}.has(
                        item.kind) {
                    var rhand_desc = "specified here"
                    var rhand_name_check = rhand
                    if rhand_name_check.kind == ast.N_EXPR_BINOP and
                            rhand_name_check.subexprs.len >= 2 and
                            rhand_name_check.optoken.str == "." {
                        rhand_name_check = rhand_name_check.subexprs[1]
                    }
                    if rhand_name_check.kind == ast.N_EXPR_IDREF {
                        rhand_desc = "'" + rhand_name_check.label + "'"
                        if rhand_name_check.type_path != none and
                                rhand_name_check.type_path.len > 0 {
                            rhand_desc = "'" +
                                rhand_name_check.type_path[1] + "'"
                        }
                    }
                    if not node.damaged {
                        msgs.add(new msg.FileMsg(
                            "The attribute " +
                            rhand_desc + " "
                            "cannot be found on this item.",
                            kind=msg.M_ERROR,
                            source_file=project_file,
                            line=node.subexprs[1].line,
                            col=node.subexprs[1].col,
                        ))
                    }
                    node.damaged = yes
                    return later none
                }
            }
        }
        if rhand.ref == none {
            if rhand.kind == ast.N_EXPR_IDREF and
                    has_attr(rhand, "value_typeref_expr") and
                    rhand.value_typeref_expr != none and
                    rhand.value_typeref_expr.
                        is_special_madeup_builtin {
                # This is a built-in like .len on an array.
                # We can't get a symbol info for this.
                if debug {
                    print(dbg_prefix + " The right hand is a special "
                        "made up built-in, "
                        "rhand.value_typeref_expr=" +
                            rhand.value_typeref_expr.as_str())
                }
                var tinfo = new typeinfo.TypeInfo(
                    typeinfo.TI_M64BUILTIN_TYPE
                )
                tinfo._orig_typeexpr = rhand.value_typeref_expr.copy()
                if rhand.value_typeref_expr.is_func_ref {
                    tinfo.func_typeexpr = tinfo._orig_typeexpr
                } else {
                    assert(not rhand.value_typeref_expr.is_user_type())
                    tinfo.kind = typeinfo.TI_C_TYPE
                    tinfo.orig_type_name =
                        rhand.value_typeref_expr.name
                    assert(tinfo.orig_type_name != none)
                    tinfo.c_type_name =
                        ast_typeref.get_c_builtin_for_m64_base_type(
                            rhand.value_typeref_expr.name
                        )
                    tinfo.modifiers = []
                    for mod in rhand.value_typeref_expr.modifiers {
                        tinfo.modifiers.add(mod.copy())
                    }
                }
                if debug {
                    print(dbg_prefix + " The right hand builtin " +
                        "was resolved to: tinfo=" + tinfo.as_str())
                }
                return tinfo
            }
            var try_stored_typeref_retrieval =
                get_type_from_stored_typeref_expr_if_any()
            if try_stored_typeref_retrieval != none {
                return later try_stored_typeref_retrieval
            }
            trigger_no_symbol_info_on(node)
            return later none
        }
        var sym_info = st_ref.ref_to_symbol_info(
            rhand.ref, node=rhand,
            project=project_file.project,
            is_moose64=is_moose64,
        )
        if debug {
            print(dbg_prefix + " Got sym_info=" + sym_info.as_str())
        }
        if sym_info == none {
            trigger_no_symbol_info_on(node)
            return later none
        }
        var is_autoprop_func = no
        var func_texpr = none
        var fallback_value_texpr = none
        if sym_info.kind == st_scope.SINFO_FUNCATTR {
            func_texpr = sym_info.typeref_expr
            assert(func_texpr != none)
            is_autoprop_func = func_texpr.is_autoprop_func
        } else {
            if sym_info.typeref_expr != none {
                fallback_value_texpr = sym_info.typeref_expr
            }
        }
        if is_autoprop_func {
            var return_texpr = none
            assert(func_texpr.is_func_ref)
            if func_texpr.return_typeref_expr != none and
                    (func_texpr.is_user_type() or
                    return_typeref_expr.name != "empty") {
                return_texpr = func_texpr.
                    return_typeref_expr.copy()
            }
            if return_texpr == none {
                if node.damaged {
                    return
                }
                if msgs == none {
                    throw new ValueError(
                        "This property has no return type."
                    )
                }
                node.damaged = yes
                msgs.add(new msg.FileMsg(
                    "Unexpected use of call expression "
                    "with no return type.",
                    source_file=project_file,
                    line=node.line, col=node.col,
                ))
                return later none
            }
            return_texpr.is_autoprop_func_result = yes
            var self_syminfo = none
            var self_texpr = none
            var self_st_ref = none
            if lhand_idref != none and
                    lhand_idref.ref != none {
                self_st_ref = lhand_idref.ref
                self_syminfo = st_ref.ref_to_symbol_info(
                    lhand_idref.ref
                )
                if self_syminfo != none and
                        self_syminfo.typeref_expr != none {
                    self_texpr = self_syminfo.
                        typeref_expr
                }
            }
            if self_texpr != none {
                return_texpr.autoprop_func_base_expr =
                    self_texpr.copy()
            }
            var return_typeinfo =
                typeinfo.create_typeinfo_from_typeexpr(
                    return_texpr,
                    is_moose64=is_moose64,
                )
            return_typeinfo.autoprop_func_typeexpr =
                func_texpr.copy()
            return_typeinfo.autoprop_self_ref =
                self_st_ref.copy()
            return later return_typeinfo
        }
        var result_tinfo = none
        func compute_result_tinfo {
            if rhand.value_typeref_expr == none and
                    fallback_value_texpr == none {
                return later
            }
            var evaluate_expr = rhand.value_typeref_expr
            if evaluate_expr == none {
                assert(fallback_value_texpr != none)
                evaluate_expr = fallback_value_texpr
            }
            result_tinfo =
                typeinfo.create_typeinfo_from_typeexpr_and_verify(
                    evaluate_expr,
                    base_node_if_known=rhand,
                    base_node_parents_if_known=parents + [node],
                    project_file=project_file,
                    is_moose64=is_moose64,
                ) later:

            await result_tinfo
            if debug {
                print(dbg_prefix + " "
                    "Taking rhand.value_typeref_expr to "
                    "compute end result: " +
                    result_tinfo.as_str())
            }
        }
        compute_result_tinfo() later:

        func get_result_tinfo_from_symbol_if_needed {
            if result_tinfo != none {
                return later
            }
            result_tinfo = get_c_or_m64_type_of_sym_info(
                project_file, sym_info, node_with_reference=rhand,
                node_with_reference_parents=parents + [node],
                msgs=msgs, debug=debug
            ) later:

            await result_tinfo
        }
        get_result_tinfo_from_symbol_if_needed() later:

        if result_tinfo != none and
                not _known_typeinfo_map.has(node) {
            _known_typeinfo_map[node] = result_tinfo.copy()
            _known_typeinfo_map[node].func_self_ref = none
        }
        if store_self_value_ref_for_funcs and
                left_hand_instance_ref != none {
            if debug {
                print(dbg_prefix + " "
                    "Setting result_tinfo.func_self_ref=" +
                    left_hand_instance_ref.as_str())
            }
            result_tinfo.func_self_ref = left_hand_instance_ref
        } else {
            if debug {
                print(dbg_prefix + " "
                    "Unsetting result_tinfo.func_self_ref.")
            }
        }
        if debug {
            print(dbg_prefix + " Got N_EXPR_BINOP '.' "
                "result_tinfo=" +
                result_tinfo.as_str())
        }
        return later result_tinfo
    }
    return later none
}

### Get the C or m64 type that is assoiated with the given
### AST node in the form of a @{compiler.typeinfo.TypeInfo} object.
### @returns (compiler.typeinfo.TypeInfo, none) The type info for
###     the node, or `none` if it can't be determined.
func get_c_or_m64_type_of_node(
        project_file, node, parents,
        store_self_value_ref_for_funcs=no,
        msgs=none, debug=no
        ) {
    assert(typename(parents) == "list")
    var result = _get_c_or_m64_type_of_node_do(
        project_file, node, parents,
        _known_typeinfo_map=none,
        store_self_value_ref_for_funcs=
            store_self_value_ref_for_funcs,
        msgs=msgs,
        debug=debug
    ) later:

    await result
    return result
}

