## @module compiler.moose64.ast.analyze
# Copyright (c) 2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import random from core.horse64.org

import compiler.ast as ast
import compiler.msg as msg
import compiler.storage.ref as st_ref
import compiler.storage.scope.manage as scope_manage
import compiler.token as token
import compiler.typeinfo as typeinfo

func get_c_or_m64_type_of_typeref(
        project_file, typeref,
        store_self_expr_for_funcs=no, msgs=none
        ) {
    var c_name = typeref.get_c_builtin_for_m64_base_type()
    if c_name != none {
        var tinfo = new typeinfo.TypeInfo(typeinfo.TI_C_TYPE)
        tinfo._set_orig_type_expr(typeref)
        tinfo.c_type_name = c_name
        return later tinfo
    }
    var m64_type_ref = typeref.try_resolve_to_user_type(
        project_file, is_moose64=yes
    ) later:

    await m64_type_ref
    if m64_type_ref == none {
        return later none
    }
    var tinfo = new typeinfo.create_typeinfo_from_global_ref(
        m64_type_ref.type_storage_ref,
        base_typeref_expr_if_known=m64_type_ref,
        store_self_expr_for_funcs=store_self_expr_for_funcs,
    )
    return later tinfo
}

func get_c_or_m64_type_of_sym_info(
        project_file, node_with_reference,
        target_sym_info, msgs=none
        ) {
    if target_sym_info.type_storage_ref != none {
        var tinfo = new typeinfo.create_typeinfo_from_global_ref(
            target_sym_info.type_storage_ref,
            base_symbol_info_if_known=target_sym_info,
            base_node_if_known=node_with_reference,
        )
        return later tinfo
    }
    var typeref_expr = target_sym_info.typeref_expr
    if typeref_expr == none {
        return later none
    }
    var result = get_c_or_m64_type_of_typeref(
        project_file, typeref_expr,
        msgs=msgs
    ) later:

    await result
    return result
}

func _get_c_or_m64_type_of_node_do(
        project_file, node, parent,
        _known_types_map=none,
        msgs=none, debug=no
        ) {
    if _known_types_map == none {
        _known_types_map = {->}
    }
    if _known_types_map.has(node) {
        return later _known_types_map[node]
    }

    var d_id = none
    if debug {
        d_id = random.gen_id()
        print("compiler.moose64.ast.anayze: debug: "
            "_get_c_or_m64_type_of_node_do() #" +
            d_id + " on: " +
            node.as_str())
    }
    func trigger_no_symbol_info_on(node) {
        if msgs == none {
            throw new ValueError(
                "Internal error: Unexpectedly failed to "
                "get symbol info."
            )
        }
        msgs.add(new msg.FileMsg(
            "Internal error: Unexpectedly failed to trace "
            "back this identifier to resolved target: " +
            node.as_str() + " "
            "Please report this to the compiler makers.",
            source_file=project_file,
            line=node.line, col=node.col,
        ))
    }

    func trigger_no_such_attribute_on(node, aname) {
        if msgs == none {
            throw new ValueError(
                "The given type doesn't have this attribute."
            )
        }
        msgs.add(new msg.FileMsg(
            "The attribute " + textfmt.as_escaped_code_string(
                aname
            ) + " cannot be found on this type.",
            source_file=project_file,
            line=node.line, col=node.col,
        ))
    }

    func evaluate_lefthand_sides_if_needed(node) {
        if node.kind != ast.N_EXPR_BINOP or
                node.optoken.str != "." {
            return later yes
        }
        if (has_attr(node.subexprs[2], "ref") and
                node.subexprs[2].ref != none) or
                _known_types_map.has(node.subexprs[2]) {
            return later yes
        }
        var c_type = _get_c_or_m64_type_of_node_do(
            project_file, node.subexprs[1], node,
            _known_types_map=_known_types_map,
            msgs=msgs,
        ) later:

        await c_type
        if c_type == none and (
                has_attr(node.subexprs[1], "ref") and
                node.subexprs[1].ref == none) {
            return later no
        }
        return later yes
    }
    var result = evaluate_lefthand_sides_if_needed(node)
    later:

    await result
    if not result {
        # This means there isn't a useful way we can derive
        # any type from a left hand that's present.
        return later none
    }

    if node.kind == ast.N_STMT_VAR {
        if not node.has_type_expr {
            return later none
        }
        var result = get_c_or_m64_type_of_typeref(
            project_file, node.subexprs[node.subexprs.len],
            msgs=msgs
        ) later:

        await result
        return result
    } elseif node.kind == ast.N_EXPR_IDREF {
        if node.ref == none {
            return later none
        }

        var sym_info = st_ref.ref_to_symbol_info(
            project_file, node, node.ref
        )

        if sym_info == none {
            if debug {
                print("compiler.moose64.ast.anayze: debug: "
                    "_get_c_or_m64_type_of_node_do() #" +
                    d_id + " failed "
                    "to find symbol info")
            }
            trigger_no_symbol_info_on(node)
            return later none
        }
        if debug {
            print("compiler.moose64.ast.anayze: debug: "
                "_get_c_or_m64_type_of_node_do() #" +
                d_id + " got "
                "symbol info: " + sym_info.as_str())
        }
        var result = get_c_or_m64_type_of_sym_info(
            project_file, node, sym_info, msgs=msgs
        ) later:

        await result
        return result
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.optoken.str == "." {
        var rhand = node.subexprs[2]
        assert(rhand.kind == ast.N_EXPR_IDREF)

        if rhand.ref == none {
            var lhand = node.subexprs[1]
            if has_attr(lhand, "ref") {
                assert(lhand.ref != none)
                var sym_info
                do {
                    sym_info = scope_manage.try_resolve_attr_on_ref(
                        project_file, lhand, lhand.ref, rhand.label,
                        error_on_invalid=yes
                    )
                } rescue ValueError {
                    trigger_no_such_attribute_on(
                        lhand, rhand.label
                    )
                }
                if sym_info == none {
                    trigger_no_symbol_info_on(lhand)
                    return later none
                }
                var result = get_c_or_m64_type_of_sym_info(
                    project_file, lhand, sym_info,
                    msgs=msgs
                ) later:

                await result
                return result
            }
        }
        var sym_info = st_ref.ref_to_symbol_info(
            project_file, rhand, rhand.ref
        )
        if sym_info == none {
            trigger_no_symbol_info_on(node)
            return later none
        }
        var result = get_c_or_m64_type_of_sym_info(
            project_file, rhand, sym_info,
            msgs=msgs
        ) later:

        await result
        return result
    }
    return later none
}

func get_c_or_m64_type_of_node(
        project_file, node, parent, msgs=none, debug=no
        ) {
    var result = _get_c_or_m64_type_of_node_do(
        project_file, node, parent,
        _known_types_map=none, msgs=msgs,
        debug=debug
    ) later:

    await result
    return result
}

