## @module compiler.typeref
# Copyright (c) 2024, ellie/@ell1e & Horse64 authors (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import compiler.ast as ast
import compiler.ast.expr as ast_expr
import compiler.token as token

const builtin_horse64_types = {}
const builtin_horse64_type_modifiers = {}
const builtin_moose64_types = {
    "byte", "i8", "i16", "u16",
    "i32", "i64", "size", "u32", "u64",
    "f32", "f64", "bool",
    "any", "auto"
}
const builtin_moose64_type_modifiers = {
    "ref", "array", "readonly"
}

type TypeRefModProp {
}

type TypeRefModProp_Range base TypeRefModProp {
    var range_value_num
    var range_value_label
}

func TypeRefModProp_Range.as_str {
    var t = "["
    if self.range_value_num != none {
        t += self.range_value_num.as_str()
    } else {
        t += self.range_value_label.as_str()
    }
    t += "]"
    return t
}

type TypeRefMod {
    var name
    var props = []
}

func TypeRefMod.init(name) {
    self.name = name + ""
}

func TypeRefMod.as_str {
    var t = self.name + ""
    for prop in self.props {
        t += prop.as_str()
    }
    return t
}

type TypeRefFuncRefExpr base TypeRefExpr {
    var arg_typeref_exprs = []
    var return_typeref_expr
}

func TypeRefFuncRefExpr.init {
    base.init()
    self.is_func_ref = yes
    self.name = none
}

func typeref_func_expr_from_varattr(
        base_symbol_info, varattr_symbol_info
        ) {

}

type TypeRefExpr base ast.TreeNode {
    var type_path
    var name
    var modifiers = []
    var init_expr = none
    var is_func_ref = no
}

func TypeRefExpr.init {
    base.init()
    self.kind = ast.N_EXPR_TYPEREF
}

func TypeRefExpr.as_code(indent=0) {
    if self.damaged {
        return "(damaged type ref expr.)"
    }
    var prefix_mod_names = {"readonly"}
    var t = ""
    for mod in self.modifiers {
        if prefix_mod_names.has(mod.name) {
            if t != "" {
                t += " "
            }
            t += mod.as_str()
        }
    }
    if t != "" {
        t += " "
    }
    if self.type_path != none and self.type_path.len > 0 {
        t = self.type_path.join(".") + "." + t
    }
    t += self.name
    for mod in self.modifiers {
        if not prefix_mod_names.has(mod.name) {
            t += " " + mod.as_str()
        }
    }
    if self.init_expr != none {
        t += self.init_expr.as_code(indent=(indent + 4))
    }
    return t
}

func get_c_builtin_for_m64_base_type(name) {
    if not builtin_moose64_types.has(name) {
        return none
    }
    if name == "i32" {
        return "int32_t"
    } elseif name == "i64" {
        return "int64_t"
    } elseif name == "bool" {
        return "signed char"
    } elseif name == "byte" {
        return "unsigned char"
    } elseif name == "i16" {
        return "int16_t"
    } elseif name == "u16" {
        return "uint16_t"
    } elseif name == "u32" {
        return "uint32_t"
    } elseif name == "u64" or name == "size" {
        return "uint64_t"
    } elseif name == "any" {
        return "void"
    } else {
        print("horsec: error: Internal error, "
            "encountered unhandled C builtin type: " +
            name.as_str())
        throw new NotImplementedError(
            "Unhandled builtin type."
        )
    }
}

func TypeRefExpr.try_resolve_to_user_type(
        project_file, is_moose64=is_moose64
        ) {
    var type_path = self.type_path
    if type_path != none and type_path.len == 0 {
        type_path = none
    }
    var result = project_file.try_lookup_symbol_path(
        none, name=self.name, type_path=type_path,
        is_write_access=no, is_moose64=is_moose64
    )
    return result
}

func TypeRefExpr.get_c_builtin_for_m64_base_type {
    if self.type_path != none and
            self.type_path.len > 0 {
        return none
    }
    return get_c_builtin_for_m64_base_type(self.name)
}

func TypeRefExpr.as_str {
    var t = "TypeRefExpr<" + self.as_code() + ">"
    return t
}

func _parse_typeref_notlater(
        tokens, pos, msgs, extend_typeref_expr=none,
        project_file=none,
        max_len=none, max_depth=64,
        is_moose64=no, debug=no
        ) {
    var startpos = pos
    if max_len == none {
        max_len = tokens.len
    }
    if pos > max_len {
        return none
    }

    var typeref_expr = extend_typeref_expr
    var start_token_len = 0
    if typeref_expr != none {
        start_token_len = typeref_expr.token_len
    }
    var typeref_token_len = start_token_len
    var typeref_damaged = no
    var mods = []
    while yes {
        if tokens[pos].kind == token.T_ENCLOSE and
                tokens[pos].str == "(" {
            var bracket_open_pos = pos
            if max_depth <= 0 {
                msgs.add(new msg.FileMsg(
                    "Invalid " + token.describe_token_at(
                        tokens, pos) + " "
                    ", exceeds maximum nesting depth "
                    "for type expression starting "
                    "in line " +
                    token.get_line(tokens, startpos).as_str() +
                    ", column " +
                    token.get_col(tokens, startpos).as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                pos += 1
                var expr_len = start_token_len + (pos - startpos)
                return new ast_expr.InvalidExpr(expr_len)
            }
            pos += 1  # Go past '('.
            var inner_expr = _parse_typeref_notlater(
                tokens, pos, msgs,
                extend_typeref_expr=typeref_expr,
                project_file=project_file,
                max_len=max_len, max_depth=(max_depth - 1),
                is_moose64=is_moose64, debug=debug
            )
            if inner_expr == none {
                # Revert back to before bracket.
                pos = bracket_open_pos
                break
            }
            pos += inner_expr.token_len
            if pos > max_len or
                    tokens[pos].kind != token.T_ENCLOSE or
                    tokens[pos].str != ")" {
                msgs.add(new msg.FileMsg(
                    "Unexpected " + token.describe_token_at(
                        tokens, pos) + " "
                    ", expected '(' "
                    "for ')' found "
                    "in line " +
                    token.get_line(tokens,
                                bracket_open_pos).as_str() +
                    ", column " +
                    token.get_col(tokens,
                                bracket_open_pos).as_str() + ".",
                    source_file=project_file,
                    line=token.get_line(tokens, pos),
                    col=token.get_col(tokens, pos),
                ))
                var expr_len = start_token_len + (pos - startpos)
                return new ast_expr.InvalidExpr(expr_len)
            }
            typeref_expr = inner_expr
            pos += 1  # Go past ')'
            typeref_token_len = start_token_len + (pos - startpos)
        }

        if typeref_expr == none and pos <= max_len and
                (tokens[pos].kind == token.T_IDENT or
                tokens[pos].kind == token.T_KEYWORD) and
                ((is_moose64 and
                  builtin_moose64_types.has(tokens[pos].str)) or
                 (not is_moose64 and
                  builtin_horse64_types.has(tokens[pos].str))) {
            typeref_expr = new TypeRefExpr()
            typeref_expr.name = tokens[pos].str
            typeref_expr.line = token.get_line(tokens, pos)
            typeref_expr.col = token.get_col(tokens, pos)
            pos += 1
            typeref_token_len =
                start_token_len + (pos - startpos)
        }
        if typeref_expr == none and pos <= max_len and
                tokens[pos].kind == token.T_IDENT and
                ((is_moose64 and
                  not builtin_moose64_type_modifiers.has(
                      tokens[pos].str)) or
                 (not is_moose64 and
                  not builtin_horse64_type_modifiers.has(
                      tokens[pos].str))) {
            typeref_expr = new TypeRefExpr()
            typeref_expr.name = tokens[pos].str
            typeref_expr.line = token.get_line(tokens, pos)
            typeref_expr.col = token.get_col(tokens, pos)
            pos += 1
            typeref_token_len =
                start_token_len + (pos - startpos)
            while pos + 1 <= max_len and
                    tokens[pos].kind == token.T_DOT and
                    tokens[pos + 1].kind == token.T_IDENT {
                if typeref_expr.type_path == none {
                    typeref_expr.type_path = []
                }
                typeref_expr.type_path.add(typeref_expr.name)
                typeref_expr.name = tokens[pos + 1].str
                typeref_token_len += 2
                pos += 2
            }
        }
        var had_mods = no
        while pos <= max_len and
                (tokens[pos].kind == token.T_IDENT or
                tokens[pos].kind == token.T_KEYWORD) and
                ((is_moose64 and
                  builtin_moose64_type_modifiers.has(
                      tokens[pos].str
                  )) or
                 (not is_moose64 and
                  builtin_horse64_type_modifiers.has(
                      tokens[pos].str
                  ))) {
            had_mods = yes
            var modifier_name = tokens[pos].str
            var modifier = new TypeRefMod(modifier_name)
            mods.add(modifier)
            pos += 1
            typeref_token_len = start_token_len + (pos - startpos)
            if modifier_name == "array" and is_moose64 {
                while pos + 2 <= max_len and
                        tokens[pos].kind == token.T_ENCLOSE and
                        tokens[pos].str == '[' and
                        tokens[pos + 2].kind == token.T_ENCLOSE and
                        tokens[pos + 2].str == ']' {
                    if tokens[pos + 1].kind == token.T_IDENT {
                        var prop = new TypeRefModProp_Range()
                        prop.range_value_label =
                            tokens[pos + 1].str
                    } elseif tokens[pos + 1].kind == token.T_NUM {
                        var prop = new TypeRefModProp_Range()
                        prop.range_value_num =
                            tokens[pos + 1].str.to_num()
                    } else {
                        msgs.add(new msg.FileMsg(
                            "Unexpected '[' followed by " +
                                token.describe_token_at(
                                    tokens, pos) + " "
                            ", expected valid range expression "
                            "for array modifier.",
                            source_file=project_file,
                            line=token.get_line(tokens, pos),
                            col=token.get_col(tokens, pos),
                        ))
                        typeref_damaged = yes
                        return typeref_expr
                    }
                    pos += 3
                    typeref_token_len =
                        start_token_len + (pos - startpos)
                }
            }
        }
        if not had_mods {
            break
        }
    }
    if typeref_token_len <= start_token_len {
        return none
    }
    if typeref_expr != none {
        assert(typeref_token_len > 0)
        typeref_expr.damaged = typeref_damaged
        typeref_expr.modifiers = mods
        typeref_expr.token_len = typeref_token_len
    }
    return typeref_expr
}

func parse_typeref(
        tokens, pos, msgs, extend_typeref_expr=none,
        project_file=none, max_len=none, is_moose64=no,
        debug=no
        ) {
    if max_len == none {
        max_len = tokens.len
    }
    var expr = _parse_typeref_notlater(
        tokens, pos, msgs,
        extend_typeref_expr=extend_typeref_expr,
        project_file=project_file,
        max_len=max_len, is_moose64=is_moose64,
        debug=debug
    )
    return later expr
}

