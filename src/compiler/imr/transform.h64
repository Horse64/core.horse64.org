## @module compiler.imr.transform
# Copyright (c) 2025, ellie/@ell1e & Horse64's contributors
# (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import math from core.horse64.org
import textfmt from core.horse64.org

import compiler.imr
import compiler.msg as msg
import compiler.storage.ref as st_ref
import compiler.typeinfo.ast_typeref as ast_typeref

func replace_refs_in_func(
        func_imr_node,
        old_ref, new_ref,
        project_file=none,
        imr_build_tracker=none,
        is_moose64=no,
        msgs=none,
        debug=no,
        ) {
    if project_file == none {
        throw new ValueError("The project_file parameter "
            "has to be specified.")
    }
    if imr_build_tracker == none {
        throw new ValueError("The imr_build_tracker parameter "
            "has to be specified.")
    }

    var project = project_file.project
    assert(func_imr_node.kind == compiler.imr.IMR_BLOCK_FUNC)

    func replace_refs_in_list(l) {
        var nested_queue = []
        for item in l {
            if item.kind == compiler.imr.IMR_BLOCK_FUNC {
                # We don't want to descend into nested funcs,
                # in case we ever allow those.
                # FIXME: However, we might need to revisit this for
                # closures later. Perhaps we should un-nest those
                # before we even run into this code path...?
                continue
            }
            if has_attr(item, "instructions") {
                nested_queue.add(item.instructions)
            }
            # FIXME: This will break closure captures for
            # Horse64. Figure out later what we'll do about that.
            if item.kind == compiler.imr.IMR_INST_VARINFO {
                if old_ref.kind == st_ref.ST_LOCAL and
                        new_ref.kind == st_ref.ST_LOCAL and
                        item.storage_id == old_ref.id {
                    item.storage_id = new_ref.id
                }
            } elseif item.kind == compiler.imr.IMR_INST_GETLISTARGLEN {
                if item.multi_arg_storage_ref.alike(old_ref) {
                    item.multi_arg_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_SETLIT {
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_SETLITVIAREF {
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_SETATTRBYID {
                if item.target_and_obj_storage_ref.alike(old_ref) {
                    item.target_and_obj_storage_ref = new_ref.copy()
                }
                if item.value_storage_ref.alike(old_ref) {
                    item.value_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_SETATTRBYIDVIAREF {
                if item.target_and_obj_storage_ref.alike(old_ref) {
                    item.target_and_obj_storage_ref = new_ref.copy()
                }
                if item.value_storage_ref.alike(old_ref) {
                    item.value_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_SETATTRBYNAME {
                if item.target_and_obj_storage_ref.alike(old_ref) {
                    item.target_and_obj_storage_ref = new_ref.copy()
                }
                if item.value_storage_ref.alike(old_ref) {
                    item.value_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_GETATTRBYNAME {
                if item.obj_storage_ref.alike(old_ref) {
                    item.obj_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_GETATTRBYID {
                if item.obj_storage_ref.alike(old_ref) {
                    item.obj_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_SETIDX {
                if item.target_and_container_storage_ref.alike(old_ref) {
                    item.target_and_container_storage_ref = new_ref.copy()
                }
                if item.index_storage_ref.alike(old_ref) {
                    item.index_storage_ref = new_ref.copy()
                }
                if item.value_storage_ref.alike(old_ref) {
                    item.value_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_SETIDXVIAREF {
                if item.target_and_container_storage_ref.alike(old_ref) {
                    item.target_and_container_storage_ref = new_ref.copy()
                }
                if item.index_storage_ref.alike(old_ref) {
                    item.index_storage_ref = new_ref.copy()
                }
                if item.value_storage_ref.alike(old_ref) {
                    item.value_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_GETIDX {
                if item.container_storage_ref.alike(old_ref) {
                    item.container_storage_ref = new_ref.copy()
                }
                if item.index_storage_ref.alike(old_ref) {
                    item.index_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_CLRZERO {
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_CONV {
                if item.source_storage_ref.alike(old_ref) {
                    item.source_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_MOVE {
                if item.source_storage_ref.alike(old_ref) {
                    item.source_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_APPLY_OP {
                if item.operand_1_storage_ref.alike(old_ref) {
                    item.operand_1_storage_ref = new_ref.copy()
                }
                if item.is_binary and
                        item.operand_2_storage_ref.alike(old_ref) {
                    item.operand_2_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_CALL {
                if item.called_func_ref.alike(old_ref) {
                    item.called_func_ref = new_ref.copy()
                }
                if item.return_value_ref != none and
                        item.return_value_ref.alike(old_ref) {
                    item.return_value_ref = new_ref.copy()
                }
                for arg in item.args {
                    if arg.ref.alike(old_ref) {
                        arg.ref = new_ref.copy()
                    }
                }
            } elseif item.kind ==
                    compiler.imr.IMR_INST_CALLWLISTFORWARD {
                if item.called_func_ref.alike(old_ref) {
                    item.called_func_ref = new_ref.copy()
                }
                if item.return_value_ref != none and
                        item.return_value_ref.alike(old_ref) {
                    item.return_value_ref = new_ref.copy()
                }
                for arg in item.args {
                    if arg.ref.alike(old_ref) {
                        arg.ref = new_ref.copy()
                    }
                }
            } elseif item.kind == compiler.imr.IMR_BLOCK_ITERLOOP {
                if item.iterated_container_ref.alike(old_ref) {
                    item.iterated_container_ref = new_ref.copy()
                }
                if item.iterator_store_ref.alike(old_ref) {
                    item.iterator_store_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_ASREF {
                if item.asref_source_storage_ref.alike(old_ref) {
                    item.asref_source_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_DEREF {
                if item.deref_source_storage_ref.alike(old_ref) {
                    item.deref_source_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_RETURN {
                if item.return_value_storage_ref != none and
                        item.return_value_storage_ref.alike(old_ref) {
                    item.return_value_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_BLOCK_COND {
                if item.evaluated_cond_ref.alike(old_ref) {
                    item.evaluated_cond_ref = new_ref.copy()
                }
            }
        }
        if nested_queue.len == 0 {
            return later
        }
        var item = nested_queue.pop_at(1)
        var result = replace_refs_in_list(item)
        later:

        await result
        if nested_queue.len == 0 {
            return later
        }
        item = nested_queue.pop_at(1)
        result = replace_refs_in_list(item)
        later repeat
    }
    if old_ref.kind == st_ref.ST_LOCAL {
        var n = func_imr_node
        if n.storage_id_to_known_type_info.has(old_ref.id) {
            n.storage_id_to_known_type_info[new_ref.id] =
                n.storage_id_to_known_type_info[old_ref.id]
            n.storage_id_to_known_type_info.del(old_ref.id)
        }
        if n.storage_id_to_known_type_expr.has(old_ref.id) {
            n.storage_id_to_known_type_expr[new_ref.id] =
                n.storage_id_to_known_type_expr[old_ref.id]
            n.storage_id_to_known_type_expr.del(old_ref.id)
        }
    }
    replace_refs_in_list(func_imr_node.instructions)
    later:

    func_imr_node.update_var_type_exprs(
        project_file, is_moose64=is_moose64, msgs=msgs,
    ) later:

    return later
}

func do_per_func_imr_block(
        callback,
        project=none,
        imr_build_tracker=none,
        build_options=none,
        is_moose64=no,
        msgs=none,
        debug=no,
        ) {
    const program_name = if is_moose64 ("moosec") else ("horsec")
    if project == none {
        throw new ValueError("The project parameter "
            "has to be specified.")
    }
    if imr_build_tracker == none {
        throw new ValueError("The imr_build_tracker parameter "
            "has to be specified.")
    }
    if build_options == none {
        throw new ValueError("The build_options parameter "
            "has to be specified.")
    }
    var had_abort = no
    func process_file(pfile) {
        var imr_for_file = imr_build_tracker.
            file_id_to_imr_result_map[
                pfile.file_id
            ]
        imr_for_file.ensure_loaded()
        later:

        func go_through_funcs(block_list) {
            var func_queue = []
            var block_queue = block_list.copy()
            var idx = 1
            while idx <= block_queue.len {
                var block = block_queue[idx]
                if has_attr(block, "instructions") {
                    block_queue += block.instructions
                }
                if block.kind != compiler.imr.IMR_BLOCK_FUNC {
                    idx += 1
                    continue
                }
                func_queue.add(block)
                idx += 1
            }
            func handle_func_block(block) {
                var result = callback(
                    pfile, block,
                ) later:

                await result
                if not result {
                    had_abort = yes
                }
                return result
            }
            if func_queue.len == 0 {
                return later
            }
            var item = func_queue.pop_at(1)
            var result = handle_func_block(item)
            later:

            await result
            if result == no {
                return later
            }
            if func_queue.len == 0 {
                return later
            }
            item = func_queue.pop_at(1)
            result = handle_func_block(item)
            later repeat
        }
        go_through_funcs(imr_for_file.blocks)
        later:

        return later yes
    }
    var result = project.do_for_all_files(
        process_file
    ) later:

    await result
    return later not had_abort
}

func add_self_and_failable_parameters_to_funcs(
        project=none,
        imr_build_tracker=none,
        build_options=none,
        is_moose64=no,
        msgs=none,
        debug=no,
        ) {
    const program_name = if is_moose64 ("moosec") else ("horsec")
    if project == none {
        throw new ValueError("The project parameter "
            "has to be specified.")
    }
    if imr_build_tracker == none {
        throw new ValueError("The imr_build_tracker parameter "
            "has to be specified.")
    }
    if build_options == none {
        throw new ValueError("The build_options parameter "
            "has to be specified.")
    }

    func handle_func_block(pfile, block) {
        if not block.is_func_attr {
            return later yes
        }

        var replace_queue = []
        var amount_of_args_used =
            block.pos_arg_count +
            block.kw_arg_count
        if debug {
            print(program_name + ": debug: " +
                "add_self_and_failable_parameters_to_funcs(): " +
                "Looking at function: " +
                "label=" + block.label.as_str())
        }
        var i = 1
        while i <= amount_of_args_used {
            replace_queue.add([
                block,
                new st_ref.StorageRef(
                    st_ref.ST_ARG, i,
                ),
                new st_ref.StorageRef(
                    st_ref.ST_ARG, i + 1,
                ),
            ])
            i += 1
        }
        replace_queue.add([
            block,
            st_ref.StorageRef(
                st_ref.ST_SELF, 0,
            ),
            st_ref.StorageRef(
                st_ref.ST_ARG, 1,
            ),
        ])
        block.pos_arg_count += 1
        
        var func_storage_ref = block.storage_ref
        var func_type_expr = none
        var user_type_expr = none
        var user_type_storage_ref = none
        func try_get_func_type {
            if func_storage_ref == none {
                return later
            }
            if debug {
                print(program_name + ": debug: " +
                    "add_self_and_failable_parameters_to_funcs(): " +
                    "Trying to resolve func storage "
                    "ref to type expr: " +
                    "func_storage_ref=" + func_storage_ref.as_str())
            }
            var resolve_result =
                ast_typeref.resolve_st_ref_to_type_ref_and_expr(
                    pfile, func_storage_ref,
                    ignore_if_ref_none=yes,
                    msgs=msgs, is_moose64=is_moose64,
                    debug=no,
                ) later:

            await resolve_result
            if resolve_result.type_expr != none and
                    resolve_result.type_expr.is_func_ref {
                func_type_expr = resolve_result.type_expr
            }
            # XXX: This code path can still fail for made-up
            # funcs like $varinit that don't have a properly
            # registered func type expression.
            # In that case, func_type_expr will remain unset.
        }
        try_get_func_type() later:

        if func_storage_ref != none and
                func_storage_ref.kind == st_ref.ST_GLOBALATTR {
            assert(func_storage_ref.id.len == 2)
            user_type_storage_ref = new st_ref.StorageRef(
                st_ref.ST_GLOBAL, func_storage_ref.id[1]
            )
        }

        func try_get_user_type_directly {
            if func_type_expr != none or user_type_expr != none {
                return later
            }
            if user_type_storage_ref == none {
                return later
            }
            if debug {
                print(program_name + ": debug: " +
                    "add_self_and_failable_parameters_to_funcs(): " +
                    "Try to resolve user type directly. "
                    "Type ref is: user_type_storage_ref=" +
                        user_type_storage_ref.as_str())
            }
            var scope = pfile.make_attr_names_scope_from_gid(
                user_type_storage_ref.id,
                msgs=msgs, is_moose64=is_moose64,
            )
            if scope == none {
                return later
            }
            var user_type_result =
                ast_typeref.resolve_st_ref_to_type_ref_and_expr(
                    pfile, user_type_storage_ref,
                    msgs=msgs, is_moose64=is_moose64,
                ) later:

            await user_type_result
            if user_type_result != none and
                    user_type_result.type_expr != none {
                user_type_expr = user_type_result.type_expr.copy()
            }
        }
        try_get_user_type_directly() later:

        if func_type_expr == none and user_type_expr == none {
            if msgs == none {
                throw new RuntimeError(
                    "Unexpectedly failed to get "
                    "func type for IMR func block."
                )
            } elseif not msg.msgs_contain_error(msgs) {
                msgs.add(new msg.FileMsg(
                    "Internal error, unexpectedly failed to "
                    "get func type expr for IMR func block despite "
                    "there not being a previous error. This "
                    "shouldn't happen. Please contact the "
                    "compiler makers about this error. "
                    "Details: "
                    "IMRFuncBlock.label=" +
                        textfmt.as_escaped_code_string(block.label),
                    source_file=pfile,
                    line=block.line,
                    col=block.col,
                ))
            }
        }

        if user_type_expr == none and
                func_type_expr != none {
            var arg_exprs = func_type_expr.arg_typeref_exprs
            if arg_exprs.len < 1 or
                    arg_exprs[1].is_func_ref or
                    not arg_exprs[1].is_user_type() {
                throw new RuntimeError(
                    "Func expr is damaged, self param missing."
                )
            }
            user_type_expr = arg_exprs[1].copy()
        }
        assert(user_type_expr != none)
        assert(user_type_storage_ref != none)

        if user_type_expr.ref_count(
                include_c_arrays=yes,
                include_arrays=yes,
                include_implicit_refs=yes,
                include_explicit_refs=yes) == 0 {
            var mod = new ast_typeref.TypeRefMod("implicit ref")
            user_type_expr.modifiers.add(mod)
        }
        block.known_arg_type_exprs = [
            user_type_expr
        ] + block.known_arg_type_exprs
        block.known_arg_type_storage_refs = [
            user_type_storage_ref
        ] + block.known_arg_type_storage_refs

        if block.func_scope != none and
                block.func_scope.has_failable {
            assert(block.kw_arg_count == 0)
            var failable_insert_index =
                block.known_arg_type_exprs.len + 1
            if block.known_arg_type_exprs.len > 0 and
                    block.known_arg_type_exprs[
                        block.known_arg_type_exprs.len
                    ] != none and
                    block.known_arg_type_exprs[
                        block.known_arg_type_exprs.len
                    ].is_list_arg {
                failable_insert_index =
                    block.known_arg_type_exprs.len
            }
            var failable_expr = new ast_typeref.TypeRefExpr()
            failable_expr.name = "moose64_failed_result_t"
            failable_expr.add_ref_modifier()
            block.known_arg_type_exprs.add_at(
                failable_insert_index, failable_expr
            )
            block.known_arg_type_storage_refs.add_at(
                failable_insert_index, none
            )
            block.pos_arg_count += 1
        }

        func handle_queue_item(item) {
            replace_refs_in_func(
                item[1], item[2], item[3],
                project_file=pfile,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64,
                msgs=msgs,
                debug=no,
            ) later:
        }
        if replace_queue.len == 0 {
            return later yes
        }
        var item = replace_queue.pop_at(1)
        var result = handle_queue_item(item)
        later:

        await result
        if replace_queue.len == 0 {
            return later yes
        }
        item = replace_queue.pop_at(1)
        result = handle_queue_item(item)
        later repeat
    }

    var result = do_per_func_imr_block(
        handle_func_block,
        project=project,
        imr_build_tracker=imr_build_tracker,
        build_options=build_options,
        is_moose64=is_moose64,
        msgs=msgs,
        debug=no,
    ) later:

    await result
    return later (result == yes)
}

func reassign_locals_and_do_lifetime_for_imr(
        project=none,
        imr_build_tracker=none,
        build_options=none,
        is_moose64=no,
        msgs=none,
        debug=no,
        ) {
    const program_name = if is_moose64 ("moosec") else ("horsec")
    if project == none {
        throw new ValueError("The project parameter "
            "has to be specified.")
    }
    if imr_build_tracker == none {
        throw new ValueError("The imr_build_tracker parameter "
            "has to be specified.")
    }
    if build_options == none {
        throw new ValueError("The build_options parameter "
            "has to be specified.")
    }
    func handle_func_block(pfile, block) {
        var replace_queue = []
        var highest_st_id_used = 1
        var amount_of_ids_used = 0
        var ids_list = []
        for st_id in block.storage_id_to_known_type_expr {
            highest_st_id_used = math.max(
                highest_st_id_used, st_id
            )
            amount_of_ids_used += 1
            ids_list.add(st_id)
        }
        if debug {
            print(program_name + ": debug: " +
                "reassign_locals_and_do_lifetime_for_imr(): " +
                "Looking at function: " +
                "label=" + block.label.as_str() + " "
                "highest_st_id_used=" +
                    highest_st_id_used.as_str() + " "
                "amount_of_ids_used=" +
                    amount_of_ids_used.as_str())
        }
        var i = 1
        while i <= amount_of_ids_used {
            assert(i >= 1 and i <= ids_list.len)
            var old_local_id = ids_list[i]
            var new_local_id = i
            replace_queue.add([
                block,
                new st_ref.StorageRef(
                    st_ref.ST_LOCAL, old_local_id,
                ),
                new st_ref.StorageRef(
                    st_ref.ST_LOCAL, new_local_id,
                ),
            ])
            i += 1
        }

        func handle_queue_item(item) {
            if debug {
                print(program_name + ": debug: " +
                    "reassign_locals_and_do_lifetime_for_imr(): " +
                    "Reassigning " + item[2].as_str() + " "
                    "to " + item[3].as_str())
            }
            replace_refs_in_func(
                item[1], item[2], item[3],
                project_file=pfile,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64,
                msgs=msgs,
                debug=no,
            ) later:
        }
        if replace_queue.len == 0 {
            return later yes
        }
        var item = replace_queue.pop_at(1)
        var result = handle_queue_item(item)
        later:

        await result
        if replace_queue.len == 0 {
            return later yes
        }
        item = replace_queue.pop_at(1)
        result = handle_queue_item(item)
        later repeat
    }

    var result = do_per_func_imr_block(
        handle_func_block,
        project=project,
        imr_build_tracker=imr_build_tracker,
        build_options=build_options,
        is_moose64=is_moose64,
        msgs=msgs,
        debug=no,
    ) later:

    await result
    return later (result == yes)
}

