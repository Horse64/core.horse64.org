## @module compiler.imr.transform
# Copyright (c) 2025, ellie/@ell1e & Horse64's contributors
# (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import math from core.horse64.org

import compiler.imr
import compiler.storage.ref as st_ref

func replace_refs_in_func(
        func_imr_node,
        old_ref, new_ref,
        project_file=none,
        imr_build_tracker=none,
        is_moose64=no,
        msgs=none,
        debug=no,
        ) {
    if project_file == none {
        throw new ValueError("The project_file parameter "
            "has to be specified.")
    }
    if imr_build_tracker == none {
        throw new ValueError("The imr_build_tracker parameter "
            "has to be specified.")
    }

    var project = project_file.project
    assert(func_imr_node.kind == compiler.imr.IMR_BLOCK_FUNC)

    func replace_refs_in_list(l) {
        var nested_queue = []
        for item in l {
            if item.kind == compiler.imr.IMR_BLOCK_FUNC {
                # We don't want to descend into nested funcs,
                # in case we ever allow those.
                # FIXME: However, we might need to revisit this for
                # closures later. Perhaps we should un-nest those
                # before we even run into this code path...?
                continue
            }
            if has_attr(item, "instructions") {
                nested_queue.add(item.instructions)
            }
            # FIXME: This will break closure captures for
            # Horse64. Figure out later what we'll do about that.
            if item.kind == compiler.imr.IMR_INST_VARINFO {
                if old_ref.kind == st_ref.ST_LOCAL and
                        new_ref.kind == st_ref.ST_LOCAL and
                        item.storage_id == old_ref.id {
                    item.storage_id = new_ref.id
                }
            } elseif item.kind == compiler.imr.IMR_INST_SETLIT {
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_SETATTRBYID {
                if item.target_and_obj_storage_ref.alike(old_ref) {
                    item.target_and_obj_storage_ref = new_ref.copy()
                }
                if item.value_storage_ref.alike(old_ref) {
                    item.value_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_SETATTRBYNAME {
                if item.target_and_obj_storage_ref.alike(old_ref) {
                    item.target_and_obj_storage_ref = new_ref.copy()
                }
                if item.value_storage_ref.alike(old_ref) {
                    item.value_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_GETATTRBYNAME {
                if item.obj_storage_ref.alike(old_ref) {
                    item.obj_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_GETATTRBYID {
                if item.obj_storage_ref.alike(old_ref) {
                    item.obj_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_SETIDX {
                if item.target_and_container_storage_ref.alike(old_ref) {
                    item.target_and_container_storage_ref = new_ref.copy()
                }
                if item.index_storage_ref.alike(old_ref) {
                    item.index_storage_ref = new_ref.copy()
                }
                if item.value_storage_ref.alike(old_ref) {
                    item.value_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_GETIDX {
                if item.container_storage_ref.alike(old_ref) {
                    item.container_storage_ref = new_ref.copy()
                }
                if item.index_storage_ref.alike(old_ref) {
                    item.index_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_CLRZERO {
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_CONV {
                if item.source_storage_ref.alike(old_ref) {
                    item.source_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_MOVE {
                if item.source_storage_ref.alike(old_ref) {
                    item.source_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_APPLY_OP {
                if item.operand_1_storage_ref.alike(old_ref) {
                    item.operand_1_storage_ref = new_ref.copy()
                }
                if item.is_binary and
                        item.operand_2_storage_ref.alike(old_ref) {
                    item.operand_2_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_CALL {
                if item.called_func_ref.alike(old_ref) {
                    item.called_func_ref = new_ref.copy()
                }
                if item.return_value_ref != none and
                        item.return_value_ref.alike(old_ref) {
                    item.return_value_ref = new_ref.copy()
                }
                for arg in item.args {
                    if arg.ref.alike(old_ref) {
                        arg.ref = new_ref.copy()
                    }
                }
            } elseif item.kind == compiler.imr.IMR_BLOCK_ITERLOOP {
                if item.iterated_container_ref.alike(old_ref) {
                    item.iterated_container_ref = new_ref.copy()
                }
                if item.iterator_store_ref.alike(old_ref) {
                    item.iterator_store_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_ASREF {
                if item.asref_source_storage_ref.alike(old_ref) {
                    item.asref_source_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_DEREF {
                if item.deref_source_storage_ref.alike(old_ref) {
                    item.deref_source_storage_ref = new_ref.copy()
                }
                if item.target_storage_ref.alike(old_ref) {
                    item.target_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_INST_RETURN {
                if item.return_value_storage_ref != none and
                        item.return_value_storage_ref.alike(old_ref) {
                    item.return_value_storage_ref = new_ref.copy()
                }
            } elseif item.kind == compiler.imr.IMR_BLOCK_COND {
                if item.evaluated_cond_ref.alike(old_ref) {
                    item.evaluated_cond_ref = new_ref.copy()
                }
            }
        }
        if nested_queue.len == 0 {
            return later
        }
        var item = nested_queue.pop_at(1)
        var result = replace_refs_in_list(item)
        later:

        await result
        if nested_queue.len == 0 {
            return later
        }
        item = nested_queue.pop_at(1)
        result = replace_refs_in_list(item)
        later repeat
    }
    if old_ref.kind == st_ref.ST_LOCAL {
        var n = func_imr_node
        if n.storage_id_to_known_type_info.has(old_ref.id) {
            n.storage_id_to_known_type_info[new_ref.id] =
                n.storage_id_to_known_type_info[old_ref.id]
            n.storage_id_to_known_type_info.del(old_ref.id)
        }
        if n.storage_id_to_known_type_expr.has(old_ref.id) {
            n.storage_id_to_known_type_expr[new_ref.id] =
                n.storage_id_to_known_type_expr[old_ref.id]
            n.storage_id_to_known_type_expr.del(old_ref.id)
        }
    }
    replace_refs_in_list(func_imr_node.instructions)
    later:

    func_imr_node.update_var_type_exprs(
        project_file, is_moose64=is_moose64, msgs=msgs,
    ) later:

    return later
}

func reassign_locals_and_do_lifetime_for_imr(
        project=none,
        imr_build_tracker=none,
        build_options=none,
        is_moose64=no,
        msgs=none,
        debug=no,
        ) {
    const program_name = if is_moose64 ("mosoec") else ("horsec")
    if project == none {
        throw new ValueError("The project parameter "
            "has to be specified.")
    }
    if imr_build_tracker == none {
        throw new ValueError("The imr_build_tracker parameter "
            "has to be specified.")
    }
    if build_options == none {
        throw new ValueError("The build_options parameter "
            "has to be specified.")
    }
    func process_file(pfile) {
        var imr_for_file = imr_build_tracker.
            file_id_to_imr_result_map[
                pfile.file_id
            ]
        imr_for_file.ensure_loaded()
        later:

        func go_through_funcs(block_list) {
            var replace_queue = []
            var block_queue = block_list.copy()
            var idx = 1
            while idx <= block_queue.len {
                var block = block_queue[idx]
                if has_attr(block, "instructions") {
                    block_queue += block.instructions
                }
                if block.kind != compiler.imr.IMR_BLOCK_FUNC {
                    idx += 1
                    continue
                }
                var highest_st_id_used = 1
                var amount_of_ids_used = 0
                var ids_list = []
                for st_id in block.storage_id_to_known_type_expr {
                    highest_st_id_used = math.max(
                        highest_st_id_used, st_id
                    )
                    amount_of_ids_used += 1
                    ids_list.add(st_id)
                }
                if debug {
                    print(program_name + ": debug: " +
                        "reassign_locals_and_do_lifetime_for_imr(): " +
                        "Looking at function: " +
                        "label=" + block.label.as_str() + " "
                        "highest_st_id_used=" +
                            highest_st_id_used.as_str() + " "
                        "amount_of_ids_used=" +
                            amount_of_ids_used.as_str())
                }
                var i = 1
                while i <= amount_of_ids_used {
                    assert(i >= 1 and i <= ids_list.len)
                    var old_local_id = ids_list[i]
                    var new_local_id = i
                    replace_queue.add([
                        block,
                        new st_ref.StorageRef(
                            st_ref.ST_LOCAL, old_local_id,
                        ),
                        new st_ref.StorageRef(
                            st_ref.ST_LOCAL, new_local_id,
                        ),
                    ])
                    i += 1
                }
                idx += 1
            }
            func handle_queue_item(item) {
                replace_refs_in_func(
                    item[1], item[2], item[3],
                    project_file=pfile,
                    imr_build_tracker=imr_build_tracker,
                    is_moose64=is_moose64,
                    msgs=msgs,
                    debug=no,
                ) later:
            }
            if replace_queue.len == 0 {
                return later
            }
            var item = replace_queue.pop_at(1)
            var result = handle_queue_item(item)
            later:

            await result
            if replace_queue.len == 0 {
                return later
            }
            item = replace_queue.pop_at(1)
            result = handle_queue_item(item)
            later repeat
        }
        go_through_funcs(imr_for_file.blocks)
        later:

        #print("RESULT: " + imr_for_file.as_str())
        return later yes
    }
    var result = project.do_for_all_files(
        process_file
    ) later:

    await result
    return later yes
}

