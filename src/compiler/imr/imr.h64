## @module compiler.imr
# Copyright (c) 2025, ellie/@ell1e & Horse64's contributors
# (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.

import json from core.horse64.org
import math from core.horse64.org
import textfmt from core.horse64.org
import time from core.horse64.org
import wildcard from core.horse64.org

import compiler.ast as ast
import compiler.ast.expr as ast_expr
import compiler.ast.transform as ast_transform
import compiler.compiler_log as clog
import compiler.globals_order as globals_order
import compiler.imr.transform as imr_transform
import compiler.moose64.autocast as m64_autocast
import compiler.moose64.builtins as m64_builtins
import compiler.moose64.ast.analyze as m64_ast_analyze
import compiler.msg as msg
import compiler.storage.ref as st_ref
import compiler.storage.scope as st_scope
import compiler.token as token
import compiler.typeinfo as typeinfo
import compiler.typeinfo.ast_typeref as ast_typeref

type IMRTranslationResult {
    var file_id_to_imr_result_map = {->}

    var msgs = []
}

func IMRTranslationResult.as_str {
    var t = ""
    for f_id in self.file_id_to_imr_result_map {
        t += "\n"
        t += self.file_id_to_imr_result_map[f_id].as_str()
    }
    return "IMRTranslationResult{" + t + "\n}"
}

type IMRNode {
    var kind
    var line
    var col
}

func IMRNode.init(kind) {
    self.kind = kind
}

func IMRNode.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = {->}
    obj["kind"] = IMRNodeKind.num_label(self.kind)
    return obj
}

func IMRNode.as_str(indent=0) {
    return "IMRNode" + self.as_json_obj().as_str()
}

func IMRNode.format_inst(
        name, pos_parameter_names=[],
        no_quotes_for_parameters=[],
        skip_parameter_names=[],
        extra_text=none,
        indent=0,
        ) {
    var spaces = " ".rep(math.max(0, indent))
    var t = spaces + name
    var data = self.as_json_obj(
        _passthrough_storage_refs=yes,
    )
    for pname in pos_parameter_names {
        if not data.has(pname) {
            print("horsec: error: Internal error, " +
                "got invalid format_inst() parameters in "
                "imr.h64 during text render: " +
                "name=" + textfmt.as_escaped_code_string(
                    name
                ) +
                " pname=" + textfmt.as_escaped_code_string(
                    pname
                ))
            throw new ValueError(
                "Name given in pos_parameter_names "
                "isn't part of JSON object data.")
        }
        if typename(data[pname]) == "str" and
                not no_quotes_for_parameters.has(pname) {
            t += " " + textfmt.as_escaped_code_string(
                data[pname])
        } else {
            t += " " + data[pname].as_str()
        }
    }
    if extra_text != none {
        t += " " + extra_text.trim()
    }
    var skip_parameter_wildcards = []
    var skip_parameter_names_new = []
    for skip_name in skip_parameter_names {
        if skip_name.has("*") {
            skip_parameter_wildcards.add(
                skip_name
            )
        } else {
            skip_parameter_names_new.add(skip_name)
        }
    }
    skip_parameter_names = skip_parameter_names_new
    func should_skip(key) {
        if skip_parameter_names.has(key) {
            return yes
        }
        for wildcard_entry in skip_parameter_wildcards {
            if wildcard.match(wildcard_entry, key) {
                return yes
            }
        }
        return no
    }

    for remaining_key in data {
        if pos_parameter_names.has(remaining_key) or
                remaining_key == "kind" or
                should_skip(remaining_key) {
            continue
        }
        t += " " + remaining_key.upper() + "="
        if typename(data[remaining_key]) == "str" and
                not no_quotes_for_parameters.has(remaining_key) {
            t += textfmt.as_escaped_code_string(
                data[remaining_key])
        } else {
            t += data[remaining_key].as_str()
        }
    }
    return t
}

type IMRBlock base IMRNode {
    var is_block = yes
    var instructions = []
}

func IMRBlock.as_str(indent=0) {
    var t = "IMRBlock{" +
        json.dump(self.as_json_obj())
    return t + "}"
}

func IMRBlock.copy {
    var self_copy = base.copy()
    self_copy.instructions = []
    for inst in self.instructions {
        self_copy.instructions.add(inst.copy())
    }
    return self_copy
}

func IMRBlock.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    var instl = []
    for inst in self.instructions {
        instl.add(inst.as_json_obj(
            _passthrough_storage_refs=
                _passthrough_storage_refs))
    }
    obj["instructions"] = instl
    return obj
}

func IMRBlock.fmt_block(indent=0, prepend_stmts=[]) {
    var indent_s = " ".rep(math.max(0, indent))
    var t = "BEGIN\n"
    for inst in prepend_stmts {
        t += inst.as_str(indent=(indent + 4)) + "\n"
    }
    for inst in self.instructions {
        t += inst.as_str(indent=(indent + 4)) + "\n"
    }
    return t + indent_s + "END"
}

type IMRVarInfo base IMRNode {
    var label
    var type_expr
    var type_expr_storage_ref
    var def_project_file
    var storage_id
}

func IMRVarInfo.init(
        var_label, var_type,
        storage_id, var_type_storage_ref,
        var_def_project_file,
        ) {
    base.init(IMR_INST_VARINFO)
    if typename(var_label) != "str" {
        throw new TypeError("The var_label parameter "
            "must be of type str.")
    }
    if typename(storage_id) != "num" {
        throw new TypeError("The storage_id parameter "
            "must be of type str.")
    }
    self.label = var_label
    self.type_expr = var_type
    var must_have_var_storage_ref = no
    var mustnt_have_var_storage_ref = no
    if self.type_expr != none {
        if self.type_expr.is_user_type() and
                not self.type_expr.is_func_ref {
            must_have_var_storage_ref = yes
        } elseif not self.type_expr.is_user_type() {
            mustnt_have_var_storage_ref = yes
        }
        if (must_have_var_storage_ref and
                var_type_storage_ref == none) or
                (var_type_storage_ref != none and
                (typename(var_type_storage_ref) != "obj" or
                not has_attr(var_type_storage_ref, "id") or
                not has_attr(var_type_storage_ref, "kind"))) {
            throw new RuntimeError(
                "The var_type_storage_ref must be set "
                "to a storage ref.")
        }
        if mustnt_have_var_storage_ref and
                var_type_storage_ref != none {
            throw new RuntimeError(
                "The var_type_storage_ref mustn't be set.")
        }
    }
    self.type_expr_storage_ref = var_type_storage_ref
    self.def_project_file = var_def_project_file
    self.storage_id = storage_id
}

func IMRVarInfo.as_str(indent=0) {
    var t = self.format_inst(
        "VARINFO", pos_parameter_names=[
            "storage_id",
            "label",
        ],
        no_quotes_for_parameters=["type_expr"],
        skip_parameter_names=[
            "type_expr_storage_ref",
            "def_project_file",
        ], indent=indent,
    )
    if self.type_expr != none {
        t += " TYPE_EXPR_STORAGE_REF="
        if self.type_expr_storage_ref != none {
            t += self.type_expr_storage_ref.as_str()
        } else {
            t += "none"
        }
    }
    t += " DEF_PROJECT_FILE=FILE" +
        self.def_project_file.file_id.as_str()
    return t
}

func IMRVarInfo.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    obj["def_project_file"] =
        self.def_project_file.as_str()
    obj["label"] = self.label
    if self.type_expr != none {
        obj["type_expr"] = self.type_expr.as_str()
        if _passthrough_storage_refs {
            obj["type_expr_storage_ref"] =
                self.type_expr_storage_ref
        } else {
            obj["type_expr_storage_ref"] =
                self.type_expr_storage_ref.as_str()
        }
    }
    obj["storage_id"] = self.storage_id
    return obj
}

type IMRClrZero base IMRNode {
    var target_storage_ref
}

func IMRClrZero.init(target_storage_ref) {
    base.init(IMR_INST_CLRZERO)
    if typename(target_storage_ref) != "obj" or
            not has_attr(target_storage_ref, "kind") or
            not has_attr(target_storage_ref, "id") {
        throw new TypeError("The target_storage_ref parameter "
        "must be of type StorageRef.")
    }
    self.target_storage_ref = target_storage_ref.copy()
}

func IMRClrZero.as_str(indent=0) {
    return self.format_inst(
        "CLRZERO", pos_parameter_names=[
            "target_storage_ref",
        ], indent=indent,
    )
}

func IMRClrZero.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
        _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["target_storage_ref"] =
            self.target_storage_ref
    } else {
        obj["target_storage_ref"] =
            self.target_storage_ref.as_str()
    }
    return obj
}

type IMRSetLit base IMRNode {
    var value
    var target_storage_ref
    var literal_kind
}

func IMRSetLit.init(value, target_storage_ref, literal_kind=none) {
    base.init(IMR_INST_SETLIT)
    if typename(target_storage_ref) != "obj" or
            not has_attr(target_storage_ref, "kind") or
            not has_attr(target_storage_ref, "id") {
        throw new TypeError("The target_storage_ref parameter "
            "must be of type StorageRef.")
    }
    if literal_kind == none {
        literal_kind = ast_expr.LK_NORMAL
    }
    self.value = value
    self.target_storage_ref = target_storage_ref.copy()
    self.literal_kind = literal_kind
}

func IMRSetLit.as_str(indent=0) {
    return self.format_inst(
        "SETLIT", pos_parameter_names=[
            "literal_kind",
            "value",
            "target_storage_ref",
        ],
        no_quotes_for_parameters=["literal_kind"],
        indent=indent,
    )
}

func IMRSetLit.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    obj["value"] = self.value
    if _passthrough_storage_refs {
        obj["target_storage_ref"] =
            self.target_storage_ref
    } else {
        obj["target_storage_ref"] =
            self.target_storage_ref.as_str()
    }
    obj["literal_kind"] = ast_expr.LiteralKind.num_label(
        self.literal_kind
    )
    return obj
}

type IMRConv base IMRNode {
    var source_storage_ref
    var target_storage_ref
    var source_type_info
    var target_type_info
}

func IMRConv.init(
        source_storage_ref, target_storage_ref,
        source_type_typeinfo,
        target_type_typeinfo,
        in_project_file=none,
        is_moose64=no,
        ) {
    const program_name = if is_moose64 ("moosec") else ("horsec")
    base.init(IMR_INST_CONV)
    if in_project_file == none {
        throw new RuntimeError("The project file must be "
            "specified for initialization.")
    }
    if typename(source_storage_ref) != "obj" or
            not has_attr(source_storage_ref, "kind") or
            not has_attr(source_storage_ref, "id") {
        throw new TypeError("The source_storage_ref parameter "
            "must be of type StorageRef.")
    }
    if typename(target_storage_ref) != "obj" or
            not has_attr(target_storage_ref, "kind") or
            not has_attr(target_storage_ref, "id") {
        throw new TypeError("The target_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.source_storage_ref = source_storage_ref.copy()
    self.target_storage_ref = target_storage_ref.copy()
    if source_type_typeinfo == none {
        throw new ValueError("The "
            "source_type_typeinfo parameter "
            "must be specified.")
    }
    if target_type_typeinfo == none {
        throw new ValueError("The "
            "target_type_typeinfo parameter "
            "must be specified.")
    }
    if not has_attr(source_type_typeinfo,
            "_orig_typeexpr") {
        throw new ValueError("The "
            "source_type_typeinfo parameter "
            "doesn't seem to be a TypeInfo instance.")
    }
    if not has_attr(target_type_typeinfo,
            "_orig_typeexpr") {
        throw new ValueError("The "
            "target_type_typeinfo parameter "
            "doesn't seem to be a TypeInfo instance.")
    }
    var source_type_expr =
        source_type_typeinfo.convert_to_typeref_expr(
            project=in_project_file.project,
            in_local_scope=none,
            in_project_file=in_project_file,
            is_moose64=is_moose64,
        )
    if source_type_expr == none {
        print(program_name + ": error: Internal error, "
            "unexpectedly failed to convert TypeInfo "
            "given to IMRConv to AST type expr for "
            "printing. typeinfo=" + source_type_typeinfo.as_str())
        throw new RuntimeError("Internal error, "
            "unexpectedly failed to convert TypeInfo "
            "given to IMRConv to AST type expr for "
            "printing.")
    }
    var target_type_expr =
        target_type_typeinfo.convert_to_typeref_expr(
            project=in_project_file.project,
            in_local_scope=none,
            in_project_file=in_project_file,
            is_moose64=is_moose64,
        )
    if target_type_expr == none {
        print(program_name + ": error: Internal error, "
            "unexpectedly failed to convert TypeInfo "
            "given to IMRConv to AST type expr for "
            "printing. typeinfo=" + target_type_typeinfo.as_str())
        throw new RuntimeError("Internal error, "
            "unexpectedly failed to convert TypeInfo "
            "given to IMRConv to AST type expr for "
            "printing.")
    }
    self.source_type_info = source_type_typeinfo.copy()
    self.target_type_info = target_type_typeinfo.copy()
    
    self.source_type_expr = source_type_expr.copy()
    self.target_type_expr = target_type_expr.copy()
}

func IMRConv.as_str(indent=0) {
    return self.format_inst(
        "CONV", pos_parameter_names=[
            "source_storage_ref",
            "target_storage_ref",
            "source_type_expr",
            "target_type_expr",
        ],
        no_quotes_for_parameters=[
            "source_type_expr",
            "target_type_expr",
        ],
        indent=indent,
    )
}

func IMRConv.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["source_storage_ref"] =
            self.source_storage_ref
    } else {
        obj["source_storage_ref"] =
            self.source_storage_ref.as_str()
    }
    if _passthrough_storage_refs {
        obj["target_storage_ref"] =
            self.target_storage_ref
    } else {
        obj["target_storage_ref"] =
            self.target_storage_ref.as_str()
    }

    obj["source_type_expr"] = self.source_type_expr.as_str()
    obj["target_type_expr"] = self.target_type_expr.as_str()
    return obj
}

type IMRMove base IMRNode {
    var source_storage_ref
    var target_storage_ref
}

func IMRMove.init(source_storage_ref, target_storage_ref) {
    base.init(IMR_INST_MOVE)
    if typename(source_storage_ref) != "obj" or
            not has_attr(source_storage_ref, "kind") or
            not has_attr(source_storage_ref, "id") {
        throw new TypeError("The source_storage_ref parameter "
            "must be of type StorageRef.")
    }
    if typename(target_storage_ref) != "obj" or
            not has_attr(target_storage_ref, "kind") or
            not has_attr(target_storage_ref, "id") {
        throw new TypeError("The target_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.source_storage_ref = source_storage_ref.copy()
    self.target_storage_ref = target_storage_ref.copy()
}

func IMRMove.as_str(indent=0) {
    return self.format_inst(
        "MOVE", pos_parameter_names=[
            "source_storage_ref",
            "target_storage_ref",
        ], indent=indent,
    )
}

func IMRMove.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["source_storage_ref"] =
            self.source_storage_ref
    } else {
        obj["source_storage_ref"] =
            self.source_storage_ref.as_str()
    }
    if _passthrough_storage_refs {
        obj["target_storage_ref"] =
            self.target_storage_ref
    } else {
        obj["target_storage_ref"] =
            self.target_storage_ref.as_str()
    }
    return obj
}

type IMRGetListArgLen base IMRNode {
    var multi_arg_storage_ref
    var target_storage_ref
}

func IMRGetListArgLen.init(
        multi_arg_storage_ref,
        target_storage_ref,
        ) {
    base.init(IMR_INST_GETLISTARGLEN)
    if typename(multi_arg_storage_ref) != "obj" or
            not has_attr(multi_arg_storage_ref, "kind") or
            not has_attr(multi_arg_storage_ref, "id") {
        throw new TypeError(
            "The multi_arg_storage_ref parameter "
            "must be of type StorageRef.")
    }
    if typename(target_storage_ref) != "obj" or
            not has_attr(target_storage_ref, "kind") or
            not has_attr(target_storage_ref, "id") {
        throw new TypeError(
            "The target_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.multi_arg_storage_ref =
        multi_arg_storage_ref.copy()
    self.target_storage_ref =
        target_storage_ref.copy()
}

func IMRGetListArgLen.as_str(indent=0) {
    return self.format_inst(
        "GETMULTIARGLEN", pos_parameter_names=[
            "multi_arg_storage_ref",
            "target_storage_ref",
        ], indent=indent,
    )
}

func IMRGetListArgLen.copy {
    var self_copy = base.copy()
    self_copy.multi_arg_storage_ref =
        self.multi_arg_storage_ref.copy()
    self_copy.target_storage_ref =
        self.target_storage_ref.copy()
    return self_copy
}

func IMRGetListArgLen.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
        _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["multi_arg_storage_ref"] =
            self.multi_arg_storage_ref
    } else {
        obj["multi_arg_storage_ref"] =
            self.multi_arg_storage_ref.as_str()
    }
    if _passthrough_storage_refs {
        obj["target_storage_ref"] =
            self.target_storage_ref
    } else {
        obj["target_storage_ref"] =
            self.target_storage_ref.as_str()
    }
    return obj
}

type IMRSetAttrById base IMRNode {
    var target_and_obj_storage_ref
    var attr_id
    var value_storage_ref
}

func IMRSetAttrById.init(
        target_and_obj_storage_ref=none,
        attr_id=none,
        value_storage_ref=none,
        ) {
    base.init(IMR_INST_SETATTRBYID)
    if typename(target_and_obj_storage_ref) != "obj" or
            not has_attr(target_and_obj_storage_ref, "kind") or
            not has_attr(target_and_obj_storage_ref, "id") {
        throw new TypeError(
            "The target_and_container_storage_ref parameter "
            "must be of type StorageRef.")
    }
    if typename(attr_id) != "num" {
        throw new TypeError(
            "The attr_id parameter must be of type num."
        )
    }
    if typename(value_storage_ref) != "obj" or
            not has_attr(value_storage_ref, "kind") or
            not has_attr(value_storage_ref, "id") {
        throw new TypeError("The value_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.target_and_obj_storage_ref =
        target_and_obj_storage_ref.copy()
    self.attr_id = attr_id
    self.value_storage_ref = value_storage_ref.copy()
}

func IMRSetAttrById.as_str(indent=0) {
    return self.format_inst(
        "SETATTRBYID", pos_parameter_names=[
            "target_and_obj_storage_ref",
            "attr_id",
            "value_storage_ref",
        ], indent=indent,
    )
}

func IMRSetAttrById.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
        _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["target_and_obj_storage_ref"] =
            self.target_and_obj_storage_ref
    } else {
        obj["target_and_obj_storage_ref"] =
            self.target_and_obj_storage_ref.as_str()
    }
    obj["attr_id"] = self.attr_id
    if _passthrough_storage_refs {
        obj["value_storage_ref"] =
            self.value_storage_ref
    } else {
        obj["value_storage_ref"] =
            self.value_storage_ref.as_str()
    }
    return obj
}

type IMRSetAttrByName base IMRNode {
    var target_and_obj_storage_ref
    var attr_name
    var value_storage_ref
}

func IMRSetAttrByName.init(
        target_and_obj_storage_ref=none,
        attr_name=none,
        value_storage_ref=none,
        ) {
    base.init(IMR_INST_SETATTRBYNAME)
    if typename(target_and_obj_storage_ref) != "obj" or
            not has_attr(target_and_obj_storage_ref, "kind") or
            not has_attr(target_and_obj_storage_ref, "id") {
        throw new TypeError(
            "The target_and_container_storage_ref parameter "
            "must be of type StorageRef.")
    }
    if typename(attr_name) != "str" {
        throw new TypeError(
            "The attr_name parameter must be of type str."
        )
    }
    if typename(value_storage_ref) != "obj" or
            not has_attr(value_storage_ref, "kind") or
            not has_attr(value_storage_ref, "id") {
        throw new TypeError("The value_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.target_and_obj_storage_ref =
        target_and_obj_storage_ref.copy()
    self.attr_name = attr_name
    self.value_storage_ref = value_storage_ref.copy()
}

func IMRSetAttrByName.as_str(indent=0) {
    return self.format_inst(
        "SETATTRBYNAME", pos_parameter_names=[
            "target_and_obj_storage_ref",
            "attr_name",
            "value_storage_ref",
        ], indent=indent,
    )
}

func IMRSetAttrByName.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["target_and_obj_storage_ref"] =
            self.target_and_obj_storage_ref
    } else {
        obj["target_and_obj_storage_ref"] =
            self.target_and_obj_storage_ref.as_str()
    }
    obj["attr_name"] = self.attr_name
    if _passthrough_storage_refs {
        obj["value_storage_ref"] =
            self.value_storage_ref
    } else {
        obj["value_storage_ref"] =
            self.value_storage_ref.as_str()
    }
    return obj
}

type IMRGetAttrByName base IMRNode {
    var obj_storage_ref
    var attr_name
    var target_storage_ref
}

func IMRGetAttrByName.init(
        obj_storage_ref=none,
        attr_name=none,
        target_storage_ref=none,
        ) {
    base.init(IMR_INST_GETATTRBYNAME)
    if typename(obj_storage_ref) != "obj" or
            not has_attr(obj_storage_ref, "kind") or
            not has_attr(obj_storage_ref, "id") {
        throw new TypeError("The obj_storage_ref parameter "
            "must be of type StorageRef.")
    }
    if typename(attr_name) != "str" {
        throw new TypeError("The attr_name parameter "
            "must be of type str.")
    }
    if typename(target_storage_ref) != "obj" or
            not has_attr(target_storage_ref, "kind") or
            not has_attr(target_storage_ref, "id") {
        throw new TypeError("The target_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.obj_storage_ref = obj_storage_ref.copy()
    self.attr_name = attr_name
    self.target_storage_ref = target_storage_ref.copy()
}

func IMRGetAttrByName.as_str(indent=0) {
    return self.format_inst(
        "GETATTRBYNAME", pos_parameter_names=[
            "obj_storage_ref",
            "attr_name",
            "target_storage_ref",
        ], indent=indent,
    )
}

func IMRGetAttrByName.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["obj_storage_ref"] =
            self.obj_storage_ref
    } else {
        obj["obj_storage_ref"] =
            self.obj_storage_ref.as_str()
    }
    obj["attr_name"] = self.attr_name
    if _passthrough_storage_refs {
        obj["target_storage_ref"] =
            self.target_storage_ref
    } else {
        obj["target_storage_ref"] =
            self.target_storage_ref.as_str()
    }
    return obj
}

type IMRGetAttrById base IMRNode {
    var obj_storage_ref
    var attr_id
    var target_storage_ref
}

func IMRGetAttrById.init(
        obj_storage_ref=none,
        attr_id=none,
        target_storage_ref=none,
        ) {
    base.init(IMR_INST_GETATTRBYID)
    if typename(obj_storage_ref) != "obj" or
            not has_attr(obj_storage_ref, "kind") or
            not has_attr(obj_storage_ref, "id") {
        throw new TypeError("The obj_storage_ref parameter "
        "must be of type StorageRef.")
    }
    if typename(attr_id) != "num" {
        throw new TypeError("The attr_id parameter "
            "must be of type num.")
    }
    if typename(target_storage_ref) != "obj" or
            not has_attr(target_storage_ref, "kind") or
            not has_attr(target_storage_ref, "id") {
        throw new TypeError("The target_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.obj_storage_ref = obj_storage_ref.copy()
    self.attr_id = attr_id
    self.target_storage_ref = target_storage_ref.copy()
}

func IMRGetAttrById.as_str(indent=0) {
    return self.format_inst(
        "GETATTRBYID", pos_parameter_names=[
            "obj_storage_ref",
            "attr_id",
            "target_storage_ref",
        ], indent=indent,
    )
}

func IMRGetAttrById.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
        _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["obj_storage_ref"] =
            self.obj_storage_ref
    } else {
        obj["obj_storage_ref"] =
            self.obj_storage_ref.as_str()
    }
    obj["attr_id"] = self.attr_id
    if _passthrough_storage_refs {
        obj["target_storage_ref"] =
            self.target_storage_ref
    } else {
        obj["target_storage_ref"] =
            self.target_storage_ref.as_str()
    }
    return obj
}

type IMRSetIdx base IMRNode {
    var target_and_container_storage_ref
    var index_storage_ref
    var value_storage_ref
}

func IMRSetIdx.init(
        target_and_container_storage_ref=none,
        index_storage_ref=none,
        value_storage_ref=none,
        ) {
    base.init(IMR_INST_SETIDX)
    if typename(target_and_container_storage_ref) != "obj" or
            not has_attr(target_and_container_storage_ref, "kind") or
            not has_attr(target_and_container_storage_ref, "id") {
        throw new TypeError(
            "The target_and_container_storage_ref parameter "
            "must be of type StorageRef.")
    }
    if typename(index_storage_ref) != "obj" or
            not has_attr(index_storage_ref, "kind") or
            not has_attr(index_storage_ref, "id") {
        throw new TypeError("The index_storage_ref parameter "
            "must be of type StorageRef.")
    }
    if typename(value_storage_ref) != "obj" or
            not has_attr(value_storage_ref, "kind") or
            not has_attr(value_storage_ref, "id") {
        throw new TypeError("The value_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.target_and_container_storage_ref =
        target_and_container_storage_ref.copy()
    self.index_storage_ref = index_storage_ref.copy()
    self.value_storage_ref = value_storage_ref.copy()
}

func IMRSetIdx.as_str(indent=0) {
    return self.format_inst(
        "SETIDX", pos_parameter_names=[
            "target_and_container_storage_ref",
            "index_storage_ref",
            "value_storage_ref",
        ], indent=indent,
    )
}

func IMRSetIdx.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["target_and_container_storage_ref"] =
            self.target_and_container_storage_ref
    } else {
        obj["target_and_container_storage_ref"] =
            self.target_and_container_storage_ref.as_str()
    }
    if _passthrough_storage_refs {
        obj["index_storage_ref"] =
            self.index_storage_ref
    } else {
        obj["index_storage_ref"] =
            self.index_storage_ref.as_str()
    }
    if _passthrough_storage_refs {
        obj["value_storage_ref"] =
            self.value_storage_ref
    } else {
        obj["value_storage_ref"] =
            self.value_storage_ref.as_str()
    }
    return obj
}

type IMRGetIdx base IMRNode {
    var container_storage_ref
    var index_storage_ref
    var target_storage_ref
}

func IMRGetIdx.init(
        container_storage_ref=none,
        index_storage_ref=none,
        target_storage_ref=none,
        ) {
    base.init(IMR_INST_GETIDX)
    if typename(container_storage_ref) != "obj" or
            not has_attr(container_storage_ref, "kind") or
            not has_attr(container_storage_ref, "id") {
        throw new TypeError("The container_storage_ref parameter "
            "must be of type StorageRef.")
    }
    if typename(index_storage_ref) != "obj" or
            not has_attr(index_storage_ref, "kind") or
            not has_attr(index_storage_ref, "id") {
        throw new TypeError("The index_storage_ref parameter "
            "must be of type StorageRef.")
    }
    if typename(target_storage_ref) != "obj" or
            not has_attr(target_storage_ref, "kind") or
            not has_attr(target_storage_ref, "id") {
        throw new TypeError("The target_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.container_storage_ref = container_storage_ref.copy()
    self.index_storage_ref = index_storage_ref.copy()
    self.target_storage_ref = target_storage_ref.copy()
}

func IMRGetIdx.as_str(indent=0) {
    return self.format_inst(
        "GETIDX", pos_parameter_names=[
            "container_storage_ref",
            "index_storage_ref",
            "target_storage_ref",
        ], indent=indent,
    )
}
func IMRGetIdx.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj()
    if _passthrough_storage_refs {
        obj["container_storage_ref"] =
            self.container_storage_ref
    } else {
        obj["container_storage_ref"] =
            self.container_storage_ref.as_str()
    }
    if _passthrough_storage_refs {
        obj["index_storage_ref"] =
            self.index_storage_ref
    } else {
        obj["index_storage_ref"] =
            self.index_storage_ref.as_str()
    }
    if _passthrough_storage_refs {
        obj["target_storage_ref"] =
            self.target_storage_ref
    } else {
        obj["target_storage_ref"] =
            self.target_storage_ref.as_str()
    }
    return obj
}

type IMRCallArg {
    var ref
    var name
}

func IMRCallArg.init(ref, name) {
    self.ref = ref
    self.name = name
}

type IMRCall base IMRNode {
    var called_func_ref = none
    var return_value_ref = none

    var arg_count = 0
    var pos_arg_count = 0
    var kw_arg_count = 0
    var args = []
    var has_later = no
    var has_later_ignore = no
    var has_later_repeat = no
}

func IMRCall.init(
        called_func_ref=none,
        arg_refs=[],
        arg_names_if_any=[],
        has_later=no,
        has_later_ignore=no,
        has_later_repeat=no,
        return_value_ref=none,
        ) {
    base.init(IMR_INST_CALL)
    if arg_refs.len != arg_names_if_any.len {
        throw new RuntimeError(
            "The arg_refs list len and "
            "arg_names_if_any list len must match."
        )
    }
    if typename(called_func_ref) != "obj" or
            not has_attr(called_func_ref, "kind") or
            not has_attr(called_func_ref, "id") {
        throw new TypeError("The called_func_ref parameter "
            "must be of type StorageRef.")
    }
    if return_value_ref != none and (
            typename(return_value_ref) != "obj" or
            not has_attr(return_value_ref, "kind") or
            not has_attr(return_value_ref, "id")) {
        throw new TypeError("The return_value_ref parameter "
            "must be either none or of type StorageRef.")
    }
    self.has_later = has_later
    self.has_later_ignore = has_later_ignore
    self.has_later_repeat = has_later_repeat
    self.called_func_ref = called_func_ref.copy()
    if return_value_ref != none {
        self.return_value_ref = return_value_ref.copy()
    }
    var pos_args = []
    var kw_args = []
    var i = 1
    while i <= arg_refs.len {
        var ref = arg_refs[i]
        if typename(ref) != "obj" or
                not has_attr(ref, "kind") or
                not has_attr(ref, "id") {
            throw new TypeError("The arg_refs values "
                "must all be of type StorageRef.")
        }
        var name = none
        if arg_names_if_any[i] != none {
            name = arg_names_if_any[i] + ""
            self.kw_arg_count += 1
            kw_args.add([ref, name])
        } else {
            self.pos_arg_count += 1
            pos_args.add(ref)
        }
        self.arg_count += 1
        i += 1
    }
    i = 1
    while i <= pos_args.len {
        self.args.add(new IMRCallArg(
            pos_args[i], none))
        i += 1
    }
    i = 1
    while i <= kw_args.len {
        self.args.add(new IMRCallArg(
            kw_args[i][1], kw_args[i][2]
        ))
        i += 1
    }
}

func IMRCall.as_str(indent=0) {
    var t = ""
    var i = 1
    var k = 1
    while i <= self.arg_count {
        if self.args[i].name != none {
            t += " "
            t += textfmt.as_escaped_code_string(
                self.args[i].name)
            k += 1
        }
        t += " "
        t += self.args[i].ref.as_str()
        i += 1
    }
    return self.format_inst(
        "CALL", pos_parameter_names=[
            "called_func_ref",
            "return_value_ref",
            "arg_count",
        ], skip_parameter_names=[
            "args",
            "kw_arg_count",
        ], extra_text=t, indent=indent,
    )
}

func IMRCall.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["called_func_ref"] =
            self.called_func_ref
    } else {
        obj["called_func_ref"] =
            self.called_func_ref.as_str()
    }
    obj["has_later"] = self.has_later
    obj["has_later_ignore"] = self.has_later_ignore
    obj["has_later_repeat"] = self.has_later_repeat
    obj["arg_count"] = self.arg_count
    obj["kw_arg_count"] = self.kw_arg_count
    if _passthrough_storage_refs {
        obj["return_value_ref"] =
            self.return_value_ref
    } else {
        obj["return_value_ref"] =
            self.return_value_ref.as_str()
    }

    obj["args"] = []
    for arg in self.args {
        var argobj = {->}
        if _passthrough_storage_refs {
            argobj["ref"] = arg.ref
        } else {
            argobj["ref"] = arg.ref.as_str()
        }
        if arg.name != none {
            argobj["name"] = arg.name
        }
        obj["args"].add(argobj)
    }
    return obj
}

type IMRCond base IMRBlock {
    var evaluated_cond_ref = none
}

func IMRCond.init(
        evaluated_cond_ref=none,
        ) {
    base.init(IMR_BLOCK_COND)
    if typename(evaluated_cond_ref) != "obj" or
            not has_attr(evaluated_cond_ref, "kind") or
            not has_attr(evaluated_cond_ref, "id") {
        throw new TypeError("The evaluated_cond_ref parameter "
            "must be of type StorageRef.")
    }
    self.evaluated_cond_ref = evaluated_cond_ref.copy()
}

func IMRCond.as_str(indent=0) {
    return self.format_inst(
        "COND", pos_parameter_names=[
            "evaluated_cond_ref",
        ],
        skip_parameter_names=[
            "instructions",
        ],
        indent=indent,
    ) + " " + self.fmt_block(indent=indent)
}

func IMRCond.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["evaluated_cond_ref"] =
            self.evaluated_cond_ref
    } else {
        obj["evaluated_cond_ref"] =
            self.evaluated_cond_ref.as_str()
    }
    return obj
}

type IMRLoop base IMRBlock {
}

func IMRLoop.init {
    base.init(IMR_BLOCK_LOOP)
}

func IMRLoop.as_str(indent=0) {
    return self.format_inst(
        "LOOP", pos_parameter_names=[
        ],
        skip_parameter_names=[
            "instructions",
        ],
        indent=indent,
    ) + " " + self.fmt_block(indent=indent)
}

func IMRLoop.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    return obj
}

type IMRBreak base IMRNode {
}

func IMRBreak.init {
    base.init(IMR_INST_BREAK)
}

func IMRBreak.as_str(indent=0) {
    return self.format_inst(
        "BREAK", pos_parameter_names=[
        ],
        skip_parameter_names=[
        ],
        indent=indent,
    )
}

func IMRBreak.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    return obj
}

type IMRContinue base IMRNode {
}

func IMRContinue.init {
    base.init(IMR_INST_CONTINUE)
}

func IMRContinue.as_str(indent=0) {
    return self.format_inst(
        "CONTINUE", pos_parameter_names=[
        ],
        skip_parameter_names=[
        ],
        indent=indent,
    )
}

func IMRContinue.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    return obj
}

type IMRIterLoop base IMRBlock {
    var iterated_container_ref = none
    var iterator_store_ref = none
}

func IMRIterLoop.init(
        iterated_container_ref=none,
        iterator_store_ref=none,
        ) {
    base.init(IMR_BLOCK_ITERLOOP)
    if typename(iterated_container_ref) != "obj" or
            not has_attr(iterated_container_ref, "kind") or
            not has_attr(iterated_container_ref, "id") {
        throw new TypeError("The iterated_container_ref parameter "
            "must be of type StorageRef.")
    }
    if typename(iterator_store_ref) != "obj" or
            not has_attr(iterator_store_ref, "kind") or
            not has_attr(iterator_store_ref, "id") {
        throw new TypeError("The iterator_store_ref parameter "
            "must be of type StorageRef.")
    }
    self.iterator_store_ref = iterator_store_ref.copy()
    self.iterated_container_ref = iterated_container_ref.copy()
}

func IMRIterLoop.as_str(indent=0) {
    return self.format_inst(
        "ITERLOOP", pos_parameter_names=[
            "iterated_container_ref",
            "iterator_store_ref",
        ],
        skip_parameter_names=[
            "instructions",
        ],
        indent=indent,
    ) + " " + self.fmt_block(indent=indent)
}

func IMRIterLoop.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["iterator_store_ref"] =
            self.iterator_store_ref
    } else {
        obj["iterator_store_ref"] =
            self.iterator_store_ref.as_str()
    }
    if _passthrough_storage_refs {
        obj["iterated_container_ref"] =
            self.iterated_container_ref
    } else {
        obj["iterated_container_ref"] =
            self.iterated_container_ref.as_str()
    }
    return obj
}

type IMRReturn base IMRNode {
    var return_value_storage_ref = none
}

func IMRReturn.init(
        return_value_storage_ref=none,
        ) {
    base.init(IMR_INST_RETURN)
    if return_value_storage_ref != none and
            (typename(return_value_storage_ref) != "obj" or
             not has_attr(return_value_storage_ref, "kind") or
             not has_attr(return_value_storage_ref, "id")) {
        throw new TypeError("The return_value_storage_ref parameter "
            "must be none or of type StorageRef.")
    }
    if return_value_storage_ref != none {
        self.return_value_storage_ref =
            return_value_storage_ref.copy()
    }
}

func IMRReturn.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["return_value_storage_ref"] =
            self.return_value_storage_ref.copy()
    } else {
        obj["return_value_storage_ref"] =
            self.return_value_storage_ref.as_str()
    }
    return obj
}

func IMRReturn.as_str(indent=0) {
    return self.format_inst(
        "RETURN", pos_parameter_names=[
            "return_value_storage_ref",
        ], indent=indent,
    )
}


type IMRReturnFail base IMRNode {
}

func IMRReturnFail.init {
    base.init(IMR_INST_RETURNFAIL)
}

func IMRReturnFail.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    return obj
}

func IMRReturnFail.as_str(indent=0) {
    return self.format_inst(
        "RETURNFAIL", indent=indent,
    )
}

type IMRApplyOp base IMRNode {
    var is_binary = yes
    var op_token
    var target_storage_ref
    var operand_1_storage_ref
    var operand_2_storage_ref
}

func IMRApplyOp.init(op_token,
        operand_1_storage_ref=none,
        operand_2_storage_ref=none,
        target_storage_ref=none,
        is_binary=no,
        ) {
    base.init(IMR_INST_APPLY_OP)
    if typename(target_storage_ref) != "obj" or
            not has_attr(target_storage_ref, "kind") or
            not has_attr(target_storage_ref, "id") {
        throw new TypeError("The target_storage_ref parameter "
            "must be of type StorageRef.")
    }
    if typename(operand_1_storage_ref) != "obj" or
            not has_attr(operand_1_storage_ref, "kind") or
            not has_attr(operand_1_storage_ref, "id") {
        throw new TypeError("The operand_1_storage_ref parameter "
            "must be of type StorageRef.")
    }
    if operand_2_storage_ref != none and
            (typename(operand_2_storage_ref) != "obj" or
             not has_attr(operand_2_storage_ref, "kind") or
             not has_attr(operand_2_storage_ref, "id")) {
        throw new TypeError("The operand_2_storage_ref parameter "
            "must be of type StorageRef or none.")
    }
    if is_binary and operand_2_storage_ref == none {
        throw new TypeError("The operand_2_storage_ref parameter "
            "must be specified when is_binary is set to yes.")
    }
    if not is_binary and operand_2_storage_ref != none {
        throw new TypeError("The operand_2_storage_ref parameter "
        "cannot be specified when is_binary is set to no.")
    }
    self.target_storage_ref = target_storage_ref.copy()
    self.operand_1_storage_ref = operand_1_storage_ref.copy()
    self.operand_2_storage_ref = none
    if is_binary {
        self.is_binary = yes
        self.operand_2_storage_ref =
            operand_2_storage_ref.copy()
    } else {
        self.is_binary = no
    }
    self.op_token = op_token.copy()
}

func IMRApplyOp.as_str(indent=0) {
    if self.is_binary {
        return self.format_inst(
            "APPLYOP", pos_parameter_names=[
                "operand",
                "is_binary",
                "operand_1_storage_ref",
                "operand_2_storage_ref",
                "target_storage_ref",
            ], indent=indent,
        )
    } else {
        return self.format_inst(
            "APPLYOP", pos_parameter_names=[
                "operand",
                "is_binary",
                "operand_1_storage_ref",
                "target_storage_ref",
            ], indent=indent,
        )
    }
}

func IMRApplyOp.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["target_storage_ref"] =
            self.target_storage_ref
    } else {
        obj["target_storage_ref"] =
            self.target_storage_ref.as_str()
    }
    if _passthrough_storage_refs {
        obj["operand_1_storage_ref"] =
            self.operand_1_storage_ref
    } else {
        obj["operand_1_storage_ref"] =
            self.operand_1_storage_ref.as_str()
    }
    if self.is_binary {
        if _passthrough_storage_refs {
            obj["operand_2_storage_ref"] =
                self.operand_2_storage_ref
        } else {
            obj["operand_2_storage_ref"] =
                self.operand_2_storage_ref.as_str()
        }
    }
    obj["is_binary"] = self.is_binary
    obj["operand"] = self.op_token.str
    return obj
}

type IMRStructOrTypeBlock base IMRBlock {
    var parent_imr_node = none
    var is_union = no
    var is_type = no
    var is_struct = no
    var is_nested = no

    var label_to_st_id_map = {->}
    var st_id_to_inst_offset_map = {->}

    var init_instructions = []

    var storage_id = none
    var label = none
    var base_type_id = none
}

func IMRStructOrTypeBlock.init(
        global_type_or_storage_id, label,
        base_type_id=none,
        is_union=no,
        is_type=no,
        is_nested=no,
        parent_imr_node=none,
        ) {
    base.init(IMR_BLOCK_STRUCTORTYPE)
    if is_nested and parent_imr_node == none {
        throw new ValueError("For nested structs or types, "
            "the parent IMR node must be specified.")
    } elseif not is_nested {
        parent_imr_node = none
    }
    self.parent_imr_node = parent_imr_node
    if label != none {
        self.label = label + ""
    } elseif not is_nested {
        throw new ValueError(
            "Any top-level struct or type must "
            "have a name."
        )
    }
    if typename(is_union) != "bool" {
        throw new TypeError(
            "The is_union parameter must "
            "be a bool."
        )
    }
    self.is_union = is_union
    if typename(is_type) != "bool" {
        throw new TypeError(
            "The is_type parameter must "
            "be a bool."
        )
    }
    self.is_type = is_type
    self.is_struct = (not is_union and not is_type)
    if typename(global_type_or_storage_id) != "num" {
        throw new TypeError(
            "The global_type_or_storage_id parameter must "
            "be a num."
        )
    }
    if is_nested {
        if base_type_id != none {
            throw new ValueError(
                "Cannot have any storage ids "
                "for nested struct or union."
            )
        }
        self.is_nested = yes
    } else {
        self.storage_id = global_type_or_storage_id
        if base_type_id != none and
                typename(base_type_id) != "num" {
            throw new TypeError(
                "The base_type_id parameter must "
                "be a num or none."
            )
        }
        self.base_type_id = base_type_id
    }
}

func IMRStructOrTypeBlock.get_internal_init_func_attr_id {
    # FIXME: implement this properly.
    return -999
}

func IMRStructOrTypeBlock.register_var_attr(
        storage_id, label, def_project_file,
        init_insts=[], type_expr=none,
        is_moose64=no,
        ) {
    if storage_id == none {
        throw new ValueError("The storage_id "
            "for a var attr cannot be none.")
    }
    if label == none {
        throw new ValueError("The label for "
            "a var attr cannot be none.")
    }
    self.label_to_st_id_map[label] = storage_id
    var var_type_storage_ref = none
    func resolve_var_type {
        if type_expr == none {
            return later yes
        }
        var result = type_expr.try_resolve_to_user_type(
            def_project_file, is_moose64=is_moose64
        ) later:

        await result
        if result != none and
                not result.had_error and
                not result.resolved_to_nonuser_type {
            var_type_storage_ref = result.resolved_storage_ref
            return later yes
        }
        return later not result.had_error
    }
    var type_is_resolved = resolve_var_type()
    later:

    await type_is_resolved
    if not type_is_resolved {
        throw new RuntimeError("Internal error, "
            "unexpectedly failed to resolve var type.")
    }

    var new_inst = new IMRVarInfo(
        label, type_expr, storage_id, var_type_storage_ref,
        def_project_file,
    )
    var new_offset = self.instructions.len + 1
    self.instructions.add(new_inst)
    self.st_id_to_inst_offset_map[storage_id] = new_offset
    if init_insts != none and init_insts.len > 0 {
        self.init_instructions += init_insts
    }
    return later
}

func IMRStructOrTypeBlock.register_struct_or_union_attr(
        storage_id, label, block_item,
        ) {
    if storage_id == none {
        throw new ValueError("The storage_id "
            "for a var attr cannot be none.")
    }
    if not has_attr(block_item, "kind") or
            block_item.kind != IMR_BLOCK_STRUCTORTYPE {
        throw new ValueError("The item registered must "
            "be an IMR node of kind IMR_BLOCK_STRUCTORTYPE.")
    }
    self.label_to_st_id_map[label] = storage_id
    var new_offset = self.instructions.len + 1
    self.instructions.add(block_item)
    self.st_id_to_inst_offset_map[storage_id] = new_offset
}

func IMRStructOrTypeBlock.as_str(indent=0) {
    var name = "STRUCTBLOCK"
    if self.is_union {
        name = "UNIONBLOCK"
    } elseif self.is_struct {
        name = "STRUCTBLOCK"
    }
    return self.format_inst(
        name, pos_parameter_names=[
            "storage_id",
            "label",
        ], skip_parameter_names=[
            "instructions",
        ], indent=indent,
    ) + " " + self.fmt_block(indent=indent)
}

func IMRStructOrTypeBlock.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    obj["label"] = self.label
    obj["storage_id"] = self.storage_id
    obj["base_type_id"] = self.base_type_id
    obj["is_union"] = self.is_union
    obj["is_struct"] = self.is_struct
    return obj
}

type IMRFuncBlock base IMRBlock {
    var is_func_attr = no
    var is_extend = no

    var global_func_id = none
    var global_type_id = none
    var type_attr_id = none
    var func_scope = none
    var label = none
    var type_path = none
    var storage_ref = none

    var pos_arg_count = 0
    var kw_arg_count = 0
    var kw_arg_names = []
    var known_arg_type_exprs = []
    var known_arg_type_storage_refs = []
    var known_return_type_expr = none
    var known_return_type_storage_ref = none

    var storage_id_to_known_type_info = {->}
    var storage_id_to_known_type_expr = {->}
    var var_info_stmts = []
}

func IMRFuncBlock.init(
        func_scope, label,
        storage_ref,
        pos_arg_count=0,
        kw_arg_count=0,
        has_return_value=yes,
        kw_arg_names=[],
        known_arg_type_exprs=[],
        known_arg_type_storage_refs=[],
        known_return_type_expr=none,
        known_return_type_storage_ref=none,
        type_path=none,
        is_extend=no,
        ) {
    base.init(IMR_BLOCK_FUNC)
    self.func_scope = func_scope
    self.label = label + ""
    self.is_extend = is_extend
    if storage_ref == none or
            not has_attr(storage_ref, "kind") or
            (storage_ref.kind != st_ref.ST_GLOBAL and
             storage_ref.kind != st_ref.ST_GLOBALATTR) {
        throw new ValueError(
            "No storage_ref was specified, or "
            "it's not of kind ST_GLOBAL or "
            "ST_GLOBALATTR."
        )
    }
    if kw_arg_count != kw_arg_names.len {
        throw new ValueError(
            "The given kw_arg_count must match "
            "the length of the given kw_arg_names list."
        )
    }
    self.storage_ref = storage_ref.copy()
    self.is_func_attr =
        storage_ref.kind == st_ref.ST_GLOBALATTR
    if self.is_func_attr {
        if type_path == none or type_path.len == 0 {
            throw new ValueError(
                "Missing type_path for a func attr."
            )
        }
        self.type_path = type_path.copy()
    } else {
        if type_path != none and type_path.len > 0 {
            throw new ValueError(
                "Unexpected type_path for a func that "
                "isn't a func attr."
            )
        }
    }
    self.pos_arg_count = pos_arg_count
    self.kw_arg_count = kw_arg_count
    var i = 1
    while i <= self.pos_arg_count + self.kw_arg_count {
        self.known_arg_type_exprs.add(
            known_arg_type_exprs[i]
        )
        self.known_arg_type_storage_refs.add(
            known_arg_type_storage_refs[i]
        )
        i += 1
    }
    self.known_return_type_expr = known_return_type_expr
    self.known_return_type_storage_ref =
        known_return_type_storage_ref
    for name in kw_arg_names {
        self.kw_arg_names.add(name + "")
    }
}

func IMRFuncBlock.update_var_type_exprs(
        project_file, is_moose64=no, msgs=none,
        ) {
    self.var_info_stmts = []

    var resolve_expr_queue = []
    for st_id in self.storage_id_to_known_type_info {
        var typeinfo_value = self.storage_id_to_known_type_info[
            st_id
        ]
        if typeinfo_value == none {
            assert(self.label != "init_as_copy" or st_id != 1 or
                not self.storage_id_to_known_type_expr.has(st_id) or
                self.storage_id_to_known_type_expr[st_id] == none)
            self.storage_id_to_known_type_expr[st_id] = none
            continue
        }
        if not self.storage_id_to_known_type_expr.has(st_id) {
            var var_type_expr = typeinfo_value.convert_to_typeref_expr(
                project=project_file.project,
                in_local_scope=none,
                in_project_file=project_file,
                is_moose64=is_moose64,
            )
            self.storage_id_to_known_type_expr[
                st_id
            ] = var_type_expr
        }
    }
    for st_id in self.storage_id_to_known_type_expr {
        var texpr = self.storage_id_to_known_type_expr[st_id]
        if is_moose64 and texpr == none {
            if msgs == none {
                throw new ValueError("Failed to get type "
                    "for value expression, this is likely "
                    "a follow-up to a previous code error.")
            } elseif not msg.msgs_contain_error(msgs) {
                var tinfo = self.storage_id_to_known_type_info[
                    st_id
                ]
                msgs.add(new msg.FileMsg(
                    "Internal error, failed to "
                    "get type expr for local var despite "
                    "there not being a previous error. This "
                    "shouldn't happen. Please contact the "
                    "compiler makers about this error. "
                    "Details: st_id=" + st_id.as_str() + " "
                    "IMRFuncBlock.label=" +
                        textfmt.as_escaped_code_string(self.label) + " "
                    "tinfo=" + tinfo.as_str(),
                    source_file=project_file,
                    line=self.line,
                    col=self.col,
                ))
            }
        }
        resolve_expr_queue.add(
            [st_id, texpr]
        )
    }

    func handle_queue_item(item) {
        var st_id = item[1]
        var var_type_expr = item[2]

        func resolve_type_if_any {
            if var_type_expr == none {
                return later
            }
            var_type_expr.try_resolve_to_user_type(
                project_file,
                is_moose64=is_moose64,
            ) later:
        }
        resolve_type_if_any() later:

        var var_type_storage_ref = none
        if var_type_expr != none and
                var_type_expr.is_user_type() and
                var_type_expr.storage_ref != none {
            var_type_storage_ref = var_type_expr.storage_ref.copy()
        }
        var vinfo = new IMRVarInfo(
            "tmp" + st_id.as_str(),
            var_type_expr,
            st_id,
            var_type_storage_ref,
            project_file,
        )
        self.var_info_stmts.add(vinfo)
    }

    if resolve_expr_queue.len == 0 {
        return later
    }
    var next_item = resolve_expr_queue.pop()
    var result = handle_queue_item(next_item)
    later:

    await result
    if resolve_expr_queue.len == 0 {
        return later
    }
    next_item = resolve_expr_queue.pop()
    result = handle_queue_item(next_item)
    later repeat
}

func IMRFuncBlock.get_func_tracker(tracker) {
    assert(self.storage_ref != none)
    assert(self.storage_ref.kind == st_ref.ST_GLOBALATTR or
        self.storage_ref.kind == st_ref.ST_GLOBAL)
    var key = self.storage_ref.id
    if typename(key) == "list" {
        key = key.as_str()
    }
    if not tracker.imr_func_id_to_tracker_info_map.has(key) {
        tracker.imr_func_id_to_tracker_info_map[key] =
            new IMRBuildTrackerFunc()
    }
    return tracker.imr_func_id_to_tracker_info_map[key]
}

func IMRFuncBlock.as_str(indent=0) {
    var t = ""
    t += self.format_inst(
        "FUNCBLOCK", pos_parameter_names=[
            "storage_ref", "label",
        ], skip_parameter_names=[
            "instructions",
            "is_func_attr",
            "is_extend",
            "type_path",
            "arg_*_type_expr",
            "arg_*_type_expr_storage_ref",
            "arg_*_kw_name",
        ], indent=indent,
    )
    t += " " + self.pos_arg_count.as_str()
    t += " " + self.kw_arg_count.as_str()
    if self.is_func_attr {
        t += " TYPE_PATH=" + self.type_path.join(".")
    }
    var i = 1
    while i <= self.pos_arg_count {
        var value = none
        if i <= self.known_arg_type_exprs.len {
            value = self.known_arg_type_exprs[i]
        }
        t += " ARG_" + i.as_str() + "_TYPE_EXPR="
        if value == none {
            t += "none"
        } else {
            t += value.as_str()
            t += " ARG_" + i.as_str() + "_TYPE_EXPR_STORAGE_REF=" +
                self.known_arg_type_storage_refs[i].as_str()
        }
        i += 1
    }
    while i <= self.pos_arg_count + self.kw_arg_count {
        var value = none
        if i <= self.known_arg_type_exprs.len {
            value = self.known_arg_type_exprs[i]
        }
        t += " ARG_" + i.as_str() + "_TYPE_EXPR="
        if value == none {
            t += "none"
        } else {
            t += vvalue.as_str()
            t += " ARG_" + i.as_str() + "_TYPE_EXPR_STORAGE_REF=" +
                self.known_arg_type_storage_refs[i].as_str()
        }
        i += 1
    }
    var k = 1
    while k <= self.kw_arg_count {
        i = self.pos_arg_count + k
        t += " ARG_" + i.as_str() + "_KW_NAME=" +
            textfmt.as_escaped_code_string(self.kw_arg_names[k])
        k += 1
    }
    if self.known_return_type_expr != none {
        t += " RETURN_TYPE_EXPR=" +
            self.known_return_type_expr.as_str()
        t += " RETURN_TYPE_EXPR_STORAGE_REF=" +
            self.known_return_type_storage_ref.as_str()
    }
    t += " IS_EXTEND=" + if self.is_extend ("yes") else ("no")
    t += " " + self.fmt_block(
        indent=indent,
        prepend_stmts=self.var_info_stmts,
    )
    return t
}

func IMRFuncBlock.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    obj["label"] = self.label
    obj["is_func_attr"] = self.is_func_attr
    if _passthrough_storage_refs {
        obj["storage_ref"] = self.storage_ref
    } else {
        obj["storage_ref"] = self.storage_ref.as_str()
    }
    obj["is_extend"] = self.is_extend == yes
    if self.is_func_attr {
        assert(self.type_path != none)
        obj["type_path"] = self.type_path.copy()
    } else {
        assert(self.type_path == none or
            self.type_path.len == 0)
    }
    var i = 1
    while i <= self.pos_arg_count + self.kw_arg_count {
        var value = none
        if i <= self.known_arg_type_exprs.len {
            value = self.known_arg_type_exprs[i]
        }
        obj["arg_" + i.as_str() + "_type_expr"] = none
        obj["arg_" + i.as_str() + "_type_expr_storage_ref"] = none
        if value != none {
            obj["arg_" + i.as_str() + "_type_expr"] = value.as_str()
            if _passthrough_storage_refs {
                obj["arg_" + i.as_str() + "_type_expr_storage_ref"] =
                    self.known_arg_type_storage_refs[i]
            } else {
                obj["arg_" + i.as_str() + "_type_expr_storage_ref"] =
                    self.known_arg_type_storage_refs[i].as_str()
            }
        }
        i += 1
    }
    var k = 1
    while k <= self.kw_arg_count {
        i = self.pos_arg_count + k
        obj["arg_" + i.as_str() + "_kw_name"] =
            self.kw_arg_names[k]
        k += 1
    }
    return obj
}

type IMRAsref base IMRNode {
    var asref_source_storage_ref = none
    var target_storage_ref = none
}

func IMRAsref.init(
        asref_source_storage_ref=none,
        target_storage_ref=none,
        ) {
    base.init(IMR_INST_ASREF)
    if typename(asref_source_storage_ref) != "obj" or
             not has_attr(asref_source_storage_ref, "kind") or
             not has_attr(asref_source_storage_ref, "id") {
        throw new TypeError("The asref_source_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.asref_source_storage_ref =
        asref_source_storage_ref.copy()
    if typename(target_storage_ref) != "obj" or
             not has_attr(target_storage_ref, "kind") or
             not has_attr(target_storage_ref, "id") {
        throw new TypeError("The target_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.target_storage_ref =
        target_storage_ref.copy()
}

func IMRAsref.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["asref_source_storage_ref"] =
            self.asref_source_storage_ref.copy()
    } else {
        obj["asref_source_storage_ref"] =
            self.asref_source_storage_ref.as_str()
    }
    if _passthrough_storage_refs {
        obj["target_storage_ref"] =
            self.target_storage_ref.copy()
    } else {
        obj["target_storage_ref"] =
            self.target_storage_ref.as_str()
    }
    return obj
}

func IMRAsref.as_str(indent=0) {
    return self.format_inst(
        "ASREF", pos_parameter_names=[
            "asref_source_storage_ref",
            "target_storage_ref",
        ], indent=indent,
    )
}

type IMRSizeof base IMRNode {
    var sizeof_source_storage_ref = none
    var target_storage_ref = none
}

func IMRSizeof.init(
        sizeof_source_storage_ref=none,
        target_storage_ref=none,
        ) {
    base.init(IMR_INST_SIZEOF)
    if typename(sizeof_source_storage_ref) != "obj" or
             not has_attr(sizeof_source_storage_ref, "kind") or
             not has_attr(sizeof_source_storage_ref, "id") {
        throw new TypeError("The sizeof_source_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.sizeof_source_storage_ref =
        sizeof_source_storage_ref.copy()
    if typename(target_storage_ref) != "obj" or
             not has_attr(target_storage_ref, "kind") or
             not has_attr(target_storage_ref, "id") {
        throw new TypeError("The target_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.target_storage_ref =
        target_storage_ref.copy()
}

func IMRSizeof.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["sizeof_source_storage_ref"] =
            self.sizeof_source_storage_ref.copy()
    } else {
        obj["sizeof_source_storage_ref"] =
            self.sizeof_source_storage_ref.as_str()
    }
    if _passthrough_storage_refs {
        obj["target_storage_ref"] =
            self.target_storage_ref.copy()
    } else {
        obj["target_storage_ref"] =
            self.target_storage_ref.as_str()
    }
    return obj
}

func IMRSizeof.as_str(indent=0) {
    return self.format_inst(
        "SIZEOF", pos_parameter_names=[
            "sizeof_source_storage_ref",
            "target_storage_ref",
        ], indent=indent,
    )
}

type IMRDeref base IMRNode {
    var deref_source_storage_ref = none
    var target_storage_ref = none
}

func IMRDeref.init(
        deref_source_storage_ref=none,
        target_storage_ref=none,
        ) {
    base.init(IMR_INST_DEREF)
    if typename(deref_source_storage_ref) != "obj" or
             not has_attr(deref_source_storage_ref, "kind") or
             not has_attr(deref_source_storage_ref, "id") {
        throw new TypeError("The deref_source_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.deref_source_storage_ref =
        deref_source_storage_ref.copy()
    if typename(target_storage_ref) != "obj" or
             not has_attr(target_storage_ref, "kind") or
             not has_attr(target_storage_ref, "id") {
        throw new TypeError("The target_storage_ref parameter "
            "must be of type StorageRef.")
    }
    self.target_storage_ref =
        target_storage_ref.copy()
}

func IMRDeref.as_json_obj(
        _passthrough_storage_refs=no,
        ) {
    var obj = base.as_json_obj(
        _passthrough_storage_refs=
            _passthrough_storage_refs)
    if _passthrough_storage_refs {
        obj["deref_source_storage_ref"] =
            self.deref_source_storage_ref.copy()
    } else {
        obj["deref_source_storage_ref"] =
            self.deref_source_storage_ref.as_str()
    }
    if _passthrough_storage_refs {
        obj["target_storage_ref"] =
            self.target_storage_ref.copy()
    } else {
        obj["target_storage_ref"] =
            self.target_storage_ref.as_str()
    }
    return obj
}

func IMRDeref.as_str(indent=0) {
    return self.format_inst(
        "DEREF", pos_parameter_names=[
            "deref_source_storage_ref",
            "target_storage_ref",
        ], indent=indent,
    )
}

enum IMRNodeKind {
    IMR_BLOCK_FUNC,
    IMR_BLOCK_COND,
    IMR_BLOCK_LOOP,
    IMR_BLOCK_ITERLOOP,
    IMR_BLOCK_STRUCTORTYPE,
    IMR_BLOCK_TYPE,
    IMR_BLOCK_DO,
    IMR_BLOCK_DO_C,
    IMR_BLOCK_RESCUE,
    IMR_BLOCK_FINALLY,
    IMR_BLOCK_WITH,
    IMR_INST_VARINFO,
    IMR_INST_CONV,
    IMR_INST_MOVE,
    IMR_INST_ASREF,
    IMR_INST_DEREF,
    IMR_INST_SIZEOF,
    IMR_INST_APPLY_OP,
    IMR_INST_GETLISTARGLEN,
    IMR_INST_CALL,
    IMR_INST_BREAK,
    IMR_INST_CONTINUE,
    IMR_INST_RETURN,
    IMR_INST_RETURNFAIL,
    IMR_INST_AWAIT,
    IMR_INST_CLRZERO,
    IMR_INST_SETLIT,
    IMR_INST_SETIDX,
    IMR_INST_SETATTRBYNAME,
    IMR_INST_SETATTRBYID,
    IMR_INST_GETIDX,
    IMR_INST_GETATTRBYNAME,
    IMR_INST_GETATTRBYID,
}

type IMRForFile {
    var project_file

    var blocks = []
}

func IMRForFile.as_str(indent=0) {
    var t = "IMRForFile{" +
        "project_file=" + self.project_file.as_str()
    t += ",blocks=" + self.blocks.as_str()
    return t + "}"
}

func IMRForFile.ensure_loaded {
    # FIXME: Eventually, we want to support swapping
    # all the inner contents to disk, and this will
    # restore them again into memory.
    return later
}

func IMRForFile.find_global_func_by_label(
        label, type_path=none) {
    for block in self.blocks {
        if block.kind != IMR_BLOCK_FUNC {
            continue
        }
        if type_path == none or type_path.len == 0 {
            if block.is_func_attr {
                continue
            }
            if block.label == label {
                return block
            }
        } else {
            if not block.is_func_attr {
                continue
            }
        }
    }
    return none
}

type ExprIMRResult {
    var instructions = []
    var storage_ref
    var known_type_info

    var need_conversion = no
    var need_conversion_from = none
    var need_conversion_to = none
}

func ExprIMRResult.as_str {
    var t = "ExprIMRResult{"
    t += "instructions=" + self.instructions.as_str()
    t += ",storage_ref=" + self.storage_ref.as_str()
    t += ",known_type_info=" + self.known_type_info.as_str()
    return t + "}"
}

func get_new_temp_storage_ref(
        node, imr_parents=[],
        func_imr_parent=none,
        file_imr_parent=none,
        optional_type_info=none,
        project_file=none,
        imr_build_tracker=none,
        is_moose64=no, msgs=none,
        ) {
    assert(imr_build_tracker != none)
    if func_imr_parent != none {
        var func_tracker = func_imr_parent.get_func_tracker(
            imr_build_tracker
        )
        assert(func_tracker.last_assigned_temp_storage_id <= 0)
        var new_value =
            func_tracker.last_assigned_temp_storage_id - 1
        func_tracker.last_assigned_temp_storage_id = new_value
        func_imr_parent.storage_id_to_known_type_info[
            new_value
        ] = none
        if optional_type_info != none {
            func_imr_parent.storage_id_to_known_type_info[
                new_value
            ] = optional_type_info.copy()
        }
        func_imr_parent.update_var_type_exprs(
            project_file,
            is_moose64=is_moose64,
            msgs=msgs,
        ) later:

        return later new st_ref.StorageRef(
            st_ref.ST_LOCAL,
            new_value
        )
    }
    throw new RuntimeError("Cannot generate IMR "
        "storage num without a func parent. All "
        "code running needs to be inside a func.")
}

func _is_node_a_compiler_builtin(
        pfile, node,
        only_check_for_non_callable_builtins=no,
        is_moose64=no) {
    if not is_moose64 {
        return no
    }

    var known_inner_storage_ref = none
    if node.kind == ast.N_EXPR_IDREF {
        known_inner_storage_ref = node.ref
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.optoken.str == "." and
            node.subexprs.len >= 2 and
            node.subexprs[2].kind == ast.N_EXPR_IDREF {
        known_inner_storage_ref = node.subexprs[2].ref
    }
    if known_inner_storage_ref == none {
        return no
    }
    if known_inner_storage_ref.kind != st_ref.ST_MCREF {
        return no
    }

    if m64_builtins.is_ast_node_referring_to_m64_builtin_assert(
            pfile, node, is_moose64=is_moose64) and
            not only_check_for_non_callable_builtins {
        return yes
    }
    if m64_builtins.is_ast_node_referring_to_m64_memory_size_of(
            pfile, node, is_moose64=is_moose64) {
        return yes
    }
    if m64_builtins.is_ast_node_referring_to_m64_memory_as_ref(
            pfile, node, is_moose64=is_moose64) {
        return yes
    }
    if m64_builtins.is_ast_node_referring_to_m64_list_arg_forward(
            pfile, node, is_moose64=is_moose64) {
        return yes
    }
    if m64_builtins.is_ast_node_referring_to_m64_list_arg_len(
            pfile, node, is_moose64=is_moose64) {
        return yes
    }
    if m64_builtins.is_ast_node_referring_to_m64_list_arg_get(
            pfile, node, is_moose64=is_moose64) {
        return yes
    }

    return no
}

func generate_imr_for_indexing_expr(
        node,
        node_parents=[],
        imr_parents=[],
        func_imr_parent=none,
        file_imr_parent=none,
        project_file=none,
        imr_build_tracker=none,
        is_moose64=no, msgs=none,
        debug=no,
        ) {
    var result_insts = []
    var idx_result = generate_imr_for_expr(
        node,
        node_parents=node_parents,
        imr_parents=imr_parents,
        func_imr_parent=func_imr_parent,
        file_imr_parent=file_imr_parent,
        project_file=project_file,
        imr_build_tracker=imr_build_tracker,
        is_moose64=is_moose64, msgs=msgs,
    ) later:

    await idx_result
    if debug {
        print(program_name + ": debug: "
            "generate_imr_for_indexing_expr(): "
            "We got an indexing result. "
            "idx_result=" + idx_result.as_str())
    }
    var attr_type_name = none
    if is_moose64 {
        attr_type_name = typeinfo.
            get_addr_type_name_for_platform(
                imr_build_tracker.build_options,
                is_moose64=is_moose64,
            )
    }
    var idx_tmp_ref = none
    if idx_result == none {
        result_insts = none
        return later none
    }
    idx_tmp_ref = idx_result.storage_ref

    func handle_idx_conversion {
        if not is_moose64 {
            return later
        }
        if idx_result.known_type_info == none {
            if msgs == none or
                    not msg.msgs_contain_error(msgs) {
                throw new RuntimeError("Failed to "
                    "get index type.")
            }
        }
        if idx_result.known_type_info.is_equivalent(
                typeinfo.create_from_simple_m64_type(
                    attr_type_name
                ),
                is_moose64=is_moose64,
                ) {
            return later
        }
        idx_tmp_ref = get_new_temp_storage_ref(
            node, imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            project_file=project_file,
            optional_type_info=
                typeinfo.create_from_simple_m64_type(
                    attr_type_name
                ),
            imr_build_tracker=imr_build_tracker,
            is_moose64=is_moose64, msgs=msgs,
        ) later:

        await idx_tmp_ref
        if idx_result.known_type_info.kind == typeinfo.TI_C_TYPE and
                ast_typeref.
                builtin_moose64_address_indexing_types.has(
                    idx_result.known_type_info.
                        orig_type_name
                ) {
            result_insts.add(new IMRConv(
                idx_result.storage_ref,
                idx_tmp_ref,
                idx_result.known_type_info,
                typeinfo.create_from_simple_m64_type(
                    attr_type_name
                ),
                in_project_file=project_file,
                is_moose64=is_moose64,
            ))
        } else {
            msgs.add(new msg.FileMsg(
                "Unexpected assignment of value of "
                "type " + idx_result.known_type_info.
                    describe_to_user(
                        project=project_file.project,
                        add_quotes_where_useful=yes,
                        is_moose64=is_moose64,
                    ) + ", "
                "cannot be converted to an index "
                "value implicitly.",
                source_file=project_file,
                line=right_hand_result.line,
                col=right_hand_result.col,
            ))
        }
    }
    handle_idx_conversion() later:

    if result_insts == none {
        return later none
    }
    var final_result = new ExprIMRResult()
    final_result.instructions =
        idx_result.instructions + result_insts
    final_result.storage_ref = idx_tmp_ref
    if is_moose64 {
        final_result.known_type_info =
            typeinfo.create_from_simple_m64_type(
                attr_type_name
            )
    }
    return final_result
}

func generate_imr_for_expr(
        node,
        node_parents=[],
        imr_parents=[],
        func_imr_parent=none,
        file_imr_parent=none,
        project_file=none,
        imr_build_tracker=none,
        try_target_storage_ref=none,
        convert_to_target_type=none,
        conversion_not_limited_to_regular_implicit=no,
        return_value_is_ignored=no,
        is_moose64=no, msgs=none,
        debug=no,
        ) {
    const program_name =
        if is_moose64 ("moosec") else ("horsec")
    assert(imr_build_tracker != none)
    var result = _generate_imr_for_expr_untyped(
        node,
        node_parents=node_parents,
        imr_parents=imr_parents,
        func_imr_parent=func_imr_parent,
        file_imr_parent=file_imr_parent,
        project_file=project_file,
        imr_build_tracker=imr_build_tracker,
        try_target_storage_ref=try_target_storage_ref,
        return_value_is_ignored=return_value_is_ignored,
        is_moose64=is_moose64,
        msgs=msgs,
        debug=debug,
    ) later:

    await result
    if debug {
        print(program_name + ": debug: " +
            "generate_imr_for_expr(): "
            "Got inner expression result for node "
            "and now we're evaluating the "
            "type: result=" + result.as_str())
    }
    if result == none or (result.storage_ref == none and
            not return_value_is_ignored) {
        if msgs == none {
            throw new RuntimeError(
                "Unexpectedly failed to generate IMR "
                "for expresson.")
        } elseif not msg.msgs_contain_error(msgs) {
            msgs.add(new msg.FileMsg(
                "Internal error, unexpectedly failed to "
                "generate IMR for expression node. Please "
                "report this to the compiler makers. "
                "msgs=" + msgs.as_str() + " "
                "result=" + result.as_str() + " "
                "node=" + node.as_str().sub(1, 400) + "...",
                source_file=project_file,
                line=node.line,
                col=node.col,
            ))
        }
        return later result
    }

    update_typing_for_imr_expr(
        result, node,
        node_parents=node_parents,
        imr_parents=imr_parents,
        func_imr_parent=func_imr_parent,
        file_imr_parent=file_imr_parent,
        project_file=project_file,
        imr_build_tracker=imr_build_tracker,
        is_moose64=is_moose64,
        msgs=msgs,
        debug=debug,
    ) later:

    if is_moose64 and
            not result.need_conversion and
            convert_to_target_type != none and
            result.known_type_info != none and
            not convert_to_target_type.is_equivalent(
                result.known_type_info,
                ignore_self_ref=yes,
            ) {
        result.need_conversion = yes
        result.need_conversion_from = result.known_type_info
        result.need_conversion_to = convert_to_target_type
    }
    func do_conversion_if_needed {
        if not result.need_conversion {
            return later
        }
        assert((try_target_storage_ref != none and
            not try_target_storage_ref.alike(
                result.storage_ref)) or
            convert_to_target_type != none)
        assert(convert_to_target_type == none or
            convert_to_target_type.is_equivalent(
                result.need_conversion_to,
                ignore_self_ref=yes,
            ))
        func get_new_tmp_target_if_needed {
            if try_target_storage_ref != none {
                return later
            }
            try_target_storage_ref = get_new_temp_storage_ref(
                node, imr_parents=imr_parents,
                func_imr_parent=func_imr_parent,
                file_imr_parent=file_imr_parent,
                optional_type_info=result.need_conversion_to,
                project_file=project_file,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64,
                msgs=msgs,
            ) later:

            await try_target_storage_ref
            assert(try_target_storage_ref != none)
        }
        get_new_tmp_target_if_needed() later:

        if not conversion_not_limited_to_regular_implicit and
                is_moose64 and
                not node.damaged {
            var inner_result = m64_autocast.
                check_if_allowed_implicit_cast_from_to(
                    result.need_conversion_from,
                    result.need_conversion_to,
                    left_side_is_literal_none=
                        node == none or
                        (node.kind == ast.N_EXPR_LIT and
                         node.literal_kind == ast_expr.LK_NORMAL and
                         node.value == none),
                    right_side_is_literal_none=no,
                    is_moose64=no,
                    debug=no
                )
            if not inner_result {
                if msgs == none {
                    throw new RuntimeError("Encountered incompatible "
                        "type use.")
                }
                if not node.damaged {
                    msgs.add(new msg.FileMsg(
                        "Unexpected value of type " +
                        result.need_conversion_from.describe_to_user(
                            project=project_file.project,
                            is_moose64=is_moose64) + ", "
                        "expected a value of type " +
                        result.need_conversion_to.describe_to_user(
                            project=project_file.project,
                            is_moose64=is_moose64) + ".",
                        source_file=project_file,
                        line=node.line,
                        col=node.col,
                    ))
                }
                node.damaged = yes
            }
        }
        var inst = new IMRConv(
            result.storage_ref,
            try_target_storage_ref,
            result.need_conversion_from,
            result.need_conversion_to,
            in_project_file=project_file,
            is_moose64=is_moose64,
        )
        result.instructions.add(inst)
    }
    do_conversion_if_needed() later:

    return result
}
func update_typing_for_imr_expr(
        result, node,
        node_parents=[],
        imr_parents=[],
        func_imr_parent=none,
        file_imr_parent=none,
        project_file=none,
        imr_build_tracker=none,
        is_moose64=no, msgs=none,
        debug=no,
        ) {
    if result == none or
            result.known_type_info != none or
            node.damaged {
        return later result
    }

    var value_tinfo = none
    func analyze_type_if_needed {
        if not is_moose64 {
            return later
        }
        if _is_node_a_compiler_builtin(
                project_file, node,
                only_check_for_non_callable_builtins=yes,
                is_moose64=is_moose64) {
            return later
        }
        value_tinfo = m64_ast_analyze.get_c_or_m64_type_of_node(
            project_file, node, node_parents,
            store_self_value_ref_for_funcs=yes,
            msgs=msgs,
        ) later:

        await value_tinfo
        if value_tinfo == none {
            node.damaged = yes
            if msgs == none or
                    not msg.msgs_contain_error(msgs) {
                print("horsec: error: Internal error, "
                    "got no error of any kind, yet couldn't "
                    "get the type of this node: " +
                    node.as_str().sub(1, 500))
                print("horsec: error: Now replaying debug info...")
                node.damaged = no  # XXX: Needed for replay to work.
                var _unused = m64_ast_analyze.get_c_or_m64_type_of_node(
                    project_file, node, node_parents,
                    store_self_value_ref_for_funcs=yes,
                    msgs=msgs,
                    debug=yes,
                ) later:

                await _unused
                node.damaged = yes  # XXX: Restore old state.
                throw new RuntimeError("Internal error, "
                    "unexpectedly failed to analyze type of "
                    "node. Please report this to the compiler "
                    "makers.")
            }
        }
    }
    analyze_type_if_needed() later:

    result.known_type_info = value_tinfo
    return later
}

func _generate_imr_for_expr_untyped(
        node,
        node_parents=[],
        imr_parents=[],
        func_imr_parent=none,
        file_imr_parent=none,
        project_file=none,
        imr_build_tracker=none,
        try_target_storage_ref=none,
        return_value_is_ignored=no,
        is_moose64=no, msgs=none,
        debug=no,
        ) {
    const program_name = if is_moose64 ("moosec") else ("horsec")
    var irregular_binop_strs = {"[", "(", ".", "new"}
    var func_parent_node = none
    var func_tracker = none
    if func_imr_parent != none {
        func_tracker = func_imr_parent.get_func_tracker(
            imr_build_tracker
        )
        var i = node_parents.len
        while i >= 1 {
            if {ast.N_STMT_FUNC, ast.N_STMT_FUNCEXTEND}.has(
                    node_parents[i].kind) {
                func_parent_node = node_parents[i]
                break
            }
            i -= 1
        }
    } else {
        throw new RuntimeError(
            "Cannot evaluate expression outside of func."
        )
    }

    if debug {
        print(program_name + ": debug: " +
            "generate_imr_for_expr(): Called on node: " +
            node.as_str().sub(1, 150))
    }

    func find_list_arg(
            based_on_func_type_info=none,
            subtract_implicit_self_arg=no,
            ) {
        if func_parent_node == none {
            return "Unexpected attempt to use list arg "
                "outside of a func."
        }
        var arg_type_exprs = none
        if based_on_func_type_info == none {
            arg_type_exprs =
                func_parent_node.extended_final_arg_type_exprs(
                    include_outer_extends=no
                )
        } else {
            if based_on_func_type_info.func_typeexpr == none {
                throw new TypeError("Supplied type info "
                    "doesn't seem to be a func.")
            }
            arg_type_exprs = []
            var source = based_on_func_type_info.
                func_typeexpr.arg_typeref_exprs
            var idx = 1
            while idx <= source.len {
                if subtract_implicit_self_arg {
                    idx += 1
                    continue
                }
                if idx == source.len and
                        based_on_func_type_info.is_failable() {
                    assert(not source[idx].is_func_ref and
                        not source[idx].is_user_type() and
                        source[idx].name ==
                            "moose64_failed_result_t")
                    break
                }
                arg_type_exprs.add(source[idx])
                idx += 1
            }
        }
        var candidate_idx = none
        var idx = 1
        while idx <= arg_type_exprs.len {
            if arg_type_exprs[idx] == none or
                    not arg_type_exprs[idx].is_list_arg {
                idx += 1
                continue
            }
            if candidate_idx != none {
                # This is invalid, we have two multi args.
                return "Unexpected func found that has "
                    "more than one list arg, this isn't "
                    "allowed."
            }
            candidate_idx = idx
            idx += 1
        }
        if candidate_idx != none and
                candidate_idx < arg_type_exprs.len {
            if msgs == none {
                throw new RuntimeError(
                    "Unexpectedly encountered a list arg "
                    "that isn't at the end of the argument list."
                )
            } elseif msg.msgs_contain_error(msgs) {
                msgs.add(new msg.FileMsg(
                    "Unexpectedly encountered a list arg "
                    "that isn't at the end of the argument list, "
                    "where it is required to be.",
                    source_file=project_file,
                    line=node.line,
                    col=node.col,
                ))
            }
            node.damaged = yes
            # XXX: It's safe to proceed here with generating
            # the instruction, it just won't lead to a runnable
            # program later.
        }
        if candidate_idx != none {
            return new st_ref.StorageRef(
                st_ref.ST_ARG, candidate_idx
            )
        }
        return "Unexpected attempt to use list arg "
            "in func that doesn't have one."
    }

    var result = new ExprIMRResult()
    update_typing_for_imr_expr(
        result, node,
        node_parents=node_parents,
        imr_parents=imr_parents,
        func_imr_parent=func_imr_parent,
        file_imr_parent=file_imr_parent,
        project_file=project_file,
        imr_build_tracker=imr_build_tracker,
        is_moose64=is_moose64,
        msgs=msgs,
    ) later:

    var our_node_typeinfo = result.known_type_info
    if is_moose64 and
            our_node_typeinfo == none and
            msgs != none and
            not msg.msgs_contain_error(msgs) and
            not _is_node_a_compiler_builtin(
                project_file, node,
                is_moose64=is_moose64
            ) {
        print(program_name + ": error: Internal error, "
            "failed to get type for this node: " +
            node.as_str().sub(1, 200))
        throw new RuntimeError("Internal error, "
            "failed to get type for expr node "
            "unexpectedly. Please report this to "
            "the compiler makers.")
    }

    if is_moose64 and
            {ast.N_EXPR_BINOP, ast.N_EXPR_IDREF}.has(node.kind) and
            (
                m64_builtins.is_ast_node_referring_to_m64_list_arg_len(
                    project_file, node, is_moose64=is_moose64,
                )
            ) {
        if debug {
            print(program_name + ": debug: " +
                "generate_imr_for_expr(): "
                "Handling special moose64 builtin... " +
                "node=" + node.as_str() + " "
                "our_node_typeinfo=" +
                    our_node_typeinfo.as_str())
        }
        if m64_builtins.is_ast_node_referring_to_m64_list_arg_len(
                project_file, node, is_moose64=is_moose64,
                ) {
            var list_arg_idx = find_list_arg()
            if typename(list_arg_idx) == "str" {
                if msgs == none {
                    throw new RuntimeError("Unexpected invalid "
                        "use of multi arg encountered.")
                }
                if not node.damaged {
                    msgs.add(new msg.FileMsg(
                        list_arg_idx,
                        source_file=project_file,
                        line=node.line,
                        col=node.col,
                    ))
                }
                node.damaged = yes
                return none
            }
            var our_type =
                typeinfo.create_from_simple_m64_type("size")
            var tmp_ref = get_new_temp_storage_ref(
                node, imr_parents=imr_parents,
                func_imr_parent=func_imr_parent,
                file_imr_parent=file_imr_parent,
                optional_type_info=our_type,
                project_file=project_file,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64, msgs=msgs,
            ) later:

            await tmp_ref

            result.instructions.add(new IMRGetListArgLen(
                new st_ref.StorageRef(
                    st_ref.ST_ARG, list_arg_idx
                ),
                tmp_ref,
            ))
            result.known_type_info = our_type
            result.storage_ref = tmp_ref
            if debug {
                print(program_name + ": debug: " +
                    "generate_imr_for_expr(): "
                    "Done setting up multi arg get on " +
                    "arg " + multi_arg_idx.as_str() + ".")
            }
            return later result
        } else {
            throw new RuntimeError("Unhandled code path.")
        }
    } elseif is_moose64 and our_node_typeinfo != none and
            our_node_typeinfo.kind == typeinfo.TI_FUNCREF and
            our_node_typeinfo.user_type_ref != none and
            {
                st_ref.ST_GLOBAL, st_ref.ST_GLOBALATTR,
                st_ref.ST_MCREF,
            }.has(our_node_typeinfo.user_type_ref.kind) {
        if debug {
            print(program_name + ": debug: " +
                "generate_imr_for_expr(): "
                "Handling func call in moose64...")
        }

        result.storage_ref = our_node_typeinfo.user_type_ref.copy()
        return later result
    } elseif is_moose64 and node.kind == ast.N_EXPR_CONTAINER {
        # XXX: This is never allowed in system level,
        # unless as part of a call where it will be handled
        # one layer above. Therefore, always emit an error
        # here.
        if msgs == none {
            throw new RuntimeError(
                "Unexpectedly encountered list container."
            )
        } elseif msg.msgs_contain_error(msgs) {
            msgs.add(new msg.FileMsg(
                "Unexpectedly encountered '[' ... ']' in "
                "a place where there is no list arg allowed.",
                source_file=project_file,
                line=node.line,
                col=node.col,
            ))
        }
        node.damaged = yes
        return later none
    } elseif node.kind == ast.N_EXPR_IDREF {
        result.storage_ref = node.ref.copy()
        return later result
    } elseif node.kind == ast.N_EXPR_LIT {
        if debug {
            print(program_name + ": debug: " +
                "generate_imr_for_expr(): "
                "Handling literal...")
        }
        var we_own_the_tmp_ref = no
        var tmp_ref = try_target_storage_ref
        func get_new_tmp_target_if_needed {
            if tmp_ref != none {
                return later
            }
            we_own_the_tmp_ref = yes
            tmp_ref = get_new_temp_storage_ref(
                node, imr_parents=imr_parents,
                func_imr_parent=func_imr_parent,
                file_imr_parent=file_imr_parent,
                optional_type_info=our_node_typeinfo,
                project_file=project_file,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64, msgs=msgs,
            ) later:

            await tmp_ref
        }
        get_new_tmp_target_if_needed() later:

        result.instructions.add(new IMRSetLit(
            node.value, tmp_ref,
            literal_kind=node.literal_kind,
        ))
        result.storage_ref = tmp_ref

        assert(func_imr_parent != none)
        var target_tmp_typeinfo = get_var_typeinfo(
            tmp_ref,
            func_parent_node=func_parent_node,
            func_imr_parent=func_imr_parent,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            msgs=msgs, is_moose64=is_moose64,
        ) later:

        await target_tmp_typeinfo

        func get_inner_conversion_if_needed {
            if is_moose64 and
                    not we_own_the_tmp_ref and
                    not our_node_typeinfo.is_equivalent(
                        target_tmp_typeinfo,
                        ignore_self_ref=yes,
                        is_moose64=is_moose64,
                    ) {
                var inner_tmp_ref = get_new_temp_storage_ref(
                    node, imr_parents=imr_parents,
                    func_imr_parent=func_imr_parent,
                    file_imr_parent=file_imr_parent,
                    optional_type_info=our_node_typeinfo,
                    project_file=project_file,
                    imr_build_tracker=imr_build_tracker,
                    is_moose64=is_moose64,
                    msgs=msgs,
                ) later:

                await inner_tmp_ref
                write_op_result_to_tmp_ref = inner_tmp_ref
                result.need_conversion = yes
                result.need_conversion_from = our_node_typeinfo
                result.need_conversion_to = target_tmp_typeinfo
                result.storage_ref = inner_tmp_ref
                return later
            }
            return later
        }
        get_inner_conversion_if_needed() later:

        return later result
    } elseif node.kind == ast.N_EXPR_TYPECAST {
        if our_node_typeinfo == none {
            if msgs == none {
                throw new RuntimeError(
                    "Unexpectedly encountered type cast "
                    "where we can't determine outer type."
                )
            } elseif msg.msgs_contain_error(msgs) {
                msgs.add(new msg.FileMsg(
                    "Unexpectedly encountered type cast "
                    "where we can't determine outer type.",
                    source_file=project_file,
                    line=node.line,
                    col=node.col,
                ))
            }
            node.damaged = yes
            return later none
        }

        var inner_typeinfo = m64_ast_analyze.
            get_c_or_m64_type_of_node(
                project_file, node.subexprs[1],
                node_parents + [node],
                store_self_value_ref_for_funcs=yes,
                msgs=msgs,
            ) later:

        await inner_typeinfo
        if inner_typeinfo == none {
            if msgs == none {
                throw new RuntimeError(
                    "Unexpectedly encountered type cast "
                    "where we can't determine inner type."
                )
            } elseif msg.msgs_contain_error(msgs) {
                msgs.add(new msg.FileMsg(
                    "Unexpectedly encountered type cast "
                    "where we can't determine inner type.",
                    source_file=project_file,
                    line=node.line,
                    col=node.col,
                ))
            }
            node.damaged = yes
            return later none
        }
        var outer_result_tmp_ref = try_target_storage_ref
        func get_new_tmp_target_if_needed {
            if outer_result_tmp_ref != none {
                return later
            }
            we_own_the_tmp_ref = yes
            outer_result_tmp_ref = get_new_temp_storage_ref(
                node, imr_parents=imr_parents,
                func_imr_parent=func_imr_parent,
                file_imr_parent=file_imr_parent,
                optional_type_info=our_node_typeinfo,
                project_file=project_file,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64, msgs=msgs,
            ) later:

            await outer_result_tmp_ref
        }
        get_new_tmp_target_if_needed() later:

        var need_conversion = yes
        if our_node_typeinfo.is_equivalent(
                inner_typeinfo, ignore_self_ref=yes,
                is_moose64=is_moose64,
                ) {
            need_conversion = no
        }

        var try_target_for_inner_result_tmp = none
        if not need_conversion {
            try_target_for_inner_result_tmp =
                outer_result_tmp_ref
        }
        var inner_result = generate_imr_for_expr(
            node.subexprs[1],
            node_parents=node_parents + [node],
            imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            try_target_storage_ref=
                try_target_for_inner_result_tmp,
            is_moose64=is_moose64,
            msgs=msgs,
        ) later:

        await inner_result
        if inner_result == none or
                inner_result.storage_ref == none {
            return later
        }
        var result_insts = []
        if need_conversion {
            result_insts.add(new IMRConv(
                inner_result.storage_ref,
                outer_result_tmp_ref,
                inner_typeinfo,
                our_node_typeinfo,
                in_project_file=project_file,
                is_moose64=is_moose64,
            ))
        } else {
            if not inner_result.storage_ref.alike(
                    outer_result_tmp_ref) {
                result_insts.add(new IMRMove(
                    inner_result.storage_ref,
                    outer_result_tmp_ref,
                ))
            }
        }
        result.instructions = result_insts
        result.storage_ref = outer_result_tmp_ref
        return result
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.optoken.str == "(" and
            node.subexprs.len >= 2 {
        assert(our_node_typeinfo != none or
            not is_moose64 or (msgs != none and
            msg.msgs_contain_error(msgs)))
        if is_moose64 and our_node_typeinfo == none {
            return later none
        }

        if debug {
            print(program_name + ": debug: " +
                "generate_imr_for_expr(): "
                "Handling call expression...")
        }

        var expect_return_value = not return_value_is_ignored
        var we_own_the_tmp_ref = no
        var tmp_ref = try_target_storage_ref
        func get_own_tmp_ref_if_needed {
            if tmp_ref != none and
                    (our_node_typeinfo != none or
                    not is_moose64) {
                return later
            }
            if not expect_return_value {
                return later
            }
            we_own_the_tmp_ref = yes
            tmp_ref = get_new_temp_storage_ref(
                node, imr_parents=imr_parents,
                func_imr_parent=func_imr_parent,
                file_imr_parent=file_imr_parent,
                optional_type_info=our_node_typeinfo,
                project_file=project_file,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64,
                msgs=msgs,
            ) later:

            await tmp_ref
        }
        get_own_tmp_ref_if_needed() later:

        var left_hand_result = generate_imr_for_expr(
            node.subexprs[1],
            node_parents=node_parents + [node],
            imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            is_moose64=is_moose64,
            msgs=msgs,
        ) later:

        await left_hand_result
        if left_hand_result == none {
            return later none
        }

        var is_as_ref = no
        var is_de_ref = no
        var is_size_of = no
        if is_moose64 and
                m64_builtins.
                    is_ast_node_referring_to_m64_memory_as_ref(
                        project_file, node.subexprs[1],
                        is_moose64=is_moose64,
                    ) {
            is_as_ref = yes
        } elseif is_moose64 and
                m64_builtins.
                    is_ast_node_referring_to_m64_memory_deref(
                        project_file, node.subexprs[1],
                        is_moose64=is_moose64,
                    ) {
            is_de_ref = yes
        } elseif is_moose64 and
                m64_builtins.
                    is_ast_node_referring_to_m64_memory_size_of(
                        project_file, node.subexprs[1],
                        is_moose64=is_moose64,
                    ) {
            is_size_of = yes
        }
        if expect_return_value and
                left_hand_result.known_type_info != none and
                left_hand_result.known_type_info.kind ==
                    typeinfo.TI_FUNCREF and
                not left_hand_result.known_type_info.can_return_value() {
            if msgs == none {
                throw new RuntimeError("Unexpected attempt to use "
                    "call return value, "
                    "but called func doesn't return any value.")
            }
            if not node.damaged {
                msgs.add(new msg.FileMsg(
                    "Unexpected attempt to use "
                    "call return value, "
                    "but called func doesn't return any value.",
                    source_file=project_file,
                    line=node.line,
                    col=node.col,
                ))
            }
            node.damaged = yes
            return later none
        } elseif not expect_return_value and
                left_hand_result.known_type_info != none and
                left_hand_result.known_type_info.kind ==
                    typeinfo.TI_FUNCREF and
                left_hand_result.known_type_info.can_return_value() {
            if msgs == none {
                throw new RuntimeError("Unexpected attempt to use "
                    "call return value, "
                    "but called func doesn't return any value.")
            }
            msgs.add(new msg.FileMsg(
                "Return value of call was ignored.",
                kind=msg.M_WARNING,
                source_file=project_file,
                line=node.line,
                col=node.col,
            ))
        }
        if is_moose64 and (is_as_ref or is_de_ref or is_size_of) and
                node.subexprs[2].kind == ast.N_EXPR_CALLARGS and
                node.subexprs[2].subexprs.len > 0 {
            # If we enter this code block, then it's a moose64 special
            # builtin and not an actual call.

            var arg_expr_result = generate_imr_for_expr(
                node.subexprs[2].subexprs[1],
                node_parents=node_parents + [node, node.subexprs[2]],
                imr_parents=imr_parents,
                func_imr_parent=func_imr_parent,
                file_imr_parent=file_imr_parent,
                project_file=project_file,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64,
                msgs=msgs,
            ) later:

            await arg_expr_result
            if arg_expr_result == none or
                    arg_expr_result.storage_ref == none {
                return later none
            }
            if not expect_return_value {
                # Proceeding past here is kind of useless,
                # since these built-ins have no state altering effect.
                result.storage_ref = none
                result.instructions = arg_expr_result.instructions
                return result
            }
            var target_tmp_typeinfo = get_var_typeinfo(
                tmp_ref,
                func_parent_node=func_parent_node,
                func_imr_parent=func_imr_parent,
                project_file=project_file,
                imr_build_tracker=imr_build_tracker,
                msgs=msgs, is_moose64=is_moose64,
            ) later:

            await target_tmp_typeinfo
            if target_tmp_typeinfo == none {
                return later none
            }
            var our_node_typeinfo =
                arg_expr_result.known_type_info.copy()
            if is_as_ref {
                our_node_typeinfo =
                    our_node_typeinfo.get_after_as_ref_operation()
            } elseif is_de_ref {
                our_node_typeinfo =
                    our_node_typeinfo.get_after_de_ref_operation()
            } elseif is_size_of {
                our_node_typeinfo = typeinfo.
                    create_from_simple_m64_type("size")
            } else {
                throw new RuntimeError("Unimplemented code "
                    "path was reached.")
            }
            if our_node_typeinfo == none {
                return later none
            }

            var write_op_result_to_tmp_ref = tmp_ref
            var conversion_taken_care_of = no

            result.storage_ref = tmp_ref
            func insert_type_conversion_if_needed {
                if is_moose64 and
                        not we_own_the_tmp_ref and
                        not our_node_typeinfo.is_equivalent(
                            target_tmp_typeinfo,
                            ignore_self_ref=yes,
                            is_moose64=is_moose64,
                        ) {
                    var inner_tmp_ref = get_new_temp_storage_ref(
                        node, imr_parents=imr_parents,
                        func_imr_parent=func_imr_parent,
                        file_imr_parent=file_imr_parent,
                        optional_type_info=our_node_typeinfo,
                        project_file=project_file,
                        imr_build_tracker=imr_build_tracker,
                        is_moose64=is_moose64,
                        msgs=msgs,
                    ) later:

                    await inner_tmp_ref
                    write_op_result_to_tmp_ref = inner_tmp_ref
                    result.need_conversion = yes
                    result.need_conversion_from = target_tmp_typeinfo
                    result.need_conversion_to = our_node_typeinfo
                    result.storage_ref = inner_tmp_ref
                    return later
                }
                return later
            }
            insert_type_conversion_if_needed() later:

            if is_as_ref {
                result.instructions.add(new IMRAsref(
                    asref_source_storage_ref=arg_expr_result.storage_ref,
                    target_storage_ref=tmp_ref,
                ))
            } elseif is_de_ref {
                result.instructions.add(new IMRDeref(
                    asref_source_storage_ref=arg_expr_result.storage_ref,
                    target_storage_ref=tmp_ref,
                ))
            } elseif is_size_of {
                result.instructions.add(new IMRSizeof(
                    sizeof_source_storage_ref=arg_expr_result.storage_ref,
                    target_storage_ref=tmp_ref,
                ))
            } else {
                throw new RuntimeError("Unimplemented code "
                    "path was reached.")
            }
            return result
        }
        # If we arrive here, then this is a regular func call.
        result.instructions += left_hand_result.instructions

        var called_func_type_info_if_known =
            left_hand_result.known_type_info
        var called_func_list_arg_idx = none
        var implicit_self_arg = no
        var args_node = node.subexprs[2]
        var call_args_len = args_node.subexprs.len
        if is_moose64 and
                called_func_type_info_if_known != none and
                called_func_type_info_if_known.is_func_attr() and
                called_func_type_info_if_known.arg_count() ==
                    args_node.subexprs.len + 1 {
            implicit_self_arg = yes
        }
        if is_moose64 and
                called_func_type_info_if_known != none {
            called_func_list_arg_idx =
                find_list_arg(
                    based_on_func_type_info=
                        called_func_type_info_if_known,
                    subtract_implicit_self_arg=implicit_self_arg,
                )
        }
        var arg_refs = []
        var arg_names_if_any = []
        var arg_types_if_known = []
        if args_node.kind != ast.N_EXPR_CALLARGS {
            throw new RuntimeError("Encountered "
                "broken call where args sub expression "
                "isn't of type N_EXPR_CALLARGS.")
        }
        var orig_arg_exprs = args_node.subexprs
        assert(not args_node.has_types)
        var queue = []
        var i = 1
        while i <= orig_arg_exprs.len {
            queue.add(orig_arg_exprs[i])
            i += 1
        }
        var arg_no = 0
        func process_item(item) {
            arg_no += 1
            var value_expr = item
            var value_name = none
            if value_expr.kind == ast.N_EXPR_CALLKWARG {
                value_name = value_expr.label
                value_expr = value_expr.subexprs[1]
            }

            var add_conv_to_type = none
            func determine_type_conversion_if_any {
                if not is_moose64 or
                        called_func_type_info_if_known == none {
                    return later
                }
                var intended_arg_no =
                    arg_no + if implicit_self_arg (1) else (0)
                var arg_intended_type =
                    called_func_type_info_if_known.construct_arg_type(
                        intended_arg_no,
                        project_file=project_file,
                        is_moose64=is_moose64, debug=no,
                    ) later:

                await arg_intended_type
                if debug {
                    print(program_name + ": debug: " +
                        "generate_imr_for_expr(): "
                        "Requiring type conversion for arg #" +
                        arg_no.as_str() + " to " +
                        arg_intended_type.as_str() + "...")
                }
                add_conv_to_type = arg_intended_type
            }

            var arg_expr_result = generate_imr_for_expr(
                value_expr,
                node_parents=node_parents + [node],
                imr_parents=imr_parents,
                func_imr_parent=func_imr_parent,
                file_imr_parent=file_imr_parent,
                project_file=project_file,
                imr_build_tracker=imr_build_tracker,
                convert_to_target_type=add_conv_to_type,
                is_moose64=is_moose64,
                msgs=msgs,
            ) later:

            await arg_expr_result
            if arg_expr_result == none {
                return later
            }
            result.instructions += arg_expr_result.instructions
            assert(not is_moose64 or
                arg_expr_result.known_type_info != none or
                _is_node_a_compiler_builtin(
                    project_file, value_expr,
                    is_moose64=is_moose64
                ) or
                msgs == none or
                msg.msgs_contain_error(msgs))
            arg_refs.add(arg_expr_result.storage_ref)
            arg_names_if_any.add(
                value_name
            )

            determine_type_conversion_if_any() later:

            arg_types_if_known.add(arg_expr_result.known_type_info)
        }
        func process_full_queue {
            if queue.len == 0 {
                return later
            }
            var result = process_item(queue.pop_at(1))
            later:

            await result
            if queue.len == 0 {
                return later
            }
            result = process_item(queue.pop_at(1))
            later repeat
        }
        process_full_queue() later:

        func handle_implicit_self_arg_in_m64 {
            if not is_moose64 or
                    called_func_type_info_if_known == none {
                return later
            }
            var have_explicit_self_arg = yes
            var texpr = called_func_type_info_if_known.
                convert_to_typeref_expr(
                    project=project_file.project,
                    is_moose64=is_moose64,
                )
            var full_args_count =
                called_func_type_info_if_known.arg_count()
            var could_have_implicit_self = no
            if called_func_type_info_if_known.is_func_attr {
                could_have_implicit_self = yes
            }
            if debug {
                print(program_name + ": debug: " +
                    "generate_imr_for_expr(): "
                    "Determining if we need to make the "
                    "self arg explicit. "
                    "texpr=" + texpr.as_str() + " "
                    "full_args_count=" +
                        full_args_count.as_str() + " "
                    "is_failable=" +
                        texpr.is_failable.as_str() + " "
                    "could_have_implicit_self=" +
                        could_have_implicit_self.as_str() + " "
                    "arg_refs=" + arg_refs.as_str())
            }
            if full_args_count != arg_refs.len + 1 or
                    texpr.arg_typeref_exprs.len < 1 or
                    texpr.arg_typeref_exprs[1].is_func_ref or
                    texpr.arg_typeref_exprs[1].is_multi_type or
                    texpr.arg_typeref_exprs[1].is_list_arg or
                    not texpr.arg_typeref_exprs[1].is_user_type() {
                return later
            }
            if called_func_type_info_if_known.func_self_ref == none {
                return later
            }
            var self_ref = called_func_type_info_if_known.func_self_ref

            var self_arg_expr = texpr.arg_typeref_exprs[1]
            if debug {
                print(program_name + ": debug: " +
                    "generate_imr_for_expr(): "
                    "Adding explicit self arg... " +
                    "self_arg_expr=" + self_arg_expr.as_str() + " "
                    "self_ref " + self_ref.as_str())
            }
            arg_refs = [self_ref.copy()] + arg_refs
            arg_names_if_any = [none] + arg_names_if_any
        }
        handle_implicit_self_arg_in_m64() later:

        if not expect_return_value {
            # We want to call this but ignore the return value.
            result.storage_ref = none
            result.instructions.add(new IMRCall(
                called_func_ref=left_hand_result.storage_ref,
                arg_refs=arg_refs,
                arg_names_if_any=arg_names_if_any,
                has_later=no,
                has_later_ignore=no,
                has_later_repeat=no,
                return_value_ref=none,
            ))
            return result
        }
        # We want to call and keep the return value:
        result.storage_ref = tmp_ref
        var target_tmp_typeinfo = get_var_typeinfo(
            tmp_ref,
            func_parent_node=func_parent_node,
            func_imr_parent=func_imr_parent,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            msgs=msgs, is_moose64=is_moose64,
        ) later:

        await target_tmp_typeinfo
        var write_op_result_to_tmp_ref = tmp_ref
        var conversion_taken_care_of = no
        assert(not we_own_the_tmp_ref or not is_moose64 or
            our_node_typeinfo != none)
        assert(not we_own_the_tmp_ref or
            tmp_ref.kind == st_ref.ST_LOCAL)

        func insert_type_conversion_if_needed {
            # Check if the return value needs to be converted.
            if is_moose64 and
                    not we_own_the_tmp_ref and
                    not our_node_typeinfo.is_equivalent(
                        target_tmp_typeinfo,
                        ignore_self_ref=yes,
                        is_moose64=is_moose64,
                    ) {
                var inner_tmp_ref = get_new_temp_storage_ref(
                    node, imr_parents=imr_parents,
                    func_imr_parent=func_imr_parent,
                    file_imr_parent=file_imr_parent,
                    optional_type_info=our_node_typeinfo,
                    project_file=project_file,
                    imr_build_tracker=imr_build_tracker,
                    is_moose64=is_moose64,
                    msgs=msgs,
                ) later:

                await inner_tmp_ref
                write_op_result_to_tmp_ref = inner_tmp_ref
                result.need_conversion = yes
                result.need_conversion_from = our_node_typeinfo
                result.need_conversion_to = target_tmp_typeinfo
                result.storage_ref = inner_tmp_ref
                return later
            }
            return later
        }
        insert_type_conversion_if_needed() later:

        result.instructions.add(new IMRCall(
            called_func_ref=left_hand_result.storage_ref,
            arg_refs=arg_refs,
            arg_names_if_any=arg_names_if_any,
            has_later=no,
            has_later_ignore=no,
            has_later_repeat=no,
            return_value_ref=write_op_result_to_tmp_ref,
        ))
        return later result
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.optoken.str == "." and
            node.subexprs.len >= 2 and
            node.subexprs[2].kind == ast.N_EXPR_IDREF {
        var tmp_ref = get_new_temp_storage_ref(
            node,
            imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            optional_type_info=our_node_typeinfo,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            is_moose64=is_moose64, msgs=msgs,
        ) later:

        await tmp_ref
        var attr_name = node.subexprs[2].label
        assert(attr_name != none)
        var left_hand_result = generate_imr_for_expr(
            node.subexprs[1],
            node_parents=node_parents + [node],
            imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            is_moose64=is_moose64,
            msgs=msgs,
        ) later:

        await left_hand_result
        if left_hand_result == none {
            return later none
        }
        result.instructions += left_hand_result.instructions
        result.instructions.add(new IMRGetAttrByName(
            obj_storage_ref=left_hand_result.storage_ref,
            attr_name=attr_name,
            target_storage_ref=tmp_ref,
        ))
        result.storage_ref = tmp_ref
        return later result
    } elseif node.kind == ast.N_EXPR_BINOP and
            node.optoken.str == "[" and
            node.subexprs.len >= 2 {
        if debug {
            print(program_name + ": debug: "
                "generate_imr_for_expr(): "
                "Looking at indexing node. node=" +
                    node.as_str().sub(1, 200))
        }
        var tmp_ref = get_new_temp_storage_ref(
            node, imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            optional_type_info=our_node_typeinfo,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            is_moose64=is_moose64, msgs=msgs,
        ) later:

        await tmp_ref
        var left_hand_result = generate_imr_for_expr(
            node.subexprs[1],
            node_parents=node_parents + [node],
            imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            is_moose64=is_moose64,
            msgs=msgs,
        ) later:

        await left_hand_result
        var right_hand_result = generate_imr_for_indexing_expr(
            node.subexprs[2],
            node_parents=node_parents + [node],
            imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            is_moose64=is_moose64, msgs=msgs,
        ) later:

        await right_hand_result
        if left_hand_result == none or
                right_hand_result == none {
            return later none
        }
        result.instructions += left_hand_result.instructions
        result.instructions += right_hand_result.instructions
        result.instructions.add(new IMRGetIdx(
            container_storage_ref=
                left_hand_result.storage_ref,
            index_storage_ref=
                right_hand_result.storage_ref,
            target_storage_ref=tmp_ref,
        ))
        result.storage_ref = tmp_ref
        return later result
    } elseif (node.kind == ast.N_EXPR_BINOP and
             not irregular_binop_strs.has(node.optoken.str) and
             node.subexprs.len >= 2) or
            (node.kind == ast.N_EXPR_UNOP and
             node.subexprs.len >= 1) {

        var is_binop = node.kind == ast.N_EXPR_BINOP
        if debug {
            print(program_name + ": debug: "
                "generate_imr_for_expr(): "
                "Looking at generic operator node. node=" +
                    node.as_str().sub(1, 200) + "... " +
                "is_binop=" + is_binop.as_str())
        }

        var tmp_ref = get_new_temp_storage_ref(
            node, imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            optional_type_info=our_node_typeinfo,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            is_moose64=is_moose64, msgs=msgs,
        ) later:

        await tmp_ref
        var is_cmp_op =
            token.compare_ops.has(node.optoken.str)
        var is_bool_cmp_op =
            token.bool_compare_ops.has(node.optoken.str)
        var left_hand_type = none
        var right_hand_type = none
        var left_hand_convert_to = none
        var right_hand_convert_to = none

        func determine_operand_types_if_needed {
            if not is_moose64 {
                return later
            }

            func determine_left_hand {
                if _is_node_a_compiler_builtin(
                        project_file, node.subexprs[1],
                        is_moose64=is_moose64) {
                    left_hand_type = typeinfo.
                        create_from_simple_m64_type("any")
                    result.modifiers.add(
                        new ast_typeref.TypeRefMod(
                            "ref"
                        )
                    )
                    return later
                }
                left_hand_type = m64_ast_analyze.
                    get_c_or_m64_type_of_node(
                        project_file, node.subexprs[1],
                        node_parents + [node],
                        store_self_value_ref_for_funcs=yes,
                        msgs=msgs,
                    ) later:

                await left_hand_type
            }
            determine_left_hand() later:

            if not is_binop {
                if left_hand_type == none {
                    return later
                }
                if is_bool_cmp_op {
                    left_hand_convert_to = typeinfo.
                        create_from_simple_m64_type("bool")
                } elseif node.optoken.str == "-" {
                    var result = m64_autocast.get_math_unop_autocast(
                        left_hand_type,
                        operand_is_literal_none=
                            node.subexprs[1].kind == ast.N_EXPR_LIT and
                            node.subexprs[1].literal_kind ==
                                ast_expr.LK_NORMAL and
                            node.subexprs[1].value == none,
                        is_moose64=is_moose64,
                    )
                    if result.incompatible {
                        return later
                    }
                    assert(result.cast_operand_to != none)
                    left_hand_convert_to = result.cast_operand_to
                    return later
                } else {
                    throw new RuntimeError(
                        "Unhandled kind of unop operator."
                    )
                }
                return later
            }
            func determine_right_hand {
                if _is_node_a_compiler_builtin(
                        project_file, node.subexprs[2],
                        is_moose64=is_moose64) {
                    right_hand_type = typeinfo.
                        create_from_simple_m64_type("any")
                    right_hand_type.modifiers.add(
                        new ast_typeref.TypeRefMod(
                            "ref"
                        )
                    )
                    return later
                }
                right_hand_type = m64_ast_analyze.
                    get_c_or_m64_type_of_node(
                        project_file, node.subexprs[2],
                        node_parents + [node],
                        store_self_value_ref_for_funcs=yes,
                        msgs=msgs,
                    ) later:

                await right_hand_type
            }
            determine_right_hand() later:

            if left_hand_type == none or right_hand_type == none {
                return later
            }
            if is_bool_cmp_op {
                left_hand_convert_to = typeinfo.
                    create_from_simple_m64_type("bool")
                right_hand_convert_to = typeinfo.
                    create_from_simple_m64_type("bool")
                return later
            }
            var inner_cast_result = m64_autocast.get_math_binop_autocast(
                left_hand_type, right_hand_type,
                left_side_is_literal_none=
                    node.subexprs[1].kind == ast.N_EXPR_LIT and
                    node.subexprs[1].literal_kind ==
                        ast_expr.LK_NORMAL and
                    node.subexprs[1].value == none,
                right_side_is_literal_none=
                    node.subexprs[2].kind == ast.N_EXPR_LIT and
                    node.subexprs[2].literal_kind ==
                        ast_expr.LK_NORMAL and
                    node.subexprs[2].value == none,
                is_cmp_op=is_cmp_op,
                is_moose64=is_moose64,
            )
            if inner_cast_result.incompatible {
                return later
            }
            assert(inner_cast_result.cast_lefthand_to != none and
                inner_cast_result.cast_righthand_to != none)
            assert(inner_cast_result.cast_lefthand_to.is_equivalent(
                inner_cast_result.cast_righthand_to, ignore_self_ref=yes))
            left_hand_convert_to = inner_cast_result.cast_lefthand_to
            right_hand_convert_to = inner_cast_result.cast_righthand_to
        }
        determine_operand_types_if_needed() later:

        if debug {
            print(program_name + ": debug: "
                "generate_imr_for_expr(): "
                "Determined operand types. "
                "left_hand_type=" +
                    left_hand_type.as_str() + " "
                "right_hand_type=" +
                    right_hand_type.as_str())
        }

        var left_hand_result = generate_imr_for_expr(
            node.subexprs[1],
            node_parents=node_parents + [node],
            imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            convert_to_target_type=left_hand_convert_to,
            conversion_not_limited_to_regular_implicit=yes,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            is_moose64=is_moose64,
            msgs=msgs,
        ) later:

        await left_hand_result

        var right_hand_result = none
        func get_righthand_result_if_binop {
            if not is_binop {
                return later
            }
            right_hand_result = generate_imr_for_expr(
                node.subexprs[2],
                node_parents=node_parents + [node],
                imr_parents=imr_parents,
                func_imr_parent=func_imr_parent,
                file_imr_parent=file_imr_parent,
                convert_to_target_type=right_hand_convert_to,
                conversion_not_limited_to_regular_implicit=yes,
                project_file=project_file,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64, msgs=msgs,
            ) later:

            await right_hand_result
        }
        get_righthand_result_if_binop() later:

        if debug {
            print(program_name + ": debug: "
                "generate_imr_for_expr(): "
                "Determined operand inner results. "
                "left_hand_result=" +
                    left_hand_result.as_str() + " "
                "right_hand_result=" +
                    right_hand_result.as_str() + " "
                "is_binop=" + is_binop.as_str())
        }
        if left_hand_result == none or
                (is_binop and right_hand_result == none) {
            return later none
        }
        result.instructions += left_hand_result.instructions

        if is_binop {
            var nest_in_cond_block = none
            var enter_else_tmp_ref = none
            func add_nesting_cond_if_needed {
                if node.optoken.str != "or" and
                        node.optoken.str != "and" {
                    return later
                }
                enter_else_tmp_ref = get_new_temp_storage_ref(
                    node, imr_parents=imr_parents,
                    func_imr_parent=func_imr_parent,
                    file_imr_parent=file_imr_parent,
                    optional_type_info=
                        typeinfo.create_from_simple_m64_type("bool"),
                    project_file=project_file,
                    imr_build_tracker=imr_build_tracker,
                    is_moose64=is_moose64, msgs=msgs,
                ) later:

                await enter_else_tmp_ref
                result.instructions.add(new IMRSetLit(
                    yes, enter_else_tmp_ref,
                    literal_kind=ast_expr.LK_NORMAL
                ))
                if node.optoken.str == "or" {
                    assert(not is_moose64 or
                        left_hand_convert_to.is_equivalent(
                            typeinfo.create_from_simple_m64_type("bool")))
                    var cond_tmp = get_new_temp_storage_ref(
                        node, imr_parents=imr_parents,
                        func_imr_parent=func_imr_parent,
                        file_imr_parent=file_imr_parent,
                        optional_type_info=
                            typeinfo.create_from_simple_m64_type("bool"),
                        project_file=project_file,
                        imr_build_tracker=imr_build_tracker,
                        is_moose64=is_moose64, msgs=msgs,
                    ) later:

                    await nest_in_cond_tmp
                    result.instructions.add(new IMRApplyOp(
                        new token.Token(
                             "not", token.T_BOOLCOMP,
                             node.line, node.col,
                        ),
                        operand_1_storage_ref=left_hand_result.storage_ref,
                        target_storage_ref=cond_tmp,
                        is_binary=no,
                    ))
                    nest_in_cond_block = new IMRCond(
                        evaluated_cond_ref=cond_tmp,
                    )
                    nest_in_cond_block.line = node.optoken.line
                    nest_in_cond_block.col = node.optoken.col
                    result.instructions.add(nest_in_cond_block)
                } else {
                    assert(node.optoken.str == "and")
                    assert(not is_moose64 or
                        left_hand_convert_to.is_equivalent(
                            typeinfo.create_from_simple_m64_type("bool")))
                    nest_in_cond_tmp = get_new_temp_storage_ref(
                        node, imr_parents=imr_parents,
                        func_imr_parent=func_imr_parent,
                        file_imr_parent=file_imr_parent,
                        optional_type_info=
                            typeinfo.create_from_simple_m64_type("bool"),
                        project_file=project_file,
                        imr_build_tracker=imr_build_tracker,
                        is_moose64=is_moose64, msgs=msgs,
                    ) later:

                    await nest_in_cond_tmp
                    nest_in_cond_block = new IMRCond(
                        evaluated_cond_ref=left_hand_result.storage_ref,
                    )
                    nest_in_cond_block.line = node.optoken.line
                    nest_in_cond_block.col = node.optoken.col
                    result.instructions.add(nest_in_cond_block)
                }
            }
            add_nesting_cond_if_needed() later:

            var add_insts_into = result
            if nest_in_cond_block != none {
                add_insts_into = nest_in_cond_block
            }
            add_insts_into.instructions += right_hand_result.instructions
            add_insts_into.instructions.add(new IMRApplyOp(
                node.optoken.copy(),
                operand_1_storage_ref=
                    left_hand_result.storage_ref,
                operand_2_storage_ref=
                    right_hand_result.storage_ref,
                target_storage_ref=tmp_ref,
                is_binary=yes,
            ))
            if nest_in_cond_block != none {
                nest_in_cond_block.instructions.add(new IMRSetLit(
                    no, enter_else_tmp_ref,
                    literal_kind=ast_expr.LK_NORMAL
                ))
            }
            if enter_else_tmp_ref != none {
                var else_cond_block = new IMRCond(
                    evaluated_cond_ref=enter_else_tmp_ref,
                )
                else_cond_block.line = node.optoken.line
                else_cond_block.col = node.optoken.col
                if node.optoken.str == "or" {
                    else_cond_block.instructions.add(new IMRSetLit(
                        yes, tmp_ref,
                        literal_kind=ast_expr.LK_NORMAL
                    ))
                } else {
                    assert(node.optoken.str == "and")
                    else_cond_block.instructions.add(new IMRSetLit(
                        no, tmp_ref,
                        literal_kind=ast_expr.LK_NORMAL
                    ))
                }
                result.instructions.add(else_cond_block)
            }

            result.storage_ref = tmp_ref

            if debug {
                print(program_name + ": debug: "
                    "generate_imr_for_expr(): "
                    "Got binop final result ready. "
                    "result=" + result.as_str())
            }
            return later result
        }
        # If we arrive here, it's a unary operator:
        result.instructions.add(new IMRApplyOp(
            node.optoken.copy(),
            operand_1_storage_ref=
                left_hand_result.storage_ref,
            target_storage_ref=tmp_ref,
            is_binary=no,
        ))

        result.storage_ref = tmp_ref

        if debug {
            print(program_name + ": debug: "
                "generate_imr_for_expr(): "
                "Got unop final result ready. "
                "result=" + result.as_str())
        }
        return later result
    }
    return later none
}

func generate_imr_for_entrypoint_func(
        imr_parents=[],
        func_imr_parent=none,
        file_imr_parent=none,
        project_file=none,
        imr_build_tracker=none,
        is_moose64=no, msgs=none,
        ) {
    var insts = []

    var init_func_info = globals_order.
        generate_init_funcs_globally(
            project_file.project
        ) later:

    await init_func_info
    project_file.ensure_ast()
    later:

    for func_info in init_func_info {
        var name = func_info.suggested_name
        if not name.starts("$") {
            name = "$" + name
        }
        var storage_id = imr_build_tracker.
            global_init_func_name_to_id_map[name]
        insts.add(new IMRCall(
            called_func_ref=new st_ref.StorageRef(
                st_ref.ST_GLOBAL, storage_id),
            arg_refs=[],
            arg_names_if_any=[],
            has_later=no,
            has_later_ignore=no,
            has_later_repeat=no,
            return_value_ref=none,
        ))
    }

    return later insts
}

func generate_imr_for_stmt(
        node,
        node_parents=[],
        imr_parents=[],
        func_imr_parent=none,
        file_imr_parent=none,
        project_file=none,
        imr_build_tracker=none,
        is_moose64=no, msgs=none,
        debug=no,
        ) {
    const program_name = if is_moose64 ("moosec") else ("horsec")

    assert(imr_build_tracker != none)
    var func_tracker = none
    if func_imr_parent != none {
        func_tracker = func_imr_parent.get_func_tracker(
            imr_build_tracker
        )
    }

    if node.kind == ast.N_STMT_RETURN {
        var result_insts = []
        var returned_expr_result = none
        var expected_return_value_tinfo = none
        var fnode_parent = none
        if node_parents.len > 0 {
            var idx = node_parents.len
            while idx >= 1 {
                fnode_parent = node_parents[idx]
                if {ast.N_STMT_FUNC,
                        ast.N_STMT_FUNCEXTEND}.has(
                        fnode_parent.kind) {
                    break
                }
                fnode_parent = none
                idx -= 1
            }
        }
        if fnode_parent == none {
            throw new RuntimeError("Unexpectedly couldn't "
                "find the func parent node.")
        }

        if node.has_failed {
            if not fnode_parent.extended_final_has_failable() {
                if msgs == none {
                    throw new RuntimeError("Unexpected return "
                        "of failed state.")
                }
                if not node.damaged {
                    msgs.add(new msg.FileMsg(
                        "Unexpected return failed statement in "
                        "func that isn't failable.",
                        source_file=project_file,
                        line=node.line,
                        col=node.col,
                    ))
                }
                node.damaged = yes
                return []
            }
            result_insts.add(new IMRReturnFail())
            return result_insts
        }

        func determine_return_value_typeinfo {
            var return_type_expr = none
            if fnode_parent != none and
                    fnode_parent.extended_final_has_return_type() {
                return_type_expr = fnode_parent.
                    extended_final_return_type_expr()
            }
            if return_type_expr != none {
                var result =
                    typeinfo.create_typeinfo_from_typeexpr_and_verify(
                        return_type_expr,
                        project=project_file.project,
                        is_moose64=is_moose64,
                    ) later:

                await result
                expected_return_value_tinfo = result
                return later
            }
            expected_return_value_tinfo = none
            return later
        }
        determine_return_value_typeinfo() later:

        if is_moose64 and
                (expected_return_value_tinfo == none or
                 expected_return_value_tinfo.is_empty_type()
                ) and
                node.subexprs.len >= 1 and
                node.subexprs[1] != none {
            if msgs == none {
                throw new RuntimeError("Unexpected return "
                    "with expression.")
            }
            if not node.damaged {
                msgs.add(new msg.FileMsg(
                    "Unexpected return with an expression to "
                    "be returned, this func doesn't return "
                    "any value.",
                    source_file=project_file,
                    line=node.line,
                    col=node.col,
                ))
            }
            node.damaged = yes
            return later []
        } elseif is_moose64 and
                expected_return_value_tinfo != none and
                not expected_return_value_tinfo.is_empty_type() and
                (node.subexprs.len < 1 or
                 node.subexprs[1] == none) {
            if msgs == none {
                throw new RuntimeError("Unexpected return "
                    "without expression.")
            }
            if not node.damaged {
                msgs.add(new msg.FileMsg(
                    "Unexpected return without an expression to "
                    "be returned, this func expects return "
                    "value of type " +
                    expected_return_value_tinfo.
                        describe_to_user(
                        project=project_file.project,
                        is_moose64=is_moose64) + ".",
                    source_file=project_file,
                    line=node.line,
                    col=node.col,
                ))
            }
            node.damaged = yes
            return later []
        }

        func obtain_return_expr_result_if_needed {
            if node.subexprs.len < 1 or
                    node.subexprs[1] == none or
                    (is_moose64 and (
                     expected_return_value_tinfo == none or
                     expected_return_value_tinfo.is_empty_type())) {
                return later
            }

            returned_expr_result = generate_imr_for_expr(
                node.subexprs[1],
                node_parents=node_parents + [node],
                imr_parents=imr_parents,
                func_imr_parent=func_imr_parent,
                file_imr_parent=file_imr_parent,
                project_file=project_file,
                convert_to_target_type=expected_return_value_tinfo,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64, msgs=msgs,
            ) later:

            await returned_expr_result
        }
        obtain_return_expr_result_if_needed() later:

        var return_expr_st_ref = none
        if returned_expr_result != none {
            return_expr_st_ref = returned_expr_result.storage_ref
            result_insts += returned_expr_result.instructions
        }

        result_insts.add(new IMRReturn(
            return_value_storage_ref=return_expr_st_ref,
        ))
        return result_insts
    } elseif node.kind == ast.N_STMT_VAR {
        var result_insts = []

        var var_type_expr = none
        func resolve_var_type {
            if not node.has_type_expr {
                return later not is_moose64
            }
            var_type_expr = node.subexprs[node.subexprs.len]
            var success = var_type_expr.try_resolve_to_user_type(
                project_file, is_moose64=is_moose64
            ) later:

            await success
            if not is_moose64 or not success or
                    func_imr_parent == none {
                return later success
            }
            var tinfo = typeinfo.
                create_typeinfo_from_typeexpr_and_verify(
                    var_type_expr,
                    self_node_if_known=node,
                    base_node_parents_if_known=node_parents,
                    project_file=project_file,
                    is_moose64=is_moose64,
                ) later:

            await tinfo
            if tinfo == none {
                return later no
            }
            assert(typename(node.symbol_info) == "list")
            for si in node.symbol_info {
                assert(si.kind == st_scope.SINFO_VAR)
                func_imr_parent.storage_id_to_known_type_info[
                    si.storage_id
                ] = tinfo
                func_imr_parent.storage_id_to_known_type_expr[
                    si.storage_id
                ] = var_type_expr
            }
            func_imr_parent.update_var_type_exprs(
                project_file,
                is_moose64=is_moose64,
                msgs=msgs,
            ) later:

            return later yes
        }
        var type_is_resolved = resolve_var_type()
        later:

        await type_is_resolved
        if not type_is_resolved {
            throw new RuntimeError("Internal error, "
                "unexpectedly failed to resolve var type.")
        }

        var var_type_storage_ref = none
        var var_type_info = none
        func resolve_var_type_if_needed {
            if var_type_expr == none or
                    not var_type_expr.is_user_type() {
                return later
            }
            var ref = none
            var result = var_type_expr.try_resolve_to_user_type(
                project_file, is_moose64=is_moose64
            ) later:

            await result
            if result != none and
                    not result.had_error and
                    not result.resolved_to_nonuser_type {
                ref = result.resolved_storage_ref
            }
            if (ref == none and
                     # Note: The func types are always user types,
                     # but can be 'bodyless' func signatures without
                     # pointing back to an actual existing func.
                     not var_type_expr.is_func_ref) or
                    (ref != none and
                     not {st_ref.ST_GLOBAL,
                        st_ref.ST_GLOBALATTR,
                        st_ref.ST_CEXT,
                        st_ref.ST_MCREF}.has(ref.kind)) {
                throw new RuntimeError("Internal error, "
                    "unexpectedly had missing or invalid "
                    "storage ref for variable declaration.")
            }
            var_type_storage_ref = ref
            var_type_info =
                typeinfo.create_typeinfo_from_typeexpr_and_verify(
                    var_type_expr,
                    base_node_if_known=node,
                    base_node_parents_if_known=node_parents,
                    project_file=project_file,
                    is_moose64=is_moose64,
                ) later:

            await var_type_info
        }
        resolve_var_type_if_needed() later:

        var idx = 0
        for label in node.var_labels {
            idx += 1
            var type_expr_storage_id = none
            assert((not is_moose64 and var_type_expr == none) or
                not var_type_expr.is_user_type() or
                var_type_expr.is_func_ref or
                var_type_storage_ref != none)
        }
        var assigned_exprs = node.subexprs.copy()
        var type_expr = none
        if node.has_type_expr and assigned_exprs.len > 0 {
            type_expr = assigned_exprs[assigned_exprs.len]
            assigned_exprs = assigned_exprs.sub(
                1, assigned_exprs.len - 1
            )
        }
        if assigned_exprs == 0 {
            return later result_insts
        }
        var queue = []
        var i = 1
        while i <= assigned_exprs.len {
            queue.add([i, assigned_exprs[i]])
            i += 1
        }
        func_imr_parent.update_var_type_exprs(
            project_file,
            is_moose64=is_moose64,
            msgs=msgs,
        ) later:

        func process_queue_item(item) {
            if result_insts == none {
                return later
            }
            var left_hand_storage_id =
                node.symbol_info[idx].storage_id
            var var_ref = new st_ref.StorageRef(
                st_ref.ST_LOCAL,
                left_hand_storage_id
            )
            if (item[2] == none or
                    (item[2].kind == ast.N_EXPR_LIT and
                     item[2].literal_kind == ast_expr.LK_NORMAL and
                     item[2].value == none)) and
                    is_moose64 {
                result_insts.add(new IMRClrZero(
                    var_ref,
                ))
                return later
            }
            var right_hand_result = generate_imr_for_expr(
                item[2],
                node_parents=node_parents + [node],
                imr_parents=imr_parents,
                func_imr_parent=func_imr_parent,
                file_imr_parent=file_imr_parent,
                project_file=project_file,
                convert_to_target_type=var_type_info,
                imr_build_tracker=imr_build_tracker,
                try_target_storage_ref=var_ref,
                is_moose64=is_moose64, msgs=msgs,
            ) later:

            await right_hand_result
            if right_hand_result != none {
                result_insts += right_hand_result.instructions
                if not right_hand_result.storage_ref.alike(
                        var_ref) {
                    result_insts.add(new IMRMove(
                        right_hand_result.storage_ref,
                        var_ref,
                    ))
                }
            } else {
                result_insts = none
            }
        }
        if queue.len == 0 or result_insts == none {
            return later result_insts
        }
        var _unused = process_queue_item(queue.pop_at(1))
        later:

        await _unused
        if queue.len == 0 or result_insts == none {
            return later result_insts
        }
        _unused = process_queue_item(queue.pop_at(1))
        later repeat
    }
    if node.kind == ast.N_STMT_BREAK {
        var breakst = new IMRBreak()
        breakst.line = node.line
        breakst.col = node.col
        return [breakst]
    }
    if node.kind == ast.N_STMT_CONTINUE {
        var continuest = new IMRContinue()
        continuest.line = node.line
        continuest.col = node.col
        return [continuest]
    }
    if node.kind == ast.N_STMT_DO {
        var result_insts = []

        var queue = [node]
        for clause in self.subexprs {
            queue.add(clause)
        }
        func process_item(item) {
            if result_insts == none {
                return later
            }

            var error_item_storage_refs = []
            func handle_rescue_clause_item(item) {
                # FIXME: extract class storage ids that
                # are referenced by rescue clause.
            }
            func handle_rescue_clause_if_needed {
                if item.kind != ast.N_EXPR_RESCUECLAUSE {
                    return later
                }
                var queue2 = []
                var idx = 0
                for elabel in self.error_labels {
                    idx += 1
                    if self.subexprs[idx] != none {
                        queue2.add([elabel, self.subexprs[idx]])
                    } else {
                        queue2.add([elabel, "any"])
                    }
                }
                if queue2.len == 0 {
                    return later
                }
                var result = handle_rescue_clause_item(
                    queue2.pop()) later:

                await result
                if queue2.len == 0 {
                    return lataer
                }
                result = handle_rescue_clause_item(
                    queue2.pop()) later repeat
            }
            handle_rescue_clause_if_needed() later:

            var inner_insts = generate_imr_for_stmts(
                node.subblocks[1],
                node_parents=node_parents + [node],
                imr_parents=imr_parents,
                func_imr_parent=func_imr_parent,
                file_imr_parent=file_imr_parent,
                project_file=project_file,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64, msgs=msgs,
            ) later:

            await inner_insts
            if inner_insts == none or result_insts == none {
                result_insts = none
                return later
            }
            var block_item = none
            if item.kind == ast.N_STMT_DO {
                block_item = new IMRDo()
            } elseif item.kind == ast.N_EXPR_RESCUECLAUSE {
                block_item = new IMRRescue()
            } else {
                block_item = new IMRFinally()
            }
            block_item.line = node.line
            block_item.col = node.col
            block_item.instructions = []
            block_item.instructions += inner_insts
            result_insts.add(block_item)
        }
        if queue.len == 0 {
            return result_insts
        }
        var result = process_item(
            queue.pop_at(1)) later:

        await result
        if queue.len == 0 {
            return result_insts
        }
        result = process_item(
            queue.pop_at(1)) later repeat
    }
    if node.kind == ast.N_STMT_WITH {
        var result_insts = []

        var with_expr = node.subexprs[1]
        var inner_insts = generate_imr_for_stmts(
            node.subblocks[1],
            node_parents=node_parents + [node],
            imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            is_moose64=is_moose64, msgs=msgs,
        ) later:

        await inner_insts
        if inner_insts == none {
            result_insts = none
            return later
        }
        var with_result = generate_imr_for_expr(
            with_expr,
            node_parents=node_parents + [node],
            imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            is_moose64=is_moose64, msgs=msgs,
        ) later:

        await with_result
        if with_result == none {
            result_insts = none
            return later
        }
        var do_block = new IMRDo()
        do_block.line = node.line
        do_block.col = node.col
        do_block.instructions = []
        do_block.instructions += with_result.instructions
        # FIXME: See what the storage for the with label is,
        # and copy over the expression into that storage.
        do_block.instructions += inner_insts
        var finally_block = new IMRFinally()
        finally_block.line = node.line
        finally_block.col = node.col
        finally_block.instructions = []
        # FIXME: Insert has_attr() calls here to check
        # if item has ".close()" and call it if it does.
        return [do_block, finally_block]
    }
    if node.kind == ast.N_STMT_WHILE {
        var result_insts = []

        var clause = node.subexprs[1]
        var inner_insts = generate_imr_for_stmts(
            node.subblocks[1],
            node_parents=node_parents + [node],
            imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            is_moose64=is_moose64, msgs=msgs,
        ) later:

        await inner_insts
        if inner_insts == none {
            result_insts = none
            return later
        }
        var cls_result = generate_imr_for_expr(
            node.subexprs[1],
            node_parents=node_parents + [node],
            imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            is_moose64=is_moose64, msgs=msgs,
        ) later:

        await cls_result
        if cls_result == none {
            result_insts = none
            return later
        }
        var loop_block = new IMRLoop()
        loop_block.line = node.line
        loop_block.col = node.col
        loop_block.instructions = []
        loop_block.instructions += cls_result.instructions
        var inverse_op_token = new token.Token(
            "not",
            token.T_BOOLCOMP,
            node.line,
            node.col,
        )
        loop_block.instructions.add(new IMRApplyOp(
            inverse_op_token,
            operand_1_storage_ref=cls_result.storage_ref,
            target_storage_ref=cls_result.storage_ref,
            is_binary=no,
        ))
        var cond_block = new IMRCond(
            evaluated_cond_ref=cls_result.storage_ref,
        )
        cond_block.line = node.line
        cond_block.col = node.col
        cond_block.instructions.add(new IMRBreak())
        loop_block.instructions.add(cond_block)
        loop_block.instructions += inner_insts
        return [loop_block]
    }
    if node.kind == ast.N_STMT_TYPE or
            node.kind == ast.N_STMT_STRUCT or
            (node.kind == ast.N_STMT_UNION and
             imr_parents.len > 0) {
        var anscope = none
        assert(imr_parents.len == 0)
        anscope = project_file.make_attr_names_scope_from_node(
            node, msgs=msgs, is_moose64=is_moose64,
            def_project_file=project_file,
        )
        if anscope == none {
            throw new RuntimeError(
                "Failed to get attribute names scope "
                "for top-level struct or type."
            )
        }
        var is_type = (node.kind == ast.N_STMT_TYPE)
        var is_union = (node.kind == ast.N_STMT_UNION)
        var storage_id = none
        var base_type_storage_id = none
        storage_id = anscope.storage_id
        if is_type {
            base_type_storage_id =
                anscope.base_global_id
        }

        var label = node.label
        var unnested_ids = {}
        unnested_ids = anscope.unnested_ids_set

        var result_insts = []
        var block_item = new IMRStructOrTypeBlock(
            storage_id, label,
            base_type_id=base_type_storage_id,
            is_union=is_union,
            is_nested=imr_parents.len > 0,
            is_type=is_type
        )
        var processing_history_for_var_attrs = []
        func handle_var(
                var_storage_id, var_label, type_expr, imr_parent,
                def_project_file) {
            processing_history_for_var_attrs.add(var_storage_id)
            imr_parent.register_var_attr(
                var_storage_id, var_label,
                def_project_file,
                init_insts=[],
                type_expr=type_expr,
                is_moose64=is_moose64,
            ) later:

            return later
        }
        func handle_item(storage_id, var_label, type_expr,
                imr_parent, def_project_file, nestediteminfo) {
            if nestediteminfo == none {
                var result = handle_var(
                    storage_id, var_label, type_expr, imr_parent,
                    def_project_file
                ) later:

                await result
                return later result
            }
            if imr_parent == none {
                imr_parent = block_item
            }
            assert(imr_parent != none)
            handle_container(
                anscope_container=nestediteminfo,
                outer_imr_parent=imr_parent
            ) later:

            return later none
        }
        func handle_container(
                anscope_container=none,
                outer_imr_parent=none) {
            var inner_is_union = is_union
            var inner_is_type = is_type
            var inner_is_nested = no
            if anscope_container != none {
                search_in = anscope_container
                inner_is_union = anscope_container.is_union
                inner_is_type = no
                inner_is_nested = yes
            } else {
                if anscope == none {
                    throw new RuntimeError(
                        "Must either have an IMRNode parent, "
                        "or an attribute names scope."
                    )
                }
                search_in = anscope
            }
            var imr_parent = block_item
            if inner_is_nested {
                if outer_imr_parent == none {
                    outer_imr_parent = block_item
                }
                assert(anscope_container.storage_id != none)
                imr_parent = new IMRStructOrTypeBlock(
                    anscope_container.storage_id,
                    anscope_container.label,
                    base_type_id=none,
                    is_union=inner_is_union,
                    is_nested=inner_is_nested,
                    is_type=inner_is_type,
                    parent_imr_node=outer_imr_parent,
                )
                outer_imr_parent.register_struct_or_union_attr(
                    anscope_container.storage_id,
                    anscope_container.label,
                    imr_parent,
                )
            }
            var var_attr_queue = []
            for id in search_in.id_to_symbol_map {
                var nestiteminfo = none
                for entry in search_in.nested_structs_unions_list {
                    if has_attr(entry,
                            "is_nested_struct_or_union_item") and
                            entry.is_nested_struct_or_union_item == yes and
                            entry.symbol_info != none and
                            entry.symbol_info.storage_id == id {
                        nestiteminfo = entry
                        break
                    }
                }
                var is_nested_multiple_layers = no
                for entry in search_in.nested_structs_unions_list {
                    if entry == nestiteminfo {
                        continue
                    }
                    if entry.contains_storage_id(id) {
                        is_nested_multiple_layers = yes
                        break
                    }
                }
                if is_nested_multiple_layers {
                    continue
                }
                var symbol_info = search_in.id_to_symbol_map[id]
                if symbol_info.kind == st_scope.SINFO_FUNCATTR {
                    continue
                }
                var_attr_queue.add([
                    symbol_info.storage_id,
                    symbol_info.name,
                    if nestiteminfo == none (symbol_info.typeref_expr)
                        else (none),
                    imr_parent,
                    search_in.id_to_def_file_map[id],
                    nestiteminfo,
                ])
            }
            var_attr_queue.sort(by=1)

            if var_attr_queue.len == 0 {
                return later
            }
            var item = var_attr_queue.pop_at(1)
            var _unused = handle_item(
                item[1], item[2], item[3], item[4], item[5], item[6]
            ) later:

            await _unused
            if var_attr_queue.len == 0 {
                return later
            }
            var item = var_attr_queue.pop_at(1)
            var _unused = handle_item(
                item[1], item[2], item[3], item[4], item[5], item[6]
            ) later repeat
        }

        result_insts.add(block_item)
        handle_container() later:

        var var_init_insts = []
        var last_handled_pfile = project_file

        var init_func_imr_block = new IMRFuncBlock(
            none, "$varinit",
            new st_ref.StorageRef(
                st_ref.ST_GLOBALATTR,
                [storage_id,
                block_item.get_internal_init_func_attr_id()]),
            has_return_value=no,
            type_path=[node.label],
            is_extend=no,
        )
        init_func_imr_block.line = node.line
        init_func_imr_block.col = node.col
        result_insts.add(init_func_imr_block)

        func generate_var_init_insts_for_var(child_storage_id) {
            assert(typename(child_storage_id) == "num")
            var source_pfile = anscope.id_to_def_file_map[
                child_storage_id
            ]
            if source_pfile == none {
                throw new RuntimeError("The source file "
                    "for attribute was unexpectedly not found.")
            }
            func load_source_file_if_needed {
                if last_handled_pfile == source_pfile {
                    return later
                }
                source_pfile.ensure_ast()
                later:

                last_handled_pfile = source_pfile
            }
            load_source_file_if_needed() later:

            var assigned_ast_expr = none
            var assigning_stmt_found = no
            for stmt in source_pfile.ast.stmts {
                if (stmt.kind != ast.N_STMT_TYPE and
                        stmt.kind != ast.N_STMT_TYPEEXTEND) or
                        not is_type {
                    if (stmt.kind != ast.N_STMT_STRUCT and
                            stmt.kind != ast.N_STMT_STRUCTEXTEND) or
                            is_type {
                        continue
                    }
                }
                if stmt.label != node.label {
                    continue
                }
                func find_assign_expr_in_item(stmt) {
                    assert(stmt.subblocks.len == 1)
                    for innerstmt in stmt.subblocks[1] {
                        if innerstmt.kind == ast.N_STMT_VAR {
                            if innerstmt.symbol_info == none or
                                    innerstmt.symbol_info.len == 0 {
                                continue
                            }
                            var idx = 0
                            for sinfo in innerstmt.symbol_info {
                                idx += 1
                                if sinfo.storage_id == child_storage_id {
                                    return [yes, innerstmt.subexprs[idx]]
                                }
                            }
                        }
                        if innerstmt.kind == ast.N_STMT_STRUCT or
                                innerstmt.kind == ast.N_STMT_TYPE or
                                innerstmt.kind == ast.N_STMT_UNION {
                            var inner_result = find_assign_expr_in_item(
                                innerstmt
                            )
                            if inner_result != none and
                                    inner_result[1] {
                                return inner_result
                            }
                        }
                    }
                    return [no, none]
                }
                var result = find_assign_expr_in_item(stmt)
                if result[1] {
                    assigned_ast_expr = result[2]
                    assert(assigned_ast_expr == none or
                        has_attr(assigned_ast_expr, "kind"))
                    assigning_stmt_found = yes
                    break
                }
            }
            if not assigning_stmt_found {
                if msgs == none {
                    throw new RuntimeError("Internal error, "
                        "unexpectedly failed to find assign.")
                }
                msgs.add(new msg.FileMsg(
                    "Internal error, unexpectedly failed to "
                    "find originating assign statement for "
                    "one of the attributes of this type or "
                    "struct. This shouldn't be possible, please "
                    "report this error to the compiler makers.",
                    source_file=project_file,
                    line=node.line,
                    col=node.col,
                ))
                return later
            }
            if assigning_stmt_found and
                    (assigned_ast_expr == none or
                     (not is_moose64 and
                      assigned_ast_expr.kind == ast.N_EXPR_LIT and
                      assigned_ast_expr.literal_kind ==
                          ast_expr.LK_NORMAL and
                      assigned_ast_expr.value == none)) {
                return later
            }
            var cls_result = generate_imr_for_expr(
                assigned_ast_expr,
                node_parents=node_parents + [node],
                imr_parents=imr_parents,
                func_imr_parent=init_func_imr_block,
                file_imr_parent=file_imr_parent,
                project_file=source_pfile,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64, msgs=msgs,
            ) later:

            await cls_result
            if cls_result == none {
                result_insts = none
                return later
            }
            var_init_insts += cls_result.instructions
            var_init_insts.add(new IMRSetAttrById(
                target_and_obj_storage_ref=new st_ref.StorageRef(
                    st_ref.ST_SELF, 0),
                attr_id=child_storage_id,
                value_storage_ref=cls_result.storage_ref,
            ))
            return later
        }

        func generate_var_init_insts {
            var result = []
            var queue = processing_history_for_var_attrs.copy()
            if queue.len == 0 {
                return result
            }
            var item = queue.pop_at(1)
            var inner_result = generate_var_init_insts_for_var(
                item) later:

            await inner_result
            result.add(inner_result)
            if queue.len == 0 {
                return result
            }
            var item = queue.pop_at(1)
            inner_result = generate_var_init_insts_for_var(
                item) later repeat
        }
        generate_var_init_insts() later:

        func load_source_file_if_needed {
            if last_handled_pfile == project_file {
                return later
            }

            project_file.ensure_ast()
            later:

            last_handled_pfile = project_file
        }
        load_source_file_if_needed() later:

        init_func_imr_block.instructions += var_init_insts
        return result_insts
    }
    if node.kind == ast.N_STMT_IF {
        var result_insts = []

        var previous_clauses_unentered_ref = none

        var branches_count = 0
        var queue = []
        for clause in node.subexprs {
            branches_count += 1
            queue.add(clause)
        }
        func create_unentered_ref_if_needed {
            if branches_count <= 1 {
                return later
            }
            previous_clauses_unentered_ref =
                get_new_temp_storage_ref(
                    node, imr_parents=imr_parents,
                    func_imr_parent=func_imr_parent,
                    file_imr_parent=file_imr_parent,
                    project_file=project_file,
                    optional_type_info=
                        new typeinfo.create_from_simple_m64_type(
                            "bool"
                        ),
                    imr_build_tracker=imr_build_tracker,
                    is_moose64=is_moose64, msgs=msgs,
                ) later:

            await previous_clauses_unentered_ref
            result_insts.add(new IMRSetLit(
                yes, previous_clauses_unentered_ref,
                literal_kind=ast_expr.LK_NORMAL
            ))
        }
        create_unentered_ref_if_needed() later:

        var first_clause = yes
        var clause_idx = 0
        var clauses_insts = []
        var clauses_refs = []
        var clauses_childinsts = []
        func process_item(item) {
            clause_idx += 1
            if result_insts == none {
                return later none
            }
            func extract_clause {
                assert(clauses_insts.len == clause_idx - 1)
                if item.is_else {
                    var else_tmp_ref = get_new_temp_storage_ref(
                        item, imr_parents=imr_parents,
                        func_imr_parent=func_imr_parent,
                        file_imr_parent=file_imr_parent,
                        optional_type_info=
                            new typeinfo.create_from_simple_m64_type(
                                "bool"
                            ),
                        project_file=project_file,
                        imr_build_tracker=imr_build_tracker,
                        is_moose64=is_moose64, msgs=msgs,
                    ) later:

                    await else_tmp_ref
                    clauses_refs.add(else_tmp_ref)
                    clauses_insts.add([])
                    return later
                }
                var cls_result = generate_imr_for_expr(
                    item.subexprs[1],
                    node_parents=node_parents + [node],
                    imr_parents=imr_parents,
                    func_imr_parent=func_imr_parent,
                    file_imr_parent=file_imr_parent,
                    project_file=project_file,
                    imr_build_tracker=imr_build_tracker,
                    is_moose64=is_moose64, msgs=msgs,
                ) later:

                await cls_result
                if cls_result == none {
                    result_insts = none
                    first_clause = no
                    return later
                }
                clauses_refs.add(
                    cls_result.storage_ref
                )
                clauses_insts.add(
                    cls_result.instructions
                )
                return later
            }
            extract_clause() later:

            if result_insts == none {
                return later
            }
            var insts = generate_imr_for_stmts(
                item.subblocks[1],
                node_parents=node_parents + [
                    node, item
                ],
                imr_parents=imr_parents,
                func_imr_parent=func_imr_parent,
                file_imr_parent=file_imr_parent,
                project_file=project_file,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64, msgs=msgs,
            ) later:

            await insts
            if insts == none {
                result_insts = none
                first_clause = no
                return later
            }
            assert(typename(insts) == "list")
            if not first_clause {
                assert(branches_count > 1)
                assert(clauses_childinsts.len >= 1)
                var currentidx = clauses_insts.len
                var old_clause_cond_clauses = clauses_insts[currentidx]
                new_clause_precond = new IMRCond(
                    evaluated_cond_ref=previous_clauses_unentered_ref
                )
                if item.is_else {
                    assert(old_clause_cond_clauses == none or
                        old_clause_cond_clauses.len == 0)
                    var tmp_ref = clauses_refs[currentidx]
                    new_clause_precond.instructions = [
                        new IMRSetLit(
                            yes, clauses_refs[currentidx],
                            literal_kind=ast_expr.LK_NORMAL
                        )
                    ]
                } else {
                    new_clause_precond.instructions =
                        old_clause_cond_clauses
                }
                clauses_insts[currentidx] = [new IMRSetLit(
                    no, clauses_refs[currentidx],
                    literal_kind=ast_expr.LK_NORMAL
                ), new_clause_precond]
            }
            first_clause = no
            if clause_idx < branches_count and
                    branches_count > 1 {
                clauses_childinsts.add([new IMRSetLit(
                    no, previous_clauses_unentered_ref,
                    literal_kind=ast_expr.LK_NORMAL
                )] + insts)
            } else {
                clauses_childinsts.add(insts)
            }
        }
        func process_queue {
            if queue.len == 0 {
                return later
            }
            var result = process_item(queue.pop_at(1))
            later:

            await result
            if queue.len == 0 {
                return later
            }
            result = process_item(queue.pop_at(1))
            later repeat
        }
        process_queue()
        later:

        var i = 1
        while i <= clauses_insts.len {
            result_insts += clauses_insts[i]
            var cond = new IMRCond(
                evaluated_cond_ref=clauses_refs[i]
            )
            cond.instructions = clauses_childinsts[i]
            result_insts.add(cond)
            i += 1
        }
        return result_insts
    }
    if node.kind == ast.N_STMT_CALL and
            node.subexprs.len >= 1 {
        var call_result = generate_imr_for_expr(
            node.subexprs[1],
            node_parents=node_parents + [node],
            imr_parents=imr_parents,
            func_imr_parent=func_imr_parent,
            file_imr_parent=file_imr_parent,
            return_value_is_ignored=yes,
            project_file=project_file,
            imr_build_tracker=imr_build_tracker,
            is_moose64=is_moose64, msgs=msgs,
        ) later:

        await call_result
        if call_result == none {
            result_insts = none
            return later
        }
        result_insts = call_result.instructions.copy()
        return result_insts
    }
    if node.kind == ast.N_STMT_ASSIGN {
        if debug {
            print(program_name + ": debug: "
                "generate_imr_for_expr(): "
                "Looking at assign statement. node=" +
                    node.as_str().sub(1, 200))
        }
        var result_insts = []
        var queue = []
        var i = 1
        while i <= node.subexprs.len / 2 {
            queue.add([node.subexprs[i * 2 - 1],
                node.subexprs[i * 2]])
            i += 1
        }
        func process_queue_item(item) {
            var left_hand_type_info = none
            func determine_left_hand_type_info_if_needed {
                if not is_moose64 {
                    return later
                }
                left_hand_type_info =
                    m64_ast_analyze.get_c_or_m64_type_of_node(
                        project_file, item[1],
                        node_parents + [node],
                        store_self_value_ref_for_funcs=yes,
                        msgs=msgs,
                    ) later:

                await left_hand_type_info
                if left_hand_type_info == none {
                    node.damaged = yes
                    if msgs == none {
                        throw new RuntimeError(
                            "Failed to get type of assigned node."
                        )
                    } elseif not msg.msgs_contain_error(msgs) {
                        msgs.add(new msg.FileMsg(
                            "Internal error, unexpectedly failed "
                            "to determine type of assigned node. "
                            "Please report this to the compiler "
                            "makers.",
                            source_file=project_file,
                            line=node.line,
                            col=node.col,
                        ))
                    }
                    return later no
                }
                return later yes
            }
            var went_fine =
                determine_left_hand_type_info_if_needed()
            later:

            await went_fine
            if not went_fine {
                result_insts = none
                return later none
            }
            var right_hand_result = generate_imr_for_expr(
                item[2],
                node_parents=node_parents + [node],
                imr_parents=imr_parents,
                func_imr_parent=func_imr_parent,
                file_imr_parent=file_imr_parent,
                project_file=project_file,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64, msgs=msgs,
            ) later:

            await right_hand_result
            if right_hand_result == none or
                    (is_moose64 and
                     right_hand_result.known_type_info == none) {
                result_insts = none
                return later
            }
            var math_assign_token = none
            if node.assign_token.kind == token.T_MATHASSIGN {
                var t_str = node.assign_token.str
                if not t_str.ends("=") {
                    throw new ValueError("Encountered unsupported "
                        "type of math assign.")
                }
                math_assign_token = new token.Token(
                    t_str.sub(1, t_str.len - 1),
                    token.T_MATH,
                    node.assign_token.line,
                    node.assign_token.col,
                )
            }

            if debug {
                print(program_name + ": debug: "
                    "generate_imr_for_expr(): "
                    "Looking at inner assigned item. "
                    "right_hand_result=" +
                        right_hand_result.as_str() + " "
                    "left_hand_type_info=" +
                        left_hand_type_info.as_str() + " "
                    "math_assign_token=" +
                        math_assign_token.as_str())
            }

            var moose64_cast_info = none
            func determine_mathassign_cast_info_if_any {
                if not is_moose64 {
                    return later
                }
                if node.assign_token.kind != token.T_MATHASSIGN {
                    return later
                }
                moose64_cast_info =
                    m64_autocast.get_math_binop_autocast(
                        left_hand_type_info,
                        right_hand_result.known_type_info,
                        left_side_is_literal_none=no,
                        right_side_is_literal_none=
                            item[2].kind == ast.N_EXPR_LIT and
                            item[2].literal_kind ==
                                ast_expr.LK_NORMAL and
                            item[2].value == none,
                        is_cmp_op=no,
                        is_moose64=is_moose64,
                    )
            }
            determine_mathassign_cast_info_if_any() later:

            if moose64_cast_info != none and
                    moose64_cast_info.incompatible {
                node.damaged = yes
                if msgs == none {
                    throw new RuntimeError(
                        "Incompatible type of math assignment."
                    )
                } elseif not msg.msgs_contain_error(msgs) {
                    msgs.add(new msg.FileMsg(
                        "Unexpected '" + node.optoken.str.as_str() +
                        "' operator applied to incompatible types " +
                        left_hand_type_info.describe_to_user(
                            project=project_file.project,
                            add_quotes_where_useful=yes,
                            is_moose64=is_moose64,
                        ) + " "
                        "and " + right_hand_result.known_type_info.
                            describe_to_user(
                                project=project_file.project,
                                add_quotes_where_useful=yes,
                                is_moose64=is_moose64,
                            ) + ".",
                        source_file=project_file,
                        line=node.optoken.line,
                        col=node.optoken.col,
                    ))
                }
                return later yes
            }

            var must_convert_value_before_final_assign = no
            var final_result_convert_from = none
            var final_result_convert_to = none
            func check_conversion_of_final_assign {
                if not is_moose64 {
                    return
                }
                if node.assign_token.kind == token.T_MATHASSIGN {
                    assert(moose64_cast_info != none)
                    if moose64_cast_info.result_type.is_equivalent(
                            left_hand_type_info,
                            ignore_self_ref=yes,
                            is_moose64=is_moose64,
                            ) {
                        return
                    }
                    must_convert_value_before_final_assign = yes
                    final_result_convert_from =
                        moose64_cast_info.result_type
                    final_result_convert_to = left_hand_type_info
                } else {
                    if left_hand_type_info.is_equivalent(
                            right_hand_result.known_type_info,
                            ignore_self_ref=yes,
                            is_moose64=is_moose64,
                            ) {
                        return
                    }
                    must_convert_value_before_final_assign = yes
                    final_result_convert_from =
                        right_hand_result.known_type_info
                    final_result_convert_to = left_hand_type_info
                }
                if not m64_autocast.
                        check_if_allowed_implicit_cast_from_to(
                            final_result_convert_from,
                            final_result_convert_to,
                            left_side_is_literal_none=no,
                            right_side_is_literal_none=
                                item[2].kind == ast.N_EXPR_LIT and
                                item[2].literal_kind ==
                                    ast_expr.LK_NORMAL and
                                item[2].value == none,
                            is_moose64=is_moose64,
                        ) {
                    node.damaged = yes
                    if msgs == none {
                        throw new RuntimeError(
                            "Incompatible type of assignment."
                        )
                    } elseif not msg.msgs_contain_error(msgs) {
                        msgs.add(new msg.FileMsg(
                            "Unexpected assignment of value of "
                            "type " + final_result_convert_from.
                                describe_to_user(
                                    project=project_file.project,
                                    add_quotes_where_useful=yes,
                                    is_moose64=is_moose64,
                                ) + ", "
                            "cannot be converted to type " +
                            final_result_convert_to.describe_to_user(
                                project=project_file.project,
                                add_quotes_where_useful=yes,
                                is_moose64=is_moose64,
                            ) + ".",
                            source_file=project_file,
                            line=right_hand_result.line,
                            col=right_hand_result.col,
                        ))
                        result_insts = none
                    }
                }
            }
            check_conversion_of_final_assign()

            if result_insts == none {
                return later
            }
            result_insts += right_hand_result.instructions

            var op_result_preconv_tmp = none
            var op_result_conv_tmp = none
            var convert_opresult_from = none
            var convert_opresult_to = none
            var left_operand_conv_tmp = none
            var left_operand_preconv_tmp = none
            var convert_lefthand_from = none
            var convert_lefthand_to = none
            var right_operand_conv_tmp = none
            var right_operand_preconv_tmp = none
            func make_lefthand_tmps {
                if node.assign_token.kind != token.T_MATHASSIGN {
                    return later
                }

                left_operand_preconv_tmp = get_new_temp_storage_ref(
                    node, imr_parents=imr_parents,
                    func_imr_parent=func_imr_parent,
                    file_imr_parent=file_imr_parent,
                    project_file=project_file,
                    optional_type_info=left_hand_type_info,
                    imr_build_tracker=imr_build_tracker,
                    is_moose64=is_moose64, msgs=msgs,
                ) later:

                await left_operand_preconv_tmp
                if not is_moose64 or
                        node.assign_token.kind != token.T_MATHASSIGN or
                        left_hand_type_info.is_equivalent(
                            moose64_cast_info.cast_lefthand_to,
                            ignore_self_ref=yes,
                            is_moose64=is_moose64,
                            ) {
                    left_operand_conv_tmp =
                        left_operand_preconv_tmp
                    return later
                }
                convert_lefthand_from = left_hand_type_info
                convert_lefthand_to = moose64_cast_info.cast_lefthand_to
                left_operand_conv_tmp = get_new_temp_storage_ref(
                    node, imr_parents=imr_parents,
                    func_imr_parent=func_imr_parent,
                    file_imr_parent=file_imr_parent,
                    project_file=project_file,
                    optional_type_info=
                        moose64_cast_info.cast_lefthand_to,
                    imr_build_tracker=imr_build_tracker,
                    is_moose64=is_moose64, msgs=msgs,
                ) later:

                await left_operand_preconv_tmp
            }
            make_lefthand_tmps() later:

            func make_opresult_tmp {
                if node.assign_token.kind != token.T_MATHASSIGN {
                    return later
                }
                if not is_moose64 or
                        node.assign_token.kind != token.T_MATHASSIGN or
                        moose64_cast_info.result_type.is_equivalent(
                            moose64_cast_info.cast_lefthand_to,
                            ignore_self_ref=yes,
                            is_moose64=is_moose64,
                        ) {
                    op_result_preconv_tmp =
                        left_operand_conv_tmp
                    return later
                }
                op_result_preconv_tmp = get_new_temp_storage_ref(
                    node, imr_parents=imr_parents,
                    func_imr_parent=func_imr_parent,
                    file_imr_parent=file_imr_parent,
                    project_file=project_file,
                    optional_type_info=
                        moose64_cast_info.result_type,
                    imr_build_tracker=imr_build_tracker,
                    is_moose64=is_moose64, msgs=msgs,
                ) later:

                await op_result_preconv_tmp
            }
            make_opresult_tmp() later:

            func check_opresult_conversion {
                if is_moose64 and
                        node.assign_token.kind == token.T_MATHASSIGN and
                        not moose64_cast_info.result_type.is_equivalent(
                            left_hand_type_info,
                            ignore_self_ref=yes,
                            is_moose64=is_moose64,
                        ) {
                    convert_opresult_from = moose64_cast_info.result_type
                    convert_opresult_to = left_hand_type_info
                    op_result_conv_tmp = get_new_temp_storage_ref(
                        node, imr_parents=imr_parents,
                        func_imr_parent=func_imr_parent,
                        file_imr_parent=file_imr_parent,
                        project_file=project_file,
                        optional_type_info=
                            convert_opresult_to,
                        imr_build_tracker=imr_build_tracker,
                        is_moose64=is_moose64, msgs=msgs,
                    ) later:

                    await op_result_conv_tmp
                } else {
                    op_result_conv_tmp = op_result_preconv_tmp
                }
            }
            check_opresult_conversion() later:

            var converted_right_hand_ref =
                right_hand_result.storage_ref
            func do_right_hand_convert {
                if is_moose64 {
                    return later
                }
                if not must_convert_value_before_final_assign {
                    return later
                }
                var right_hand_required_type =
                    left_hand_type_info
                if node.assign_token.kind == token.T_MATHASSIGN {
                    right_hand_required_type =
                        moose64_cast_info.cast_righthand_to
                }
                if right_hand_required_type.is_equivalent(
                        right_hand_result.known_type_info,
                        ignore_self_ref=yes,
                        is_moose64=is_moose64,
                        ) {
                    return later
                }
                converted_right_hand_ref = get_new_temp_storage_ref(
                    node, imr_parents=imr_parents,
                    func_imr_parent=func_imr_parent,
                    file_imr_parent=file_imr_parent,
                    project_file=project_file,
                    optional_type_info=right_hand_required_type,
                    imr_build_tracker=imr_build_tracker,
                    is_moose64=is_moose64, msgs=msgs,
                ) later:

                await converted_right_hand_ref
                result_insts.add(new IMRConv(
                    right_hand_result.storage_ref,
                    converted_right_hand_ref,
                    right_hand_result.known_type_info,
                    right_hand_required_type,
                    in_project_file=project_file,
                    is_moose64=is_moose64,
                ))
            }
            do_right_hand_convert() later:

            var left_hand_node = item[1]
            func try_handle_set_idx {
                if left_hand_node.kind != ast.N_EXPR_BINOP or
                        left_hand_node.optoken.str != "[" or
                        left_hand_node.subexprs.len < 2 {
                    return later no
                }
                var container_result = generate_imr_for_expr(
                    left_hand_node.subexprs[1],
                    node_parents=node_parents + [
                        node, left_hand_node],
                    imr_parents=imr_parents,
                    func_imr_parent=func_imr_parent,
                    file_imr_parent=file_imr_parent,
                    project_file=project_file,
                    imr_build_tracker=imr_build_tracker,
                    is_moose64=is_moose64, msgs=msgs,
                ) later:

                await container_result
                var idx_result = generate_imr_for_indexing_expr(
                    left_hand_node.subexprs[2],
                    node_parents=node_parents + [
                        node, left_hand_node],
                    imr_parents=imr_parents,
                    func_imr_parent=func_imr_parent,
                    file_imr_parent=file_imr_parent,
                    project_file=project_file,
                    imr_build_tracker=imr_build_tracker,
                    is_moose64=is_moose64, msgs=msgs,
                ) later:

                await idx_result
                if debug {
                    print(program_name + ": debug: "
                        "generate_imr_for_expr(): "
                        "For assign, we got an indexing result. "
                        "idx_result=" + idx_result.as_str())
                }
                var idx_tmp_ref = none
                if container_result == none or idx_result == none {
                    result_insts = none
                    return later yes
                }
                idx_tmp_ref = idx_result.storage_ref

                if node.assign_token.kind == token.T_ASSIGN {
                    result_insts.add(new IMRSetIdx(
                        target_and_container_storage_ref=
                            container_result.storage_ref,
                        index_storage_ref=
                            idx_result.storage_ref,
                        value_storage_ref=
                            converted_right_hand_ref,
                    ))
                    return later yes
                } elseif math_assign_token != none {
                    result_insts.add(new IMRGetIdx(
                        container_storage_ref=
                            container_result.storage_ref,
                        index_storage_ref=idx_tmp_ref,
                        target_storage_ref=left_operand_preconv_tmp,
                    ))
                    if convert_lefthand_from != convert_lefthand_to {
                        result_insts.add(new IMRConv(
                            left_operand_preconv_tmp,
                            left_operand_conv_tmp,
                            convert_lefthand_from,
                            convert_lefthand_to,
                            in_project_file=project_file,
                            is_moose64=is_moose64,
                        ))
                    } else {
                        assert(left_operand_preconv_tmp ==
                            left_operand_conv_tmp)
                    }
                    result_insts.add(new IMRApplyOp(
                        math_assign_token,
                        operand_1_storage_ref=
                            left_operand_conv_tmp,
                        operand_2_storage_ref=
                            converted_right_hand_ref,
                        target_storage_ref=op_result_preconv_tmp,
                        is_binary=yes,
                    ))
                    if convert_opresult_from !=
                            convert_opresult_to {
                        assert(op_result_preconv_tmp != op_result_conv_tmp)
                        result_insts.add(new IMRConv(
                            op_result_preconv_tmp,
                            op_result_conv_tmp,
                            convert_opresult_from,
                            convert_opresult_to,
                            in_project_file=project_file,
                            is_moose64=is_moose64,
                        ))
                    } else {
                        assert(op_result_preconv_tmp == op_result_conv_tmp)
                    }
                    result_insts.add(new IMRSetIdx(
                        target_and_container_storage_ref=
                            container_result.storage_ref,
                        index_storage_ref=
                            idx_result.storage_ref,
                        value_storage_ref=op_result_conv_tmp,
                    ))
                    return later yes
                } else {
                    throw new ValueError("Encountered unsupported "
                        "type of assign.")
                }
            }
            func try_handle_set_attr {
                if left_hand_node.kind != ast.N_EXPR_BINOP or
                        left_hand_node.optoken.str != "." or
                        left_hand_node.subexprs.len < 2 or
                        left_hand_node.subexprs[2].kind !=
                            ast.N_EXPR_IDREF {
                    return later no
                }
                var attr_name = left_hand_node.subexprs[2].label
                var obj_result = generate_imr_for_expr(
                    left_hand_node.subexprs[1],
                    node_parents=node_parents + [
                        node, left_hand_node],
                    imr_parents=imr_parents,
                    func_imr_parent=func_imr_parent,
                    file_imr_parent=file_imr_parent,
                    project_file=project_file,
                    imr_build_tracker=imr_build_tracker,
                    is_moose64=is_moose64, msgs=msgs,
                ) later:

                await obj_result
                if obj_result == none {
                    result_insts = none
                    return later yes
                }
                if node.assign_token.kind == token.T_ASSIGN {
                    result_insts.add(new IMRSetAttrByName(
                        target_and_obj_storage_ref=
                            obj_result.storage_ref,
                        attr_name=attr_name,
                        value_storage_ref=
                            converted_right_hand_ref,
                    ))
                    return later yes
                } elseif math_assign_token != none {
                    result_insts.add(new IMRGetAttrByName(
                        obj_storage_ref=
                            obj_result.storage_ref,
                        attr_name=attr_name,
                        target_storage_ref=left_operand_preconv_tmp,
                    ))
                    if convert_lefthand_from != convert_lefthand_to {
                        result_insts.add(new IMRConv(
                            left_operand_preconv_tmp,
                            left_operand_conv_tmp,
                            convert_lefthand_from,
                            convert_lefthand_to,
                            in_project_file=project_file,
                            is_moose64=is_moose64,
                        ))
                    } else {
                        assert(left_operand_preconv_tmp ==
                            left_operand_conv_tmp)
                    }
                    result_insts.add(new IMRApplyOp(
                        math_assign_token,
                        operand_1_storage_ref=left_operand_conv_tmp,
                        operand_2_storage_ref=
                            converted_right_hand_ref,
                        target_storage_ref=op_result_preconv_tmp,
                        is_binary=yes,
                    ))
                    if convert_opresult_from !=
                            convert_opresult_to {
                        assert(op_result_preconv_tmp != op_result_conv_tmp)
                        result_insts.add(new IMRConv(
                            op_result_preconv_tmp,
                            op_result_conv_tmp,
                            convert_opresult_from,
                            convert_opresult_to,
                            in_project_file=project_file,
                            is_moose64=is_moose64,
                        ))
                    } else {
                        assert(op_result_preconv_tmp == op_result_conv_tmp)
                    }
                    result_insts.add(new IMRSetAttrByName(
                        target_and_obj_storage_ref=
                            obj_result.storage_ref,
                        attr_name=attr_name,
                        value_storage_ref=op_result_conv_tmp,
                    ))
                    return later yes
                } else {
                    throw new ValueError("Encountered unsupported "
                        "type of assign.")
                }
            }

            # Try to handle the special set index case:
            var success_idx = try_handle_set_idx() later:

            await success_idx
            if success_idx {
                return later
            }
            # Try to handle the special set attr case:
            var success_attr = try_handle_set_attr() later:

            await success_attr
            if success_attr {
                return later
            }

            # If we arrive here, it must be a regular assign
            # that isn't a set index or set attr:
            if left_hand_node.kind != ast.N_EXPR_IDREF or
                    left_hand_node.ref == none {
                return later
            }
            if result_insts != none and
                    right_hand_result != none {
                if node.assign_token.kind == token.T_ASSIGN {
                    result_insts.add(new IMRMove(
                        converted_right_hand_ref,
                        left_hand_node.ref,
                    ))
                } elseif math_assign_token != none {
                    var adjust_op_result_preconv = no
                    var adjust_op_result_conv = no
                    var adjust_left_operand_conv = no
                    if op_result_preconv_tmp == left_operand_conv_tmp {
                        adjust_op_result_preconv = yes
                    }
                    if op_result_conv_tmp == left_operand_conv_tmp {
                        adjust_op_result_conv = yes
                    }
                    if left_operand_preconv_tmp ==
                            left_operand_conv_tmp {
                        adjust_left_operand_conv = yes
                    }
                    if adjust_op_result_preconv {
                        op_result_preconv_tmp = left_hand_node.ref
                    }
                    if adjust_op_result_conv {
                        op_result_conv_tmp = left_hand_node.ref
                    }
                    if adjust_left_operand_conv {
                        left_operand_conv_tmp = left_hand_node.ref
                    }
                    left_operand_preconv_tmp = left_hand_node.ref

                    if convert_lefthand_from != convert_lefthand_to {
                        result_insts.add(new IMRConv(
                            left_operand_preconv_tmp,
                            left_operand_conv_tmp,
                            convert_lefthand_from,
                            convert_lefthand_to,
                            in_project_file=project_file,
                            is_moose64=is_moose64,
                        ))
                    } else {
                        assert(left_operand_preconv_tmp ==
                            left_operand_conv_tmp)
                    }
                    result_insts.add(new IMRApplyOp(
                        math_assign_token,
                        operand_1_storage_ref=
                            left_operand_conv_tmp,
                        operand_2_storage_ref=
                            converted_right_hand_ref,
                        target_storage_ref=
                            op_result_preconv_tmp,
                        is_binary=yes,
                    ))
                    if convert_opresult_from !=
                            convert_opresult_to {
                        assert(op_result_preconv_tmp != op_result_conv_tmp)
                        result_insts.add(new IMRConv(
                            op_result_preconv_tmp,
                            op_result_conv_tmp,
                            convert_opresult_from,
                            convert_opresult_to,
                            in_project_file=project_file,
                            is_moose64=is_moose64,
                        ))
                    } else {
                        assert(op_result_preconv_tmp == op_result_conv_tmp)
                    }
                    if not op_result_conv_tmp.alike(
                            left_hand_node.ref) {
                        result_insts.add(new IMRMove(
                            op_result_conv_tmp,
                            left_hand_node.ref,
                        ))
                    }
                } else {
                    throw new ValueError("Encountered unsupported "
                        "type of assign.")
                }
            } else {
                result_insts = none
                return later yes
            }
        }
        if queue.len == 0 or result_insts == none {
            return later result_insts
        }
        var _unused = process_queue_item(queue.pop_at(1))
        later:

        await _unused
        if queue.len == 0 or result_insts == none {
            return later result_insts
        }
        _unused = process_queue_item(queue.pop_at(1))
        later repeat
    }
    return later none
}

func generate_imr_for_stmts(
        nodes,
        node_parents=[],
        imr_parents=[],
        func_imr_parent=none,
        file_imr_parent=none,
        project_file=none,
        imr_build_tracker=none,
        is_moose64=no, msgs=none,
        ) {
    var result = []
    var queue = nodes.copy()
    if queue.len == 0 {
        return later result
    }
    var item = queue.pop_at(1)
    var inner_result = generate_imr_for_stmt(
        item,
        node_parents=node_parents,
        imr_parents=imr_parents,
        func_imr_parent=func_imr_parent,
        file_imr_parent=file_imr_parent,
        project_file=project_file,
        imr_build_tracker=imr_build_tracker,
        is_moose64=is_moose64, msgs=msgs,
    ) later:

    await inner_result
    if inner_result != none {
        if typename(inner_result) == "list" {
            result += inner_result
        } else {
            result.add(inner_result)
        }
    }
    if queue.len == 0 {
        return later result
    }
    var item = queue.pop_at(1)
    var inner_result = generate_imr_for_stmt(
        item,
        node_parents=node_parents,
        imr_parents=imr_parents,
        func_imr_parent=func_imr_parent,
        file_imr_parent=file_imr_parent,
        project_file=project_file,
        imr_build_tracker=imr_build_tracker,
        is_moose64=is_moose64, msgs=msgs,
    ) later repeat
}

func is_func_stmt_entry_point_func(
        pfile, stmt, build_options=none,
        is_moose64=no,
        ) {
    if not pfile.is_entrypoint {
        return no
    }
    if stmt == none or stmt.kind != ast.N_STMT_FUNC {
        return no
    }
    return stmt.label == "main"
}

func generate_imr_for_file(
        pfile,
        imr_build_tracker=none,
        build_options=none,
        is_moose64=no,
        msgs=none,
        ) {
    const program_name =
        if is_moose64 ("moosec") else ("horsec")

    var result = new IMRForFile()
    result.project_file = pfile

    pfile.ensure_ast() later:

    var _func_stmt_to_imr_func_map = {->}

    func get_imr_node_for_func(node) {
        if not {ast.N_STMT_FUNC,
                ast.N_STMT_FUNCEXTEND}.has(
                    node.kind) {
            return none
        }

        if not _func_stmt_to_imr_func_map.has(
                node) {
            var item = result.find_global_func_by_label(
                node.label, type_path=node.type_path,
            )
            _func_stmt_to_imr_func_map[
                node
            ] = item
        }
        return _func_stmt_to_imr_func_map[
            node
        ]
    }

    func collect_funcs(node, parents) {
        var parent = if parents.len > 0
            (parents[parents.len]) else (none)
        if node.damaged {
            return later node
        }
        if node.kind == ast.N_STMT_FUNC or
                node.kind == ast.N_STMT_FUNCEXTEND {
            var is_extend =
                node.kind == ast.N_STMT_FUNCEXTEND
            var fscope = node.func_scope
            assert(fscope != none)

            var pos_arg_count = 0
            var kw_arg_count = 0
            var known_arg_type_exprs = none
            var known_arg_type_storage_refs = none
            var has_return_value = no
            var known_return_type_expr = none
            var known_return_type_storage_ref = none
            var kw_arg_names = []
            var full_arg_names = []

            kw_arg_count = fscope.extended_final_kw_arg_count(
                include_outer_extends=no
            )
            pos_arg_count = fscope.extended_final_arg_count(
                include_outer_extends=no
            ) - kw_arg_count
            full_arg_names = fscope.extended_final_arg_names(
                include_outer_extends=no
            )
            var i = pos_arg_count + 1
            while i <= pos_arg_count + kw_arg_count {
                kw_arg_names.add(full_arg_names[i])
                i += 1
            }

            has_return_value = (
                not is_moose64 or
                (fscope.extended_final_has_return_type() and
                 fscope.extended_final_return_type_expr() != none and
                 (fscope.extended_final_return_type_expr().is_user_type() or
                  fscope.extended_final_return_type_expr().name != "empty"))
            )
            func resolve_arg_type(type_expr) {
                var result = type_expr.try_resolve_to_user_type(
                    pfile, is_moose64=is_moose64
                ) later:

                await result
                if result != none and
                        not result.had_error and
                        not result.resolved_to_nonuser_type {
                    known_arg_type_storage_refs.add(
                        result.resolved_storage_ref
                    )
                } else {
                    known_arg_type_storage_refs.add(none)
                }
                return later
            }
            func fetch_return_type_if_needed {
                if not has_return_value or
                        (not is_moose64 and
                         not fscope.
                            extended_final_has_return_type()) {
                    return later
                }
                known_return_type_expr = fscope.
                    extended_final_return_type_expr()
                known_return_type_storage_ref = none
                var result = known_return_type_expr.
                    try_resolve_to_user_type(
                        pfile, is_moose64=is_moose64
                    ) later:

                await result
                if result != none and
                        not result.had_error and
                        not result.resolved_to_nonuser_type {
                    known_return_type_storage_ref =
                        result.resolved_storage_ref
                }
            }
            func fetch_arg_types_if_needed {
                if not is_moose64 {
                    return later
                }
                known_arg_type_exprs =
                    fscope.extended_final_arg_type_exprs(
                        include_outer_extends=no
                    )
                known_arg_type_storage_refs = []
                var queue = known_arg_type_exprs.copy()
                if queue.len == 0 {
                    return later
                }
                var _unused = resolve_arg_type(queue.pop_at(1))
                later:

                await _unused
                if queue.len == 0 {
                    return later
                }
                _unused = resolve_arg_type(queue.pop_at(1))
                later repeat
            }
            fetch_arg_types_if_needed() later:
            fetch_return_type_if_needed() later:

            if is_moose64 and
                    known_arg_type_storage_refs.len !=
                    pos_arg_count + kw_arg_count {
                throw new RuntimeError("Internal error, "
                    "unexpectedly failed to "
                    "analyze argument types.")
            }
            if is_moose64 and
                    has_return_value and
                    known_return_type_expr == none {
                throw new RuntimeError("Internal error, "
                    "unexpectedly failed to analyze "
                    "return type.")
            }
            var block = none
            if node.type_path != none and
                    node.type_path.len > 0 {
                assert(fscope.is_type_attr)
                var type_id =
                    fscope.owning_type_storage_id
                var attr_id =
                    fscope.owning_type_scope.
                        name_to_symbol_map[
                            node.label
                        ].storage_id
                if type_id == none or attr_id == none {
                    var node_str = node.as_str()
                    print(program_name + ": error: "
                        "Found invalid func node with "
                        "invalid storage. pfile=" +
                        pfile.as_str() + " "
                        "label=" + textfmt.as_escaped_code_string(
                            node.label) + " "
                        "node=" +
                        node_str.sub(1, 100) +
                        "... "
                        "type_id=" + type_id.as_str() + " "
                        "attr_id=" + attr_id.as_str())
                    throw new RuntimeError(
                        "Internal error, encountered func "
                        "node with broken storage."
                    )
                }
                block = new IMRFuncBlock(
                    fscope, node.label,
                    new st_ref.StorageRef(
                        st_ref.ST_GLOBALATTR,
                        [type_id, attr_id]),
                    pos_arg_count=pos_arg_count,
                    kw_arg_count=kw_arg_count,
                    has_return_value=has_return_value,
                    kw_arg_names=kw_arg_names,
                    known_arg_type_exprs=
                        known_arg_type_exprs,
                    known_arg_type_storage_refs=
                        known_arg_type_storage_refs,
                    known_return_type_expr=
                        known_return_type_expr,
                    known_return_type_storage_ref=
                        known_return_type_storage_ref,
                    type_path=node.type_path,
                    is_extend=is_extend,
                )
                block.line = node.line
                block.col = node.col
            } else {
                block = new IMRFuncBlock(
                    fscope, node.label,
                    new st_ref.StorageRef(
                        st_ref.ST_GLOBAL,
                        fscope.storage_id
                    ),
                    pos_arg_count=pos_arg_count,
                    kw_arg_count=kw_arg_count,
                    has_return_value=has_return_value,
                    kw_arg_names=kw_arg_names,
                    known_arg_type_exprs=
                        known_arg_type_exprs,
                    known_arg_type_storage_refs=
                        known_arg_type_storage_refs,
                    known_return_type_expr=
                        known_return_type_expr,
                    known_return_type_storage_ref=
                        known_return_type_storage_ref,
                    is_extend=is_extend,
                )
                block.line = node.line
                block.col = node.col
            }
            result.blocks.add(block)
            _func_stmt_to_imr_func_map[node] = block
        }
        return later node
    }
    var success = ast_transform.visit_ast_tree(
        pfile.ast, collect_funcs,
        pass_func_boundaries=yes,
        parent_chain=yes, backward=no,
    ) later:

    await success
    if not success {
        assert(msgs == none or
            msg.msgs_contain_error(msgs))
        return result
    }
    assert(success == yes)

    var init_func_info = globals_order.
        generate_init_funcs_for_file(
            pfile
        ) later:

    await init_func_info
    pfile.ensure_ast()
    later:

    func collect_func_and_type_contents(node, parents) {
        var parent = if parents.len > 0
            (parents[parents.len]) else (none)
        if node.damaged {
            return later node
        }
        if (node.kind == ast.N_STMT_TYPE or
                node.kind == ast.N_STMT_STRUCT) and
                parent == none {
            var stmts = generate_imr_for_stmt(
                node,
                node_parents=[],
                imr_parents=[],
                func_imr_parent=none,
                file_imr_parent=result,
                project_file=pfile,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64,
                msgs=msgs,
            ) later:

            await stmts
            func have_struct_or_type_entry(l) {
                for entry in l {
                    if entry.kind == IMR_BLOCK_STRUCTORTYPE {
                        return yes
                    }
                }
                return no
            }
            if stmts.len < 1 or not have_struct_or_type_entry(stmts) {
                throw new RuntimeError(
                    "Unexpectedly didn't get any "
                    "IMR_BLOCK_STRUCTORTYPE when processing "
                    "type or struct."
                )
            }
            result.blocks += stmts

            return later node
        }
        if node.kind == ast.N_STMT_FUNC or
                node.kind == ast.N_STMT_FUNCEXTEND {
            var is_entrypoint = is_func_stmt_entry_point_func(
                pfile, node,
                build_options=build_options,
                is_moose64=is_moose64,
            )
            var imr_node = get_imr_node_for_func(node)
            assert(imr_node != none)

            var inner_code_stmts = generate_imr_for_stmts(
                node.subblocks[1],
                node_parents=[node],
                imr_parents=[imr_node],
                func_imr_parent=imr_node,
                file_imr_parent=result,
                project_file=pfile,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64,
                msgs=msgs,
            ) later:

            await inner_code_stmts
            imr_node.instructions += inner_code_stmts
            return later node
        }
        return later node
    }
    var success = ast_transform.visit_ast_tree(
        pfile.ast, collect_func_and_type_contents,
        pass_func_boundaries=yes,
        parent_chain=yes, backward=no,
    ) later:

    await success
    if not success {
        assert(msgs == none or
            msg.msgs_contain_error(msgs))
        return result
    }
    assert(success == yes)
    func handle_global_init_func(info) {
        var name = info.suggested_name
        if not name.starts("$") {
            name = "$" + name
        }
        var new_global_id = pfile.project.last_global_storage_id + 1
        pfile.project.last_global_storage_id = new_global_id
        var init_func_imr_block = new IMRFuncBlock(
            none, name,
            new st_ref.StorageRef(
                st_ref.ST_GLOBAL,
                new_global_id),
            has_return_value=no,
            type_path=none,
            is_extend=no,
        )
        imr_build_tracker.global_init_func_name_to_id_map[
            name
        ] = new_global_id
        result.blocks.add(init_func_imr_block)
        var queue = []
        for init_id in info.storage_ids_for_init {
            queue.add(init_id)
        }
        func handle_global_var_init(varid) {
            # XXX: We're not using the global scope here,
            # since we don't want the drop-in node copy but
            # the original AST node.
            var stmt = none
            var idx = 0
            for teststmt in pfile.ast.stmts {
                if teststmt.kind != ast.N_STMT_VAR {
                    continue
                }
                var found = no
                idx = 0
                for sym_info in teststmt.symbol_info {
                    idx += 1
                    if sym_info.storage_id == varid {
                        found = yes
                        break
                    }
                }
                if not found {
                    continue
                } else {
                    stmt = teststmt
                    break
                }
            }
            assert(idx >= 1 and idx <= stmt.var_labels.len)
            var var_label = stmt.var_labels[idx]
            var var_type_expr = none
            var var_type_storage_ref = none
            if stmt.has_type_expr {
                var_type_expr = stmt.subexprs[stmt.subexprs.len]
            }
            var var_assigned_expr = stmt.subexprs[idx]
            if not is_moose64 and
                    (var_assigned_expr != none and
                     var_assigned_expr.kind == ast.N_EXPR_LIT and
                     var_assigned_expr.literal_kind ==
                         ast_expr.LK_NORMAL and
                     var_assigned_expr.value == none) {
                var_assigned_expr = none
            }
            func resolve_var_type_expr_if_needed {
                if var_type_expr == none {
                    return
                }
                var result = var_type_expr.try_resolve_to_user_type(
                    pfile, is_moose64=is_moose64,
                ) later:

                await result
                if result != none and
                        not result.had_error and
                        not result.resolved_to_nonuser_type {
                    var_type_storage_ref = result.resolved_storage_ref
                }
            }
            resolve_var_type_expr_if_needed()
            later:

            var new_inst = new IMRVarInfo(
                var_label, var_type_expr,
                varid, var_type_storage_ref,
                pfile,
            )
            result.blocks = [new_inst] + result.blocks

            var left_hand_storage_id = varid
            var var_ref = new st_ref.StorageRef(
                st_ref.ST_GLOBAL, left_hand_storage_id
            )
            if is_moose64 and (var_assigned_expr == none or
                    (var_assigned_expr == ast.N_EXPR_LIT and
                     var_assigned_expr.literal_kind ==
                         ast_expr.LK_NORMAL and
                     var_assigned_expr.value == none)) {
                result_insts.add(new IMRClrZero(
                    var_ref,
                ))
                return later yes
            }
            if not is_moose64 and var_assigned_expr == none {
                return later yes
            }
            var right_hand_result = generate_imr_for_expr(
                var_assigned_expr,
                node_parents=[stmt],
                imr_parents=[init_func_imr_block],
                func_imr_parent=init_func_imr_block,
                file_imr_parent=result,
                project_file=pfile,
                imr_build_tracker=imr_build_tracker,
                try_target_storage_ref=var_ref,
                is_moose64=is_moose64, msgs=msgs,
            ) later:

            await right_hand_result
            if right_hand_result == none or
                    right_hand_result.storage_ref == none or
                    (right_hand_result.storage_ref.kind ==
                        st_ref.ST_LOCAL and
                     right_hand_result.instructions.len == 0) {
                if msgs == none {
                    print(program_name + ": warning: Internal error, "
                        "unexpectedly failed to generate right-hand "
                        "init side for this global var statement: " +
                        stmt.as_str())
                } else {
                    msgs.add(new msg.FileMsg(
                        "Internal error, "
                        "unexpectedly failed to generate right-hand "
                        "init side for this global var statement. " +
                        "right_hand_result=" +
                            right_hand_result.as_str() + " "
                        "right_hand_result.storage_ref=" +
                            if right_hand_result != none
                                (right_hand_result.storage_ref.as_str())
                                else ("none"),
                        source_file=pfile,
                        line=stmt.line,
                        col=stmt.col,
                    ))
                }
                return later no
            }
            init_func_imr_block.instructions +=
                right_hand_result.instructions
            if not right_hand_result.storage_ref.alike(
                    var_ref) {
                init_func_imr_block.instructions.add(new IMRMove(
                    right_hand_result.storage_ref,
                    var_ref,
                ))
            }
            return later yes
        }
        if queue.len == 0 {
            return later yes
        }
        var inner_result = handle_global_var_init(
            queue.pop_at(1))
        later:

        await inner_result
        if not inner_result {
            return later no
        }
        if queue.len == 0 {
            return later yes
        }
        inner_result = handle_global_var_init(
            queue.pop_at(1)) later repeat
    }
    func handle_global_init_funcs {
        var queue = init_func_info.copy()
        if queue.len == 0 {
            return later yes
        }
        var inner_result = handle_global_init_func(
            queue.pop_at(1)
        ) later:

        await inner_result
        if not inner_result {
            return later no
        }
        if queue.len == 0 {
            return later yes
        }
        inner_result = handle_global_init_func(
            queue.pop_at(1)
        ) later repeat
    }
    var globals_result = handle_global_init_funcs()
    later:

    await globals_result
    if not globals_result {
        assert(msgs == none or
            msg.msgs_contain_error(msgs))
        return result
    }

    return later result
}

func expand_imr_for_entrypoint_by_file(
        pfile,
        imr_for_file=none,
        imr_build_tracker=none,
        build_options=none,
        is_moose64=no,
        msgs=none,
        ) {
    const program_name =
        if is_moose64 ("moosec") else ("horsec")
    var result = imr_for_file

    if not pfile.is_entrypoint {
        return later yes
    }

    pfile.ensure_ast()
    later:

    var _func_stmt_to_imr_func_map = {->}

    func get_imr_node_for_func(node) {
        if not {ast.N_STMT_FUNC,
                ast.N_STMT_FUNCEXTEND}.has(
                node.kind) {
            return none
        }

        if not _func_stmt_to_imr_func_map.has(
                node) {
            var item = result.find_global_func_by_label(
                node.label, type_path=node.type_path,
            )
            _func_stmt_to_imr_func_map[
                node
            ] = item
        }
        return _func_stmt_to_imr_func_map[
            node
        ]
    }

    func add_entrypoint_contents(node, parents) {
        var parent = if parents.len > 0
            (parents[parents.len]) else (none)
        if node.damaged {
            return later node
        }
        if node.kind != ast.N_STMT_FUNC {
            return later node
        }

        var is_entrypoint = is_func_stmt_entry_point_func(
            pfile, node,
            build_options=build_options,
            is_moose64=is_moose64,
        )
        if not is_entrypoint {
            return later node
        }

        var imr_node = get_imr_node_for_func(node)
        assert(imr_node != none)

        var entrypoint_stmts = []
        func get_entrypoint_stmts {
            if not is_entrypoint {
                return later
            }
            entrypoint_stmts = generate_imr_for_entrypoint_func(
                imr_parents=[imr_node],
                func_imr_parent=imr_node,
                file_imr_parent=result,
                project_file=pfile,
                imr_build_tracker=imr_build_tracker,
                is_moose64=is_moose64,
                msgs=msgs,
            ) later:

            await entrypoint_stmts
        }
        get_entrypoint_stmts() later:

        imr_node.instructions = entrypoint_stmts +
            imr_node.instructions
        return later node
    }
    var entrypoint_success = ast_transform.visit_ast_tree(
        pfile.ast, add_entrypoint_contents,
        pass_func_boundaries=yes,
        parent_chain=yes, backward=no,
    ) later:

    await entrypoint_success
    if not entrypoint_success {
        assert(msgs == none or
            msg.msgs_contain_error(msgs))
        return later no
    }
    assert(entrypoint_success == yes)

    return later yes
}

type IMRBuildTrackerFunc {
    var last_assigned_temp_storage_id = 0
}

type IMRBuildTracker {
    var file_id_to_imr_result_map = {->}

    var global_init_func_name_to_id_map = {->}

    var imr_func_id_to_tracker_info_map = {->}

    var build_options
}

func get_var_typeinfo(
        ref,
        func_parent_node=none,
        func_imr_parent=none,
        project_file=none,
        imr_build_tracker=none,
        msgs=none, is_moose64=no,
        ) {
    assert(project_file != none)
    if ref.kind == st_ref.ST_LOCAL {
        if func_imr_parent == none {
            throw new ValueError(
                "Cannot examine local var without a func."
            )
        }
        var func_tracker = func_imr_parent.get_func_tracker(
            imr_build_tracker
        )
        if func_tracker == none {
            throw new ValueError(
                "Cannot find func tracker."
            )
        }
        if not func_imr_parent.storage_id_to_known_type_info.has(
                ref.id) {
            throw new ValueError(
                "Cannot find local var in func registry."
            )
        }
        var tinfo = func_imr_parent.storage_id_to_known_type_info[
            ref.id
        ]
        if tinfo != none {
            tinfo = tinfo.copy()
        }
        return later tinfo
    } elseif {st_ref.ST_GLOBAL, st_ref.ST_ARG,
            st_ref.ST_GLOBALATTR}.has(ref.kind) {
        if ref.kind == st_ref.ST_ARG and (
                func_imr_parent == none or
                func_parent_node == none) {
            throw new ValueError(
                "Cannot examine arg var without a func and "
                "a func node."
            )
        }
        var sinfo = st_ref.ref_to_symbol_info(
            ref, node=func_parent_node,
            project=project_file.project,
            is_moose64=is_moose64,
        )
        if sinfo == none {
            throw new ValueError(
                "Cannot find var's symbol info."
            )
        }
        if sinfo.typeref_expr == none {
            throw new ValueError(
                "Var's symbol info is invalid and lacks type."
            )
        }
        var base_node =
            if ref.kind == st_ref.ST_ARG
                (func_parent_node) else (none)
        var tinfo = typeinfo.
            create_typeinfo_from_typeexpr_and_verify(
                sinfo.typeref_expr,
                base_node_if_known=base_node,
                project_file=project_file,
                is_moose64=is_moose64,
            ) later:

        await tinfo
        return later tinfo
    } else {
        throw new ValueError(
            "Cannot find type info for this var type."
        )
    }
}

func generate_imr_for_project(
        project,
        build_options=none,
        msgs=none, is_moose64=no, debug=no,
        ) {
    is_moose64 =
        is_moose64 or (build_options != none and
            build_options.is_moose64)
    const program_name =
        if is_moose64 ("moosec") else ("horsec")
    var boptions = build_options
    var imrresult = new IMRTranslationResult()
    if msgs != none {
        imrresult.msgs = msgs
    } else {
        imrresult.msgs = none
    }
    var imr_build_tracker = new IMRBuildTracker()
    imr_build_tracker.build_options = build_options

    if boptions.print_stages {
        clog.log_or_print(
            new msg.FileMsg(
                "stage imr: " +
                "Launched on project=" +
                project.as_str() + " "
                "[t=" + time.ticks().as_str() + "]",
                kind=msg.M_INFO,
            ),
            msgs=imrresult.msgs, program_name=program_name,
            force_print=not boptions.format_output_for_scripts,
        )
    }
    if debug {
        print(program_name + ": debug: "
            "generate_imr_for_project(): "
            "Starting per file loop for "
            "project=" + project.as_str() + ", "
            "is_moose64=" +
                is_moose64.as_str())
    }

    func process_file(pfile) {
        assert(pfile.file_id != none)
        if boptions.print_stages {
            clog.log_or_print(
                new msg.FileMsg(
                    "stage imr: " +
                    "Processing file pfile=" +
                    pfile.as_str() + " "
                    "[t=" + time.ticks().as_str() + "]",
                    kind=msg.M_INFO,
                ),
                msgs=imrresult.msgs,
                program_name=program_name,
                force_print=not boptions.format_output_for_scripts,
            )
        }
        var result = generate_imr_for_file(
            pfile, imr_build_tracker=imr_build_tracker,
            build_options=build_options,
            msgs=imrresult.msgs,
            is_moose64=is_moose64)
        later:

        await result
        imr_build_tracker.file_id_to_imr_result_map[
            pfile.file_id
        ] = result
        return later yes
    }
    var result = project.do_for_all_files(
        process_file
    ) later:

    await result
    if msg.msgs_contain_error(imrresult.msgs) {
        result = no
    }
    assert(result == yes or result == no)
    if not result {
        return later no
    }

    if debug {
        print(program_name + ": debug: "
            "generate_imr_for_project(): "
            "Starting entry point finalization for "
            "project=" + project.as_str() + ", "
            "is_moose64=" +
            is_moose64.as_str())
    }
    if boptions.print_stages {
        clog.log_or_print(
            new msg.FileMsg(
                "stage imr: " +
                "Processing finalizing entrypoint... "
                "[t=" + time.ticks().as_str() + "]",
                kind=msg.M_INFO,
            ),
            msgs=imrresult.msgs,
            program_name=program_name,
            force_print=not boptions.format_output_for_scripts,
        )
    }
    func process_file_2(pfile) {
        var imr_for_file = imr_build_tracker.
            file_id_to_imr_result_map[
                pfile.file_id
            ]
        imr_for_file.ensure_loaded()
        later:

        var success = expand_imr_for_entrypoint_by_file(
            pfile,
            imr_for_file=imr_for_file,
            imr_build_tracker=imr_build_tracker,
            build_options=build_options,
            is_moose64=is_moose64,
            msgs=msgs,
        ) later:

        await success
        if not success {
            return later no
        }

        return later yes
    }
    var result = project.do_for_all_files(
        process_file_2
    ) later:

    await result
    if msg.msgs_contain_error(imrresult.msgs) {
        result = no
    }
    if not result {
        return later no
    }

    if boptions.print_stages {
        clog.log_or_print(
            new msg.FileMsg(
                "stage imr: " +
                "Starting IMR transformations... "
                "[t=" + time.ticks().as_str() + "]",
                kind=msg.M_INFO,
            ),
            msgs=imrresult.msgs,
            program_name=program_name,
            force_print=not boptions.format_output_for_scripts,
        )
    }
    func do_self_parameter_if_moose64 {
        if not is_moose64 {
            return later
        }
        if debug {
            print(program_name + ": debug: "
                "generate_imr_for_project(): "
                "Will now do IMR transformation "
                "to add self parameters to funcs...")
        }
        result = imr_transform.add_self_parameters_to_funcs(
            project=project,
            imr_build_tracker=imr_build_tracker,
            build_options=build_options,
            is_moose64=is_moose64,
            msgs=imrresult.msgs,
            debug=debug,
        ) later:

        await result
    }
    do_self_parameter_if_moose64()
    later:

    if not result {
        return later no
    }
    if debug {
        print(program_name + ": debug: "
            "generate_imr_for_project(): "
            "Will now do IMR transformation of "
            "reassigning "
            "locals and computing lifetimes...")
    }
    result = imr_transform.reassign_locals_and_do_lifetime_for_imr(
        project=project,
        imr_build_tracker=imr_build_tracker,
        build_options=build_options,
        is_moose64=is_moose64,
        msgs=imrresult.msgs,
        debug=debug,
    ) later:

    await result
    if not result {
        return later no
    }
    if debug {
        print(program_name + ": debug: "
            "generate_imr_for_project(): "
            "Completed IMR generation. "
            "project=" + project.as_str() + ", "
            "is_moose64=" +
            is_moose64.as_str() + " "
            "successful=" + result.as_str())
    }
    if boptions.print_stages {
        clog.log_or_print(
            new msg.FileMsg(
                "stage imr: " +
                "IMR completed. "
                "[t=" + time.ticks().as_str() + "]",
                kind=msg.M_INFO,
            ),
            msgs=imrresult.msgs,
            program_name=program_name,
            force_print=not boptions.format_output_for_scripts,
        )
    }
    assert(result == yes or result == no)
    for f_id in imr_build_tracker.file_id_to_imr_result_map {
        imrresult.file_id_to_imr_result_map[f_id] =
            imr_build_tracker.file_id_to_imr_result_map[f_id].copy()
    }
    return later no  # FIXME
}

