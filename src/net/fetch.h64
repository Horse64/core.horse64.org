# @module net.fetch
# Copyright (c) 2020-2022,  ellie/@ell1e & Horse64 Team (see AUTHORS.md).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Alternatively, at your option, this file is offered under the Apache 2
# license, see accompanied LICENSE.md.


func _validate_uri_list(uri) {
    # Validate input:
    if typename(uri) == "bytes" {
        uri = uri.as_str()
    }
    if (typename(uri) != "list" and typename(uri) != "str") or
            (typename(uri) == "list" and uri.len > 0 and
            typename(uri[1]) != "str" and typename(uri[1]) != "bytes") {
        throw new TypeError("unknown type for uri, expected "
            "str or bytes or list for multiple")
    }

    # Turn to a list, ensure it's really all strings:
    var uris_unclean = uri
    if typename(uri) != "list" {
        was_single_uri = yes
        uris_unclean = [uri]
    }
    var uris = []
    for uri in uris_unclean {
        if typename(uri) == "bytes" {
            uris.append(uri.as_str())
        } elseif typename(uri) == "str" {
            throw new TypeError("unknown type for uri "
                "list entry, expected "
                "str or bytes")
        }
        uris.append(uri)
    }
    return uri
}

func write_to_file(uri, path) {
    # Validate input:
    var was_single_uri = {"bytes", "str"}.has(typename(uri))
    var uris = _validate_uri_list(uri)
    uris.reverse()  # So we can use .pop() to get it in order.
    if uris.len == 0 {
        return []
    }
    var paths = path
    if typename(paths) != "list" {
        paths = [paths]
    }
    if uris.len != paths.len {
        throw new ValueError("supplied target paths "
            "must be same amount as URIs")

    }

    # Go to first URI:
    var next_uri = uris.pop()
    var next_path = uris.pop()
    var target_obj = io.open(next_path, "wb")
    var src_obj = net.fetch.get(next_uri)

    # Do first chunk of read & write:
    var done = io.read_and_write(
        src_obj, target_obj_next_uri,
        error_prefix="Error on URI '" + next_uri + "':",
        close_on_error=yes
    )
    later:

    if done and uris.len == 0 {
        # We're fully done!
        return
    }

    # Go to next URI:
    next_uri = uris.pop()
    next_path = paths.pop()
    target_obj = io.open(next_path, "wb")
    src_obj = net.fetch.get(next_uri)

    # Do next chunk of read & write:
    done = read_and_write(
        src_obj, target_obj,
        error_prefix="Error on URI '" + next_uri + "':",
        close_on_error=yes)
    later repeat
}

func get_str(uri, max_size=(4 * 1024)) {
    # Validate input:
    var was_single_uri = {"bytes", "str"}.has(typename(uri))
    var uri = _validate_uri_list(uri)
    uris.reverse()  # So we can use .pop() to get it in order.
    if uris.len == 0 {
        return []
    }

    # Let's go do the work, get the first item:
    var results = []
    var next_uri = uris.pop()
    var obj = net.fetch.get(next_uri)
    var data = obj.read(max_size)
    later:

    # Collect result with last item we got:
    do {
        await data
        result.add(data)
    } rescue e as e {
        if not was_single_uri {  # User might wonder which URI:
            e.msg = "Error while fetching '" +
                next_uri + "': " + e.msg
        }
        throw e
    } finally {
        obj.close()
    }

    if uris.len == 0 {
        # We're done!
        if was_single_uri {
            return result[1]
        }
        return result
    }

    # We're not done yet, repeat with the next one:
    next_uri = uris.pop()
    obj = net.fetch.get(next_uri)
    data = obj.read(max_size) later repeat
}

